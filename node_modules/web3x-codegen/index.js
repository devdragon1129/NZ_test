#!/usr/bin/env node
"use strict";
/*
  Copyright (c) 2019 xf00f

  This file is part of web3x and is released under the MIT License.
  https://opensource.org/licenses/MIT
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const fs_extra_1 = require("fs-extra");
const typescript_1 = __importStar(require("typescript"));
const sources_1 = require("./sources");
const printer = typescript_1.default.createPrinter({
    newLine: typescript_1.default.NewLineKind.LineFeed,
});
function makeImports(name, web3xPath) {
    return [
        typescript_1.default.createImportDeclaration(undefined, undefined, typescript_1.default.createImportClause(typescript_1.default.createIdentifier('BN'), undefined), typescript_1.default.createLiteral('bn.js')),
        typescript_1.default.createImportDeclaration(undefined, undefined, typescript_1.default.createImportClause(undefined, typescript_1.default.createNamedImports([typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('Address'))])), typescript_1.default.createLiteral(`${web3xPath}/address`)),
        typescript_1.default.createImportDeclaration(undefined, undefined, typescript_1.default.createImportClause(undefined, typescript_1.default.createNamedImports([
            typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('EventLog')),
            typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('TransactionReceipt')),
        ])), typescript_1.default.createLiteral(`${web3xPath}/formatters`)),
        typescript_1.default.createImportDeclaration(undefined, undefined, typescript_1.default.createImportClause(undefined, typescript_1.default.createNamedImports([
            typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('Contract')),
            typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('ContractOptions')),
            typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('TxCall')),
            typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('TxSend')),
            typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('EventSubscriptionFactory')),
        ])), typescript_1.default.createLiteral(`${web3xPath}/contract`)),
        typescript_1.default.createImportDeclaration(undefined, undefined, typescript_1.default.createImportClause(undefined, typescript_1.default.createNamedImports([typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier('Eth'))])), typescript_1.default.createLiteral(`${web3xPath}/eth`)),
        typescript_1.default.createImportDeclaration(undefined, undefined, typescript_1.default.createImportClause(typescript_1.default.createIdentifier('abi'), undefined), typescript_1.default.createLiteral(`./${name}Abi`)),
    ];
}
function makeEventType(definition) {
    const props = typescript_1.default.createTypeLiteralNode(definition.inputs.map(input => typescript_1.default.createPropertySignature(undefined, input.name, undefined, getTsTypeFromSolidityType(input, true), undefined)));
    return typescript_1.default.createTypeAliasDeclaration(undefined, [typescript_1.default.createToken(typescript_1.default.SyntaxKind.ExportKeyword)], `${definition.name}Event`, undefined, props);
}
function makeEventTypes(abi) {
    return abi.filter(def => def.type === 'event').map(makeEventType);
}
function makeEventLogInterface(definition) {
    const eventName = `${definition.name}Event`;
    return typescript_1.default.createInterfaceDeclaration(undefined, [typescript_1.default.createToken(typescript_1.default.SyntaxKind.ExportKeyword)], `${eventName}Log`, undefined, [
        typescript_1.default.createHeritageClause(typescript_1.default.SyntaxKind.ExtendsKeyword, [
            typescript_1.default.createExpressionWithTypeArguments([
                typescript_1.default.createTypeReferenceNode(eventName, undefined),
                typescript_1.default.createLiteralTypeNode(typescript_1.default.createLiteral(definition.name)),
            ], typescript_1.default.createRegularExpressionLiteral('EventLog')),
        ]),
    ], []);
}
function makeEventLogInterfaces(abi) {
    return abi.filter(def => def.type === 'event').map(makeEventLogInterface);
}
function makeEventsInterface(name, abi) {
    const events = abi.filter(def => def.type === 'event').map(event => event.name);
    return typescript_1.default.createInterfaceDeclaration(undefined, undefined, `${name}Events`, undefined, undefined, events.map(eventName => typescript_1.default.createPropertySignature(undefined, eventName, undefined, typescript_1.default.createTypeReferenceNode(`EventSubscriptionFactory`, [
        typescript_1.default.createTypeReferenceNode(`${eventName}EventLog`, undefined),
    ]), undefined)));
}
function makeEventLogsInterface(name, abi) {
    const events = abi.filter(def => def.type === 'event').map(event => event.name);
    return typescript_1.default.createInterfaceDeclaration(undefined, undefined, `${name}EventLogs`, undefined, undefined, events.map(eventName => typescript_1.default.createPropertySignature(undefined, eventName, undefined, typescript_1.default.createTypeReferenceNode(`${eventName}EventLog`, undefined), undefined)));
}
function makeTxEventLogsInterface(name, abi) {
    const events = abi.filter(def => def.type === 'event').map(event => event.name);
    return typescript_1.default.createInterfaceDeclaration(undefined, undefined, `${name}TxEventLogs`, undefined, undefined, events.map(eventName => typescript_1.default.createPropertySignature(undefined, eventName, undefined, typescript_1.default.createArrayTypeNode(typescript_1.default.createTypeReferenceNode(`${eventName}EventLog`, undefined)), undefined)));
}
function makeTransactionReceiptInterface(name) {
    return typescript_1.default.createInterfaceDeclaration(undefined, [typescript_1.default.createToken(typescript_1.default.SyntaxKind.ExportKeyword)], `${name}TransactionReceipt`, undefined, [
        typescript_1.default.createHeritageClause(typescript_1.default.SyntaxKind.ExtendsKeyword, [
            typescript_1.default.createExpressionWithTypeArguments([typescript_1.default.createTypeReferenceNode(`${name}TxEventLogs`, undefined)], typescript_1.default.createRegularExpressionLiteral('TransactionReceipt')),
        ]),
    ], []);
}
function getBaseType(type, returnValue) {
    if (type.match(/u?int\d*/) || type.match(/u?fixed[0-9x]*/)) {
        return !returnValue
            ? typescript_1.default.createUnionTypeNode([
                typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.NumberKeyword),
                typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword),
                typescript_1.default.createTypeReferenceNode(typescript_1.default.createIdentifier('BN'), undefined),
            ])
            : typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword);
    }
    if (type === 'bool') {
        return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.BooleanKeyword);
    }
    if (type === 'address') {
        return typescript_1.default.createTypeReferenceNode('Address', undefined);
    }
    return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword);
}
function getTupleType(components, returnValue) {
    return typescript_1.default.createTypeLiteralNode(components.map(prop => typescript_1.default.createPropertySignature(undefined, prop.name, undefined, getTsTypeFromSolidityType(prop, returnValue), undefined)));
}
function getTsTypeFromSolidityType(input, returnValue, type) {
    type = type || input.type;
    const arrayMatched = type.match(/(.+)\[\d*\]$/);
    if (arrayMatched) {
        const tsType = getTsTypeFromSolidityType(input, returnValue, arrayMatched[1]);
        return typescript_1.default.createArrayTypeNode(tsType);
    }
    else {
        const isTuple = type === 'tuple';
        return isTuple ? getTupleType(input.components, returnValue) : getBaseType(type, returnValue);
    }
}
function makeParameter(input, index) {
    return typescript_1.default.createParameter(undefined, undefined, undefined, input.name || `a${index}`, undefined, getTsTypeFromSolidityType(input, false));
}
function generateReturnTypes(outputs) {
    if (outputs.length === 0) {
        return [];
    }
    else if (outputs.length === 1) {
        // original return value.
        return [getTsTypeFromSolidityType(outputs[0], true)];
    }
    else {
        // multiple return values: return an object.
        const propSigs = [];
        for (let index = 0; index < outputs.length; index++) {
            const output = outputs[index];
            const type = getTsTypeFromSolidityType(output, true);
            if (output.name) {
                // name exists for the output: create a key for that
                const nameSig = typescript_1.default.createPropertySignature(undefined, typescript_1.default.createStringLiteral(output.name), undefined, type, undefined);
                propSigs.push(nameSig);
            }
            // always create a key for the index.
            const indexSig = typescript_1.default.createPropertySignature(undefined, typescript_1.default.createNumericLiteral(index.toString()), undefined, type, undefined);
            propSigs.push(indexSig);
        }
        return [typescript_1.default.createTypeLiteralNode(propSigs)];
    }
}
function getOutputType(name, definition) {
    if (!definition.stateMutability) {
        if (definition.constant && definition.constant === true) {
            return typescript_1.default.createTypeReferenceNode('TxCall', generateReturnTypes(definition.outputs || []));
        }
        else {
            return typescript_1.default.createTypeReferenceNode('TxSend', [
                typescript_1.default.createTypeReferenceNode(`${name}TransactionReceipt`, undefined)
            ]);
        }
    }
    if (definition.stateMutability === 'view' || definition.stateMutability === 'pure') {
        if (definition.outputs && definition.outputs.length) {
            return typescript_1.default.createTypeReferenceNode('TxCall', generateReturnTypes(definition.outputs));
        }
        else {
            return typescript_1.default.createTypeReferenceNode('TxCall', [typescript_1.default.createKeywordTypeNode(typescript_1.SyntaxKind.VoidKeyword)]);
        }
    }
    else {
        return typescript_1.default.createTypeReferenceNode('TxSend', [
            typescript_1.default.createTypeReferenceNode(`${name}TransactionReceipt`, undefined)
        ]);
    }
}
function makeMethodSignature(name, definition) {
    return typescript_1.default.createMethodSignature(undefined, definition.inputs.map(makeParameter), getOutputType(name, definition), definition.name, undefined);
}
function makeMethodsInterface(name, abi) {
    const methods = abi.filter(def => def.type === 'function').map(def => makeMethodSignature(name, def));
    return typescript_1.default.createInterfaceDeclaration(undefined, undefined, `${name}Methods`, undefined, undefined, methods);
}
function makeContract(name, initData, abi) {
    const members = [];
    const ctor = typescript_1.default.createConstructor(undefined, undefined, [
        typescript_1.default.createParameter(undefined, undefined, undefined, 'eth', undefined, typescript_1.default.createTypeReferenceNode('Eth', undefined)),
        typescript_1.default.createParameter(undefined, undefined, undefined, 'address', typescript_1.default.createToken(typescript_1.default.SyntaxKind.QuestionToken), typescript_1.default.createTypeReferenceNode('Address', undefined)),
        typescript_1.default.createParameter(undefined, undefined, undefined, 'options', typescript_1.default.createToken(typescript_1.default.SyntaxKind.QuestionToken), typescript_1.default.createTypeReferenceNode('ContractOptions', undefined)),
    ], typescript_1.default.createBlock([
        typescript_1.default.createStatement(typescript_1.default.createCall(typescript_1.default.createSuper(), undefined, [
            typescript_1.default.createIdentifier('eth'),
            typescript_1.default.createIdentifier('abi'),
            typescript_1.default.createIdentifier('address'),
            typescript_1.default.createIdentifier('options'),
        ])),
    ], true));
    members.push(ctor);
    if (initData) {
        const ctorDef = abi.find(def => def.type === 'constructor');
        const inputs = ctorDef && ctorDef.inputs ? ctorDef.inputs : [];
        const deployMethod = typescript_1.default.createMethod(undefined, undefined, undefined, 'deploy', undefined, undefined, inputs.map(makeParameter), typescript_1.default.createTypeReferenceNode('TxSend', [typescript_1.default.createTypeReferenceNode(`${name}TransactionReceipt`, undefined)]), typescript_1.default.createBlock([
            typescript_1.default.createReturn(typescript_1.default.createAsExpression(typescript_1.default.createCall(typescript_1.default.createPropertyAccess(typescript_1.default.createSuper(), 'deployBytecode'), undefined, [
                typescript_1.default.createStringLiteral(initData),
                ...inputs.map(input => typescript_1.default.createIdentifier(input.name)),
            ]), typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword))),
        ], true));
        members.push(deployMethod);
    }
    return typescript_1.default.createClassDeclaration(undefined, [typescript_1.default.createToken(typescript_1.default.SyntaxKind.ExportKeyword)], name, undefined, [
        typescript_1.default.createHeritageClause(typescript_1.default.SyntaxKind.ExtendsKeyword, [
            typescript_1.default.createExpressionWithTypeArguments([typescript_1.default.createTypeReferenceNode(`${name}Definition`, undefined)], typescript_1.default.createRegularExpressionLiteral('Contract')),
        ]),
    ], members);
}
function makeDefinitionInterface(name) {
    const props = [
        typescript_1.default.createPropertySignature(undefined, 'methods', undefined, typescript_1.default.createTypeReferenceNode(`${name}Methods`, undefined), undefined),
        typescript_1.default.createPropertySignature(undefined, 'events', undefined, typescript_1.default.createTypeReferenceNode(`${name}Events`, undefined), undefined),
        typescript_1.default.createPropertySignature(undefined, 'eventLogs', undefined, typescript_1.default.createTypeReferenceNode(`${name}EventLogs`, undefined), undefined),
    ];
    return typescript_1.default.createInterfaceDeclaration(undefined, [typescript_1.default.createToken(typescript_1.default.SyntaxKind.ExportKeyword)], `${name}Definition`, undefined, undefined, props);
}
function makeAbiExport(name) {
    return typescript_1.default.createVariableStatement([typescript_1.default.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], [typescript_1.default.createVariableDeclaration(`${name}Abi`, undefined, typescript_1.default.createIdentifier('abi'))]);
}
function makeFile(name, abi, initData, web3xPath) {
    const imports = makeImports(name, web3xPath);
    const eventTypes = makeEventTypes(abi);
    const eventLogTypes = makeEventLogInterfaces(abi);
    const eventsInterface = makeEventsInterface(name, abi);
    const eventLogsInterface = makeEventLogsInterface(name, abi);
    const eventTxLogsInterface = makeTxEventLogsInterface(name, abi);
    const txReceiptInterface = makeTransactionReceiptInterface(name);
    const methodsInterface = makeMethodsInterface(name, abi);
    const definitionInterface = makeDefinitionInterface(name);
    const contract = makeContract(name, initData, abi);
    const abiExport = makeAbiExport(name);
    return typescript_1.default.createNodeArray([
        ...imports,
        ...eventTypes,
        ...eventLogTypes,
        eventsInterface,
        eventLogsInterface,
        eventTxLogsInterface,
        txReceiptInterface,
        methodsInterface,
        definitionInterface,
        contract,
        abiExport,
    ]);
}
async function makeAndWriteAbi(outputPath, name, abi, web3xPath) {
    const abiOutputFile = `${outputPath}/${name}Abi.ts`;
    const output = `import { ContractAbi} from '${web3xPath}/contract';\nexport default new ContractAbi(${JSON.stringify(abi, undefined, 2)});`;
    fs_1.default.writeFileSync(abiOutputFile, output);
}
async function makeAndWriteFiles(outputPath, name, { abi, initData }, web3xPath) {
    const interfaceOutputFile = `${outputPath}/${name}.ts`;
    const resultFile = typescript_1.default.createSourceFile('', '', typescript_1.default.ScriptTarget.Latest, false, typescript_1.default.ScriptKind.TS);
    resultFile.statements = makeFile(name, abi, initData, web3xPath);
    fs_1.default.writeFileSync(interfaceOutputFile, printer.printFile(resultFile));
    makeAndWriteAbi(outputPath, name, abi, web3xPath);
}
exports.makeAndWriteFiles = makeAndWriteFiles;
function getWeb3xPath() {
    const pkg = JSON.parse(fs_1.default.readFileSync('package.json').toString());
    return { ...pkg.dependencies, ...pkg.devDependencies }['web3x-es'] ? 'web3x-es' : 'web3x';
}
exports.getWeb3xPath = getWeb3xPath;
async function main() {
    const configFile = process.argv[2] || 'contracts.json';
    const config = JSON.parse(fs_1.default.readFileSync(configFile).toString());
    const { outputPath = './contracts', web3xPath = getWeb3xPath() } = config;
    fs_extra_1.ensureDirSync(outputPath);
    await Promise.all(Object.entries(config.contracts).map(async (entry) => {
        const buildData = await sources_1.loadDataFromConfig(entry[1]);
        makeAndWriteFiles(outputPath, entry[0], buildData, web3xPath);
    }));
}
if (require.main === module) {
    // tslint:disable-next-line:no-console
    main().catch(console.error);
}
