'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@0xsequence/utils');
var ethers = require('ethers');
var providers = require('@ethersproject/providers');

function isNetworkConfig(cand) {
  return cand && cand.chainId !== undefined && cand.name !== undefined && cand.rpcUrl !== undefined && cand.relayer !== undefined;
}
const getNetworkId = chainId => {
  if (typeof chainId === 'number') {
    return chainId;
  }

  if (chainId.chainId) {
    return chainId.chainId;
  }

  return ethers.ethers.BigNumber.from(chainId).toNumber();
};
const maybeNetworkId = chainId => {
  if (!chainId) return undefined;
  return getNetworkId(chainId);
};
const getAuthNetwork = networks => {
  if (!networks || networks.length === 0) return undefined;
  if (networks[0] && networks[0].isAuthChain) return networks[0];
  if (networks.length > 1 && networks[1].isAuthChain) return networks[1];
  return undefined;
};
const isValidNetworkConfig = (networkConfig, raise = false, skipRelayerCheck = false) => {
  if (!networkConfig) throw new Error(`invalid network config: empty config`);
  const configs = [];

  if (Array.isArray(networkConfig)) {
    configs.push(...networkConfig);
  } else {
    configs.push(networkConfig);
  }

  if (configs.length === 0) {
    if (raise) throw new Error(`invalid network config: empty config`);
    return false;
  } // Ensure distinct chainId configs


  const chainIds = configs.map(c => c.chainId).sort();
  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i);

  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  } // Downcase all network names


  configs.forEach(c => c.name = c.name.toLowerCase()); // Ensure distinct network names

  const names = configs.map(c => c.name).sort();
  const nameDupes = names.filter((c, i) => names.indexOf(c) !== i);

  if (nameDupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`);
    return false;
  } // Ensure rpcUrl or provider is specified
  // Ensure relayerUrl or relayer is specified
  // Ensure one default chain
  // Ensure one auth chain


  let defaultChain = false;
  let authChain = false;

  for (let i = 0; i < configs.length; i++) {
    const c = configs[i];

    if ((!c.rpcUrl || c.rpcUrl === '') && !c.provider) {
      if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: rpcUrl or provider must be provided`);
      return false;
    }

    if (!skipRelayerCheck) {
      if (!c.relayer) {
        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: relayer must be provided`);
        return false;
      }
    }

    if (c.isDefaultChain) {
      if (defaultChain) {
        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: DefaultChain is already set by another config`);
        return false;
      }

      defaultChain = true;
    }

    if (c.isAuthChain) {
      if (authChain) {
        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: AuthChain is already set by another config`);
      }

      authChain = true;
    }
  }

  if (!defaultChain) {
    if (raise) throw new Error(`invalid network config: DefaultChain must be set`);
    return false;
  }

  if (!authChain) {
    if (raise) throw new Error(`invalid network config: AuthChain must be set`);
    return false;
  }

  return true;
};
const ensureValidNetworks = (networks, skipRelayerCheck = false) => {
  isValidNetworkConfig(networks, true, skipRelayerCheck);
  return networks;
};
const ensureUniqueNetworks = (networks, raise = true) => {
  const chainIds = networks.map(c => c.chainId).sort();
  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i);

  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }

  return true;
}; // sortNetworks orders the network config list by: defaultChain, authChain, ..rest by chainId ascending numbers

const sortNetworks = (networks, defaultChainId) => {
  if (!networks) return [];
  const config = networks.sort((a, b) => {
    if (a.chainId === b.chainId) return 0;
    return a.chainId < b.chainId ? -1 : 1;
  }); // Set defaultChainId if passed to set default chain

  if (defaultChainId) {
    let found = false;
    networks.forEach(n => {
      n.isDefaultChain = false;

      if (n.name === defaultChainId || n.chainId === defaultChainId) {
        found = true;
        n.isDefaultChain = true;
      }
    });

    if (!found) {
      throw new Error(`unable to set default network as chain '${defaultChainId}' does not exist`);
    }
  } // // AuthChain goes first
  // const authConfigIdx = config.findIndex(c => c.isAuthChain)
  // if (authConfigIdx > 0) config.splice(0, 0, config.splice(authConfigIdx, 1)[0])
  // // DefaultChain goes second
  // const defaultConfigIdx = config.findIndex(c => c.isDefaultChain && c.isAuthChain !== true)
  // if (defaultConfigIdx > 0) config.splice(1, 0, config.splice(defaultConfigIdx, 1)[0])
  // DefaultChain goes first


  const defaultConfigIdx = config.findIndex(c => c.isDefaultChain);
  if (defaultConfigIdx > 0) config.splice(0, 0, config.splice(defaultConfigIdx, 1)[0]); // AuthChain goes second

  const authConfigIdx = config.findIndex(c => c.isAuthChain && c.isDefaultChain !== true);
  if (authConfigIdx > 0) config.splice(1, 0, config.splice(authConfigIdx, 1)[0]);
  return config;
};
const updateNetworkConfig = (src, dest) => {
  if (!src || !dest) return;

  if (!src.chainId && !src.name) {
    throw new Error('failed to update network config: source config is missing chainId or name');
  }

  if (src.chainId !== dest.chainId && src.name !== dest.name) {
    throw new Error('failed to update network config: one of chainId or name must match');
  }

  if (src.rpcUrl) {
    dest.rpcUrl = src.rpcUrl;
    dest.provider = undefined;
  }

  if (src.provider) {
    dest.provider = src.provider;
  }

  if (src.relayer) {
    dest.relayer = src.relayer;
  }

  if (src.ensAddress) {
    dest.ensAddress = src.ensAddress;
  } // NOTE: we do not set default or auth chain from here
  // if (src.isDefaultChain) {
  //   dest.isDefaultChain = src.isDefaultChain
  // }
  // if (src.isAuthChain) {
  //   dest.isAuthChain = src.isAuthChain
  // }

};
const createNetworkConfig = (networks, defaultChainId, vars) => {
  let config = [];

  if (typeof networks === 'function' && vars) {
    config = networks(vars);
  } else {
    config = networks;
  }

  if (defaultChainId) {
    config.forEach(n => n.isDefaultChain = false);
    const mainNetwork = config.filter(n => n.chainId === defaultChainId);

    if (!mainNetwork || mainNetwork.length === 0) {
      throw new Error(`defaultChainId ${defaultChainId} cannot be found in network list`);
    } else {
      mainNetwork[0].isDefaultChain = true;
    }
  }

  return ensureValidNetworks(sortNetworks(config));
};
const findNetworkConfig = (networks, chainId) => {
  if (typeof chainId === 'string') {
    if (chainId.startsWith('0x')) {
      const id = ethers.ethers.BigNumber.from(chainId).toNumber();
      return networks.find(n => n.chainId === id);
    } else {
      return networks.find(n => n.name === chainId);
    }
  } else if (typeof chainId === 'number') {
    return networks.find(n => n.chainId === chainId);
  } else if (chainId.chainId) {
    return networks.find(n => n.chainId === chainId.chainId);
  } else {
    return undefined;
  }
};
const checkNetworkConfig = (network, networkId) => {
  if (!network) return false;
  if (network.name === networkId) return true;
  if (network.chainId === networkId) return true;
  return false;
};
const networksIndex = networks => {
  const index = {};

  for (let i = 0; i < networks.length; i++) {
    index[networks[i].name] = networks[i];
  }

  return index;
};

const mainnetNetworks = createNetworkConfig(vars => [{
  title: 'Ethereum',
  name: 'mainnet',
  chainId: 1,
  ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  rpcUrl: utils.urlClean(`${vars.baseRpcUrl}/mainnet`),
  relayer: {
    url: utils.urlClean(`${vars.baseRelayerUrl}/mainnet`)
  },
  isDefaultChain: true
}, {
  title: 'Matic',
  name: 'matic',
  chainId: 137,
  rpcUrl: 'https://rpc-mainnet.matic.network',
  relayer: {
    url: utils.urlClean(`${vars.baseRelayerUrl}/matic`)
  },
  isAuthChain: true
}], 1, {
  baseRpcUrl: 'https://nodes.sequence.app',
  baseRelayerUrl: 'https://relayers.sequence.app'
});
const testnetNetworks = createNetworkConfig(vars => [{
  name: 'rinkeby',
  chainId: 4,
  ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  rpcUrl: utils.urlClean(`${vars.baseRpcUrl}/rinkeby`),
  relayer: {
    url: utils.urlClean(`${vars.baseRelayerUrl}/rinkeby`)
  },
  isDefaultChain: true
}, {
  name: 'goerli',
  chainId: 5,
  ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  rpcUrl: utils.urlClean(`${vars.baseRpcUrl}/goerli`),
  relayer: {
    url: utils.urlClean(`${vars.baseRelayerUrl}/goerli`)
  },
  isAuthChain: true
} // {
//   name: 'ropsten',
//   chainId: 3,
//   ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
//   rpcUrl: '',
//   // relayer: null
// },
// {
//   name: 'kovan',
//   chainId: 42,
//   rpcUrl: '',
//   relayer: null
// },
// {
//   name: 'mumbai',
//   chainId: 80001,
//   rpcUrl: 'https://rpc-mumbai.matic.today',
//   relayer: null
// }
], undefined, {
  baseRpcUrl: 'https://nodes.sequence.app',
  baseRelayerUrl: 'https://relayers.sequence.app'
}); // export const mainnetNetworksIndex = networksIndex(mainnetNetworks)
// export const testnetNetworksIndex = networksIndex(testnetNetworks)

// WalletContext is the module addresses deployed on a network, aka the context / environment
// of the Sequence Smart Wallet system on Ethereum.
// sequenceContext are the deployed addresses of modules available on public networks.
const sequenceContext = {
  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',
  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',
  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',
  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',
  sequenceUtils: '0xd130B43062D875a4B7aF3f8fc036Bc6e9D3E1B3E'
};

const JsonRpcVersion = '2.0';

class JsonRpcRouter {
  constructor(middlewares, sender) {
    this.sender = void 0;
    this.handler = void 0;
    this.sender = sender;

    if (middlewares) {
      this.setMiddleware(middlewares);
    }
  }

  setMiddleware(middlewares) {
    this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender.sendAsync);
  }

  sendAsync(request, callback, chainId) {
    try {
      this.handler(request, callback, chainId);
    } catch (err) {
      callback(err, undefined);
    }
  } // createWeb3Provider(network?: Networkish): EthersWeb3Provider {
  //   return new EthersWeb3Provider(this.sender, network)
  // }


}
const createJsonRpcMiddlewareStack = (middlewares, handler) => {
  if (middlewares.length === 0) return handler;

  const toMiddleware = v => {
    if (v.sendAsyncMiddleware) {
      return v.sendAsyncMiddleware;
    } else {
      return v;
    }
  };

  let chain;
  chain = toMiddleware(middlewares[middlewares.length - 1])(handler);

  for (let i = middlewares.length - 2; i >= 0; i--) {
    chain = toMiddleware(middlewares[i])(chain);
  }

  return chain;
};

function isJsonRpcProvider(cand) {
  return cand !== undefined && cand.send !== undefined && cand.constructor.defaultUrl !== undefined && cand.detectNetwork !== undefined && cand.getSigner !== undefined && cand.perform !== undefined;
}
function isJsonRpcHandler(cand) {
  return cand !== undefined && cand.sendAsync !== undefined;
}

let _nextId = 0;
class JsonRpcSender {
  constructor(provider, defaultChainId) {
    this.send = void 0;
    this.request = void 0;
    this.defaultChainId = void 0;

    this.sendAsync = (request, callback, chainId) => {
      this.send(request.method, request.params, chainId || this.defaultChainId).then(r => {
        callback(undefined, {
          jsonrpc: '2.0',
          id: request.id,
          result: r
        });
      }).catch(e => {
        callback(e, undefined);
      });
    };

    this.defaultChainId = defaultChainId;

    if (isJsonRpcProvider(provider)) {
      // we can ignore defaultChainId for JsonRpcProviders as they are already chain-bound
      this.send = provider.send.bind(provider);
    } else if (isJsonRpcHandler(provider)) {
      this.send = (method, params, chainId) => {
        return new Promise((resolve, reject) => {
          provider.sendAsync({
            // TODO: really shouldn't have to set these here?
            jsonrpc: JsonRpcVersion,
            id: ++_nextId,
            method,
            params
          }, (error, response) => {
            if (error) {
              reject(error);
            } else if (response) {
              resolve(response.result);
            } else {
              resolve(undefined);
            }
          }, chainId || this.defaultChainId);
        });
      };
    } else {
      this.send = provider;
    }

    this.request = (request, chainId) => {
      return this.send(request.method, request.params, chainId);
    };
  }

}
class JsonRpcExternalProvider {
  constructor(provider) {
    this.provider = provider;

    this.sendAsync = (request, callback) => {
      this.provider.send(request.method, request.params).then(r => {
        callback(undefined, {
          jsonrpc: '2.0',
          id: request.id,
          result: r
        });
      }).catch(e => {
        callback(e, undefined);
      });
    };

    this.send = this.sendAsync;
  }

}

class AllowProvider {
  constructor(isAllowedFunc) {
    this.sendAsyncMiddleware = void 0;
    this.isAllowedFunc = void 0;

    if (isAllowedFunc) {
      this.isAllowedFunc = isAllowedFunc;
    } else {
      this.isAllowedFunc = request => true;
    }

    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);
  }

  setIsAllowedFunc(fn) {
    this.isAllowedFunc = fn;
    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);
  }

}
const allowProviderMiddleware = isAllowed => next => {
  return (request, callback, chainId) => {
    // ensure precondition is met or do not allow the request to continue
    if (!isAllowed(request)) {
      throw new Error('allowProvider middleware precondition is unmet.');
    } // request is allowed. keep going..


    next(request, callback, chainId);
  };
};

class CachedProvider {
  constructor(defaultChainId) {
    this.cachableJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', 'sequence_getWalletContext', 'sequence_getNetworks'];
    this.cache = void 0;
    this.onUpdateCallback = void 0;
    this.defaultChainId = void 0;

    this.sendAsyncMiddleware = next => {
      return (request, callback, chainId) => {
        // Respond early with cached result
        if (this.cachableJsonRpcMethods.includes(request.method)) {
          const key = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);
          const result = this.getCacheValue(key);

          if (result && result !== '') {
            callback(undefined, {
              jsonrpc: '2.0',
              id: request.id,
              result: result
            });
            return;
          }
        } // Continue down the handler chain


        next(request, (error, response, chainId) => {
          // Store result in cache and continue
          if (this.cachableJsonRpcMethods.includes(request.method)) {
            if (response && response.result) {
              const key = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);
              this.setCacheValue(key, response.result);
            }
          } // Exec next handler


          callback(error, response);
        }, chainId || this.defaultChainId);
      };
    };

    this.cacheKey = (method, params, chainId) => {
      let key = '';

      if (chainId) {
        key = `${chainId}:${method}:`;
      } else {
        key = `:${method}:`;
      }

      if (!params || params.length === 0) {
        return key + '[]';
      }

      return key + JSON.stringify(params);
    };

    this.getCache = () => this.cache;

    this.setCache = cache => {
      this.cache = cache;

      if (this.onUpdateCallback) {
        this.onUpdateCallback();
      }
    };

    this.getCacheValue = key => {
      return this.cache[key];
    };

    this.setCacheValue = (key, value) => {
      this.cache[key] = value;

      if (this.onUpdateCallback) {
        this.onUpdateCallback(key, value);
      }
    };

    this.clearCache = () => {
      this.cache = {};
    };

    this.cache = {};
    this.defaultChainId = defaultChainId;
  }

  onUpdate(callback) {
    this.onUpdateCallback = callback;
  }

}

class EagerProvider {
  constructor(props) {
    this.props = void 0;

    this.sendAsyncMiddleware = next => {
      return (request, callback, chainId) => {
        const {
          id,
          method
        } = request;

        switch (method) {
          case 'net_version':
            if (this.props.chainId) {
              callback(undefined, {
                jsonrpc: '2.0',
                id: id,
                result: `${this.props.chainId}`
              });
              return;
            }

            break;

          case 'eth_chainId':
            if (this.props.chainId) {
              callback(undefined, {
                jsonrpc: '2.0',
                id: id,
                result: ethers.ethers.utils.hexlify(this.props.chainId)
              });
              return;
            }

            break;

          case 'eth_accounts':
            if (this.props.accountAddress) {
              callback(undefined, {
                jsonrpc: '2.0',
                id: id,
                result: [ethers.ethers.utils.getAddress(this.props.accountAddress)]
              });
              return;
            }

            break;

          case 'sequence_getWalletContext':
            if (this.props.walletContext) {
              callback(undefined, {
                jsonrpc: '2.0',
                id: id,
                result: this.props.walletContext
              });
              return;
            }

            break;
        }

        next(request, callback, chainId);
      };
    };

    this.props = props;
  }

}

const exceptionProviderMiddleware = next => {
  return (request, callback, chainId) => {
    next(request, (error, response) => {
      if (!error && response && response.error) {
        if (typeof response.error === 'string') {
          throw new Error(response.error);
        } else {
          throw new Error(response.error.data);
        }
      }

      callback(error, response);
    }, chainId);
  };
};

const loggingProviderMiddleware = next => {
  return (request, callback, chainId) => {
    const chainIdLabel = chainId ? ` chainId:${chainId}` : '';
    console.log(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params);
    next(request, (error, response) => {
      if (error) {
        console.warn(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `error:`, error);
      } else {
        console.log(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `response:`, response);
      }

      callback(error, response);
    }, chainId);
  };
};

const networkProviderMiddleware = getChainId => next => {
  return (request, callback, chainId) => {
    const networkChainId = getChainId(request);
    const {
      id,
      method
    } = request;

    switch (method) {
      case 'net_version':
        callback(undefined, {
          jsonrpc: '2.0',
          id: id,
          result: `${networkChainId}`
        });
        return;

      case 'eth_chainId':
        callback(undefined, {
          jsonrpc: '2.0',
          id: id,
          result: ethers.ethers.utils.hexlify(networkChainId)
        });
        return;
    } // request is allowed. keep going..


    next(request, callback, chainId);
  };
};

const SignerJsonRpcMethods = ['personal_sign', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v4', 'eth_sendTransaction', 'eth_sendRawTransaction', 'sequence_getWalletContext', 'sequence_getWalletConfig', 'sequence_getWalletState', 'sequence_getNetworks', 'sequence_updateConfig', 'sequence_publishConfig', 'sequence_estimateGasLimits', 'sequence_gasRefundOptions', 'sequence_getNonce', 'sequence_relay'];
class SigningProvider {
  constructor(provider) {
    this.provider = void 0;

    this.sendAsyncMiddleware = next => {
      return (request, callback, chainId) => {
        // Forward signing requests to the signing provider
        if (SignerJsonRpcMethods.includes(request.method)) {
          this.provider.sendAsync(request, callback, chainId);
          return;
        } // Continue to next handler


        next(request, callback, chainId);
      };
    };

    this.provider = provider;
  }

}

class PublicProvider {
  constructor(rpcUrl) {
    this.privateJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', ...SignerJsonRpcMethods];
    this.provider = void 0;
    this.rpcUrl = void 0;

    this.sendAsyncMiddleware = next => {
      return (request, callback) => {
        // When provider is configured, send non-private methods to our local public provider
        if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {
          this.provider.send(request.method, request.params).then(r => {
            callback(undefined, {
              jsonrpc: '2.0',
              id: request.id,
              result: r
            });
          }).catch(e => callback(e));
          return;
        } // Continue to next handler


        utils.logger.debug('[public-provider] sending request to signer window', request.method);
        next(request, callback);
      };
    };

    if (rpcUrl) {
      this.setRpcUrl(rpcUrl);
    }
  }

  getRpcUrl() {
    return this.rpcUrl;
  }

  setRpcUrl(rpcUrl) {
    if (!rpcUrl || rpcUrl === '') {
      this.rpcUrl = undefined;
      this.provider = undefined;
    } else {
      this.rpcUrl = rpcUrl;
      this.provider = new providers.JsonRpcProvider(rpcUrl);
    }
  }

}

exports.AllowProvider = AllowProvider;
exports.CachedProvider = CachedProvider;
exports.EagerProvider = EagerProvider;
exports.JsonRpcExternalProvider = JsonRpcExternalProvider;
exports.JsonRpcRouter = JsonRpcRouter;
exports.JsonRpcSender = JsonRpcSender;
exports.JsonRpcVersion = JsonRpcVersion;
exports.PublicProvider = PublicProvider;
exports.SigningProvider = SigningProvider;
exports.allowProviderMiddleware = allowProviderMiddleware;
exports.checkNetworkConfig = checkNetworkConfig;
exports.createJsonRpcMiddlewareStack = createJsonRpcMiddlewareStack;
exports.createNetworkConfig = createNetworkConfig;
exports.ensureUniqueNetworks = ensureUniqueNetworks;
exports.ensureValidNetworks = ensureValidNetworks;
exports.exceptionProviderMiddleware = exceptionProviderMiddleware;
exports.findNetworkConfig = findNetworkConfig;
exports.getAuthNetwork = getAuthNetwork;
exports.getNetworkId = getNetworkId;
exports.isJsonRpcHandler = isJsonRpcHandler;
exports.isJsonRpcProvider = isJsonRpcProvider;
exports.isNetworkConfig = isNetworkConfig;
exports.isValidNetworkConfig = isValidNetworkConfig;
exports.loggingProviderMiddleware = loggingProviderMiddleware;
exports.mainnetNetworks = mainnetNetworks;
exports.maybeNetworkId = maybeNetworkId;
exports.networkProviderMiddleware = networkProviderMiddleware;
exports.networksIndex = networksIndex;
exports.sequenceContext = sequenceContext;
exports.sortNetworks = sortNetworks;
exports.testnetNetworks = testnetNetworks;
exports.updateNetworkConfig = updateNetworkConfig;
