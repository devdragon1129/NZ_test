'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ethers = require('ethers');
var providers = require('@ethersproject/providers');
var abi = require('@0xsequence/abi');
var transactions = require('@0xsequence/transactions');
var config = require('@0xsequence/config');
var utils$1 = require('ethers/lib/utils');
var utils = require('@0xsequence/utils');
var fetchPonyfill = require('fetch-ponyfill');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var fetchPonyfill__default = /*#__PURE__*/_interopDefault(fetchPonyfill);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function isBaseRelayerOptions(obj) {
  return obj.bundleCreation !== undefined && typeof obj.bundleCreation === 'boolean' || obj.creationGasLimit !== undefined && utils.isBigNumberish(obj.creationGasLimit) || obj.provider !== undefined && (ethers.providers.Provider.isProvider(obj.provider) || typeof obj.provider === 'string');
}
const BaseRelayerDefaults = {
  bundleCreation: true,
  creationGasLimit: ethers.ethers.constants.Two.pow(17)
};
class BaseRelayer {
  constructor(options) {
    this.provider = void 0;
    this.bundleCreation = void 0;
    this.creationGasLimit = void 0;

    const opts = _extends({}, BaseRelayerDefaults, options);

    this.bundleCreation = opts.bundleCreation;
    this.provider = opts.provider;
    this.creationGasLimit = ethers.ethers.BigNumber.from(opts.creationGasLimit);
  }

  async isWalletDeployed(walletAddress) {
    if (!this.provider) throw new Error('Bundled creation provider not found');
    return (await this.provider.getCode(walletAddress)) !== '0x';
  }

  prepareWalletDeploy(config$1, context) {
    const factoryInterface = new utils$1.Interface(abi.walletContracts.factory.abi);
    return {
      to: context.factory,
      data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy'), [context.mainModule, config.imageHash(config$1)])
    };
  }

  async prepareTransactions(config$1, context, signature, ...transactions$1) {
    //, gasLimit?: ethers.BigNumberish }> {
    const walletAddress = config.addressOf(config$1, context);
    const walletInterface = new utils$1.Interface(abi.walletContracts.mainModule.abi);

    const encodedSignature = async function () {
      const sig = await signature;
      if (typeof sig === 'string') return sig;
      return config.encodeSignature(sig);
    }();

    if (this.bundleCreation && !(await this.isWalletDeployed(walletAddress))) {
      return {
        to: context.guestModule,
        data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [transactions.sequenceTxAbiEncode([_extends({}, this.prepareWalletDeploy(config$1, context), {
          delegateCall: false,
          revertOnError: false,
          gasLimit: this.creationGasLimit,
          value: ethers.ethers.constants.Zero
        }), {
          delegateCall: false,
          revertOnError: true,
          gasLimit: ethers.ethers.constants.Zero,
          to: walletAddress,
          value: ethers.ethers.constants.Zero,
          data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [transactions.sequenceTxAbiEncode(transactions$1), transactions.readSequenceNonce(...transactions$1), await encodedSignature])
        }]), 0, []])
      };
    } else {
      return {
        to: walletAddress,
        data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [transactions.sequenceTxAbiEncode(transactions$1), transactions.readSequenceNonce(...transactions$1), await encodedSignature])
      };
    }
  }

}

const DEFAULT_GAS_LIMIT = ethers.ethers.BigNumber.from(800000);
const ProviderRelayerDefaults = {
  waitPollRate: 1000,
  deltaBlocksLog: 12,
  fromBlockLog: -1024
};
function isProviderRelayerOptions(obj) {
  return obj.provider !== undefined && providers.Provider.isProvider(obj.provider);
}
class ProviderRelayer extends BaseRelayer {
  constructor(options) {
    super(options);
    this.provider = void 0;
    this.waitPollRate = void 0;
    this.deltaBlocksLog = void 0;
    this.fromBlockLog = void 0;

    const opts = _extends({}, ProviderRelayerDefaults, options);

    this.provider = opts.provider;
    this.waitPollRate = opts.waitPollRate;
    this.deltaBlocksLog = opts.deltaBlocksLog;
    this.fromBlockLog = opts.fromBlockLog;
  }

  async estimateGasLimits(config$1, context, ...transactions) {
    var _this = this;

    const walletAddr = config.addressOf(config$1, context);
    const gasCosts = await Promise.all(transactions.map(async function (tx) {
      // Respect gasLimit request of the transaction (as long as its not 0)
      if (tx.gasLimit && !ethers.ethers.BigNumber.from(tx.gasLimit || 0).eq(ethers.ethers.constants.Zero)) {
        return tx.gasLimit;
      } // Fee can't be estimated locally for delegateCalls


      if (tx.delegateCall) {
        return DEFAULT_GAS_LIMIT;
      } // Fee can't be estimated for self-called if wallet hasn't been deployed


      if (tx.to === walletAddr && !(await _this.isWalletDeployed(walletAddr))) {
        return DEFAULT_GAS_LIMIT;
      }

      if (!_this.provider) {
        throw new Error('signer.provider is not set, but is required');
      } // TODO: If the wallet address has been deployed, gas limits can be
      // estimated with more accurately by using self-calls with the batch transactions one by one


      return _this.provider.estimateGas({
        from: walletAddr,
        to: tx.to,
        data: tx.data,
        value: tx.value
      });
    }));
    return transactions.map((t, i) => {
      t.gasLimit = gasCosts[i];
      return t;
    });
  }

  async getNonce(config$1, context, space, blockTag) {
    if (!this.provider) {
      throw new Error('provider is not set');
    }

    const addr = config.addressOf(config$1, context);

    if ((await this.provider.getCode(addr)) === '0x') {
      return 0;
    }

    const module = new ethers.ethers.Contract(addr, abi.walletContracts.mainModule.abi, this.provider);
    return (await module.readNonce(space ? space : 0, {
      blockTag: blockTag
    })).toNumber();
  }

  async wait(metaTxnId, timeout) {
    if (typeof metaTxnId !== 'string') {
      console.log("computing id", metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions);
      return this.wait(transactions.computeMetaTxnHash(config.addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions), timeout);
    } // Transactions can only get executed on nonce change
    // get all nonce changes and look for metaTxnIds in between logs


    const timeoutTime = new Date().getTime() + timeout;
    let lastBlock = this.fromBlockLog;

    if (lastBlock < 0) {
      const block = await this.provider.getBlockNumber();
      lastBlock = block + lastBlock;
    }

    const normalMetaTxnId = metaTxnId.replace('0x', '');

    while (new Date().getTime() < timeoutTime) {
      const block = await this.provider.getBlockNumber();
      const logs = await this.provider.getLogs({
        fromBlock: Math.max(0, lastBlock - this.deltaBlocksLog),
        toBlock: block,
        // Nonce change event topic
        topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']
      });
      lastBlock = block; // Get receipts of all transactions

      const txs = await Promise.all(logs.map(l => this.provider.getTransactionReceipt(l.transactionHash))); // Find a transaction with a TxExecuted log

      const found = txs.find(tx => tx.logs.find(l => l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId || l.topics.length === 1 && // TxFailed event topic
      l.topics[0] === "0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7" && l.data.length >= 64 && l.data.replace('0x', '').startsWith(normalMetaTxnId))); // If found return that

      if (found) {
        return _extends({}, found, await this.provider.getTransaction(found.transactionHash));
      } // Otherwise wait and try again


      await new Promise(r => setTimeout(r, this.waitPollRate));
    }

    throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);
  }

}

function isLocalRelayerOptions(obj) {
  return obj.signer !== undefined && ethers.Signer.isSigner(obj.signer);
}
class LocalRelayer extends ProviderRelayer {
  constructor(options) {
    super(ethers.Signer.isSigner(options) ? {
      provider: options.provider
    } : _extends({}, options, {
      provider: options.signer.provider
    }));
    this.signer = void 0;
    this.signer = ethers.Signer.isSigner(options) ? options : options.signer;
    if (!this.signer.provider) throw new Error("Signer must have a provider");
  }

  async deployWallet(config, context) {
    // NOTE: on hardhat some tests fail on HookCallerMock when not passing gasLimit directly as below,
    // and using eth_gasEstimate. Perhaps review HookCallerMock.sol and fix it to avoid what looks
    // like an infinite loop?
    const walletDeployTxn = this.prepareWalletDeploy(config, context); // NOTE: for hardhat to pass, we have to set the gasLimit directly, as its unable to estimate

    return this.signer.sendTransaction(_extends({}, walletDeployTxn, {
      gasLimit: ethers.ethers.constants.Two.pow(17)
    }));
  }

  async gasRefundOptions(_config, _context, ..._transactions) {
    return [];
  }

  async relay(signedTxs) {
    if (!signedTxs.context.guestModule || signedTxs.context.guestModule.length !== 42) {
      throw new Error('LocalRelayer requires the context.guestModule address');
    }

    const txRequest = await this.prepareTransactions(signedTxs.config, signedTxs.context, signedTxs.signature, ...signedTxs.transactions); // TODO: think about computing gas limit individually, summing together and passing across
    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation
    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum.add(tx.gasLimit), ethers.BigNumber.from(0))
    // txRequest.gasLimit = gasLimit

    return this.signer.sendTransaction(txRequest);
  }

}

/* eslint-disable */
// relayer v0.3.0 ab6bd1a3fe3c382e79ec52ca7d0f41c939517306
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.
// WebRPC description and code-gen version
const WebRPCVersion = "v1"; // Schema version of your RIDL schema

const WebRPCSchemaVersion = "v0.3.0"; // Schema hash generated from your RIDL schema

const WebRPCSchemaHash = "ab6bd1a3fe3c382e79ec52ca7d0f41c939517306"; //
// Types
//

let ETHTxnStatus;

(function (ETHTxnStatus) {
  ETHTxnStatus["UNKNOWN"] = "UNKNOWN";
  ETHTxnStatus["FAILED"] = "FAILED";
  ETHTxnStatus["PARTIALLY_FAILED"] = "PARTIALLY_FAILED";
  ETHTxnStatus["SENT"] = "SENT";
  ETHTxnStatus["REVERTED"] = "REVERTED";
  ETHTxnStatus["SUCCESS"] = "SUCCESS";
  ETHTxnStatus["FINAL"] = "FINAL";
  ETHTxnStatus["DROPPED"] = "DROPPED";
})(ETHTxnStatus || (ETHTxnStatus = {}));

let ContractType;

(function (ContractType) {
  ContractType["UNKNOWN"] = "UNKNOWN";
  ContractType["ERC20_TOKEN"] = "ERC20_TOKEN";
  ContractType["ERC721_TOKEN"] = "ERC721_TOKEN";
  ContractType["ERC1155_TOKEN"] = "ERC1155_TOKEN";
  ContractType["META_ERC20_WRAPPER"] = "META_ERC20_WRAPPER";
  ContractType["NIFTYSWAP"] = "NIFTYSWAP";
  ContractType["BRIDGE"] = "BRIDGE";
})(ContractType || (ContractType = {}));

//
// Client
//
class RelayerService {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/RelayerService/';

    this.ping = headers => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.version = headers => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      });
    };

    this.runtimeStatus = headers => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.getSequenceContext = headers => {
      return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            data: _data.data
          };
        });
      });
    };

    this.getChainID = headers => {
      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            chainID: _data.chainID
          };
        });
      });
    };

    this.sendMetaTxn = (args, headers) => {
      return this.fetch(this.url('SendMetaTxn'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            txnHash: _data.txnHash
          };
        });
      });
    };

    this.getMetaTxnNonce = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnNonce'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            nonce: _data.nonce
          };
        });
      });
    };

    this.getMetaTxnReceipt = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnReceipt'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            receipt: _data.receipt
          };
        });
      });
    };

    this.tokenFee = headers => {
      return this.fetch(this.url('TokenFee'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            isFee: _data.isFee,
            fee: _data.fee
          };
        });
      });
    };

    this.updateMetaTxnGasLimits = (args, headers) => {
      return this.fetch(this.url('UpdateMetaTxnGasLimits'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            payload: _data.payload
          };
        });
      });
    };

    this.feeTokens = headers => {
      return this.fetch(this.url('FeeTokens'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            isFeeRequired: _data.isFeeRequired,
            tokens: _data.tokens
          };
        });
      });
    };

    this.getMetaTxnNetworkFeeOptions = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnNetworkFeeOptions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            options: _data.options
          };
        });
      });
    };

    this.pushMetaTxn = (args, headers) => {
      return this.fetch(this.url('PushMetaTxn'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.getMetaTxn = (args, headers) => {
      return this.fetch(this.url('GetMetaTxn'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            signedMetaTxn: _data.signedMetaTxn
          };
        });
      });
    };

    this.hostname = hostname;
    this.fetch = fetch;
  }

  url(name) {
    return this.hostname + this.path + name;
  }

}

const createHTTPRequest = (body = {}, headers = {}) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {})
  };
};

const buildResponse = res => {
  return res.text().then(text => {
    let data;

    try {
      data = JSON.parse(text);
    } catch (err) {
      throw {
        code: 'unknown',
        msg: `expecting JSON, got: ${text}`,
        status: res.status
      };
    }

    if (!res.ok) {
      throw data; // webrpc error response
    }

    return data;
  });
};

var relayer_gen = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WebRPCVersion: WebRPCVersion,
  WebRPCSchemaVersion: WebRPCSchemaVersion,
  WebRPCSchemaHash: WebRPCSchemaHash,
  get ETHTxnStatus () { return ETHTxnStatus; },
  get ContractType () { return ContractType; },
  RelayerService: RelayerService
});

const FAILED_STATUSES = [ETHTxnStatus.FAILED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.DROPPED, ETHTxnStatus.REVERTED];
function isRpcRelayerOptions(obj) {
  return obj.url !== undefined && typeof obj.url === 'string';
}
class RpcRelayer extends BaseRelayer {
  constructor(options) {
    super(options);
    this.service = void 0;
    this.service = new RelayerService(options.url, fetchPonyfill__default['default']().fetch);
  }

  async waitReceipt(metaTxnHash, wait = 1000) {
    if (typeof metaTxnHash !== 'string') {
      console.log("computing id", metaTxnHash.config, metaTxnHash.context, metaTxnHash.chainId, ...metaTxnHash.transactions);
      return this.waitReceipt(transactions.computeMetaTxnHash(config.addressOf(metaTxnHash.config, metaTxnHash.context), metaTxnHash.chainId, ...metaTxnHash.transactions));
    }

    console.log("waiting for", metaTxnHash);
    let result = await this.service.getMetaTxnReceipt({
      metaTxID: metaTxnHash
    }); // TODO: remove check for 'UNKNOWN' status when 'QUEUED' status is supported

    while ((!result.receipt.txnReceipt || result.receipt.txnReceipt === 'null') && (result.receipt.status === 'UNKNOWN' || result.receipt.status === 'QUEUED')) {
      await new Promise(r => setTimeout(r, wait));
      result = await this.service.getMetaTxnReceipt({
        metaTxID: metaTxnHash
      });
    }

    return result;
  }

  async estimateGasLimits(config$1, context, ...transactions$1) {
    utils.logger.info(`[rpc-relayer/estimateGasLimits] estimate gas limits request ${JSON.stringify(transactions$1)}`);

    if (transactions$1.length == 0) {
      return [];
    }

    const addr = config.addressOf(config$1, context);
    const prevNonce = transactions.readSequenceNonce(...transactions$1); // Set temporal nonce to simulate meta-txn

    if (prevNonce === undefined) {
      transactions$1 = transactions.appendNonce(transactions$1, await this.getNonce(config$1, context));
    }

    const coder = ethers.ethers.utils.defaultAbiCoder;
    const encoded = coder.encode([transactions.MetaTransactionsType], [transactions.sequenceTxAbiEncode(transactions$1)]);
    const res = await this.service.updateMetaTxnGasLimits({
      walletAddress: addr,
      payload: encoded
    });
    const decoded = coder.decode([transactions.MetaTransactionsType], res.payload)[0];
    const modTxns = transactions$1.map((t, i) => _extends({}, t, {
      gasLimit: decoded[i].gasLimit
    }));
    utils.logger.info(`[rpc-relayer/estimateGasLimits] got transactions with gas limits ${JSON.stringify(modTxns)}`); // Remove placeholder nonce if previously defined

    return prevNonce === undefined ? modTxns : transactions.appendNonce(modTxns, prevNonce);
  }

  async gasRefundOptions(config$1, context, ...transactions$1) {
    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value
    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically
    // with http cache response for this endpoint and service-worker.. lots of approaches
    const feeTokens = await this.service.feeTokens();

    if (feeTokens.isFeeRequired) {
      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ');
      utils.logger.info(`[rpc-relayer/gasRefundOptions] relayer fees are required, accepted tokens are ${symbols}`);
      const addr = config.addressOf(config$1, context);
      const prevNonce = transactions.readSequenceNonce(...transactions$1); // Set temporal nonce to simulate meta-txn

      if (prevNonce === undefined) {
        transactions$1 = transactions.appendNonce(transactions$1, await this.getNonce(config$1, context));
      }

      const res = await this.service.getMetaTxnNetworkFeeOptions({
        walletConfig: _extends({}, config$1, {
          address: addr
        }),
        payload: transactions.packMetaTransactionsData(...transactions$1)
      });
      utils.logger.info(`[rpc-relayer/gasRefundOptions] got refund options ${JSON.stringify(res.options)}`);
      return res.options;
    } else {
      utils.logger.info(`[rpc-relayer/gasRefundOptions] relayer fees are not required`);
      return [];
    }
  }

  async getNonce(config$1, context, space) {
    const addr = config.addressOf(config$1, context);
    utils.logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${addr} space: ${space}`);
    const resp = await this.service.getMetaTxnNonce({
      walletContractAddress: addr
    });
    const nonce = ethers.ethers.BigNumber.from(resp.nonce).toNumber();
    utils.logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${addr} ${nonce} space: ${space}`);
    return nonce;
  }

  async relay(signedTxs) {
    utils.logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)}`);

    if (!this.provider) {
      utils.logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);
      throw new Error('provider is not set');
    }

    const prep = await this.prepareTransactions(signedTxs.config, signedTxs.context, signedTxs.signature, ...signedTxs.transactions);
    const metaTxn = await this.service.sendMetaTxn({
      call: {
        contract: prep.to,
        input: prep.data
      }
    });
    utils.logger.warn(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`);
    return this.wait(metaTxn.txnHash);
  }

  async wait(metaTxnHash, wait = 1000) {
    var _this = this;

    const {
      receipt
    } = await this.waitReceipt(metaTxnHash, wait);

    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {
      throw new MetaTransactionResponseException(receipt);
    }

    const txReceipt = JSON.parse(receipt.txnReceipt);
    return {
      blockHash: txReceipt.blockHash,
      blockNumber: ethers.ethers.BigNumber.from(txReceipt.blockNumber).toNumber(),
      confirmations: 1,
      from: typeof metaTxnHash === 'string' ? undefined : config.addressOf(metaTxnHash.config, metaTxnHash.context),
      hash: txReceipt.transactionHash,
      raw: receipt.txnReceipt,
      wait: async function (confirmations) {
        return _this.provider.waitForTransaction(txReceipt.transactionHash, confirmations);
      }
    };
  }

}

class MetaTransactionResponseException {
  constructor(receipt) {
    this.receipt = receipt;
  }

}

function isRelayer(cand) {
  return cand && cand.estimateGasLimits !== undefined && cand.gasRefundOptions !== undefined && cand.getNonce !== undefined && cand.relay !== undefined;
}

exports.BaseRelayer = BaseRelayer;
exports.BaseRelayerDefaults = BaseRelayerDefaults;
exports.LocalRelayer = LocalRelayer;
exports.ProviderRelayer = ProviderRelayer;
exports.ProviderRelayerDefaults = ProviderRelayerDefaults;
exports.RpcRelayer = RpcRelayer;
exports.RpcRelayerProto = relayer_gen;
exports.isBaseRelayerOptions = isBaseRelayerOptions;
exports.isLocalRelayerOptions = isLocalRelayerOptions;
exports.isProviderRelayerOptions = isProviderRelayerOptions;
exports.isRelayer = isRelayer;
exports.isRpcRelayerOptions = isRpcRelayerOptions;
exports.proto = relayer_gen;
