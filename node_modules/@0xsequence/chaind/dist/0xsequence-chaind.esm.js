function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/* eslint-disable */
// chaind v0.1.0 531b5f9feca9a458710a75e770b5ad8f4bdb77e2
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.
// WebRPC description and code-gen version
const WebRPCVersion = "v1"; // Schema version of your RIDL schema

const WebRPCSchemaVersion = "v0.1.0"; // Schema hash generated from your RIDL schema

const WebRPCSchemaHash = "531b5f9feca9a458710a75e770b5ad8f4bdb77e2"; //
// Types
//

let SortOrder;

(function (SortOrder) {
  SortOrder["DESC"] = "DESC";
  SortOrder["ASC"] = "ASC";
})(SortOrder || (SortOrder = {}));

//
// Client
//
class ChaindService {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/ChaindService/';

    this.ping = headers => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.version = headers => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      });
    };

    this.runtimeStatus = headers => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.etherBalance = (args, headers) => {
      return this.fetch(this.url('EtherBalance'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            balance: _data.balance
          };
        });
      });
    };

    this.contractBalanceOf = (args, headers) => {
      return this.fetch(this.url('ContractBalanceOf'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            balances: _data.balances
          };
        });
      });
    };

    this.contractBalanceOfTokenIDs = (args, headers) => {
      return this.fetch(this.url('ContractBalanceOfTokenIDs'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            balances: _data.balances
          };
        });
      });
    };

    this.contractBalanceSync = (args, headers) => {
      return this.fetch(this.url('ContractBalanceSync'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            balances: _data.balances
          };
        });
      });
    };

    this.contractBalanceSyncTokenIDs = (args, headers) => {
      return this.fetch(this.url('ContractBalanceSyncTokenIDs'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            balances: _data.balances
          };
        });
      });
    };

    this.contractCall = (args, headers) => {
      return this.fetch(this.url('ContractCall'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            returns: _data.returns
          };
        });
      });
    };

    this.hostname = hostname;
    this.fetch = fetch;
  }

  url(name) {
    return this.hostname + this.path + name;
  }

}

const createHTTPRequest = (body = {}, headers = {}) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {})
  };
};

const buildResponse = res => {
  return res.text().then(text => {
    let data;

    try {
      data = JSON.parse(text);
    } catch (err) {
      throw {
        code: 'unknown',
        msg: `expecting JSON, got: ${text}`,
        status: res.status
      };
    }

    if (!res.ok) {
      throw data; // webrpc error response
    }

    return data;
  });
};

export { ChaindService, SortOrder, WebRPCSchemaHash, WebRPCSchemaVersion, WebRPCVersion };
