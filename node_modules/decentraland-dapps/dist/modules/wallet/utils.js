"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProviderChainId = exports.getAddEthereumChainParameters = exports.sendTransaction = exports.transactionEvents = exports.TransactionEventType = exports.getTargetNetworkProvider = exports.buildWallet = exports.fetchManaBalance = exports.setTransactionsApiUrl = exports.getTransactionsApiUrl = void 0;
const events_1 = require("events");
const ethers_1 = require("ethers");
const eth_1 = require("web3x/eth");
const decentraland_transactions_1 = require("decentraland-transactions");
const chain_id_1 = require("@dcl/schemas/dist/dapps/chain-id");
const eth_2 = require("../../lib/eth");
const chainConfiguration_1 = require("../../lib/chainConfiguration");
let TRANSACTIONS_API_URL = 'https://transactions-api.decentraland.co/v1';
const getTransactionsApiUrl = () => TRANSACTIONS_API_URL;
exports.getTransactionsApiUrl = getTransactionsApiUrl;
const setTransactionsApiUrl = (url) => (TRANSACTIONS_API_URL = url);
exports.setTransactionsApiUrl = setTransactionsApiUrl;
function fetchManaBalance(chainId, address) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const provider = yield eth_2.getNetworkProvider(chainId);
            const contract = decentraland_transactions_1.getContract(decentraland_transactions_1.ContractName.MANAToken, chainId);
            const mana = new ethers_1.Contract(contract.address, contract.abi, new ethers_1.providers.Web3Provider(provider));
            const balance = yield mana.balanceOf(address);
            return parseFloat(ethers_1.utils.formatEther(balance));
        }
        catch (error) {
            return 0;
        }
    });
}
exports.fetchManaBalance = fetchManaBalance;
function buildWallet() {
    return __awaiter(this, void 0, void 0, function* () {
        const provider = yield eth_2.getConnectedProvider();
        if (!provider) {
            // This could happen if metamask is not installed
            throw new Error('Could not connect to Ethereum');
        }
        const eth = new eth_1.Eth(provider);
        const accounts = yield eth.getAccounts();
        if (accounts.length === 0) {
            // This could happen if metamask was not enabled
            throw new Error('Could not get address');
        }
        const address = accounts[0].toString();
        const chainId = yield eth.getId();
        const chainConfig = chainConfiguration_1.getChainConfiguration(chainId);
        const expectedChainId = eth_2.getConnectedProviderChainId();
        const expectedChainConfig = chainConfiguration_1.getChainConfiguration(expectedChainId);
        const networks = {};
        for (const network of Object.keys(expectedChainConfig.networkMapping)) {
            const networkChainId = expectedChainConfig.networkMapping[network];
            networks[network] = {
                chainId: networkChainId,
                mana: yield fetchManaBalance(networkChainId, address)
            };
        }
        return {
            address: address.toLowerCase(),
            providerType: eth_2.getConnectedProviderType(),
            networks: networks,
            network: chainConfig.network,
            chainId
        };
    });
}
exports.buildWallet = buildWallet;
function getTargetNetworkProvider(chainId) {
    return __awaiter(this, void 0, void 0, function* () {
        const networkProvider = yield eth_2.getNetworkProvider(chainId);
        return new ethers_1.providers.Web3Provider(networkProvider);
    });
}
exports.getTargetNetworkProvider = getTargetNetworkProvider;
var TransactionEventType;
(function (TransactionEventType) {
    TransactionEventType["ERROR"] = "error";
    TransactionEventType["SUCCESS"] = "success";
})(TransactionEventType = exports.TransactionEventType || (exports.TransactionEventType = {}));
exports.transactionEvents = new events_1.EventEmitter();
function sendTransaction(...args) {
    return __awaiter(this, void 0, void 0, function* () {
        const [contract, contractMethodNameOrGetPopulatedTransaction, ...contractArguments] = args;
        try {
            // get connected provider
            const connectedProvider = yield eth_2.getConnectedProvider();
            if (!connectedProvider) {
                throw new Error('Provider not connected');
            }
            const chainId = yield getProviderChainId(connectedProvider);
            // get a provider for the target network
            const targetNetworkProvider = yield getTargetNetworkProvider(contract.chainId);
            // intantiate the contract
            const contractInstance = new ethers_1.Contract(contract.address, contract.abi, targetNetworkProvider);
            // populate the transaction data
            const unsignedTx = yield (typeof contractMethodNameOrGetPopulatedTransaction ===
                'function'
                ? contractMethodNameOrGetPopulatedTransaction(contractInstance.populateTransaction)
                : contractInstance.populateTransaction[contractMethodNameOrGetPopulatedTransaction](...contractArguments));
            // if the connected provider is in the target network, use it to sign and send the tx
            if (chainId === contract.chainId) {
                const signer = targetNetworkProvider.getSigner();
                const tx = yield signer.sendTransaction(unsignedTx);
                exports.transactionEvents.emit(TransactionEventType.SUCCESS, { txHash: tx.hash });
                return tx.hash;
            }
            else {
                // otherwise, send it as a meta tx
                const txHash = yield decentraland_transactions_1.sendMetaTransaction(connectedProvider, targetNetworkProvider, unsignedTx.data, contract, {
                    serverURL: exports.getTransactionsApiUrl()
                });
                exports.transactionEvents.emit(TransactionEventType.SUCCESS, { txHash });
                return txHash;
            }
        }
        catch (error) {
            const data = {
                type: TransactionEventType.ERROR,
                error: error
            };
            exports.transactionEvents.emit(TransactionEventType.ERROR, data);
            throw error;
        }
    });
}
exports.sendTransaction = sendTransaction;
function getAddEthereumChainParameters(chainId) {
    const hexChainId = '0x' + chainId.toString(16);
    const chainName = chain_id_1.getChainName(chainId);
    const config = chainConfiguration_1.getChainConfiguration(chainId);
    switch (chainId) {
        case chain_id_1.ChainId.MATIC_MAINNET:
            return {
                chainId: hexChainId,
                chainName,
                nativeCurrency: {
                    name: 'MATIC',
                    symbol: 'MATIC',
                    decimals: 18
                },
                rpcUrls: ['https://rpc-mainnet.maticvigil.com/'],
                blockExplorerUrls: ['https://polygonscan.com/']
            };
        case chain_id_1.ChainId.MATIC_MUMBAI:
            return {
                chainId: hexChainId,
                chainName,
                nativeCurrency: {
                    name: 'MATIC',
                    symbol: 'MATIC',
                    decimals: 18
                },
                rpcUrls: ['https://rpc-mumbai.maticvigil.com/'],
                blockExplorerUrls: ['https://mumbai.polygonscan.com/']
            };
        case chain_id_1.ChainId.ETHEREUM_MAINNET:
        case chain_id_1.ChainId.ETHEREUM_ROPSTEN:
        case chain_id_1.ChainId.ETHEREUM_RINKEBY:
        case chain_id_1.ChainId.ETHEREUM_KOVAN:
        case chain_id_1.ChainId.ETHEREUM_GOERLI:
            return {
                chainId: hexChainId,
                chainName,
                nativeCurrency: {
                    name: 'Ether',
                    symbol: 'ETH',
                    decimals: 18
                },
                rpcUrls: [config.rpcURL],
                blockExplorerUrls: ['https://etherscan.io']
            };
    }
}
exports.getAddEthereumChainParameters = getAddEthereumChainParameters;
/**
 * Obtains the chain id through a provider.
 * Different providers might return the chain id as a hex or a number.
 * This function abtracts the logic in order to always obtain the chain id as a number from any given provider.
 * @param provider - The provider used to obtain the chain id
 * @returns A number representing the chain id, Eg: 80001 for Mumbai, 137 for Matic Mainnet
 */
function getProviderChainId(provider) {
    return __awaiter(this, void 0, void 0, function* () {
        const providerChainId = (yield provider.request({
            method: 'eth_chainId',
            params: []
        }));
        let chainId;
        if (typeof providerChainId === 'string') {
            chainId = parseInt(providerChainId, 16);
        }
        else {
            chainId = providerChainId;
        }
        return chainId;
    });
}
exports.getProviderChainId = getProviderChainId;
//# sourceMappingURL=utils.js.map