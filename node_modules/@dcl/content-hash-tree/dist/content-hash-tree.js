"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentHashTree = void 0;
const merkle_tree_1 = __importDefault(require("./merkle-tree"));
const ethers_1 = require("ethers");
class ContentHashTree {
    constructor(contentHashes) {
        this.tree = new merkle_tree_1.default(contentHashes.map((contentHash, index) => {
            return ContentHashTree.toNode(index, contentHash);
        }));
    }
    static verifyProof(index, contentHash, proof, root) {
        let pair = ContentHashTree.toNode(index, contentHash);
        for (const item of proof) {
            pair = merkle_tree_1.default.combinedHash(pair, item);
        }
        return pair.equals(root);
    }
    // keccak256(abi.encode(index, contentHash))
    static toNode(index, contentHash) {
        return Buffer.from(ethers_1.utils
            .solidityKeccak256(['uint256', 'string'], [index, contentHash])
            .substr(2), 'hex');
    }
    getHexRoot() {
        return this.tree.getHexRoot();
    }
    // returns the hex bytes32 values of the proof
    getProof(index, contentHash) {
        return this.tree.getHexProof(ContentHashTree.toNode(index, contentHash));
    }
}
exports.ContentHashTree = ContentHashTree;
//# sourceMappingURL=content-hash-tree.js.map