"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFile = void 0;
const jszip_1 = __importDefault(require("jszip"));
const path_1 = require("path");
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const constants_1 = require("../item/constants");
const util_1 = require("util");
const constants_2 = require("./constants");
const schemas_1 = require("./schemas");
const files_errors_1 = require("./files.errors");
const ajv = new ajv_1.default();
(0, ajv_formats_1.default)(ajv);
const validator = ajv
    .addSchema(schemas_1.WearableConfigSchema, 'WearableConfig')
    .addSchema(schemas_1.BuilderConfigSchema, 'BuilderConfig');
async function loadFile(fileName, file) {
    const extension = getExtension(fileName);
    if (extension === '.zip') {
        return handleZippedModelFiles(file);
    }
    else if (isModelPath(fileName)) {
        return handleFileModel(fileName, file);
    }
    else {
        throw new files_errors_1.WrongExtensionError(fileName);
    }
}
exports.loadFile = loadFile;
function getExtension(fileName) {
    const matches = fileName.match(/\.[0-9a-z]+$/i);
    const extension = matches ? matches[0] : null;
    return extension;
}
function isImageFile(fileName) {
    return fileName.toLowerCase().endsWith('.png');
}
function isModelFile(fileName) {
    fileName = fileName.toLowerCase();
    return fileName.endsWith('.gltf') || fileName.endsWith('.glb');
}
function isModelPath(fileName) {
    fileName = fileName.toLowerCase();
    // we ignore PNG files that end with "_mask", since those are auxiliary
    const isMask = fileName.includes('_mask');
    return (isModelFile(fileName) ||
        (fileName.indexOf(constants_1.THUMBNAIL_PATH) === -1 &&
            !isMask &&
            isImageFile(fileName)));
}
/**
 * Unzips files and build the content record and asset config.
 * One of the models will be taken into consideration if multiple models are uploaded.
 *
 * @param zipFile - The ZIP file.
 */
async function handleZippedModelFiles(zipFile) {
    const zip = await jszip_1.default.loadAsync(zipFile);
    const fileNames = [];
    const promiseOfFileContents = [];
    let fileFormat;
    if (globalThis.Blob && zipFile instanceof globalThis.Blob) {
        fileFormat = 'blob';
    }
    else if (Buffer.isBuffer(zipFile)) {
        fileFormat = 'nodebuffer';
    }
    else if (zipFile instanceof Uint8Array) {
        fileFormat = 'uint8array';
    }
    else if (zipFile instanceof ArrayBuffer) {
        fileFormat = 'arraybuffer';
    }
    zip.forEach((filePath, file) => {
        if (!(0, path_1.basename)(filePath).startsWith('.') &&
            (0, path_1.basename)(filePath) !== constants_2.WEARABLE_MANIFEST &&
            (0, path_1.basename)(filePath) !== constants_2.BUILDER_MANIFEST) {
            fileNames.push(filePath);
            promiseOfFileContents.push(file.async(fileFormat));
        }
    });
    const fileContents = await Promise.all(promiseOfFileContents);
    const content = fileNames.reduce((acc, fileName, index) => {
        let size;
        if (globalThis.Blob && fileContents[index] instanceof globalThis.Blob) {
            size = fileContents[index].size;
        }
        else {
            size = fileContents[index].length;
        }
        if (size > constants_2.MAX_FILE_SIZE) {
            throw new files_errors_1.FileTooBigError(fileName, size);
        }
        acc[fileName] = fileContents[index];
        return acc;
    }, {});
    let wearable = undefined;
    let builder = undefined;
    const wearableZipFile = zip.file(constants_2.WEARABLE_MANIFEST);
    const builderZipFile = zip.file(constants_2.BUILDER_MANIFEST);
    if (wearableZipFile) {
        const wearableFileContents = await wearableZipFile.async('uint8array');
        wearable = await loadWearableConfig(wearableFileContents);
        wearable.data.representations.forEach((representation) => {
            if (!representation.contents.includes(representation.mainFile)) {
                throw new files_errors_1.ModelInRepresentationNotFoundError(representation.mainFile);
            }
            representation.contents.forEach((content) => {
                if (!zip.file(representation.mainFile)) {
                    throw new files_errors_1.FileNotFoundError(content);
                }
            });
        });
    }
    if (builderZipFile) {
        const builderZipFileContents = await builderZipFile.async('uint8array');
        builder = await loadBuilderConfig(builderZipFileContents);
    }
    let result = { content };
    if (builder) {
        result = { ...result, builder };
    }
    if (wearable) {
        result = { ...result, wearable };
    }
    else {
        const mainModelFile = fileNames.find(isModelPath);
        if (!mainModelFile) {
            throw new files_errors_1.ModelFileNotFoundError();
        }
        result = { ...result, mainModel: mainModelFile };
    }
    return result;
}
function handleFileModel(fileName, file) {
    return { content: { [fileName]: file }, mainModel: fileName };
}
async function readContent(file) {
    if (globalThis.Blob && file instanceof globalThis.Blob) {
        return file.text();
    }
    else if (globalThis.TextDecoder) {
        return new TextDecoder('utf-8').decode(file);
    }
    return new util_1.TextDecoder('utf-8').decode(file);
}
async function loadBuilderConfig(file) {
    const content = await readContent(file);
    const parsedContent = JSON.parse(content);
    if (!validator.validate('BuilderConfig', parsedContent)) {
        throw new files_errors_1.InvalidBuilderConfigFileError(validator.errors);
    }
    return parsedContent;
}
async function loadWearableConfig(file) {
    const content = await readContent(file);
    const parsedContent = JSON.parse(content);
    if (!validator.validate('WearableConfig', parsedContent)) {
        throw new files_errors_1.InvalidWearableConfigFileError(validator.errors);
    }
    return parsedContent;
}
//# sourceMappingURL=files.js.map