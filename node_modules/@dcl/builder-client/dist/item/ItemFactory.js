"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemFactory = void 0;
const uuid_1 = require("uuid");
const content_1 = require("../content/content");
const constants_1 = require("./constants");
const ItemFactory_errors_1 = require("./ItemFactory.errors");
const types_1 = require("./types");
class ItemFactory {
    constructor(item = null) {
        this.item = item;
        this.newContent = {};
    }
    /**
     * Instantiates a new item with the base properties.
     * @param BasicItem - The set of properties that, without a representation, defines an item.
     */
    newItem({ id, name, rarity, category, collection_id, description, urn }) {
        if (!this.isMetadataTextValid(name) ||
            (description && !this.isMetadataTextValid(description))) {
            throw new Error('Invalid item name or description');
        }
        this.item = {
            id: id !== null && id !== void 0 ? id : (0, uuid_1.v4)(),
            name,
            description: description || '',
            thumbnail: constants_1.THUMBNAIL_PATH,
            type: types_1.ItemType.WEARABLE,
            collection_id: collection_id !== null && collection_id !== void 0 ? collection_id : null,
            content_hash: null,
            rarity,
            urn: urn !== null && urn !== void 0 ? urn : null,
            data: {
                category,
                replaces: [],
                hides: [],
                tags: [],
                representations: []
            },
            metrics: constants_1.DEFAULT_METRICS,
            contents: {}
        };
        return this;
    }
    /**
     * Instantiates a new item with the base properties.
     * @param wearableConfig - The AssetJSON object containing all the information about the item.
     * @param contents - The item's content.
     */
    fromConfig(wearableConfig, content, builderConfig) {
        var _a, _b, _c, _d, _e;
        this.newItem({
            id: (_a = builderConfig === null || builderConfig === void 0 ? void 0 : builderConfig.id) !== null && _a !== void 0 ? _a : (0, uuid_1.v4)(),
            name: wearableConfig.name,
            rarity: (_b = wearableConfig.rarity) !== null && _b !== void 0 ? _b : null,
            category: wearableConfig.data.category,
            collection_id: (_c = builderConfig === null || builderConfig === void 0 ? void 0 : builderConfig.collectionId) !== null && _c !== void 0 ? _c : null,
            description: (_d = wearableConfig.description) !== null && _d !== void 0 ? _d : null,
            urn: (_e = wearableConfig.id) !== null && _e !== void 0 ? _e : null
        });
        if (content[constants_1.THUMBNAIL_PATH]) {
            this.withThumbnail(content[constants_1.THUMBNAIL_PATH]);
        }
        if (wearableConfig.data.replaces) {
            this.withReplaces(wearableConfig.data.replaces);
        }
        if (wearableConfig.data.hides) {
            this.withHides(wearableConfig.data.hides);
        }
        if (wearableConfig.data.tags) {
            this.withTags(wearableConfig.data.tags);
        }
        wearableConfig.data.representations.forEach((representation) => {
            representation.bodyShapes.forEach((bodyShape) => {
                this.withRepresentation(bodyShape, representation.mainFile, this.buildWearableConfigRepresentationContents(content, representation.contents), representation.overrideHides, representation.overrideReplaces);
            });
        });
        return this;
    }
    /**
     * Sets or updates the item's id.
     * It requires the item to be defined first.
     * @param id - The item's id.
     */
    withId(id) {
        return this.setItemProperty('id', id);
    }
    /**
     * Sets or updates the item's name.
     * It requires the item to be defined first.
     * @param name - The item's name.
     */
    withName(name) {
        return this.setItemProperty('name', name);
    }
    /**
     * Sets or updates the item's description.
     * It requires the item to be defined first.
     * @param description - The item's description.
     */
    withDescription(description) {
        return this.setItemProperty('description', description);
    }
    /**
     * Sets or updates the item's replaces property.
     * It requires the item to be defined first.
     * @param replaces - The item's replaces property.
     */
    withReplaces(replaces) {
        return this.setItemDataProperty('replaces', replaces);
    }
    /**
     * Sets or updates the item's rarity.
     * It requires the item to be defined first.
     * @param rarity - The item's rarity.
     */
    withRarity(rarity) {
        return this.setItemProperty('rarity', rarity);
    }
    /**
     * Sets or updates the item's collectionId.
     * It requires the item to be defined first.
     * @param collectionId - The item's collectionId.
     */
    withCollectionId(collectionId) {
        return this.setItemProperty('collection_id', collectionId);
    }
    /**
     * Sets or updates the item's category.
     * It requires the item to be defined first.
     * @param category - The item's category.
     */
    withCategory(category) {
        return this.setItemDataProperty('category', category);
    }
    /**
     * Sets or updates the item's hides property.
     * It requires the item to be defined first.
     * @param hides - The item's hides property.
     */
    withHides(hides) {
        return this.setItemDataProperty('hides', hides);
    }
    /**
     * Sets or updates the item's tags property.
     * It requires the item to be defined first.
     * @param tags - The item's tags property.
     */
    withTags(tags) {
        return this.setItemDataProperty('tags', tags);
    }
    /**
     * Sets or updates the item's urn property.
     * It requires the item to be defined first.
     * @param urn - The item's urn property.
     */
    withUrn(urn) {
        return this.setItemProperty('urn', urn);
    }
    /**
     * Sets or updates the item's thumbnail.
     * It requires the item to be defined first.
     * @param thumbnail - The item's thumbnail.
     */
    withThumbnail(thumbnail) {
        if (!this.item) {
            throw new ItemFactory_errors_1.ItemNotInitializedError();
        }
        this.newContent = {
            ...this.newContent,
            [constants_1.THUMBNAIL_PATH]: thumbnail
        };
        delete this.item.contents[constants_1.THUMBNAIL_PATH];
        return this;
    }
    /**
     * Sets or updates the item's content.
     * It requires the item to be defined first.
     * @param content - The item's new content
     */
    withContent(content) {
        if (!this.item) {
            throw new ItemFactory_errors_1.ItemNotInitializedError();
        }
        this.newContent = {
            ...this.newContent,
            ...content
        };
        for (const key in content) {
            delete this.item.contents[key];
        }
        return this;
    }
    /**
     * Sets or updates the item's image.
     * The image will be used at the deployment process
     * to be uploaded to the catalyst.
     * It requires the item to be defined first.
     * @param thumbnail - The item's thumbnail.
     */
    withImage(image) {
        if (!this.item) {
            throw new ItemFactory_errors_1.ItemNotInitializedError();
        }
        this.newContent = {
            ...this.newContent,
            [constants_1.IMAGE_PATH]: image
        };
        delete this.item.contents[constants_1.IMAGE_PATH];
        return this;
    }
    /**
     * Adds a new a representation and its contents to the item, taking into consideration the specified body shape.
     * If BOTH is used as the body shape, both representations, female and male will be added.
     * It requires the item to be defined first.
     * @param bodyShape - The body shape that the new representation will represent.
     * @param model - The name of the content's key that points to the model to be used to build the new representation.
     * @param contents - The contents of the representation to be used to build the new representation.
     */
    withRepresentation(bodyShape, model, contents, overrideHides = [], overrideReplaces = []) {
        if (!this.item) {
            throw new ItemFactory_errors_1.ItemNotInitializedError();
        }
        const representationAlreadyExists = this.item.data.representations.some((representation) => this.representsBodyShape(bodyShape, representation));
        if (representationAlreadyExists) {
            throw new Error("The representation that you're about to add already exists in the item");
        }
        const sortedContents = (0, content_1.sortContent)(bodyShape, contents);
        this.newContent = {
            ...this.newContent,
            ...this.getBodyShapeSortedContents(bodyShape, sortedContents),
            ...(this.itemHasRepresentations() && sortedContents.all[constants_1.THUMBNAIL_PATH]
                ? {}
                : { [constants_1.THUMBNAIL_PATH]: sortedContents.all[constants_1.THUMBNAIL_PATH] })
        };
        this.item = {
            ...this.item,
            data: {
                ...this.item.data,
                representations: [
                    ...this.item.data.representations,
                    ...this.buildRepresentations(bodyShape, model, sortedContents, overrideHides, overrideReplaces)
                ]
            }
        };
        return this;
    }
    /**
     * Removes a representation and its contents from the item, taking into consideration the specified body shape.
     * If BOTH is used as the body shape, all the representations will be removed.
     * This method will only remove the thumbnail if after removing the representation there are no representations left.
     * It requires the item to be defined first.
     * @param bodyShape - The body shape that will be used to identify the representation to remove.
     */
    withoutRepresentation(bodyShape) {
        if (!this.item) {
            throw new ItemFactory_errors_1.ItemNotInitializedError();
        }
        this.newContent = this.removeContentsOfBodyShape(bodyShape, this.newContent);
        this.item = {
            ...this.item,
            data: {
                ...this.item.data,
                representations: this.item.data.representations.filter((representation) => !this.representsBodyShape(bodyShape, representation))
            },
            contents: {
                ...this.item.contents,
                ...this.removeContentsOfBodyShape(bodyShape, this.item.contents)
            }
        };
        if (!this.itemHasRepresentations()) {
            delete this.item.contents[constants_1.THUMBNAIL_PATH];
            delete this.newContent[constants_1.THUMBNAIL_PATH];
        }
        return this;
    }
    async build() {
        if (!this.item) {
            throw new Error('The item must be set before creating it');
        }
        return {
            item: {
                ...this.item,
                contents: {
                    ...this.item.contents,
                    ...(await (0, content_1.computeHashes)(this.newContent))
                }
            },
            newContent: this.newContent
        };
    }
    /**
     * Check that the given text won't break the item's metadata when used.
     * @param text - The text to verify that won't break the item's metadata.
     */
    isMetadataTextValid(text) {
        const invalidCharacters = [':'];
        const invalidCharactersRegex = new RegExp(invalidCharacters.join('|'));
        return text.search(invalidCharactersRegex) === -1;
    }
    /**
     * Builds an item's representation.
     * @param bodyShape - The body shape of the representation to build.
     * @param model - The name of the content's key that points to the model.
     * @param contents - The sorted contents of the representation to build.
     */
    buildRepresentations(bodyShape, model, contents, overrideHides, overrideReplaces) {
        const representations = [];
        // Add male representation
        if (bodyShape === types_1.WearableBodyShape.MALE) {
            representations.push({
                bodyShapes: [types_1.WearableBodyShape.MALE],
                mainFile: (0, content_1.prefixContentName)(types_1.WearableBodyShape.MALE, model),
                contents: Object.keys(contents.male),
                overrideHides,
                overrideReplaces
            });
        }
        // Add female representation
        if (bodyShape === types_1.WearableBodyShape.FEMALE) {
            representations.push({
                bodyShapes: [types_1.WearableBodyShape.FEMALE],
                mainFile: (0, content_1.prefixContentName)(types_1.WearableBodyShape.FEMALE, model),
                contents: Object.keys(contents.female),
                overrideHides,
                overrideReplaces
            });
        }
        return representations;
    }
    /**
     * Checks if an item's representation would fit a specific body shape.
     * @param bodyShape - The body shape to check for.
     * @param representation - The representation to see if fits the body shape.
     */
    representsBodyShape(bodyShape, representation) {
        return representation.bodyShapes.includes(bodyShape);
    }
    /**
     * Builds a new record of contents without the contents of the specified body shape.
     * @param bodyShape - The body shape of the contents to be left out.
     * @param contents - The contents to be filtered taking into consideration the specified body shape.
     */
    removeContentsOfBodyShape(bodyShape, contents) {
        return Object.keys(contents)
            .filter((key) => !key.startsWith(bodyShape === types_1.WearableBodyShape.MALE ? 'male' : 'female'))
            .reduce((accum, key) => {
            accum[key] = contents[key];
            return accum;
        }, {});
    }
    /**
     * Checks if the item has representations.
     * It requires the item to be defined first.
     */
    itemHasRepresentations() {
        if (!this.item) {
            throw new ItemFactory_errors_1.ItemNotInitializedError();
        }
        return this.item.data.representations.length > 0;
    }
    /**
     * Gets the sorted contents based on a given body shape.
     * @param bodyShape - The body shape to get the contents of.
     * @param contents - The full list of sorted contents.
     */
    getBodyShapeSortedContents(bodyShape, contents) {
        switch (bodyShape) {
            case types_1.WearableBodyShape.MALE:
                return contents.male;
            case types_1.WearableBodyShape.FEMALE:
                return contents.female;
            default:
                throw new Error(`The BodyShape ${bodyShape} couldn't get matched with the content`);
        }
    }
    /**
     * Sets an item's property by checking first if the item is defined.
     * @param property - The property of the item to be set.
     * @param value - The value of the property to be set.
     */
    setItemProperty(property, value) {
        if (!this.item) {
            throw new ItemFactory_errors_1.ItemNotInitializedError();
        }
        this.item = {
            ...this.item,
            [property]: value
        };
        return this;
    }
    /**
     * Sets an item's property in the data section by checking first if the item is defined.
     * @param property - The property of the item to be set.
     * @param value - The value of the property to be set.
     */
    setItemDataProperty(property, value) {
        if (!this.item) {
            throw new ItemFactory_errors_1.ItemNotInitializedError();
        }
        this.item = {
            ...this.item,
            data: {
                ...this.item.data,
                [property]: value
            }
        };
        return this;
    }
    /**
     * Builds a map of contents based on a list of content paths (keys of the map).
     * @param rawContent - The map containing the content available for an item.
     * @param contentPaths - The paths or keys of the rawContent map to build the new content map.
     */
    buildWearableConfigRepresentationContents(rawContent, contentPaths) {
        return contentPaths.reduce((accumulator, content) => {
            accumulator[content] = rawContent[content];
            return accumulator;
        }, {});
    }
}
exports.ItemFactory = ItemFactory;
//# sourceMappingURL=ItemFactory.js.map