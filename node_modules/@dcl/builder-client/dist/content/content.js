"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortContent = exports.prefixContentName = exports.computeHashes = void 0;
const hashing_1 = require("@dcl/hashing");
const buffer_1 = require("buffer");
const types_1 = require("../item/types");
const constants_1 = require("../item/constants");
/**
 * Computes the hashes of RawContents.
 * @param contents - The raw contents of an item.
 */
async function computeHashes(contents) {
    const filePaths = Object.keys(contents);
    const fileHashes = await Promise.all(filePaths.map(async (path) => {
        const blob = contents[path];
        const file = await makeContentFile(path, blob);
        return (0, hashing_1.hashV1)(file.content);
    }));
    return filePaths.reduce((hashes, path, index) => {
        hashes[path] = fileHashes[index];
        return hashes;
    }, {});
}
exports.computeHashes = computeHashes;
/**
 * Creates a content file to later perform a hash on it.
 * @param path - The path of the content file.
 * @param content - The content of the file.
 */
async function makeContentFile(path, content) {
    if (typeof content === 'string') {
        // This must be polyfilled in the browser
        const buffer = buffer_1.Buffer.from(content);
        return { name: path, content: buffer };
    }
    else if (globalThis.Blob && content instanceof globalThis.Blob) {
        // Blob can only be used in the browser
        const buffer = await content.arrayBuffer();
        return { name: path, content: new Uint8Array(buffer) };
    }
    else if (content instanceof Uint8Array) {
        return { name: path, content };
    }
    else if (content instanceof ArrayBuffer) {
        return { name: path, content: new Uint8Array(content) };
    }
    else if (buffer_1.Buffer.isBuffer(content)) {
        return { name: path, content: new Uint8Array(content) };
    }
    throw new Error('Unable to create ContentFile: content must be a string, a Blob or a Uint8Array');
}
/**
 * Prefixes a content name using the body shape.
 * @param bodyShape - The body shaped of the content.
 * @param contentKey - The name of the content.
 */
function prefixContentName(bodyShape, contentKey) {
    return `${bodyShape === types_1.WearableBodyShape.MALE ? 'male' : 'female'}/${contentKey}`;
}
exports.prefixContentName = prefixContentName;
/**
 * Sorts the content into "male", "female" and "all" taking into consideration the body shape.
 * All contains the item thumbnail and both male and female representations according to the shape.
 * If the body representation is male, "female" will be an empty object and viceversa.
 * @param bodyShape - The body shaped used to sort the content.
 * @param contents - The contents to be sorted.
 */
function sortContent(bodyShape, contents) {
    const male = bodyShape === types_1.WearableBodyShape.MALE
        ? prefixContents(types_1.WearableBodyShape.MALE, contents)
        : {};
    const female = bodyShape === types_1.WearableBodyShape.FEMALE
        ? prefixContents(types_1.WearableBodyShape.FEMALE, contents)
        : {};
    const all = {
        [constants_1.THUMBNAIL_PATH]: contents[constants_1.THUMBNAIL_PATH],
        ...male,
        ...female
    };
    return { male, female, all };
}
exports.sortContent = sortContent;
/**
 * Creates a new contents record with the names of the contents blobs record prefixed.
 * The names need to be prefixed so they won't collide with other
 * pre-uploaded models. The name of the content is the name of the uploaded file.
 * @param bodyShape - The body shaped used to prefix the content names.
 * @param contents - The contents which keys are going to be prefixed.
 */
function prefixContents(bodyShape, contents) {
    return Object.keys(contents).reduce((newContents, key) => {
        // Do not include the thumbnail in each of the body shapes
        if (key === constants_1.THUMBNAIL_PATH) {
            return newContents;
        }
        newContents[prefixContentName(bodyShape, key)] = contents[key];
        return newContents;
    }, {});
}
//# sourceMappingURL=content.js.map