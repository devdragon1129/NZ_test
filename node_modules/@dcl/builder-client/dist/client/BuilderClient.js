"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuilderClient = void 0;
const form_data_1 = __importDefault(require("form-data"));
const buffer_1 = require("buffer");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const dcl_crypto_1 = require("dcl-crypto");
const BuilderClient_errors_1 = require("./BuilderClient.errors");
class BuilderClient {
    constructor(url, identity, address, externalFetch = cross_fetch_1.default) {
        this.AUTH_CHAIN_HEADER_PREFIX = 'x-identity-auth-chain-';
        this.getIdentity = () => identity instanceof Function ? identity() : identity;
        this.getAddress = () => (address instanceof Function ? address() : address);
        this.fetch = (path, init) => {
            var _a, _b;
            const method = (_b = (_a = init === null || init === void 0 ? void 0 : init.method) !== null && _a !== void 0 ? _a : path) !== null && _b !== void 0 ? _b : 'get';
            const fullUrl = url + path;
            return externalFetch(fullUrl, {
                ...init,
                headers: {
                    ...init === null || init === void 0 ? void 0 : init.headers,
                    ...this.createAuthHeaders(method, path.replace(/\/v[0-9]/, ''))
                }
            });
        };
    }
    /**
     * Creates the authorization headers for the given method and path.
     * @param method - The HTTP method.
     * @param path - The HTTP request path.
     */
    createAuthHeaders(method, path) {
        const identity = this.getIdentity();
        const headers = {};
        const endpoint = (method + ':' + path).toLowerCase();
        const authChain = dcl_crypto_1.Authenticator.signPayload(identity, endpoint);
        for (let i = 0; i < authChain.length; i++) {
            headers[this.AUTH_CHAIN_HEADER_PREFIX + i] = JSON.stringify(authChain[i]);
        }
        return headers;
    }
    convertToFormDataBinary(data) {
        const blobExists = globalThis.Blob !== undefined;
        const bufferExists = buffer_1.Buffer !== undefined;
        if ((blobExists && data instanceof globalThis.Blob) ||
            (bufferExists && buffer_1.Buffer.isBuffer(data))) {
            return data;
        }
        if (blobExists &&
            (data instanceof Uint8Array || data instanceof ArrayBuffer)) {
            return new Blob([data]);
        }
        else if (bufferExists && data instanceof Uint8Array) {
            return buffer_1.Buffer.from(data.buffer);
        }
        else if (bufferExists && data instanceof ArrayBuffer) {
            return buffer_1.Buffer.from(data);
        }
        throw new Error('Unsupported content type');
    }
    /**
     * Updates or inserts an item. The item can be updated by id or URN.
     * @param item - The item to insert or update.
     * @param newContent - The content to be added or updated in the item. This content must be contained in the items contents.
     */
    async upsertItem(item, newContent) {
        var _a, _b, _c, _d;
        const contentIsContainedInItem = Object.keys(newContent).every((key) => key in item.contents);
        if (!contentIsContainedInItem) {
            throw new Error('The new content is not contained in the item contents');
        }
        let upsertResponse;
        let upsertResponseBody;
        const endpointParam = (_a = item.id) !== null && _a !== void 0 ? _a : item.urn;
        try {
            upsertResponse = await this.fetch(`/v1/items/${endpointParam}`, {
                headers: { 'content-type': 'application/json' },
                body: JSON.stringify({
                    item: { ...item, eth_address: this.getAddress() }
                }),
                method: 'put'
            });
            upsertResponseBody =
                (await upsertResponse.json());
        }
        catch (error) {
            throw new BuilderClient_errors_1.ClientError(error.message, undefined, null);
        }
        if (!upsertResponse.ok || !upsertResponseBody.ok) {
            throw new BuilderClient_errors_1.ClientError((_b = upsertResponseBody.error) !== null && _b !== void 0 ? _b : 'Unknown error', upsertResponse.status, upsertResponseBody.data);
        }
        if (Object.keys(newContent).length > 0) {
            const formData = new form_data_1.default();
            for (const path in newContent) {
                formData.append(item.contents[path], this.convertToFormDataBinary(newContent[path]), path);
            }
            let uploadResponse;
            try {
                uploadResponse = await this.fetch(`/v1/items/${(_c = item.id) !== null && _c !== void 0 ? _c : upsertResponseBody.data.id}/files`, {
                    body: formData,
                    method: 'post'
                });
            }
            catch (error) {
                throw new BuilderClient_errors_1.ClientError(error.message, undefined, null);
            }
            const uploadResponseBody = await uploadResponse.json();
            if (!uploadResponse.ok || !uploadResponseBody.ok) {
                throw new BuilderClient_errors_1.ClientError((_d = uploadResponseBody.error) !== null && _d !== void 0 ? _d : 'Unknown error', uploadResponse.status, uploadResponseBody.data);
            }
        }
        return upsertResponseBody.data;
    }
    /**
     * Gets the content size of an already uploaded content file.
     * @param contentIdentifier - The content hash.
     */
    async getContentSize(contentIdentifier) {
        let contentsResponse;
        try {
            contentsResponse = await this.fetch(`/v1/storage/contents/${contentIdentifier}`, { method: 'head' });
        }
        catch (error) {
            throw new BuilderClient_errors_1.ClientError(error.message, undefined, null);
        }
        if (!contentsResponse.ok ||
            !contentsResponse.headers.has('content-length')) {
            throw new BuilderClient_errors_1.ClientError('An error occurred trying to get the size of a content', contentsResponse.status, null);
        }
        return Number(contentsResponse.headers.get('content-length'));
    }
    /**
     * The ID of the third party to retrieve.
     * @param thirdPartyId - The third party id (urn:decentraland:mumbai:collections-thirdparty:third-part-name).
     */
    async getThirdParty(thirdPartyId) {
        var _a;
        let thirdPartyResponse;
        let thirdPartyResponseBody;
        try {
            thirdPartyResponse = await this.fetch(`/v1/thirdParties/${thirdPartyId}`);
        }
        catch (error) {
            throw new BuilderClient_errors_1.ClientError(error.message, undefined, null);
        }
        if (!thirdPartyResponse.ok) {
            throw new BuilderClient_errors_1.ClientError('Unexpected response status', thirdPartyResponse.status, null);
        }
        const responseContentType = thirdPartyResponse.headers.get('content-type');
        if (!responseContentType ||
            !responseContentType.includes('application/json')) {
            throw new BuilderClient_errors_1.ClientError('Unexpected content-type in response', thirdPartyResponse.status, null);
        }
        try {
            thirdPartyResponseBody =
                (await thirdPartyResponse.json());
        }
        catch (error) {
            throw new BuilderClient_errors_1.ClientError(error.message, thirdPartyResponse.status, null);
        }
        if (!thirdPartyResponseBody.ok) {
            throw new BuilderClient_errors_1.ClientError((_a = thirdPartyResponseBody.error) !== null && _a !== void 0 ? _a : 'Unknown error', thirdPartyResponse.status, thirdPartyResponseBody.data);
        }
        return thirdPartyResponseBody.data;
    }
    /**
     * Gets the external NFTs owned by the user.
     * @param options - A set of options to query the NFTs.
     */
    async getNFTs({ owner, first, skip, cursor } = {}) {
        const params = [];
        let url = '/v1/nfts';
        if (owner) {
            params.push(`owner=${owner}`);
        }
        if (first) {
            params.push(`first=${first}`);
        }
        if (skip) {
            params.push(`skip=${skip}`);
        }
        if (cursor) {
            params.push(`cursor=${cursor}`);
        }
        if (params.length > 0) {
            url = `${url}?${params.join('&')}`;
        }
        let res;
        try {
            res = await this.fetch(url);
        }
        catch (e) {
            throw new BuilderClient_errors_1.ClientError(e.message, undefined, null);
        }
        const body = await res.json();
        if (!res.ok || !body.ok) {
            throw new BuilderClient_errors_1.ClientError(body.error || 'Unknown error', res.status, null);
        }
        return body.data;
    }
    async getNFT({ contractAddress, tokenId }) {
        let res;
        try {
            res = await this.fetch(`/v1/nfts/${contractAddress}/${tokenId}`);
        }
        catch (e) {
            throw new BuilderClient_errors_1.ClientError(e.message, undefined, null);
        }
        const body = await res.json();
        if (!res.ok || !body.ok) {
            throw new BuilderClient_errors_1.ClientError(body.error || 'Unknown error', res.status, null);
        }
        return body.data;
    }
}
exports.BuilderClient = BuilderClient;
//# sourceMappingURL=BuilderClient.js.map