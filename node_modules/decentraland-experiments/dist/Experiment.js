"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var Variant_1 = require("./Variant");
/**
 *
 */
var Experiment = /** @class */ (function () {
    function Experiment(options) {
        this.options = options;
        this.completed = false;
        this.active = false;
        this.activeVariant = undefined;
    }
    Object.defineProperty(Experiment.prototype, "name", {
        /**
         * Name of the current Experiment
         */
        get: function () {
            return this.options.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Experiment.prototype, "value", {
        /**
         * Value of the current variation
         */
        get: function () {
            return this.activeVariant && this.activeVariant.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Experiment.prototype, "variant", {
        /**
         *
         */
        get: function () {
            return this.activeVariant || Variant_1.EmptyVariant;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Finish the test, marks it as completed and dispatch
     * the `experiment_conversion` event with the final state to segment
     */
    Experiment.prototype.complete = function () {
        this.active = false;
        this.completed = true;
    };
    /**
     * Activate the current experiment
     */
    Experiment.prototype.activate = function (forceVariant) {
        if (!this.isActive() && !this.isCompleted()) {
            this.state =
                typeof this.options.initialState === 'function'
                    ? this.options.initialState()
                    : {};
            var variant = void 0;
            if (forceVariant) {
                variant = this.getVariant(forceVariant);
            }
            if (variant === undefined) {
                variant = this.getRandomVariant();
            }
            this.active = true;
            this.activeVariant = variant;
        }
    };
    /**
     * Random return a varia`nt
     */
    Experiment.prototype.getRandomVariant = function () {
        var e_1, _a;
        if (Array.isArray(this.options.variants) &&
            this.options.variants.length > 0) {
            var offset = 0;
            var random = Math.random();
            try {
                for (var _b = __values(this.options.variants), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var variant = _c.value;
                    if (random < variant.ratio + offset) {
                        return variant;
                    }
                    else {
                        offset += variant.ratio;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return Variant_1.EmptyVariant;
    };
    Experiment.prototype.getVariant = function (name) {
        if (name === Variant_1.EmptyVariant.name || !Array.isArray(this.options.variants)) {
            return Variant_1.EmptyVariant;
        }
        return this.options.variants.find(function (current) { return current.name === name; });
    };
    /**
     * Return all available values
     */
    Experiment.prototype.getAllVariants = function () {
        if (!Array.isArray(this.options.variants)) {
            return [];
        }
        return this.options.variants.slice();
    };
    /**
     * Modify de state using `Object.assign`
     */
    Experiment.prototype.setState = function (patchState) {
        if (patchState && this.isActive() && !this.isCompleted()) {
            this.state = Object.assign({}, this.state, patchState);
        }
    };
    /**
     * Return if the experiment is completed
     */
    Experiment.prototype.isCompleted = function () {
        return this.completed;
    };
    /**
     * Return if the experiment is active
     */
    Experiment.prototype.isActive = function () {
        return this.active;
    };
    /**
     * Execute the tracker
     */
    Experiment.prototype.track = function (segmentEvent) {
        if (this.isActive() && !this.isCompleted()) {
            this.options.track(segmentEvent, this);
        }
    };
    return Experiment;
}());
exports.default = Experiment;
//# sourceMappingURL=Experiment.js.map