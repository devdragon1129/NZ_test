"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("./index");
var random_1 = __importDefault(require("./__mock__/random"));
describe("src/Experiment", function () {
    describe(".activate()", function () {
        test("must setup experiment as active and add state, value and variant", function () {
            random_1.default.mockReturnValueOnce(0.2);
            var variant = new index_1.Variant('experiment_variant', 1, 234);
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant],
                track: function () { }
            });
            expect(experiment.name).toBe('experiment_test');
            expect(experiment.state).toBeUndefined();
            expect(experiment.value).toBeUndefined();
            expect(experiment.variant).toBe(index_1.EmptyVariant);
            expect(experiment.isActive()).toBe(false);
            expect(experiment.isCompleted()).toBe(false);
            experiment.activate();
            expect(experiment.state).toEqual({});
            expect(experiment.value).toBe(234);
            expect(experiment.variant).toBe(variant);
            expect(experiment.isActive()).toBe(true);
            expect(experiment.isCompleted()).toBe(false);
        });
        test("must select one of the variants", function () {
            random_1.default.mockReturnValueOnce(0.2);
            var variant1 = new index_1.Variant('experiment_variant_1', 0.5, 12);
            var variant2 = new index_1.Variant('experiment_variant_2', 0.5, 34);
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant1, variant2],
                track: function () { }
            });
            experiment.activate();
            expect(experiment.state).toEqual({});
            expect(experiment.value).toBe(variant1.value);
            expect(experiment.variant).toBe(variant1);
            expect(experiment.isActive()).toBe(true);
            expect(experiment.isCompleted()).toBe(false);
        });
        test("must select a variant by name", function () {
            // random.mockReturnValueOnce(0.2)
            var variantExpected = new index_1.Variant('experiment_variant_expected', 0.000000000001, 999);
            var variant1 = new index_1.Variant('experiment_variant_1', 0.33, 12);
            var variant2 = new index_1.Variant('experiment_variant_2', 0.33, 34);
            var variant3 = new index_1.Variant('experiment_variant_3', 0.34, 34);
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variantExpected, variant1, variant2, variant3],
                track: function () { }
            });
            experiment.activate('experiment_variant_expected');
            expect(random_1.default.mock.calls).toEqual([]); // random wasn't call
            expect(experiment.state).toEqual({});
            expect(experiment.value).toBe(variantExpected.value);
            expect(experiment.variant).toBe(variantExpected);
            expect(experiment.isActive()).toBe(true);
            expect(experiment.isCompleted()).toBe(false);
        });
        test("must select a variant randomly", function () {
            random_1.default.mockReturnValueOnce(0.3).mockReturnValueOnce(0.6);
            var variant1 = new index_1.Variant('experiment_variant_1', 0.5, 12);
            var variant2 = new index_1.Variant('experiment_variant_2', 0.5, 34);
            var experiment1 = new index_1.Experiment({
                name: 'experiment_test_1',
                variants: [variant1, variant2],
                track: function () { }
            });
            var experiment2 = new index_1.Experiment({
                name: 'experiment_test_2',
                variants: [variant1, variant2],
                track: function () { }
            });
            experiment1.activate();
            expect(experiment1.state).toEqual({});
            expect(experiment1.value).toBe(variant1.value);
            expect(experiment1.variant).toBe(variant1);
            expect(experiment1.isActive()).toBe(true);
            expect(experiment1.isCompleted()).toBe(false);
            experiment2.activate();
            expect(experiment2.state).toEqual({});
            expect(experiment2.value).toBe(variant2.value);
            expect(experiment2.variant).toBe(variant2);
            expect(experiment2.isActive()).toBe(true);
            expect(experiment2.isCompleted()).toBe(false);
        });
        test("If the sum of ratios is less than 1 the \"empty variant\" could be selected", function () {
            random_1.default.mockReturnValueOnce(0.6);
            var variant = new index_1.Variant('variant', 0.1, 999);
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant],
                track: function () { }
            });
            experiment.activate();
            expect(experiment.state).toEqual({});
            expect(experiment.value).toBe(index_1.EmptyVariant.value);
            expect(experiment.variant).toBe(index_1.EmptyVariant);
            expect(experiment.isActive()).toBe(true);
            expect(experiment.isCompleted()).toBe(false);
        });
        test("the EmptyVariant can be force selected", function () {
            var variant = new index_1.Variant('variant', 0.999999999, 999);
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant],
                track: function () { }
            });
            experiment.activate(index_1.EmptyVariant.name);
            expect(experiment.state).toEqual({});
            expect(experiment.value).toBe(index_1.EmptyVariant.value);
            expect(experiment.variant).toBe(index_1.EmptyVariant);
            expect(experiment.isActive()).toBe(true);
            expect(experiment.isCompleted()).toBe(false);
        });
    });
    describe(".setState()", function () {
        test("the state must be undefined if the experiment is not active", function () {
            var variant = new index_1.Variant('experiment_variant', 1, 234);
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant],
                track: function () { }
            });
            expect(experiment.state).toBeUndefined();
            experiment.activate();
            expect(experiment.state).toEqual({});
        });
        test("the state can be initialized with initialState props", function () {
            var variant = new index_1.Variant('experiment_variant', 1, 234);
            var value = Math.random();
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant],
                initialState: function () {
                    return { value: value };
                },
                track: function () { }
            });
            expect(experiment.state).toBeUndefined();
            experiment.activate();
            expect(experiment.state.value).toEqual(value);
        });
        test("the state can be modified after activation of the experiment", function () {
            var variant = new index_1.Variant('experiment_variant', 1, 234);
            var value = Math.random();
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant],
                initialState: function () {
                    return { value: value };
                },
                track: function () { }
            });
            expect(experiment.state).toBeUndefined();
            experiment.setState({ value: 1 });
            expect(experiment.state).toBeUndefined();
            experiment.activate();
            expect(experiment.state.value).toEqual(value);
            experiment.setState({ value: 2 });
            expect(experiment.state.value).toEqual(2);
        });
        test("the setState method merge the current state with the new one", function () {
            var variant = new index_1.Variant('experiment_variant', 1, 234);
            var value = Math.random();
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant],
                initialState: function () {
                    return { value: value, otherValue: 1 };
                },
                track: function () { }
            });
            experiment.activate();
            expect(experiment.state).toEqual({ value: value, otherValue: 1 });
            experiment.setState({ otherValue: 2 });
            expect(experiment.state).toEqual({ value: value, otherValue: 2 });
        });
    });
    describe(".track()", function () {
        test("track constructor will be call when the experiment is active, not completed and track method is call", function () {
            var track = jest.fn();
            var event = {
                type: 'track',
                name: 'Event',
                properties: {}
            };
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [],
                track: track
            });
            experiment.track(event);
            expect(track.mock.calls.length).toEqual(0);
            experiment.activate();
            experiment.track(event);
            expect(track.mock.calls.length).toEqual(1);
            expect(track.mock.calls[0]).toEqual([event, experiment]);
            experiment.complete();
            experiment.track(event);
            expect(track.mock.calls.length).toEqual(1);
        });
        test("track constructor is able to call the complete method", function () {
            var track = jest
                .fn()
                .mockImplementation(function (event, experiment) {
                if (event) {
                    experiment.complete();
                }
            });
            var event = {
                type: 'track',
                name: 'Event',
                properties: {}
            };
            var experiment = new index_1.Experiment({
                name: 'experiment_test',
                variants: [],
                track: track
            });
            experiment.activate();
            expect(experiment.isActive()).toBe(true);
            expect(experiment.isCompleted()).toBe(false);
            experiment.track(event);
            expect(track.mock.calls.length).toEqual(1);
            expect(track.mock.calls[0]).toEqual([event, experiment]);
            expect(experiment.isActive()).toBe(false);
            expect(experiment.isCompleted()).toBe(true);
        });
    });
    describe(".getAllVariants()", function () {
        test("return all variants", function () {
            var variant1 = new index_1.Variant('experiment_variant_1', 0.1, 12);
            var variant2 = new index_1.Variant('experiment_variant_2', 0.1, 34);
            var variant3 = new index_1.Variant('experiment_variant_3', 0.1, 34);
            var experiment1 = new index_1.Experiment({
                name: 'experiment_test',
                variants: [variant1, variant2, variant3],
                track: function () { }
            });
            var experiment2 = new index_1.Experiment({
                name: 'experiment_test',
                variants: null,
                track: function () { }
            });
            expect(experiment1.getAllVariants()).toEqual([
                variant1,
                variant2,
                variant3
            ]);
            expect(experiment2.getAllVariants()).toEqual([]);
        });
    });
    // describe(``)
});
//# sourceMappingURL=Experiment.test.js.map