"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("./index");
var window_1 = __importDefault(require("./window"));
var analytics_1 = __importStar(require("./__mock__/analytics"));
var random_1 = __importDefault(require("./__mock__/random"));
var localStorage_1 = require("./__mock__/localStorage");
var sessionStorage_1 = require("./__mock__/sessionStorage");
var window_2 = require("./__mock__/window");
var console_1 = require("./__mock__/console");
var SIGN_UP_EVENT = 'sign_up_event';
function createExperiments(storage, segment) {
    if (storage === void 0) { storage = window_1.default.localStorage; }
    if (segment === void 0) { segment = analytics_1.default; }
    return new index_1.Experiments({
        avatar_sign_up_test: new index_1.Experiment({
            name: 'sign_up_vs_send',
            initialState: function () { return ({ calls: 0 }); },
            variants: [
                new index_1.Variant('sign_up', 0.5, 'Sign up'),
                new index_1.Variant('send', 0.5, 'Send')
            ],
            track: function (event, currentExperiment) {
                if (event.type === 'track' && event.name === SIGN_UP_EVENT) {
                    currentExperiment.setState({
                        calls: currentExperiment.state.calls + 1
                    });
                    currentExperiment.complete();
                }
            }
        }),
        fail_on_activation: new index_1.Experiment({
            name: 'failed_state',
            variants: [new index_1.Variant('variant', 1, 'Variant Value')],
            initialState: function () {
                throw new Error("example error on initialState");
            },
            track: function () { }
        }),
        fail_on_track: new index_1.Experiment({
            name: 'failed_track',
            variants: [new index_1.Variant('variant', 1, 'Variant Value')],
            track: function () {
                throw new Error("example error on track");
            }
        })
    }, storage, segment);
}
describe("src/Experiments", function () {
    describe("constructor", function () {
        test("must load previous data from storage", function () {
            createExperiments();
            expect(localStorage_1.getItem.mock.calls.length).toEqual(1);
            expect(localStorage_1.getItem.mock.calls[0]).toEqual([index_1.PERSIST_KEY]);
            createExperiments(window_1.default.sessionStorage);
            expect(sessionStorage_1.getItem.mock.calls.length).toEqual(1);
            expect(sessionStorage_1.getItem.mock.calls[0]).toEqual([index_1.PERSIST_KEY]);
        });
        test("must log and should not fail if persisted data is invalid", function () {
            localStorage_1.getItem.mockReturnValueOnce('-');
            createExperiments();
            expect(localStorage_1.getItem.mock.calls.length).toEqual(1);
            expect(localStorage_1.getItem.mock.calls[0]).toEqual([index_1.PERSIST_KEY]);
            expect(console_1.error.mock.calls.length).toEqual(1);
            expect(console_1.error.mock.calls[0]).toEqual([
                'Persisted experiments cannot be loaded: ',
                new SyntaxError('Unexpected end of JSON input'),
                '-'
            ]);
        });
        test("must listen for storage event", function () {
            var experiments = createExperiments();
            expect(window_2.addEventListener.mock.calls.length).toEqual(1);
            expect(window_2.addEventListener.mock.calls[0]).toEqual([
                'storage',
                experiments.handleStorageChange
            ]);
        });
        test("must listen for analytics event", function () {
            var experiments = createExperiments();
            expect(analytics_1.on.mock.calls.length).toEqual(1);
            expect(analytics_1.on.mock.calls[0]).toEqual(['track', experiments.handleTrackEvent]);
        });
        test("must listen for window.analytics event", function () {
            window_1.default.analytics = analytics_1.default;
            var experiments = createExperiments(window_1.default.localStorage, null);
            expect(analytics_1.on.mock.calls.length).toEqual(1);
            expect(analytics_1.on.mock.calls[0]).toEqual(['track', experiments.handleTrackEvent]);
            delete window_1.default.analytics;
        });
        test("must not fail if analytics isn't present", function () {
            createExperiments(window_1.default.localStorage, null);
            expect(analytics_1.on.mock.calls.length).toEqual(0);
            expect(console_1.warn.mock.calls.length).toEqual(1);
        });
    });
    describe(".detach()", function () {
        test("must remove all analytics event", function () {
            var experiments = createExperiments();
            experiments.detach();
            expect(analytics_1.off.mock.calls.length).toEqual(1);
            expect(analytics_1.off.mock.calls[0]).toEqual(['track', experiments.handleTrackEvent]);
        });
        test("must remove all storage event", function () {
            var experiments = createExperiments();
            experiments.detach();
            expect(window_2.removeEventListener.mock.calls.length).toEqual(1);
            expect(window_2.removeEventListener.mock.calls[0]).toEqual([
                'storage',
                experiments.handleStorageChange
            ]);
        });
    });
    describe(".getCurrentValueFor()", function () {
        test("must return default value if the experiment not exists", function () {
            var experiments = createExperiments();
            var value = experiments.getCurrentValueFor('missing_experiment', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(value).toEqual('Default Value');
        });
        test("must return one of the variants values", function () {
            random_1.default.mockReturnValueOnce(0.2);
            var experiments = createExperiments();
            var value = experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(value).toEqual('Sign up');
        });
        test("must persist the result in the storage", function () {
            random_1.default.mockReturnValueOnce(0.7);
            var experiments = createExperiments();
            var value = experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(value).toEqual('Send');
            expect(localStorage_1.setItem.mock.calls.length).toEqual(1);
            expect(localStorage_1.setItem.mock.calls[0]).toEqual([
                index_1.PERSIST_KEY,
                '[["sign_up_vs_send","send"]]'
            ]);
        });
        test("must return the same value", function () {
            random_1.default.mockReturnValueOnce(0.7);
            var experiments = createExperiments();
            var value = experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(value).toEqual('Send');
            var value2 = experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(value2).toEqual('Send');
        });
        test("must load and return previous persisted values", function () {
            localStorage_1.getItem.mockReturnValueOnce('[["sign_up_vs_send","send"]]');
            var experiments = createExperiments();
            var value = experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(value).toEqual('Send');
        });
        test("must update variants if storage change", function () {
            var experiments = createExperiments();
            // broadcast storage change
            localStorage_1.getItem.mockReturnValueOnce('[["sign_up_vs_send","send"]]');
            // simulated broadcast current change
            experiments.handleStorageChange();
            var value = experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(value).toEqual('Send');
            expect(localStorage_1.setItem.mock.calls.length).toEqual(0);
        });
        test("must track the experiment_show event when value is activated for first time", function () {
            var experiments = createExperiments();
            experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(analytics_1.track.mock.calls.length).toEqual(1);
            expect(analytics_1.track.mock.calls[0]).toEqual([
                'experiment_show',
                { experiment: 'sign_up_vs_send', variation: 'sign_up' }
            ]);
            experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            expect(analytics_1.track.mock.calls.length).toEqual(1);
        });
        test("must complete experiment and should not track events if activation fail", function () {
            var experiments = createExperiments();
            var value = experiments.getCurrentValueFor('fail_on_activation', 'Default Value');
            expect(value).toEqual('Default Value');
            expect(analytics_1.track.mock.calls.length).toEqual(0);
            expect(console_1.error.mock.calls.length).toEqual(1);
            expect(console_1.error.mock.calls[0]).toEqual([
                'Error executing activate method of "failed_state": ',
                new Error('example error on initialState'),
                experiments.getExperiment('fail_on_activation')
            ]);
        });
        test("must track the experiment_conversion event when the experiment is completed", function () {
            var experiments = createExperiments();
            experiments.getCurrentValueFor('avatar_sign_up_test', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            expect(analytics_1.track.mock.calls.length).toEqual(1);
            expect(analytics_1.track.mock.calls[0]).toEqual([
                'experiment_show',
                { experiment: 'sign_up_vs_send', variation: 'sign_up' }
            ]);
            experiments.handleTrackEvent(SIGN_UP_EVENT, {});
            expect(analytics_1.track.mock.calls.length).toEqual(2);
            expect(analytics_1.track.mock.calls[1]).toEqual([
                'experiment_conversion',
                { experiment: 'sign_up_vs_send', variation: 'sign_up', calls: 1 }
            ]);
        });
        test("must complete the experiment and track the experiment_conversion event when the experiment fail on track", function () {
            var experiments = createExperiments();
            experiments.getCurrentValueFor('fail_on_track', 'Default Value');
            // simulated broadcast current change
            experiments.handleStorageChange();
            var experiment = experiments.getExperiment('fail_on_track');
            expect(experiment).toBeTruthy();
            expect(experiment && experiment.isActive()).toBe(false);
            expect(experiment && experiment.isCompleted()).toBe(true);
            expect(analytics_1.track.mock.calls.length).toEqual(2);
            expect(analytics_1.track.mock.calls[0]).toEqual([
                'experiment_show',
                { experiment: 'failed_track', variation: 'variant' }
            ]);
            expect(analytics_1.track.mock.calls[1]).toEqual([
                'experiment_conversion',
                {
                    experiment: 'failed_track',
                    variation: 'variant',
                    error_message: 'example error on track'
                }
            ]);
            experiments.handleTrackEvent(SIGN_UP_EVENT, {});
            expect(analytics_1.track.mock.calls.length).toEqual(2);
        });
    });
    describe(".getAllValuesFor()", function () {
        test("must return all values for an experiment", function () {
            var experiments = createExperiments();
            expect(experiments.getAllValuesFor('avatar_sign_up_test')).toEqual([
                'Sign up',
                'Send'
            ]);
        });
        test("must return an empty array if the experiment not exists", function () {
            var experiments = createExperiments();
            expect(experiments.getAllValuesFor('missing_test')).toEqual([]);
        });
    });
});
//# sourceMappingURL=Experiments.test.js.map