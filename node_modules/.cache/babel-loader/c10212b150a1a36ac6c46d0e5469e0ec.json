{"ast":null,"code":"var PromiseStates;\n\n(function (PromiseStates) {\n  PromiseStates[PromiseStates[\"Pending\"] = 0] = \"Pending\";\n  PromiseStates[PromiseStates[\"Fulfilled\"] = 1] = \"Fulfilled\";\n  PromiseStates[PromiseStates[\"Rejected\"] = 2] = \"Rejected\";\n})(PromiseStates || (PromiseStates = {}));\n\nvar FulFillmentAgregator =\n/** @class */\nfunction () {\n  function FulFillmentAgregator() {\n    this.count = 0;\n    this.target = 0;\n    this.results = [];\n  }\n\n  return FulFillmentAgregator;\n}();\n\nvar InternalPromise =\n/** @class */\nfunction () {\n  function InternalPromise(resolver) {\n    var _this = this;\n\n    this._state = PromiseStates.Pending;\n    this._children = new Array();\n    this._rejectWasConsumed = false;\n\n    if (!resolver) {\n      return;\n    }\n\n    try {\n      resolver(function (value) {\n        _this._resolve(value);\n      }, function (reason) {\n        _this._reject(reason);\n      });\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n\n  Object.defineProperty(InternalPromise.prototype, \"_result\", {\n    get: function get() {\n      return this._resultValue;\n    },\n    set: function set(value) {\n      this._resultValue = value;\n\n      if (this._parent && this._parent._result === undefined) {\n        this._parent._result = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InternalPromise.prototype.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n  };\n\n  InternalPromise.prototype.then = function (onFulfilled, onRejected) {\n    var _this = this;\n\n    var newPromise = new InternalPromise();\n    newPromise._onFulfilled = onFulfilled;\n    newPromise._onRejected = onRejected; // Composition\n\n    this._children.push(newPromise);\n\n    newPromise._parent = this;\n\n    if (this._state !== PromiseStates.Pending) {\n      setTimeout(function () {\n        if (_this._state === PromiseStates.Fulfilled || _this._rejectWasConsumed) {\n          var returnedValue = newPromise._resolve(_this._result);\n\n          if (returnedValue !== undefined && returnedValue !== null) {\n            if (returnedValue._state !== undefined) {\n              var returnedPromise = returnedValue;\n\n              newPromise._children.push(returnedPromise);\n\n              returnedPromise._parent = newPromise;\n              newPromise = returnedPromise;\n            } else {\n              newPromise._result = returnedValue;\n            }\n          }\n        } else {\n          newPromise._reject(_this._reason);\n        }\n      });\n    }\n\n    return newPromise;\n  };\n\n  InternalPromise.prototype._moveChildren = function (children) {\n    var _a;\n\n    var _this = this;\n\n    (_a = this._children).push.apply(_a, children.splice(0, children.length));\n\n    this._children.forEach(function (child) {\n      child._parent = _this;\n    });\n\n    if (this._state === PromiseStates.Fulfilled) {\n      for (var _i = 0, _b = this._children; _i < _b.length; _i++) {\n        var child = _b[_i];\n\n        child._resolve(this._result);\n      }\n    } else if (this._state === PromiseStates.Rejected) {\n      for (var _c = 0, _d = this._children; _c < _d.length; _c++) {\n        var child = _d[_c];\n\n        child._reject(this._reason);\n      }\n    }\n  };\n\n  InternalPromise.prototype._resolve = function (value) {\n    try {\n      this._state = PromiseStates.Fulfilled;\n      var returnedValue = null;\n\n      if (this._onFulfilled) {\n        returnedValue = this._onFulfilled(value);\n      }\n\n      if (returnedValue !== undefined && returnedValue !== null) {\n        if (returnedValue._state !== undefined) {\n          // Transmit children\n          var returnedPromise = returnedValue;\n          returnedPromise._parent = this;\n\n          returnedPromise._moveChildren(this._children);\n\n          value = returnedPromise._result;\n        } else {\n          value = returnedValue;\n        }\n      }\n\n      this._result = value;\n\n      for (var _i = 0, _a = this._children; _i < _a.length; _i++) {\n        var child = _a[_i];\n\n        child._resolve(value);\n      }\n\n      this._children.length = 0;\n      delete this._onFulfilled;\n      delete this._onRejected;\n    } catch (e) {\n      this._reject(e, true);\n    }\n  };\n\n  InternalPromise.prototype._reject = function (reason, onLocalThrow) {\n    if (onLocalThrow === void 0) {\n      onLocalThrow = false;\n    }\n\n    this._state = PromiseStates.Rejected;\n    this._reason = reason;\n\n    if (this._onRejected && !onLocalThrow) {\n      try {\n        this._onRejected(reason);\n\n        this._rejectWasConsumed = true;\n      } catch (e) {\n        reason = e;\n      }\n    }\n\n    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {\n      var child = _a[_i];\n\n      if (this._rejectWasConsumed) {\n        child._resolve(null);\n      } else {\n        child._reject(reason);\n      }\n    }\n\n    this._children.length = 0;\n    delete this._onFulfilled;\n    delete this._onRejected;\n  };\n\n  InternalPromise.resolve = function (value) {\n    var newPromise = new InternalPromise();\n\n    newPromise._resolve(value);\n\n    return newPromise;\n  };\n\n  InternalPromise._RegisterForFulfillment = function (promise, agregator, index) {\n    promise.then(function (value) {\n      agregator.results[index] = value;\n      agregator.count++;\n\n      if (agregator.count === agregator.target) {\n        agregator.rootPromise._resolve(agregator.results);\n      }\n\n      return null;\n    }, function (reason) {\n      if (agregator.rootPromise._state !== PromiseStates.Rejected) {\n        agregator.rootPromise._reject(reason);\n      }\n    });\n  };\n\n  InternalPromise.all = function (promises) {\n    var newPromise = new InternalPromise();\n    var agregator = new FulFillmentAgregator();\n    agregator.target = promises.length;\n    agregator.rootPromise = newPromise;\n\n    if (promises.length) {\n      for (var index = 0; index < promises.length; index++) {\n        InternalPromise._RegisterForFulfillment(promises[index], agregator, index);\n      }\n    } else {\n      newPromise._resolve([]);\n    }\n\n    return newPromise;\n  };\n\n  InternalPromise.race = function (promises) {\n    var newPromise = new InternalPromise();\n\n    if (promises.length) {\n      for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {\n        var promise = promises_1[_i];\n        promise.then(function (value) {\n          if (newPromise) {\n            newPromise._resolve(value);\n\n            newPromise = null;\n          }\n\n          return null;\n        }, function (reason) {\n          if (newPromise) {\n            newPromise._reject(reason);\n\n            newPromise = null;\n          }\n        });\n      }\n    }\n\n    return newPromise;\n  };\n\n  return InternalPromise;\n}();\n/**\r\n * Helper class that provides a small promise polyfill\r\n */\n\n\nvar PromisePolyfill =\n/** @class */\nfunction () {\n  function PromisePolyfill() {}\n  /**\r\n   * Static function used to check if the polyfill is required\r\n   * If this is the case then the function will inject the polyfill to window.Promise\r\n   * @param force defines a boolean used to force the injection (mostly for testing purposes)\r\n   */\n\n\n  PromisePolyfill.Apply = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (force || typeof Promise === 'undefined') {\n      var root = window;\n      root.Promise = InternalPromise;\n    }\n  };\n\n  return PromisePolyfill;\n}();\n\nexport { PromisePolyfill };","map":null,"metadata":{},"sourceType":"module"}