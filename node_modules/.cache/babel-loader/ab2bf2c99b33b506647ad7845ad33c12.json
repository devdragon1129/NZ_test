{"ast":null,"code":"import { Engine } from \"../../Engines/engine\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\nimport { _TimeToken } from \"../../Instrumentation/timeToken\";\n/** @hidden */\n\nvar _OcclusionDataStorage =\n/** @class */\nfunction () {\n  function _OcclusionDataStorage() {\n    /** @hidden */\n    this.occlusionInternalRetryCounter = 0;\n    /** @hidden */\n\n    this.isOcclusionQueryInProgress = false;\n    /** @hidden */\n\n    this.isOccluded = false;\n    /** @hidden */\n\n    this.occlusionRetryCount = -1;\n    /** @hidden */\n\n    this.occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;\n    /** @hidden */\n\n    this.occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;\n  }\n\n  return _OcclusionDataStorage;\n}();\n\nexport { _OcclusionDataStorage };\n\nEngine.prototype.createQuery = function () {\n  return this._gl.createQuery();\n};\n\nEngine.prototype.deleteQuery = function (query) {\n  this._gl.deleteQuery(query);\n\n  return this;\n};\n\nEngine.prototype.isQueryResultAvailable = function (query) {\n  return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT_AVAILABLE);\n};\n\nEngine.prototype.getQueryResult = function (query) {\n  return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT);\n};\n\nEngine.prototype.beginOcclusionQuery = function (algorithmType, query) {\n  var glAlgorithm = this._getGlAlgorithmType(algorithmType);\n\n  this._gl.beginQuery(glAlgorithm, query);\n\n  return this;\n};\n\nEngine.prototype.endOcclusionQuery = function (algorithmType) {\n  var glAlgorithm = this._getGlAlgorithmType(algorithmType);\n\n  this._gl.endQuery(glAlgorithm);\n\n  return this;\n};\n\nEngine.prototype._createTimeQuery = function () {\n  var timerQuery = this.getCaps().timerQuery;\n\n  if (timerQuery.createQueryEXT) {\n    return timerQuery.createQueryEXT();\n  }\n\n  return this.createQuery();\n};\n\nEngine.prototype._deleteTimeQuery = function (query) {\n  var timerQuery = this.getCaps().timerQuery;\n\n  if (timerQuery.deleteQueryEXT) {\n    timerQuery.deleteQueryEXT(query);\n    return;\n  }\n\n  this.deleteQuery(query);\n};\n\nEngine.prototype._getTimeQueryResult = function (query) {\n  var timerQuery = this.getCaps().timerQuery;\n\n  if (timerQuery.getQueryObjectEXT) {\n    return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_EXT);\n  }\n\n  return this.getQueryResult(query);\n};\n\nEngine.prototype._getTimeQueryAvailability = function (query) {\n  var timerQuery = this.getCaps().timerQuery;\n\n  if (timerQuery.getQueryObjectEXT) {\n    return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_AVAILABLE_EXT);\n  }\n\n  return this.isQueryResultAvailable(query);\n};\n\nEngine.prototype.startTimeQuery = function () {\n  var caps = this.getCaps();\n  var timerQuery = caps.timerQuery;\n\n  if (!timerQuery) {\n    return null;\n  }\n\n  var token = new _TimeToken();\n\n  this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);\n\n  if (caps.canUseTimestampForTimerQuery) {\n    token._startTimeQuery = this._createTimeQuery();\n    timerQuery.queryCounterEXT(token._startTimeQuery, timerQuery.TIMESTAMP_EXT);\n  } else {\n    if (this._currentNonTimestampToken) {\n      return this._currentNonTimestampToken;\n    }\n\n    token._timeElapsedQuery = this._createTimeQuery();\n\n    if (timerQuery.beginQueryEXT) {\n      timerQuery.beginQueryEXT(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);\n    } else {\n      this._gl.beginQuery(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);\n    }\n\n    this._currentNonTimestampToken = token;\n  }\n\n  return token;\n};\n\nEngine.prototype.endTimeQuery = function (token) {\n  var caps = this.getCaps();\n  var timerQuery = caps.timerQuery;\n\n  if (!timerQuery || !token) {\n    return -1;\n  }\n\n  if (caps.canUseTimestampForTimerQuery) {\n    if (!token._startTimeQuery) {\n      return -1;\n    }\n\n    if (!token._endTimeQuery) {\n      token._endTimeQuery = this._createTimeQuery();\n      timerQuery.queryCounterEXT(token._endTimeQuery, timerQuery.TIMESTAMP_EXT);\n    }\n  } else if (!token._timeElapsedQueryEnded) {\n    if (!token._timeElapsedQuery) {\n      return -1;\n    }\n\n    if (timerQuery.endQueryEXT) {\n      timerQuery.endQueryEXT(timerQuery.TIME_ELAPSED_EXT);\n    } else {\n      this._gl.endQuery(timerQuery.TIME_ELAPSED_EXT);\n    }\n\n    token._timeElapsedQueryEnded = true;\n  }\n\n  var disjoint = this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);\n\n  var available = false;\n\n  if (token._endTimeQuery) {\n    available = this._getTimeQueryAvailability(token._endTimeQuery);\n  } else if (token._timeElapsedQuery) {\n    available = this._getTimeQueryAvailability(token._timeElapsedQuery);\n  }\n\n  if (available && !disjoint) {\n    var result = 0;\n\n    if (caps.canUseTimestampForTimerQuery) {\n      if (!token._startTimeQuery || !token._endTimeQuery) {\n        return -1;\n      }\n\n      var timeStart = this._getTimeQueryResult(token._startTimeQuery);\n\n      var timeEnd = this._getTimeQueryResult(token._endTimeQuery);\n\n      result = timeEnd - timeStart;\n\n      this._deleteTimeQuery(token._startTimeQuery);\n\n      this._deleteTimeQuery(token._endTimeQuery);\n\n      token._startTimeQuery = null;\n      token._endTimeQuery = null;\n    } else {\n      if (!token._timeElapsedQuery) {\n        return -1;\n      }\n\n      result = this._getTimeQueryResult(token._timeElapsedQuery);\n\n      this._deleteTimeQuery(token._timeElapsedQuery);\n\n      token._timeElapsedQuery = null;\n      token._timeElapsedQueryEnded = false;\n      this._currentNonTimestampToken = null;\n    }\n\n    return result;\n  }\n\n  return -1;\n};\n\nEngine.prototype._getGlAlgorithmType = function (algorithmType) {\n  return algorithmType === AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE ? this._gl.ANY_SAMPLES_PASSED_CONSERVATIVE : this._gl.ANY_SAMPLES_PASSED;\n};\n\nObject.defineProperty(AbstractMesh.prototype, \"isOcclusionQueryInProgress\", {\n  get: function get() {\n    return this._occlusionDataStorage.isOcclusionQueryInProgress;\n  },\n  set: function set(value) {\n    this._occlusionDataStorage.isOcclusionQueryInProgress = value;\n  },\n  enumerable: false,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"_occlusionDataStorage\", {\n  get: function get() {\n    if (!this.__occlusionDataStorage) {\n      this.__occlusionDataStorage = new _OcclusionDataStorage();\n    }\n\n    return this.__occlusionDataStorage;\n  },\n  enumerable: false,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"isOccluded\", {\n  get: function get() {\n    return this._occlusionDataStorage.isOccluded;\n  },\n  set: function set(value) {\n    this._occlusionDataStorage.isOccluded = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"occlusionQueryAlgorithmType\", {\n  get: function get() {\n    return this._occlusionDataStorage.occlusionQueryAlgorithmType;\n  },\n  set: function set(value) {\n    this._occlusionDataStorage.occlusionQueryAlgorithmType = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"occlusionType\", {\n  get: function get() {\n    return this._occlusionDataStorage.occlusionType;\n  },\n  set: function set(value) {\n    this._occlusionDataStorage.occlusionType = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"occlusionRetryCount\", {\n  get: function get() {\n    return this._occlusionDataStorage.occlusionRetryCount;\n  },\n  set: function set(value) {\n    this._occlusionDataStorage.occlusionRetryCount = value;\n  },\n  enumerable: true,\n  configurable: true\n}); // We also need to update AbstractMesh as there is a portion of the code there\n\nAbstractMesh.prototype._checkOcclusionQuery = function () {\n  var dataStorage = this._occlusionDataStorage;\n\n  if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {\n    dataStorage.isOccluded = false;\n    return false;\n  }\n\n  var engine = this.getEngine();\n\n  if (engine.webGLVersion < 2) {\n    dataStorage.isOccluded = false;\n    return false;\n  }\n\n  if (!engine.isQueryResultAvailable) {\n    // Occlusion query where not referenced\n    dataStorage.isOccluded = false;\n    return false;\n  }\n\n  if (this.isOcclusionQueryInProgress && this._occlusionQuery) {\n    var isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);\n\n    if (isOcclusionQueryAvailable) {\n      var occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);\n      dataStorage.isOcclusionQueryInProgress = false;\n      dataStorage.occlusionInternalRetryCounter = 0;\n      dataStorage.isOccluded = occlusionQueryResult === 1 ? false : true;\n    } else {\n      dataStorage.occlusionInternalRetryCounter++;\n\n      if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {\n        dataStorage.isOcclusionQueryInProgress = false;\n        dataStorage.occlusionInternalRetryCounter = 0; // if optimistic set isOccluded to false regardless of the status of isOccluded. (Render in the current render loop)\n        // if strict continue the last state of the object.\n\n        dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  var scene = this.getScene();\n\n  if (scene.getBoundingBoxRenderer) {\n    var occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();\n\n    if (!this._occlusionQuery) {\n      this._occlusionQuery = engine.createQuery();\n    }\n\n    engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery);\n    occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);\n    engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);\n    this._occlusionDataStorage.isOcclusionQueryInProgress = true;\n  }\n\n  return dataStorage.isOccluded;\n};","map":null,"metadata":{},"sourceType":"module"}