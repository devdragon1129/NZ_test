{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\n\nvar ArcRotateCameraPointersInput =\n/** @class */\nfunction (_super) {\n  __extends(ArcRotateCameraPointersInput, _super);\n\n  function ArcRotateCameraPointersInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\n\n\n    _this.buttons = [0, 1, 2];\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\n\n    _this.angularSensibilityX = 1000.0;\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\n\n    _this.angularSensibilityY = 1000.0;\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\n\n    _this.pinchPrecision = 12.0;\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\n\n    _this.pinchDeltaPercentage = 0;\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\n\n    _this.useNaturalPinchZoom = false;\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\n\n    _this.panningSensibility = 1000.0;\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\n\n    _this.multiTouchPanning = true;\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\n\n    _this.multiTouchPanAndZoom = true;\n    /**\r\n     * Revers pinch action direction.\r\n     */\n\n    _this.pinchInwards = true;\n    _this._isPanClick = false;\n    _this._twoFingerActivityCount = 0;\n    _this._isPinching = false;\n    return _this;\n  }\n  /**\r\n   * Gets the class name of the current input.\r\n   * @returns the class name\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.getClassName = function () {\n    return \"ArcRotateCameraPointersInput\";\n  };\n  /**\r\n   * Called on pointer POINTERMOVE event if only a single touch is active.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {\n    if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {\n      this.camera.inertialPanningX += -offsetX / this.panningSensibility;\n      this.camera.inertialPanningY += offsetY / this.panningSensibility;\n    } else {\n      this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\n      this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\n    }\n  };\n  /**\r\n   * Called on pointer POINTERDOUBLETAP event.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onDoubleTap = function (type) {\n    if (this.camera.useInputToRestoreState) {\n      this.camera.restoreState();\n    }\n  };\n  /**\r\n   * Called on pointer POINTERMOVE event if multiple touches are active.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n      // First time this method is called for new pinch.\n      // Next time this is called there will be a\n      // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n      return;\n    }\n\n    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n      // Last time this method is called at the end of a pinch.\n      return;\n    }\n\n    var direction = this.pinchInwards ? 1 : -1;\n\n    if (this.multiTouchPanAndZoom) {\n      if (this.useNaturalPinchZoom) {\n        this.camera.radius = this.camera.radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);\n      } else if (this.pinchDeltaPercentage) {\n        this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * this.camera.radius * this.pinchDeltaPercentage;\n      } else {\n        this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * direction * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n      }\n\n      if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\n        var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n        var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n        this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\n        this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\n      }\n    } else {\n      this._twoFingerActivityCount++;\n      var previousPinchDistance = Math.sqrt(previousPinchSquaredDistance);\n      var pinchDistance = Math.sqrt(pinchSquaredDistance);\n\n      if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(pinchDistance - previousPinchDistance) > this.camera.pinchToPanMaxDistance) {\n        // Since pinch has not been active long, assume we intend to zoom.\n        if (this.pinchDeltaPercentage) {\n          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * this.camera.radius * this.pinchDeltaPercentage;\n        } else {\n          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * direction * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n        } // Since we are pinching, remain pinching on next iteration.\n\n\n        this._isPinching = true;\n      } else {\n        // Pause between pinch starting and moving implies not a zoom event.\n        // Pan instead.\n        if (this.panningSensibility !== 0 && this.multiTouchPanning && multiTouchPanPosition && previousMultiTouchPanPosition) {\n          var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n          var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n          this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\n          this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\n        }\n      }\n    }\n  };\n  /**\r\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n   * press.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onButtonDown = function (evt) {\n    this._isPanClick = evt.button === this.camera._panningMouseButton;\n  };\n  /**\r\n   * Called each time a new POINTERUP event occurs. Ie, for each button\r\n   * release.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onButtonUp = function (evt) {\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  };\n  /**\r\n   * Called when window becomes inactive.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onLostFocus = function () {\n    this._isPanClick = false;\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  };\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"buttons\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"useNaturalPinchZoom\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"panningSensibility\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanning\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanAndZoom\", void 0);\n\n  return ArcRotateCameraPointersInput;\n}(BaseCameraPointersInput);\n\nexport { ArcRotateCameraPointersInput };\nCameraInputTypes[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;","map":null,"metadata":{},"sourceType":"module"}