{"ast":null,"code":"import { SceneSerializer } from './sceneSerializer';\nimport { Mesh } from '../Meshes/mesh';\nimport { Light } from '../Lights/light';\nimport { Camera } from '../Cameras/camera';\nimport { Skeleton } from '../Bones/skeleton';\nimport { Material } from '../Materials/material';\nimport { MultiMaterial } from '../Materials/multiMaterial';\nimport { TransformNode } from '../Meshes/transformNode';\nimport { ParticleSystem } from '../Particles/particleSystem';\nimport { MorphTargetManager } from '../Morph/morphTargetManager';\nimport { ShadowGenerator } from '../Lights/Shadows/shadowGenerator';\nimport { PostProcess } from '../PostProcesses/postProcess';\n/**\r\n * Class used to record delta files between 2 scene states\r\n */\n\nvar SceneRecorder =\n/** @class */\nfunction () {\n  function SceneRecorder() {\n    this._trackedScene = null;\n  }\n  /**\r\n   * Track a given scene. This means the current scene state will be considered the original state\r\n   * @param scene defines the scene to track\r\n   */\n\n\n  SceneRecorder.prototype.track = function (scene) {\n    this._trackedScene = scene;\n    this._savedJSON = SceneSerializer.Serialize(scene);\n  };\n  /**\r\n   * Get the delta between current state and original state\r\n   * @returns a string containing the delta\r\n   */\n\n\n  SceneRecorder.prototype.getDelta = function () {\n    if (!this._trackedScene) {\n      return null;\n    }\n\n    var newJSON = SceneSerializer.Serialize(this._trackedScene);\n    var deltaJSON = {};\n\n    for (var node in newJSON) {\n      this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\n    }\n\n    return deltaJSON;\n  };\n\n  SceneRecorder.prototype._compareArray = function (key, original, current, deltaJSON) {\n    if (original.length === 0 && current.length === 0) {\n      return true;\n    } // Numbers?\n\n\n    if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {\n      if (original.length !== current.length) {\n        return false;\n      }\n\n      if (original.length === 0) {\n        return true;\n      }\n\n      for (var index = 0; index < original.length; index++) {\n        if (original[index] !== current[index]) {\n          deltaJSON[key] = current;\n          return false;\n        }\n      }\n\n      return true;\n    } // let's use uniqueId to find similar objects\n\n\n    var originalUniqueIds = [];\n\n    var _loop_1 = function _loop_1() {\n      var originalObject = original[index];\n      var originalUniqueId = originalObject.uniqueId;\n      originalUniqueIds.push(originalUniqueId); // Look for that object in current state\n\n      var currentObjects = current.filter(function (c) {\n        return c.uniqueId === originalUniqueId;\n      });\n\n      if (currentObjects.length) {\n        // We have a candidate\n        var currentObject = currentObjects[0];\n        var newObject = {};\n\n        if (!this_1._compareObjects(originalObject, currentObject, newObject)) {\n          if (!deltaJSON[key]) {\n            deltaJSON[key] = [];\n          }\n\n          newObject.__state = {\n            id: currentObject.id || currentObject.name\n          };\n          deltaJSON[key].push(newObject);\n        }\n      } else {\n        // We need to delete\n        var newObject = {\n          __state: {\n            deleteId: originalObject.id || originalObject.name\n          }\n        };\n        deltaJSON[key].push(newObject);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < original.length; index++) {\n      _loop_1();\n    } // Checking for new objects\n\n\n    for (var index = 0; index < current.length; index++) {\n      var currentObject = current[index];\n      var currentUniqueId = currentObject.uniqueId; // Object was added\n\n      if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\n        if (!deltaJSON[key]) {\n          deltaJSON[key] = [];\n        }\n\n        deltaJSON[key].push(currentObject);\n      }\n    }\n\n    return true;\n  };\n\n  SceneRecorder.prototype._compareObjects = function (originalObjet, currentObject, deltaJSON) {\n    var aDifferenceWasFound = false;\n\n    for (var prop in originalObjet) {\n      if (!originalObjet.hasOwnProperty(prop)) {\n        continue;\n      }\n\n      var originalValue = originalObjet[prop];\n      var currentValue = currentObject[prop];\n      var diffFound = false;\n\n      if (Array.isArray(originalValue)) {\n        diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);\n      } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == '[object String]') {\n        diffFound = originalValue !== currentValue;\n      }\n\n      if (diffFound) {\n        aDifferenceWasFound = true;\n        deltaJSON[prop] = currentValue;\n      }\n    }\n\n    return !aDifferenceWasFound;\n  };\n\n  SceneRecorder.prototype._compareCollections = function (key, original, current, deltaJSON) {\n    // Same ?\n    if (original === current) {\n      return;\n    }\n\n    if (original && current) {\n      // Array?\n      if (Array.isArray(original) && Array.isArray(current)) {\n        if (this._compareArray(key, original, current, deltaJSON)) {\n          return;\n        }\n      } else if (typeof original === \"object\" && typeof current === \"object\") {\n        // Object\n        var newObject = {};\n\n        if (!this._compareObjects(original, current, newObject)) {\n          deltaJSON[key] = newObject;\n        }\n\n        return;\n      }\n    }\n  };\n\n  SceneRecorder.GetShadowGeneratorById = function (scene, id) {\n    var generators = scene.lights.map(function (l) {\n      return l.getShadowGenerator();\n    });\n\n    for (var _i = 0, generators_1 = generators; _i < generators_1.length; _i++) {\n      var generator = generators_1[_i];\n\n      if (generator && generator.id === id) {\n        return generator;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Apply a given delta to a given scene\r\n   * @param deltaJSON defines the JSON containing the delta\r\n   * @param scene defines the scene to apply the delta to\r\n   */\n\n\n  SceneRecorder.ApplyDelta = function (deltaJSON, scene) {\n    var _this = this;\n\n    if (typeof deltaJSON === 'string') {\n      deltaJSON = JSON.parse(deltaJSON);\n    } // Scene\n\n\n    var anyScene = scene;\n\n    for (var prop in deltaJSON) {\n      var source = deltaJSON[prop];\n      var property = anyScene[prop];\n\n      if (Array.isArray(property) || prop === \"shadowGenerators\") {\n        // Restore array\n        switch (prop) {\n          case \"cameras\":\n            this._ApplyDeltaForEntity(source, scene, scene.getCameraByID.bind(scene), function (data) {\n              return Camera.Parse(data, scene);\n            });\n\n            break;\n\n          case \"lights\":\n            this._ApplyDeltaForEntity(source, scene, scene.getLightByID.bind(scene), function (data) {\n              return Light.Parse(data, scene);\n            });\n\n            break;\n\n          case \"shadowGenerators\":\n            this._ApplyDeltaForEntity(source, scene, function (id) {\n              return _this.GetShadowGeneratorById(scene, id);\n            }, function (data) {\n              return ShadowGenerator.Parse(data, scene);\n            });\n\n            break;\n\n          case \"meshes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMeshByID.bind(scene), function (data) {\n              return Mesh.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"skeletons\":\n            this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), function (data) {\n              return Skeleton.Parse(data, scene);\n            });\n\n            break;\n\n          case \"materials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialByID.bind(scene), function (data) {\n              return Material.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"multiMaterials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialByID.bind(scene), function (data) {\n              return MultiMaterial.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"transformNodes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeByID.bind(scene), function (data) {\n              return TransformNode.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"particleSystems\":\n            this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemByID.bind(scene), function (data) {\n              return ParticleSystem.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"morphTargetManagers\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), function (data) {\n              return MorphTargetManager.Parse(data, scene);\n            });\n\n            break;\n\n          case \"postProcesses\":\n            this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), function (data) {\n              return PostProcess.Parse(data, scene, \"\");\n            });\n\n            break;\n        }\n      } else if (!isNaN(property)) {\n        anyScene[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      }\n    }\n  };\n\n  SceneRecorder._ApplyPropertiesToEntity = function (deltaJSON, entity) {\n    for (var prop in deltaJSON) {\n      var source = deltaJSON[prop];\n      var property = entity[prop];\n\n      if (property === undefined) {\n        continue;\n      }\n\n      if (!isNaN(property) || Array.isArray(property)) {\n        entity[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      }\n    }\n  };\n\n  SceneRecorder._ApplyDeltaForEntity = function (sources, scene, finder, addNew) {\n    for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n      var source = sources_1[_i]; // Update\n\n      if (source.__state && source.__state.id !== undefined) {\n        var targetEntity = finder(source.__state.id);\n\n        if (targetEntity) {\n          this._ApplyPropertiesToEntity(source, targetEntity);\n        }\n      } else if (source.__state && source.__state.deleteId !== undefined) {\n        var target = finder(source.__state.deleteId);\n        target === null || target === void 0 ? void 0 : target.dispose();\n      } else {\n        // New\n        addNew(source);\n      }\n    }\n  };\n\n  return SceneRecorder;\n}();\n\nexport { SceneRecorder };","map":null,"metadata":{},"sourceType":"module"}