{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\nimport { Color4 } from \"../Maths/math.color\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { SubMesh } from \"../Meshes/subMesh\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { Tools } from \"../Misc/tools\";\nimport { Tags } from \"../Misc/tags\";\nimport { extractMinAndMax } from \"../Maths/math.functions\";\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\n\nvar Geometry =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new geometry\r\n   * @param id defines the unique ID\r\n   * @param scene defines the hosting scene\r\n   * @param vertexData defines the VertexData used to get geometry data\r\n   * @param updatable defines if geometry must be updatable (false by default)\r\n   * @param mesh defines the mesh that will be associated with the geometry\r\n   */\n  function Geometry(id, scene, vertexData, updatable, mesh) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n    /**\r\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n     */\n\n\n    this.delayLoadState = 0;\n    this._totalVertices = 0;\n    this._isDisposed = false;\n    this._indexBufferIsUpdatable = false;\n    this._positionsCache = [];\n    /**\r\n     * If set to true (false by defaut), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n     */\n\n    this.useBoundingInfoFromGeometry = false;\n    this.id = id;\n    this.uniqueId = scene.getUniqueId();\n    this._engine = scene.getEngine();\n    this._meshes = [];\n    this._scene = scene; //Init vertex buffer cache\n\n    this._vertexBuffers = {};\n    this._indices = [];\n    this._updatable = updatable; // vertexData\n\n    if (vertexData) {\n      this.setAllVerticesData(vertexData, updatable);\n    } else {\n      this._totalVertices = 0;\n      this._indices = [];\n    }\n\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObjects = {};\n    } // applyToMesh\n\n\n    if (mesh) {\n      this.applyToMesh(mesh);\n      mesh.computeWorldMatrix(true);\n    }\n  }\n\n  Object.defineProperty(Geometry.prototype, \"boundingBias\", {\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\n    get: function get() {\n      return this._boundingBias;\n    },\n\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\n    set: function set(value) {\n      if (this._boundingBias) {\n        this._boundingBias.copyFrom(value);\n      } else {\n        this._boundingBias = value.clone();\n      }\n\n      this._updateBoundingInfo(true, null);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Static function used to attach a new empty geometry to a mesh\r\n   * @param mesh defines the mesh to attach the geometry to\r\n   * @returns the new Geometry\r\n   */\n\n  Geometry.CreateGeometryForMesh = function (mesh) {\n    var geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\n    geometry.applyToMesh(mesh);\n    return geometry;\n  };\n\n  Object.defineProperty(Geometry.prototype, \"meshes\", {\n    /** Get the list of meshes using this geometry */\n    get: function get() {\n      return this._meshes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Geometry.prototype, \"extend\", {\n    /**\r\n     * Gets the current extend of the geometry\r\n     */\n    get: function get() {\n      return this._extend;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the hosting scene\r\n   * @returns the hosting Scene\r\n   */\n\n  Geometry.prototype.getScene = function () {\n    return this._scene;\n  };\n  /**\r\n   * Gets the hosting engine\r\n   * @returns the hosting Engine\r\n   */\n\n\n  Geometry.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * Defines if the geometry is ready to use\r\n   * @returns true if the geometry is ready to be used\r\n   */\n\n\n  Geometry.prototype.isReady = function () {\n    return this.delayLoadState === 1 || this.delayLoadState === 0;\n  };\n\n  Object.defineProperty(Geometry.prototype, \"doNotSerialize\", {\n    /**\r\n     * Gets a value indicating that the geometry should not be serialized\r\n     */\n    get: function get() {\n      for (var index = 0; index < this._meshes.length; index++) {\n        if (!this._meshes[index].doNotSerialize) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  Geometry.prototype._rebuild = function () {\n    if (this._vertexArrayObjects) {\n      this._vertexArrayObjects = {};\n    } // Index buffer\n\n\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices);\n    } // Vertex buffers\n\n\n    for (var key in this._vertexBuffers) {\n      var vertexBuffer = this._vertexBuffers[key];\n\n      vertexBuffer._rebuild();\n    }\n  };\n  /**\r\n   * Affects all geometry data in one call\r\n   * @param vertexData defines the geometry data\r\n   * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n   */\n\n\n  Geometry.prototype.setAllVerticesData = function (vertexData, updatable) {\n    vertexData.applyToGeometry(this, updatable);\n    this.notifyUpdate();\n  };\n  /**\r\n   * Set specific vertex data\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @param data defines the vertex data to use\r\n   * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n   * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n   */\n\n\n  Geometry.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (updatable && Array.isArray(data)) {\n      // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\n      data = new Float32Array(data);\n    }\n\n    var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\n    this.setVerticesBuffer(buffer);\n  };\n  /**\r\n   * Removes a specific vertex data\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   */\n\n\n  Geometry.prototype.removeVerticesData = function (kind) {\n    if (this._vertexBuffers[kind]) {\n      this._vertexBuffers[kind].dispose();\n\n      delete this._vertexBuffers[kind];\n    }\n  };\n  /**\r\n   * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n   * @param buffer defines the vertex buffer to use\r\n   * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n   */\n\n\n  Geometry.prototype.setVerticesBuffer = function (buffer, totalVertices) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    var kind = buffer.getKind();\n\n    if (this._vertexBuffers[kind]) {\n      this._vertexBuffers[kind].dispose();\n    }\n\n    this._vertexBuffers[kind] = buffer;\n\n    if (kind === VertexBuffer.PositionKind) {\n      var data = buffer.getData();\n\n      if (totalVertices != null) {\n        this._totalVertices = totalVertices;\n      } else {\n        if (data != null) {\n          this._totalVertices = data.length / (buffer.byteStride / 4);\n        }\n      }\n\n      this._updateExtend(data);\n\n      this._resetPointsArrayCache();\n\n      var meshes = this._meshes;\n      var numOfMeshes = meshes.length;\n\n      for (var index = 0; index < numOfMeshes; index++) {\n        var mesh = meshes[index];\n        mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n\n        mesh._createGlobalSubMesh(false);\n\n        mesh.computeWorldMatrix(true);\n      }\n    }\n\n    this.notifyUpdate(kind);\n\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n\n      this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\n    }\n  };\n  /**\r\n   * Update a specific vertex buffer\r\n   * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n   * It will do nothing if the buffer is not updatable\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @param data defines the data to use\r\n   * @param offset defines the offset in the target buffer where to store the data\r\n   * @param useBytes set to true if the offset is in bytes\r\n   */\n\n\n  Geometry.prototype.updateVerticesDataDirectly = function (kind, data, offset, useBytes) {\n    if (useBytes === void 0) {\n      useBytes = false;\n    }\n\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return;\n    }\n\n    vertexBuffer.updateDirectly(data, offset, useBytes);\n    this.notifyUpdate(kind);\n  };\n  /**\r\n   * Update a specific vertex buffer\r\n   * This function will create a new buffer if the current one is not updatable\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @param data defines the data to use\r\n   * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n   */\n\n\n  Geometry.prototype.updateVerticesData = function (kind, data, updateExtends) {\n    if (updateExtends === void 0) {\n      updateExtends = false;\n    }\n\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return;\n    }\n\n    vertexBuffer.update(data);\n\n    if (kind === VertexBuffer.PositionKind) {\n      this._updateBoundingInfo(updateExtends, data);\n    }\n\n    this.notifyUpdate(kind);\n  };\n\n  Geometry.prototype._updateBoundingInfo = function (updateExtends, data) {\n    if (updateExtends) {\n      this._updateExtend(data);\n    }\n\n    this._resetPointsArrayCache();\n\n    if (updateExtends) {\n      var meshes = this._meshes;\n\n      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\n        var mesh = meshes_1[_i];\n\n        if (mesh._boundingInfo) {\n          mesh._boundingInfo.reConstruct(this._extend.minimum, this._extend.maximum);\n        } else {\n          mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n        }\n\n        var subMeshes = mesh.subMeshes;\n\n        for (var _a = 0, subMeshes_1 = subMeshes; _a < subMeshes_1.length; _a++) {\n          var subMesh = subMeshes_1[_a];\n          subMesh.refreshBoundingInfo();\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Geometry.prototype._bind = function (effect, indexToBind) {\n    if (!effect) {\n      return;\n    }\n\n    if (indexToBind === undefined) {\n      indexToBind = this._indexBuffer;\n    }\n\n    var vbs = this.getVertexBuffers();\n\n    if (!vbs) {\n      return;\n    }\n\n    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects) {\n      this._engine.bindBuffers(vbs, indexToBind, effect);\n\n      return;\n    } // Using VAO\n\n\n    if (!this._vertexArrayObjects[effect.key]) {\n      this._vertexArrayObjects[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect);\n    }\n\n    this._engine.bindVertexArrayObject(this._vertexArrayObjects[effect.key], indexToBind);\n  };\n  /**\r\n   * Gets total number of vertices\r\n   * @returns the total number of vertices\r\n   */\n\n\n  Geometry.prototype.getTotalVertices = function () {\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    return this._totalVertices;\n  };\n  /**\r\n   * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n   * @returns a float array containing vertex data\r\n   */\n\n\n  Geometry.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return null;\n    }\n\n    var data = vertexBuffer.getData();\n\n    if (!data) {\n      return null;\n    }\n\n    var tightlyPackedByteStride = vertexBuffer.getSize() * VertexBuffer.GetTypeByteLength(vertexBuffer.type);\n    var count = this._totalVertices * vertexBuffer.getSize();\n\n    if (vertexBuffer.type !== VertexBuffer.FLOAT || vertexBuffer.byteStride !== tightlyPackedByteStride) {\n      var copy_1 = [];\n      vertexBuffer.forEach(count, function (value) {\n        return copy_1.push(value);\n      });\n      return copy_1;\n    }\n\n    if (!(data instanceof Array || data instanceof Float32Array) || vertexBuffer.byteOffset !== 0 || data.length !== count) {\n      if (data instanceof Array) {\n        var offset = vertexBuffer.byteOffset / 4;\n        return Tools.Slice(data, offset, offset + count);\n      } else if (data instanceof ArrayBuffer) {\n        return new Float32Array(data, vertexBuffer.byteOffset, count);\n      } else {\n        var offset = data.byteOffset + vertexBuffer.byteOffset;\n\n        if (forceCopy || copyWhenShared && this._meshes.length !== 1) {\n          var result = new Float32Array(count);\n          var source = new Float32Array(data.buffer, offset, count);\n          result.set(source);\n          return result;\n        } // Portect against bad data\n\n\n        var remainder = offset % 4;\n\n        if (remainder) {\n          offset = Math.max(0, offset - remainder);\n        }\n\n        return new Float32Array(data.buffer, offset, count);\n      }\n    }\n\n    if (forceCopy || copyWhenShared && this._meshes.length !== 1) {\n      return Tools.Slice(data);\n    }\n\n    return data;\n  };\n  /**\r\n   * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @returns true if the vertex buffer with the specified kind is updatable\r\n   */\n\n\n  Geometry.prototype.isVertexBufferUpdatable = function (kind) {\n    var vb = this._vertexBuffers[kind];\n\n    if (!vb) {\n      return false;\n    }\n\n    return vb.isUpdatable();\n  };\n  /**\r\n   * Gets a specific vertex buffer\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @returns a VertexBuffer\r\n   */\n\n\n  Geometry.prototype.getVertexBuffer = function (kind) {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._vertexBuffers[kind];\n  };\n  /**\r\n   * Returns all vertex buffers\r\n   * @return an object holding all vertex buffers indexed by kind\r\n   */\n\n\n  Geometry.prototype.getVertexBuffers = function () {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._vertexBuffers;\n  };\n  /**\r\n   * Gets a boolean indicating if specific vertex buffer is present\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @returns true if data is present\r\n   */\n\n\n  Geometry.prototype.isVerticesDataPresent = function (kind) {\n    if (!this._vertexBuffers) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n\n      return false;\n    }\n\n    return this._vertexBuffers[kind] !== undefined;\n  };\n  /**\r\n   * Gets a list of all attached data kinds (Position, normal, etc...)\r\n   * @returns a list of string containing all kinds\r\n   */\n\n\n  Geometry.prototype.getVerticesDataKinds = function () {\n    var result = [];\n    var kind;\n\n    if (!this._vertexBuffers && this._delayInfo) {\n      for (kind in this._delayInfo) {\n        result.push(kind);\n      }\n    } else {\n      for (kind in this._vertexBuffers) {\n        result.push(kind);\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Update index buffer\r\n   * @param indices defines the indices to store in the index buffer\r\n   * @param offset defines the offset in the target buffer where to store the data\r\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n   */\n\n\n  Geometry.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n    if (gpuMemoryOnly === void 0) {\n      gpuMemoryOnly = false;\n    }\n\n    if (!this._indexBuffer) {\n      return;\n    }\n\n    if (!this._indexBufferIsUpdatable) {\n      this.setIndices(indices, null, true);\n    } else {\n      var needToUpdateSubMeshes = indices.length !== this._indices.length;\n\n      if (!gpuMemoryOnly) {\n        this._indices = indices.slice();\n      }\n\n      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\n\n      if (needToUpdateSubMeshes) {\n        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n          var mesh = _a[_i];\n\n          mesh._createGlobalSubMesh(true);\n        }\n      }\n    }\n  };\n  /**\r\n   * Creates a new index buffer\r\n   * @param indices defines the indices to store in the index buffer\r\n   * @param totalVertices defines the total number of vertices (could be null)\r\n   * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n   */\n\n\n  Geometry.prototype.setIndices = function (indices, totalVertices, updatable) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n\n    this._disposeVertexArrayObjects();\n\n    this._indices = indices;\n    this._indexBufferIsUpdatable = updatable;\n\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\n    }\n\n    if (totalVertices != undefined) {\n      // including null and undefined\n      this._totalVertices = totalVertices;\n    }\n\n    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._createGlobalSubMesh(true);\n    }\n\n    this.notifyUpdate();\n  };\n  /**\r\n   * Return the total number of indices\r\n   * @returns the total number of indices\r\n   */\n\n\n  Geometry.prototype.getTotalIndices = function () {\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    return this._indices.length;\n  };\n  /**\r\n   * Gets the index buffer array\r\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n   * @returns the index buffer array\r\n   */\n\n\n  Geometry.prototype.getIndices = function (copyWhenShared, forceCopy) {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    var orig = this._indices;\n\n    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\n      return orig;\n    } else {\n      var len = orig.length;\n      var copy = [];\n\n      for (var i = 0; i < len; i++) {\n        copy.push(orig[i]);\n      }\n\n      return copy;\n    }\n  };\n  /**\r\n   * Gets the index buffer\r\n   * @return the index buffer\r\n   */\n\n\n  Geometry.prototype.getIndexBuffer = function () {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._indexBuffer;\n  };\n  /** @hidden */\n\n\n  Geometry.prototype._releaseVertexArrayObject = function (effect) {\n    if (effect === void 0) {\n      effect = null;\n    }\n\n    if (!effect || !this._vertexArrayObjects) {\n      return;\n    }\n\n    if (this._vertexArrayObjects[effect.key]) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\n\n      delete this._vertexArrayObjects[effect.key];\n    }\n  };\n  /**\r\n   * Release the associated resources for a specific mesh\r\n   * @param mesh defines the source mesh\r\n   * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n   */\n\n\n  Geometry.prototype.releaseForMesh = function (mesh, shouldDispose) {\n    var meshes = this._meshes;\n    var index = meshes.indexOf(mesh);\n\n    if (index === -1) {\n      return;\n    }\n\n    meshes.splice(index, 1);\n    mesh._geometry = null;\n\n    if (meshes.length === 0 && shouldDispose) {\n      this.dispose();\n    }\n  };\n  /**\r\n   * Apply current geometry to a given mesh\r\n   * @param mesh defines the mesh to apply geometry to\r\n   */\n\n\n  Geometry.prototype.applyToMesh = function (mesh) {\n    if (mesh._geometry === this) {\n      return;\n    }\n\n    var previousGeometry = mesh._geometry;\n\n    if (previousGeometry) {\n      previousGeometry.releaseForMesh(mesh);\n    }\n\n    var meshes = this._meshes; // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\n\n    mesh._geometry = this;\n\n    this._scene.pushGeometry(this);\n\n    meshes.push(mesh);\n\n    if (this.isReady()) {\n      this._applyToMesh(mesh);\n    } else {\n      mesh._boundingInfo = this._boundingInfo;\n    }\n  };\n\n  Geometry.prototype._updateExtend = function (data) {\n    if (data === void 0) {\n      data = null;\n    }\n\n    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\n      this._extend = {\n        minimum: this._boundingInfo.minimum.clone(),\n        maximum: this._boundingInfo.maximum.clone()\n      };\n    } else {\n      if (!data) {\n        data = this.getVerticesData(VertexBuffer.PositionKind);\n      }\n\n      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\n    }\n  };\n\n  Geometry.prototype._applyToMesh = function (mesh) {\n    var numOfMeshes = this._meshes.length; // vertexBuffers\n\n    for (var kind in this._vertexBuffers) {\n      if (numOfMeshes === 1) {\n        this._vertexBuffers[kind].create();\n      }\n\n      var buffer = this._vertexBuffers[kind].getBuffer();\n\n      if (buffer) {\n        buffer.references = numOfMeshes;\n      }\n\n      if (kind === VertexBuffer.PositionKind) {\n        if (!this._extend) {\n          this._updateExtend();\n        }\n\n        mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n\n        mesh._createGlobalSubMesh(false); //bounding info was just created again, world matrix should be applied again.\n\n\n        mesh._updateBoundingInfo();\n      }\n    } // indexBuffer\n\n\n    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices);\n    }\n\n    if (this._indexBuffer) {\n      this._indexBuffer.references = numOfMeshes;\n    } // morphTargets\n\n\n    mesh._syncGeometryWithMorphTargetManager(); // instances\n\n\n    mesh.synchronizeInstances();\n  };\n\n  Geometry.prototype.notifyUpdate = function (kind) {\n    if (this.onGeometryUpdated) {\n      this.onGeometryUpdated(this, kind);\n    }\n\n    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._markSubMeshesAsAttributesDirty();\n    }\n  };\n  /**\r\n   * Load the geometry if it was flagged as delay loaded\r\n   * @param scene defines the hosting scene\r\n   * @param onLoaded defines a callback called when the geometry is loaded\r\n   */\n\n\n  Geometry.prototype.load = function (scene, onLoaded) {\n    if (this.delayLoadState === 2) {\n      return;\n    }\n\n    if (this.isReady()) {\n      if (onLoaded) {\n        onLoaded();\n      }\n\n      return;\n    }\n\n    this.delayLoadState = 2;\n\n    this._queueLoad(scene, onLoaded);\n  };\n\n  Geometry.prototype._queueLoad = function (scene, onLoaded) {\n    var _this = this;\n\n    if (!this.delayLoadingFile) {\n      return;\n    }\n\n    scene._addPendingData(this);\n\n    scene._loadFile(this.delayLoadingFile, function (data) {\n      if (!_this._delayLoadingFunction) {\n        return;\n      }\n\n      _this._delayLoadingFunction(JSON.parse(data), _this);\n\n      _this.delayLoadState = 1;\n      _this._delayInfo = [];\n\n      scene._removePendingData(_this);\n\n      var meshes = _this._meshes;\n      var numOfMeshes = meshes.length;\n\n      for (var index = 0; index < numOfMeshes; index++) {\n        _this._applyToMesh(meshes[index]);\n      }\n\n      if (onLoaded) {\n        onLoaded();\n      }\n    }, undefined, true);\n  };\n  /**\r\n   * Invert the geometry to move from a right handed system to a left handed one.\r\n   */\n\n\n  Geometry.prototype.toLeftHanded = function () {\n    // Flip faces\n    var tIndices = this.getIndices(false);\n\n    if (tIndices != null && tIndices.length > 0) {\n      for (var i = 0; i < tIndices.length; i += 3) {\n        var tTemp = tIndices[i + 0];\n        tIndices[i + 0] = tIndices[i + 2];\n        tIndices[i + 2] = tTemp;\n      }\n\n      this.setIndices(tIndices);\n    } // Negate position.z\n\n\n    var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\n\n    if (tPositions != null && tPositions.length > 0) {\n      for (var i = 0; i < tPositions.length; i += 3) {\n        tPositions[i + 2] = -tPositions[i + 2];\n      }\n\n      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\n    } // Negate normal.z\n\n\n    var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\n\n    if (tNormals != null && tNormals.length > 0) {\n      for (var i = 0; i < tNormals.length; i += 3) {\n        tNormals[i + 2] = -tNormals[i + 2];\n      }\n\n      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\n    }\n  }; // Cache\n\n  /** @hidden */\n\n\n  Geometry.prototype._resetPointsArrayCache = function () {\n    this._positions = null;\n  };\n  /** @hidden */\n\n\n  Geometry.prototype._generatePointsArray = function () {\n    if (this._positions) {\n      return true;\n    }\n\n    var data = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (!data || data.length === 0) {\n      return false;\n    }\n\n    for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\n    }\n\n    for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\n    } // just in case the number of positions was reduced, splice the array\n\n\n    this._positionsCache.length = data.length / 3;\n    this._positions = this._positionsCache;\n    return true;\n  };\n  /**\r\n   * Gets a value indicating if the geometry is disposed\r\n   * @returns true if the geometry was disposed\r\n   */\n\n\n  Geometry.prototype.isDisposed = function () {\n    return this._isDisposed;\n  };\n\n  Geometry.prototype._disposeVertexArrayObjects = function () {\n    if (this._vertexArrayObjects) {\n      for (var kind in this._vertexArrayObjects) {\n        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\n      }\n\n      this._vertexArrayObjects = {};\n    }\n  };\n  /**\r\n   * Free all associated resources\r\n   */\n\n\n  Geometry.prototype.dispose = function () {\n    var meshes = this._meshes;\n    var numOfMeshes = meshes.length;\n    var index;\n\n    for (index = 0; index < numOfMeshes; index++) {\n      this.releaseForMesh(meshes[index]);\n    }\n\n    this._meshes = [];\n\n    this._disposeVertexArrayObjects();\n\n    for (var kind in this._vertexBuffers) {\n      this._vertexBuffers[kind].dispose();\n    }\n\n    this._vertexBuffers = {};\n    this._totalVertices = 0;\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n\n    this._indexBuffer = null;\n    this._indices = [];\n    this.delayLoadState = 0;\n    this.delayLoadingFile = null;\n    this._delayLoadingFunction = null;\n    this._delayInfo = [];\n    this._boundingInfo = null;\n\n    this._scene.removeGeometry(this);\n\n    this._isDisposed = true;\n  };\n  /**\r\n   * Clone the current geometry into a new geometry\r\n   * @param id defines the unique ID of the new geometry\r\n   * @returns a new geometry object\r\n   */\n\n\n  Geometry.prototype.copy = function (id) {\n    var vertexData = new VertexData();\n    vertexData.indices = [];\n    var indices = this.getIndices();\n\n    if (indices) {\n      for (var index = 0; index < indices.length; index++) {\n        vertexData.indices.push(indices[index]);\n      }\n    }\n\n    var updatable = false;\n    var stopChecking = false;\n    var kind;\n\n    for (kind in this._vertexBuffers) {\n      // using slice() to make a copy of the array and not just reference it\n      var data = this.getVerticesData(kind);\n\n      if (data) {\n        if (data instanceof Float32Array) {\n          vertexData.set(new Float32Array(data), kind);\n        } else {\n          vertexData.set(data.slice(0), kind);\n        }\n\n        if (!stopChecking) {\n          var vb = this.getVertexBuffer(kind);\n\n          if (vb) {\n            updatable = vb.isUpdatable();\n            stopChecking = !updatable;\n          }\n        }\n      }\n    }\n\n    var geometry = new Geometry(id, this._scene, vertexData, updatable);\n    geometry.delayLoadState = this.delayLoadState;\n    geometry.delayLoadingFile = this.delayLoadingFile;\n    geometry._delayLoadingFunction = this._delayLoadingFunction;\n\n    for (kind in this._delayInfo) {\n      geometry._delayInfo = geometry._delayInfo || [];\n\n      geometry._delayInfo.push(kind);\n    } // Bounding info\n\n\n    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n    return geometry;\n  };\n  /**\r\n   * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n   * @return a JSON representation of the current geometry data (without the vertices data)\r\n   */\n\n\n  Geometry.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.updatable = this._updatable;\n\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n\n    return serializationObject;\n  };\n\n  Geometry.prototype.toNumberArray = function (origin) {\n    if (Array.isArray(origin)) {\n      return origin;\n    } else {\n      return Array.prototype.slice.call(origin);\n    }\n  };\n  /**\r\n   * Serialize all vertices data into a JSON oject\r\n   * @returns a JSON representation of the current geometry data\r\n   */\n\n\n  Geometry.prototype.serializeVerticeData = function () {\n    var serializationObject = this.serialize();\n\n    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      serializationObject.positions = this.toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n        serializationObject.positions._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      serializationObject.normals = this.toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n        serializationObject.normals._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      serializationObject.tangets = this.toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\n        serializationObject.tangets._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      serializationObject.uvs = this.toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\n        serializationObject.uvs._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      serializationObject.uv2s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\n        serializationObject.uv2s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      serializationObject.uv3s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\n        serializationObject.uv3s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      serializationObject.uv4s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\n        serializationObject.uv4s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      serializationObject.uv5s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\n        serializationObject.uv5s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      serializationObject.uv6s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\n        serializationObject.uv6s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      serializationObject.colors = this.toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\n        serializationObject.colors._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      serializationObject.matricesIndices = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\n      serializationObject.matricesIndices._isExpanded = true;\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\n        serializationObject.matricesIndices._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      serializationObject.matricesWeights = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\n        serializationObject.matricesWeights._updatable = true;\n      }\n    }\n\n    serializationObject.indices = this.toNumberArray(this.getIndices());\n    return serializationObject;\n  }; // Statics\n\n  /**\r\n   * Extracts a clone of a mesh geometry\r\n   * @param mesh defines the source mesh\r\n   * @param id defines the unique ID of the new geometry object\r\n   * @returns the new geometry object\r\n   */\n\n\n  Geometry.ExtractFromMesh = function (mesh, id) {\n    var geometry = mesh._geometry;\n\n    if (!geometry) {\n      return null;\n    }\n\n    return geometry.copy(id);\n  };\n  /**\r\n   * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n   * Be aware Math.random() could cause collisions, but:\r\n   * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n   * @returns a string containing a new GUID\r\n   */\n\n\n  Geometry.RandomId = function () {\n    return Tools.RandomId();\n  };\n  /** @hidden */\n\n\n  Geometry._ImportGeometry = function (parsedGeometry, mesh) {\n    var scene = mesh.getScene(); // Geometry\n\n    var geometryId = parsedGeometry.geometryId;\n\n    if (geometryId) {\n      var geometry = scene.getGeometryByID(geometryId);\n\n      if (geometry) {\n        geometry.applyToMesh(mesh);\n      }\n    } else if (parsedGeometry instanceof ArrayBuffer) {\n      var binaryInfo = mesh._binaryInfo;\n\n      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\n        var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\n      }\n\n      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\n        var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\n      }\n\n      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\n        var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\n      }\n\n      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\n        var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\n      }\n\n      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\n        var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\n      }\n\n      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\n        var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\n      }\n\n      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\n        var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\n      }\n\n      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\n        var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\n      }\n\n      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\n        var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\n      }\n\n      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\n        var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\n      }\n\n      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\n        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\n        var floatIndices = [];\n\n        for (var i = 0; i < matricesIndicesData.length; i++) {\n          var index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\n      }\n\n      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\n        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\n        var floatIndices = [];\n\n        for (var i = 0; i < matricesIndicesData.length; i++) {\n          var index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\n      }\n\n      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\n        var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\n      }\n\n      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\n        var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\n        mesh.setIndices(indicesData, null);\n      }\n\n      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\n        var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\n        mesh.subMeshes = [];\n\n        for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\n          var materialIndex = subMeshesData[i * 5 + 0];\n          var verticesStart = subMeshesData[i * 5 + 1];\n          var verticesCount = subMeshesData[i * 5 + 2];\n          var indexStart = subMeshesData[i * 5 + 3];\n          var indexCount = subMeshesData[i * 5 + 4];\n          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\n        }\n      }\n    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\n      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\n      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\n\n      if (parsedGeometry.tangents) {\n        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\n      }\n\n      if (parsedGeometry.uvs) {\n        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\n      }\n\n      if (parsedGeometry.uvs2) {\n        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\n      }\n\n      if (parsedGeometry.uvs3) {\n        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\n      }\n\n      if (parsedGeometry.uvs4) {\n        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\n      }\n\n      if (parsedGeometry.uvs5) {\n        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\n      }\n\n      if (parsedGeometry.uvs6) {\n        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\n      }\n\n      if (parsedGeometry.colors) {\n        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\n      }\n\n      if (parsedGeometry.matricesIndices) {\n        if (!parsedGeometry.matricesIndices._isExpanded) {\n          var floatIndices = [];\n\n          for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {\n            var matricesIndex = parsedGeometry.matricesIndices[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\n        }\n      }\n\n      if (parsedGeometry.matricesIndicesExtra) {\n        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\n          var floatIndices = [];\n\n          for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\n            var matricesIndex = parsedGeometry.matricesIndicesExtra[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\n        }\n      }\n\n      if (parsedGeometry.matricesWeights) {\n        Geometry._CleanMatricesWeights(parsedGeometry, mesh);\n\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\n      }\n\n      if (parsedGeometry.matricesWeightsExtra) {\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\n      }\n\n      mesh.setIndices(parsedGeometry.indices, null);\n    } // SubMeshes\n\n\n    if (parsedGeometry.subMeshes) {\n      mesh.subMeshes = [];\n\n      for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\n        var parsedSubMesh = parsedGeometry.subMeshes[subIndex];\n        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\n      }\n    } // Flat shading\n\n\n    if (mesh._shouldGenerateFlatShading) {\n      mesh.convertToFlatShadedMesh();\n      mesh._shouldGenerateFlatShading = false;\n    } // Update\n\n\n    mesh.computeWorldMatrix(true);\n    scene.onMeshImportedObservable.notifyObservers(mesh);\n  };\n\n  Geometry._CleanMatricesWeights = function (parsedGeometry, mesh) {\n    var epsilon = 1e-3;\n\n    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\n      return;\n    }\n\n    var noInfluenceBoneIndex = 0.0;\n\n    if (parsedGeometry.skeletonId > -1) {\n      var skeleton = mesh.getScene().getLastSkeletonByID(parsedGeometry.skeletonId);\n\n      if (!skeleton) {\n        return;\n      }\n\n      noInfluenceBoneIndex = skeleton.bones.length;\n    } else {\n      return;\n    }\n\n    var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n    var matricesWeights = parsedGeometry.matricesWeights;\n    var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\n    var influencers = parsedGeometry.numBoneInfluencer;\n    var size = matricesWeights.length;\n\n    for (var i = 0; i < size; i += 4) {\n      var weight = 0.0;\n      var firstZeroWeight = -1;\n\n      for (var j = 0; j < 4; j++) {\n        var w = matricesWeights[i + j];\n        weight += w;\n\n        if (w < epsilon && firstZeroWeight < 0) {\n          firstZeroWeight = j;\n        }\n      }\n\n      if (matricesWeightsExtra) {\n        for (var j = 0; j < 4; j++) {\n          var w = matricesWeightsExtra[i + j];\n          weight += w;\n\n          if (w < epsilon && firstZeroWeight < 0) {\n            firstZeroWeight = j + 4;\n          }\n        }\n      }\n\n      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\n        firstZeroWeight = influencers - 1;\n      }\n\n      if (weight > epsilon) {\n        var mweight = 1.0 / weight;\n\n        for (var j = 0; j < 4; j++) {\n          matricesWeights[i + j] *= mweight;\n        }\n\n        if (matricesWeightsExtra) {\n          for (var j = 0; j < 4; j++) {\n            matricesWeightsExtra[i + j] *= mweight;\n          }\n        }\n      } else {\n        if (firstZeroWeight >= 4) {\n          matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\n          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\n        } else {\n          matricesWeights[i + firstZeroWeight] = 1.0 - weight;\n          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\n        }\n      }\n    }\n\n    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\n\n    if (parsedGeometry.matricesWeightsExtra) {\n      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\n    }\n  };\n  /**\r\n   * Create a new geometry from persisted data (Using .babylon file format)\r\n   * @param parsedVertexData defines the persisted data\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n   * @returns the new geometry object\r\n   */\n\n\n  Geometry.Parse = function (parsedVertexData, scene, rootUrl) {\n    if (scene.getGeometryByID(parsedVertexData.id)) {\n      return null; // null since geometry could be something else than a box...\n    }\n\n    var geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\n\n    if (Tags) {\n      Tags.AddTagsTo(geometry, parsedVertexData.tags);\n    }\n\n    if (parsedVertexData.delayLoadingFile) {\n      geometry.delayLoadState = 4;\n      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\n      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\n      geometry._delayInfo = [];\n\n      if (parsedVertexData.hasUVs) {\n        geometry._delayInfo.push(VertexBuffer.UVKind);\n      }\n\n      if (parsedVertexData.hasUVs2) {\n        geometry._delayInfo.push(VertexBuffer.UV2Kind);\n      }\n\n      if (parsedVertexData.hasUVs3) {\n        geometry._delayInfo.push(VertexBuffer.UV3Kind);\n      }\n\n      if (parsedVertexData.hasUVs4) {\n        geometry._delayInfo.push(VertexBuffer.UV4Kind);\n      }\n\n      if (parsedVertexData.hasUVs5) {\n        geometry._delayInfo.push(VertexBuffer.UV5Kind);\n      }\n\n      if (parsedVertexData.hasUVs6) {\n        geometry._delayInfo.push(VertexBuffer.UV6Kind);\n      }\n\n      if (parsedVertexData.hasColors) {\n        geometry._delayInfo.push(VertexBuffer.ColorKind);\n      }\n\n      if (parsedVertexData.hasMatricesIndices) {\n        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n      }\n\n      if (parsedVertexData.hasMatricesWeights) {\n        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n      }\n\n      geometry._delayLoadingFunction = VertexData.ImportVertexData;\n    } else {\n      VertexData.ImportVertexData(parsedVertexData, geometry);\n    }\n\n    scene.pushGeometry(geometry, true);\n    return geometry;\n  };\n\n  return Geometry;\n}();\n\nexport { Geometry };","map":null,"metadata":{},"sourceType":"module"}