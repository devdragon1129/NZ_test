{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { createSelector } from 'reselect';\nimport { ContractName, getContract } from 'decentraland-transactions';\nimport { getAddress } from 'decentraland-dapps/dist/modules/wallet/selectors';\nimport { getPendingTransactions } from 'modules/transaction/selectors';\nimport { getItems, getStatusByItemId } from 'modules/item/selectors';\nimport { SyncStatus } from 'modules/item/types';\nimport { getCurationsByCollectionId } from 'modules/curations/collectionCuration/selectors';\nimport { getCollectionThirdParty, getData as getThirdParties } from 'modules/thirdParty/selectors';\nimport { getThirdPartyForCollection, isUserManagerOfThirdParty } from 'modules/thirdParty/utils';\nimport { getIsRaritiesWithOracleEnabled } from 'modules/features/selectors';\nimport { isEqual } from 'lib/address';\nimport { isThirdParty } from 'lib/urn';\nimport { SET_COLLECTION_MINTERS_SUCCESS, APPROVE_COLLECTION_SUCCESS, REJECT_COLLECTION_SUCCESS } from './actions';\nimport { CollectionType } from './types';\nimport { canSeeCollection, getCollectionType, getMostRelevantStatus, canManageCollectionItems, sortCollectionByCreatedAt, UNSYNCED_COLLECTION_ERROR_PREFIX } from './utils';\nexport var getState = function getState(state) {\n  return state.collection;\n};\nexport var getData = function getData(state) {\n  return getState(state).data;\n};\nexport var getLoading = function getLoading(state) {\n  return getState(state).loading;\n};\nexport var getPaginationData = function getPaginationData(state) {\n  return getState(state).pagination;\n};\nexport var getError = function getError(state) {\n  return getState(state).error;\n};\nexport var getPaginatedCollections = function getPaginatedCollections(state, pageSize) {\n  var paginationData = getPaginationData(state);\n  var allCollections = getData(state);\n  var ids = paginationData ? pageSize ? paginationData.ids.slice(0, pageSize) : paginationData.ids : [];\n  return ids.map(function (id) {\n    return allCollections[id];\n  }).filter(Boolean);\n};\nexport var getUnsyncedCollectionError = function getUnsyncedCollectionError(state) {\n  var error = getError(state);\n\n  if (!error || !error.startsWith(UNSYNCED_COLLECTION_ERROR_PREFIX)) {\n    return null;\n  }\n\n  return error;\n};\nexport var getCollections = createSelector(getData, getAddress, function (collectionData) {\n  return Object.values(collectionData).sort(sortCollectionByCreatedAt);\n});\nexport var getWalletCollections = createSelector(getCollections, getAddress, function (collections, address) {\n  return collections.filter(function (collection) {\n    return address && isEqual(collection.owner, address);\n  });\n});\nexport var getAuthorizedCollections = createSelector(getCollections, getAddress, getThirdParties, function (collections, address, thirdParties) {\n  return collections.filter(function (collection) {\n    var type = getCollectionType(collection);\n\n    switch (type) {\n      case CollectionType.DECENTRALAND:\n        return address && canSeeCollection(collection, address);\n\n      case CollectionType.THIRD_PARTY:\n        var thirdParty = getThirdPartyForCollection(thirdParties, collection);\n        return address && thirdParty && isUserManagerOfThirdParty(address, thirdParty);\n\n      default:\n        throw new Error(\"Invalid collection type \".concat(type));\n    }\n  });\n});\nexport var getCollection = function getCollection(state, collectionId) {\n  var collections = getCollections(state);\n  return collections.find(function (collection) {\n    return collection.id === collectionId;\n  }) || null;\n};\nexport var getCollectionItemCount = function getCollectionItemCount(state, collectionId) {\n  var _collections$collecti;\n\n  var collections = getData(state);\n  return ((_collections$collecti = collections[collectionId]) === null || _collections$collecti === void 0 ? void 0 : _collections$collecti.itemCount) || 0;\n};\nexport var getCollectionsByContractAddress = createSelector(function (state) {\n  return getData(state);\n}, function (collectionsById) {\n  return Object.values(collectionsById).reduce(function (acc, collection) {\n    var contractAddress = collection.contractAddress;\n\n    if (contractAddress) {\n      acc[contractAddress] = collection;\n    }\n\n    return acc;\n  }, {});\n});\nexport var isOnSaleLoading = createSelector(getPendingTransactions, function (transactions) {\n  return transactions.some(function (transaction) {\n    return transaction.actionType === SET_COLLECTION_MINTERS_SUCCESS;\n  });\n});\nexport var hasPendingCurationTransaction = createSelector(getPendingTransactions, function (transactions) {\n  return transactions.some(function (transaction) {\n    return [APPROVE_COLLECTION_SUCCESS, REJECT_COLLECTION_SUCCESS].includes(transaction.actionType);\n  });\n});\nexport var getStatusByCollectionId = createSelector(function (state) {\n  return getItems(state);\n}, function (state) {\n  return getStatusByItemId(state);\n}, getCurationsByCollectionId, function (items, itemStatusByItemId, curationsByCollectionId) {\n  var statusByCollectionId = {};\n\n  var _iterator = _createForOfIteratorHelper(items),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      var collectionId = item.collectionId; // TODO: @TPW item.isPublished is only necessary if we end up using this selector for this feature\n\n      if (collectionId && item.isPublished) {\n        var _curationsByCollectio;\n\n        if (((_curationsByCollectio = curationsByCollectionId[collectionId]) === null || _curationsByCollectio === void 0 ? void 0 : _curationsByCollectio.status) === 'pending') {\n          statusByCollectionId[collectionId] = SyncStatus.UNDER_REVIEW;\n        } else if (collectionId in statusByCollectionId) {\n          statusByCollectionId[collectionId] = getMostRelevantStatus(statusByCollectionId[collectionId], itemStatusByItemId[item.id]);\n        } else {\n          statusByCollectionId[collectionId] = itemStatusByItemId[item.id];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return statusByCollectionId;\n});\nexport var hasViewAndEditRights = function hasViewAndEditRights(state, address, collection) {\n  var thirdParty = isThirdParty(collection.urn) ? getCollectionThirdParty(state, collection) : null;\n  var isTPManager = thirdParty && isUserManagerOfThirdParty(address, thirdParty);\n  return isTPManager || canManageCollectionItems(collection, address);\n};\n/**\n * Returns the corresponding rarities contract depending on if the rarities with oracle\n * feature flag is enabled or not.\n */\n\nexport var getRaritiesContract = function getRaritiesContract(state, chainId) {\n  var useRaritiesWithOracle = getIsRaritiesWithOracleEnabled(state);\n  var contractName = useRaritiesWithOracle ? ContractName.RaritiesWithOracle : ContractName.Rarities;\n  return getContract(contractName, chainId);\n};","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/collection/selectors.ts"],"names":["createSelector","ContractName","getContract","getAddress","getPendingTransactions","getItems","getStatusByItemId","SyncStatus","getCurationsByCollectionId","getCollectionThirdParty","getData","getThirdParties","getThirdPartyForCollection","isUserManagerOfThirdParty","getIsRaritiesWithOracleEnabled","isEqual","isThirdParty","SET_COLLECTION_MINTERS_SUCCESS","APPROVE_COLLECTION_SUCCESS","REJECT_COLLECTION_SUCCESS","CollectionType","canSeeCollection","getCollectionType","getMostRelevantStatus","canManageCollectionItems","sortCollectionByCreatedAt","UNSYNCED_COLLECTION_ERROR_PREFIX","getState","state","collection","data","getLoading","loading","getPaginationData","pagination","getError","error","getPaginatedCollections","pageSize","paginationData","allCollections","ids","slice","map","id","filter","Boolean","getUnsyncedCollectionError","startsWith","getCollections","collectionData","Object","values","sort","getWalletCollections","collections","address","owner","getAuthorizedCollections","thirdParties","type","DECENTRALAND","THIRD_PARTY","thirdParty","Error","getCollection","collectionId","find","getCollectionItemCount","itemCount","getCollectionsByContractAddress","collectionsById","reduce","acc","contractAddress","isOnSaleLoading","transactions","some","transaction","actionType","hasPendingCurationTransaction","includes","getStatusByCollectionId","items","itemStatusByItemId","curationsByCollectionId","statusByCollectionId","item","isPublished","status","UNDER_REVIEW","hasViewAndEditRights","urn","isTPManager","getRaritiesContract","chainId","useRaritiesWithOracle","contractName","RaritiesWithOracle","Rarities"],"mappings":"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","sourcesContent":["import { createSelector } from 'reselect'\nimport { ChainId } from '@dcl/schemas'\nimport { ContractName, getContract } from 'decentraland-transactions'\nimport { getAddress } from 'decentraland-dapps/dist/modules/wallet/selectors'\nimport { Transaction } from 'decentraland-dapps/dist/modules/transaction/types'\nimport { RootState } from 'modules/common/types'\nimport { getPendingTransactions } from 'modules/transaction/selectors'\nimport { getItems, getStatusByItemId } from 'modules/item/selectors'\nimport { Item, SyncStatus } from 'modules/item/types'\nimport { getCurationsByCollectionId } from 'modules/curations/collectionCuration/selectors'\nimport { CollectionCuration } from 'modules/curations/collectionCuration/types'\nimport { getCollectionThirdParty, getData as getThirdParties } from 'modules/thirdParty/selectors'\nimport { getThirdPartyForCollection, isUserManagerOfThirdParty } from 'modules/thirdParty/utils'\nimport { ThirdParty } from 'modules/thirdParty/types'\nimport { getIsRaritiesWithOracleEnabled } from 'modules/features/selectors'\nimport { isEqual } from 'lib/address'\nimport { isThirdParty } from 'lib/urn'\nimport { SET_COLLECTION_MINTERS_SUCCESS, APPROVE_COLLECTION_SUCCESS, REJECT_COLLECTION_SUCCESS } from './actions'\nimport { Collection, CollectionType } from './types'\nimport { CollectionState } from './reducer'\nimport {\n  canSeeCollection,\n  getCollectionType,\n  getMostRelevantStatus,\n  canManageCollectionItems,\n  sortCollectionByCreatedAt,\n  UNSYNCED_COLLECTION_ERROR_PREFIX\n} from './utils'\n\nexport const getState = (state: RootState) => state.collection\nexport const getData = (state: RootState) => getState(state).data\nexport const getLoading = (state: RootState) => getState(state).loading\nexport const getPaginationData = (state: RootState) => getState(state).pagination\nexport const getError = (state: RootState) => getState(state).error\n\nexport const getPaginatedCollections = (state: RootState, pageSize?: number) => {\n  const paginationData = getPaginationData(state)\n  const allCollections = getData(state)\n  const ids = paginationData ? (pageSize ? paginationData.ids.slice(0, pageSize) : paginationData.ids) : []\n  return ids.map(id => allCollections[id]).filter(Boolean)\n}\n\nexport const getUnsyncedCollectionError = (state: RootState) => {\n  const error = getError(state)\n  if (!error || !error.startsWith(UNSYNCED_COLLECTION_ERROR_PREFIX)) {\n    return null\n  }\n  return error\n}\n\nexport const getCollections = createSelector<RootState, CollectionState['data'], string | undefined, Collection[]>(\n  getData,\n  getAddress,\n  collectionData => Object.values(collectionData).sort(sortCollectionByCreatedAt)\n)\n\nexport const getWalletCollections = createSelector<RootState, Collection[], string | undefined, Collection[]>(\n  getCollections,\n  getAddress,\n  (collections, address) => collections.filter(collection => address && isEqual(collection.owner, address))\n)\n\nexport const getAuthorizedCollections = createSelector<\n  RootState,\n  Collection[],\n  string | undefined,\n  Record<string, ThirdParty>,\n  Collection[]\n>(getCollections, getAddress, getThirdParties, (collections, address, thirdParties) =>\n  collections.filter(collection => {\n    const type = getCollectionType(collection)\n    switch (type) {\n      case CollectionType.DECENTRALAND:\n        return address && canSeeCollection(collection, address)\n      case CollectionType.THIRD_PARTY:\n        const thirdParty = getThirdPartyForCollection(thirdParties, collection)\n        return address && thirdParty && isUserManagerOfThirdParty(address, thirdParty)\n      default:\n        throw new Error(`Invalid collection type ${type}`)\n    }\n  })\n)\n\nexport const getCollection = (state: RootState, collectionId: string) => {\n  const collections = getCollections(state)\n  return collections.find(collection => collection.id === collectionId) || null\n}\n\nexport const getCollectionItemCount = (state: RootState, collectionId: string): number => {\n  const collections = getData(state)\n  return collections[collectionId]?.itemCount || 0\n}\n\nexport const getCollectionsByContractAddress = createSelector<RootState, ReturnType<typeof getData>, Record<string, Collection>>(\n  state => getData(state),\n  collectionsById =>\n    Object.values(collectionsById).reduce((acc, collection) => {\n      const { contractAddress } = collection\n      if (contractAddress) {\n        acc[contractAddress] = collection\n      }\n      return acc\n    }, {} as Record<string, Collection>)\n)\n\nexport const isOnSaleLoading = createSelector<RootState, Transaction[], boolean>(getPendingTransactions, transactions =>\n  transactions.some(transaction => transaction.actionType === SET_COLLECTION_MINTERS_SUCCESS)\n)\n\nexport const hasPendingCurationTransaction = createSelector<RootState, Transaction[], boolean>(getPendingTransactions, transactions =>\n  transactions.some(transaction => [APPROVE_COLLECTION_SUCCESS, REJECT_COLLECTION_SUCCESS].includes(transaction.actionType))\n)\n\nexport const getStatusByCollectionId = createSelector<\n  RootState,\n  Item[],\n  Record<string, SyncStatus>,\n  Record<string, CollectionCuration>,\n  Record<string, SyncStatus>\n>(\n  state => getItems(state),\n  (state: RootState) => getStatusByItemId(state),\n  getCurationsByCollectionId,\n  (items, itemStatusByItemId, curationsByCollectionId) => {\n    const statusByCollectionId: Record<string, SyncStatus> = {}\n    for (const item of items) {\n      const { collectionId } = item\n      // TODO: @TPW item.isPublished is only necessary if we end up using this selector for this feature\n      if (collectionId && item.isPublished) {\n        if (curationsByCollectionId[collectionId]?.status === 'pending') {\n          statusByCollectionId[collectionId] = SyncStatus.UNDER_REVIEW\n        } else if (collectionId in statusByCollectionId) {\n          statusByCollectionId[collectionId] = getMostRelevantStatus(statusByCollectionId[collectionId], itemStatusByItemId[item.id])\n        } else {\n          statusByCollectionId[collectionId] = itemStatusByItemId[item.id]\n        }\n      }\n    }\n    return statusByCollectionId\n  }\n)\n\nexport const hasViewAndEditRights = (state: RootState, address: string, collection: Collection): boolean => {\n  const thirdParty = isThirdParty(collection.urn) ? getCollectionThirdParty(state, collection) : null\n  const isTPManager = thirdParty && isUserManagerOfThirdParty(address, thirdParty)\n  return isTPManager || canManageCollectionItems(collection, address)\n}\n\n/**\n * Returns the corresponding rarities contract depending on if the rarities with oracle\n * feature flag is enabled or not.\n */\nexport const getRaritiesContract = (state: RootState, chainId: ChainId) => {\n  const useRaritiesWithOracle = getIsRaritiesWithOracleEnabled(state)\n  const contractName = useRaritiesWithOracle ? ContractName.RaritiesWithOracle : ContractName.Rarities\n\n  return getContract(contractName, chainId)\n}\n"]},"metadata":{},"sourceType":"module"}