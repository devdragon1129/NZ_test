{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sortContent = exports.prefixContentName = exports.computeHashes = void 0;\n\nvar hashing_1 = require(\"@dcl/hashing\");\n\nvar buffer_1 = require(\"buffer\");\n\nvar types_1 = require(\"../item/types\");\n\nvar constants_1 = require(\"../item/constants\");\n/**\n * Computes the hashes of RawContents.\n * @param contents - The raw contents of an item.\n */\n\n\nfunction computeHashes(_x) {\n  return _computeHashes.apply(this, arguments);\n}\n\nfunction _computeHashes() {\n  _computeHashes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(contents) {\n    var filePaths, fileHashes;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            filePaths = Object.keys(contents);\n            _context2.next = 3;\n            return Promise.all(filePaths.map( /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path) {\n                var blob, file;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        blob = contents[path];\n                        _context.next = 3;\n                        return makeContentFile(path, blob);\n\n                      case 3:\n                        file = _context.sent;\n                        return _context.abrupt(\"return\", (0, hashing_1.hashV1)(file.content));\n\n                      case 5:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function (_x4) {\n                return _ref.apply(this, arguments);\n              };\n            }()));\n\n          case 3:\n            fileHashes = _context2.sent;\n            return _context2.abrupt(\"return\", filePaths.reduce(function (hashes, path, index) {\n              hashes[path] = fileHashes[index];\n              return hashes;\n            }, {}));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _computeHashes.apply(this, arguments);\n}\n\nexports.computeHashes = computeHashes;\n/**\n * Creates a content file to later perform a hash on it.\n * @param path - The path of the content file.\n * @param content - The content of the file.\n */\n\nfunction makeContentFile(_x2, _x3) {\n  return _makeContentFile.apply(this, arguments);\n}\n/**\n * Prefixes a content name using the body shape.\n * @param bodyShape - The body shaped of the content.\n * @param contentKey - The name of the content.\n */\n\n\nfunction _makeContentFile() {\n  _makeContentFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path, content) {\n    var buffer, _buffer;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(typeof content === 'string')) {\n              _context3.next = 5;\n              break;\n            }\n\n            // This must be polyfilled in the browser\n            buffer = buffer_1.Buffer.from(content);\n            return _context3.abrupt(\"return\", {\n              name: path,\n              content: buffer\n            });\n\n          case 5:\n            if (!(globalThis.Blob && content instanceof globalThis.Blob)) {\n              _context3.next = 12;\n              break;\n            }\n\n            _context3.next = 8;\n            return content.arrayBuffer();\n\n          case 8:\n            _buffer = _context3.sent;\n            return _context3.abrupt(\"return\", {\n              name: path,\n              content: new Uint8Array(_buffer)\n            });\n\n          case 12:\n            if (!(content instanceof Uint8Array)) {\n              _context3.next = 16;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", {\n              name: path,\n              content: content\n            });\n\n          case 16:\n            if (!(content instanceof ArrayBuffer)) {\n              _context3.next = 20;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", {\n              name: path,\n              content: new Uint8Array(content)\n            });\n\n          case 20:\n            if (!buffer_1.Buffer.isBuffer(content)) {\n              _context3.next = 22;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", {\n              name: path,\n              content: new Uint8Array(content)\n            });\n\n          case 22:\n            throw new Error('Unable to create ContentFile: content must be a string, a Blob or a Uint8Array');\n\n          case 23:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _makeContentFile.apply(this, arguments);\n}\n\nfunction prefixContentName(bodyShape, contentKey) {\n  return \"\".concat(bodyShape === types_1.WearableBodyShape.MALE ? 'male' : 'female', \"/\").concat(contentKey);\n}\n\nexports.prefixContentName = prefixContentName;\n/**\n * Sorts the content into \"male\", \"female\" and \"all\" taking into consideration the body shape.\n * All contains the item thumbnail and both male and female representations according to the shape.\n * If the body representation is male, \"female\" will be an empty object and viceversa.\n * @param bodyShape - The body shaped used to sort the content.\n * @param contents - The contents to be sorted.\n */\n\nfunction sortContent(bodyShape, contents) {\n  var male = bodyShape === types_1.WearableBodyShape.MALE ? prefixContents(types_1.WearableBodyShape.MALE, contents) : {};\n  var female = bodyShape === types_1.WearableBodyShape.FEMALE ? prefixContents(types_1.WearableBodyShape.FEMALE, contents) : {};\n\n  var all = _objectSpread(_defineProperty({}, constants_1.THUMBNAIL_PATH, contents[constants_1.THUMBNAIL_PATH]), male, female);\n\n  return {\n    male: male,\n    female: female,\n    all: all\n  };\n}\n\nexports.sortContent = sortContent;\n/**\n * Creates a new contents record with the names of the contents blobs record prefixed.\n * The names need to be prefixed so they won't collide with other\n * pre-uploaded models. The name of the content is the name of the uploaded file.\n * @param bodyShape - The body shaped used to prefix the content names.\n * @param contents - The contents which keys are going to be prefixed.\n */\n\nfunction prefixContents(bodyShape, contents) {\n  return Object.keys(contents).reduce(function (newContents, key) {\n    // Do not include the thumbnail in each of the body shapes\n    if (key === constants_1.THUMBNAIL_PATH) {\n      return newContents;\n    }\n\n    newContents[prefixContentName(bodyShape, key)] = contents[key];\n    return newContents;\n  }, {});\n}","map":null,"metadata":{},"sourceType":"script"}