{"ast":null,"code":"import { getURNProtocol, Network } from '@dcl/schemas';\nimport { getChainIdByNetwork } from 'decentraland-dapps/dist/lib/eth';\n/**\n * urn:decentraland:\n *   (?<protocol>\n *     mainnet|\n *     ropsten|\n *     matic|\n *     mumbai|\n *     off-chain\n *   ):\n *   (\n *     (?<type>\n *       base-avatars|\n *       collections-v2|\n *       collections-thirdparty\n *     ):\n *     (?<suffix>\n *       ((?<=base-avatars:)BaseMale|BaseFemale)|\n *       ((?<=collections-v2)0x[a-fA-F0-9]{40})|\n *       ((?<=collections-thirdparty:)\n *          (?<thirdPartyName>[^:|\\\\s]+)\n *          (:(?<thirdPartyCollectionId>[^:|\\\\s]+))?\n *          (:(?<thirdPartyTokenId>[^:|\\\\s]+))?\n *       )\n *     )\n *   )\n */\n\nvar baseMatcher = 'urn:decentraland';\nvar protocolMatcher = '(?<protocol>mainnet|ropsten|matic|mumbai|off-chain)';\nvar typeMatcher = '(?<type>base-avatars|collections-v2|collections-thirdparty)';\nvar baseAvatarsSuffixMatcher = '((?<=base-avatars:)BaseMale|BaseFemale)';\nvar collectionsSuffixMatcher = '((?<=collections-v2:)(?<collectionAddress>0x[a-fA-F0-9]{40}))(:(?<tokenId>[^:|\\\\s]+))?';\nvar thirdPartySuffixMatcher = '((?<=collections-thirdparty:)(?<thirdPartyName>[^:|\\\\s]+)(:(?<thirdPartyCollectionId>[^:|\\\\s]+))?(:(?<thirdPartyTokenId>[^:|\\\\s]+))?)';\nvar urnRegExp = new RegExp(\"\".concat(baseMatcher, \":\").concat(protocolMatcher, \":\").concat(typeMatcher, \":(?<suffix>\").concat(baseAvatarsSuffixMatcher, \"|\").concat(collectionsSuffixMatcher, \"|\").concat(thirdPartySuffixMatcher, \")\"));\nexport var URNProtocol;\n\n(function (URNProtocol) {\n  URNProtocol[\"MAINNET\"] = \"mainnet\";\n  URNProtocol[\"ROPSTEN\"] = \"ropsten\";\n  URNProtocol[\"MATIC\"] = \"matic\";\n  URNProtocol[\"MUMBAI\"] = \"mumbai\";\n  URNProtocol[\"OFF_CHAIN\"] = \"off-chain\";\n})(URNProtocol || (URNProtocol = {}));\n\nexport var URNType;\n\n(function (URNType) {\n  URNType[\"BASE_AVATARS\"] = \"base-avatars\";\n  URNType[\"COLLECTIONS_V2\"] = \"collections-v2\";\n  URNType[\"COLLECTIONS_THIRDPARTY\"] = \"collections-thirdparty\";\n})(URNType || (URNType = {}));\n\nexport function buildThirdPartyURN(thirdPartyName, collectionId, tokenId) {\n  var urn = \"urn:decentraland:\".concat(getNetworkURNProtocol(Network.MATIC), \":collections-thirdparty:\").concat(thirdPartyName, \":\").concat(collectionId);\n\n  if (tokenId) {\n    urn += \":\".concat(tokenId);\n  }\n\n  return urn;\n}\nexport function buildCatalystItemURN(contractAddress, tokenId) {\n  return \"urn:decentraland:\".concat(getNetworkURNProtocol(Network.MATIC), \":collections-v2:\").concat(contractAddress, \":\").concat(tokenId);\n}\nexport function buildDefaultCatalystCollectionURN() {\n  return \"urn:decentraland:\".concat(getNetworkURNProtocol(Network.MATIC), \":collections-v2:0x0000000000000000000000000000000000000000\");\n}\nexport function extractThirdPartyId(urn) {\n  var decodedURN = decodeURN(urn);\n\n  if (decodedURN.type !== URNType.COLLECTIONS_THIRDPARTY) {\n    throw new Error('URN is not a third party URN');\n  }\n\n  return \"urn:decentraland:\".concat(decodedURN.protocol, \":collections-thirdparty:\").concat(decodedURN.thirdPartyName);\n}\nexport function extractThirdPartyTokenId(urn) {\n  var decodedURN = decodeURN(urn);\n\n  if (decodedURN.type !== URNType.COLLECTIONS_THIRDPARTY) {\n    throw new Error(\"Tried to build a third party token for a non third party URN \\\"\".concat(urn, \"\\\"\"));\n  }\n\n  var thirdPartyCollectionId = decodedURN.thirdPartyCollectionId,\n      thirdPartyTokenId = decodedURN.thirdPartyTokenId;\n  return \"\".concat(thirdPartyCollectionId, \":\").concat(thirdPartyTokenId);\n} // TODO: This logic is repeated in collection/util's `getCollectionType`, but being used only for items (item.urn).\n// It should probably be replaced by a getItemType or we should see if it's better to only keep one way of doing this\n\nexport function isThirdParty(urn) {\n  if (!urn) {\n    return false;\n  }\n\n  var decodedURN = decodeURN(urn);\n  return decodedURN.type === URNType.COLLECTIONS_THIRDPARTY;\n}\nexport function decodeURN(urn) {\n  var matches = urnRegExp.exec(urn);\n\n  if (!matches || !matches.groups) {\n    throw new Error(\"Invalid URN: \\\"\".concat(urn, \"\\\"\"));\n  }\n\n  return matches.groups;\n}\n\nfunction getNetworkURNProtocol(network) {\n  return getURNProtocol(getChainIdByNetwork(network));\n}","map":{"version":3,"sources":["/opt/work/NZ_test/src/lib/urn.ts"],"names":["getURNProtocol","Network","getChainIdByNetwork","baseMatcher","protocolMatcher","typeMatcher","baseAvatarsSuffixMatcher","collectionsSuffixMatcher","thirdPartySuffixMatcher","urnRegExp","RegExp","URNProtocol","URNType","buildThirdPartyURN","thirdPartyName","collectionId","tokenId","urn","getNetworkURNProtocol","MATIC","buildCatalystItemURN","contractAddress","buildDefaultCatalystCollectionURN","extractThirdPartyId","decodedURN","decodeURN","type","COLLECTIONS_THIRDPARTY","Error","protocol","extractThirdPartyTokenId","thirdPartyCollectionId","thirdPartyTokenId","isThirdParty","matches","exec","groups","network"],"mappings":"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","sourcesContent":["import { getURNProtocol, Network } from '@dcl/schemas'\nimport { getChainIdByNetwork } from 'decentraland-dapps/dist/lib/eth'\n\n/**\n * urn:decentraland:\n *   (?<protocol>\n *     mainnet|\n *     ropsten|\n *     matic|\n *     mumbai|\n *     off-chain\n *   ):\n *   (\n *     (?<type>\n *       base-avatars|\n *       collections-v2|\n *       collections-thirdparty\n *     ):\n *     (?<suffix>\n *       ((?<=base-avatars:)BaseMale|BaseFemale)|\n *       ((?<=collections-v2)0x[a-fA-F0-9]{40})|\n *       ((?<=collections-thirdparty:)\n *          (?<thirdPartyName>[^:|\\\\s]+)\n *          (:(?<thirdPartyCollectionId>[^:|\\\\s]+))?\n *          (:(?<thirdPartyTokenId>[^:|\\\\s]+))?\n *       )\n *     )\n *   )\n */\nconst baseMatcher = 'urn:decentraland'\nconst protocolMatcher = '(?<protocol>mainnet|ropsten|matic|mumbai|off-chain)'\nconst typeMatcher = '(?<type>base-avatars|collections-v2|collections-thirdparty)'\n\nconst baseAvatarsSuffixMatcher = '((?<=base-avatars:)BaseMale|BaseFemale)'\nconst collectionsSuffixMatcher = '((?<=collections-v2:)(?<collectionAddress>0x[a-fA-F0-9]{40}))(:(?<tokenId>[^:|\\\\s]+))?'\nconst thirdPartySuffixMatcher =\n  '((?<=collections-thirdparty:)(?<thirdPartyName>[^:|\\\\s]+)(:(?<thirdPartyCollectionId>[^:|\\\\s]+))?(:(?<thirdPartyTokenId>[^:|\\\\s]+))?)'\n\nconst urnRegExp = new RegExp(\n  `${baseMatcher}:${protocolMatcher}:${typeMatcher}:(?<suffix>${baseAvatarsSuffixMatcher}|${collectionsSuffixMatcher}|${thirdPartySuffixMatcher})`\n)\n\nexport enum URNProtocol {\n  MAINNET = 'mainnet',\n  ROPSTEN = 'ropsten',\n  MATIC = 'matic',\n  MUMBAI = 'mumbai',\n  OFF_CHAIN = 'off-chain'\n}\nexport enum URNType {\n  BASE_AVATARS = 'base-avatars',\n  COLLECTIONS_V2 = 'collections-v2',\n  COLLECTIONS_THIRDPARTY = 'collections-thirdparty'\n}\nexport type URN = string\n\ntype BaseDecodedURN = {\n  protocol: URNProtocol\n  suffix: string\n}\ntype BaseAvatarURN = { type: URNType.BASE_AVATARS }\ntype CollectionsV2URN = { type: URNType.COLLECTIONS_V2; collectionAddress: string; tokenId?: string }\ntype CollectionThirdPartyURN = {\n  type: URNType.COLLECTIONS_THIRDPARTY\n  thirdPartyName: string\n  thirdPartyCollectionId?: string\n  thirdPartyTokenId?: string\n}\nexport type DecodedURN<T extends URNType = any> = BaseDecodedURN &\n  (T extends URNType.BASE_AVATARS\n    ? BaseAvatarURN\n    : T extends URNType.COLLECTIONS_V2\n    ? CollectionsV2URN\n    : T extends URNType.COLLECTIONS_THIRDPARTY\n    ? CollectionThirdPartyURN\n    : BaseAvatarURN | CollectionsV2URN | CollectionThirdPartyURN)\n\nexport function buildThirdPartyURN(thirdPartyName: string, collectionId: string, tokenId?: string) {\n  let urn = `urn:decentraland:${getNetworkURNProtocol(Network.MATIC)}:collections-thirdparty:${thirdPartyName}:${collectionId}`\n  if (tokenId) {\n    urn += `:${tokenId}`\n  }\n  return urn\n}\n\nexport function buildCatalystItemURN(contractAddress: string, tokenId: string): URN {\n  return `urn:decentraland:${getNetworkURNProtocol(Network.MATIC)}:collections-v2:${contractAddress}:${tokenId}`\n}\n\nexport function buildDefaultCatalystCollectionURN() {\n  return `urn:decentraland:${getNetworkURNProtocol(Network.MATIC)}:collections-v2:0x0000000000000000000000000000000000000000`\n}\n\nexport function extractThirdPartyId(urn: URN): string {\n  const decodedURN = decodeURN(urn)\n  if (decodedURN.type !== URNType.COLLECTIONS_THIRDPARTY) {\n    throw new Error('URN is not a third party URN')\n  }\n\n  return `urn:decentraland:${decodedURN.protocol}:collections-thirdparty:${decodedURN.thirdPartyName}`\n}\n\nexport function extractThirdPartyTokenId(urn: URN) {\n  const decodedURN = decodeURN(urn)\n  if (decodedURN.type !== URNType.COLLECTIONS_THIRDPARTY) {\n    throw new Error(`Tried to build a third party token for a non third party URN \"${urn}\"`)\n  }\n\n  const { thirdPartyCollectionId, thirdPartyTokenId } = decodedURN\n  return `${thirdPartyCollectionId}:${thirdPartyTokenId}`\n}\n\n// TODO: This logic is repeated in collection/util's `getCollectionType`, but being used only for items (item.urn).\n// It should probably be replaced by a getItemType or we should see if it's better to only keep one way of doing this\nexport function isThirdParty(urn?: string) {\n  if (!urn) {\n    return false\n  }\n\n  const decodedURN = decodeURN(urn)\n  return decodedURN.type === URNType.COLLECTIONS_THIRDPARTY\n}\n\nexport function decodeURN(urn: URN): DecodedURN {\n  const matches = urnRegExp.exec(urn)\n\n  if (!matches || !matches.groups) {\n    throw new Error(`Invalid URN: \"${urn}\"`)\n  }\n\n  return matches.groups as DecodedURN\n}\n\nfunction getNetworkURNProtocol(network: Network) {\n  return getURNProtocol(getChainIdByNetwork(network))\n}\n"]},"metadata":{},"sourceType":"module"}