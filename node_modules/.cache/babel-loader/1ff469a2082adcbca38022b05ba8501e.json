{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Tools } from \"../../Misc/tools\";\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\n\nvar FreeCameraTouchInput =\n/** @class */\nfunction () {\n  /**\r\n   * Manage the touch inputs to control the movement of a free camera.\r\n   * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n   * @param allowMouse Defines if mouse events can be treated as touch events\r\n   */\n  function FreeCameraTouchInput(\n  /**\r\n   * Define if mouse events can be treated as touch events\r\n   */\n  allowMouse) {\n    if (allowMouse === void 0) {\n      allowMouse = false;\n    }\n\n    this.allowMouse = allowMouse;\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\n\n    this.touchAngularSensibility = 200000.0;\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\n\n    this.touchMoveSensibility = 250.0;\n    this._offsetX = null;\n    this._offsetY = null;\n    this._pointerPressed = new Array();\n  }\n  /**\r\n   * Attach the input controls to a specific dom element to get the input from.\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n\n  FreeCameraTouchInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this;\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    var previousPosition = null;\n\n    if (this._pointerInput === undefined) {\n      this._onLostFocus = function () {\n        _this._offsetX = null;\n        _this._offsetY = null;\n      };\n\n      this._pointerInput = function (p) {\n        var evt = p.event;\n        var isMouseEvent = !_this.camera.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;\n\n        if (!_this.allowMouse && (evt.pointerType === \"mouse\" || isMouseEvent)) {\n          return;\n        }\n\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          _this._pointerPressed.push(evt.pointerId);\n\n          if (_this._pointerPressed.length !== 1) {\n            return;\n          }\n\n          previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n        } else if (p.type === PointerEventTypes.POINTERUP) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          var index = _this._pointerPressed.indexOf(evt.pointerId);\n\n          if (index === -1) {\n            return;\n          }\n\n          _this._pointerPressed.splice(index, 1);\n\n          if (index != 0) {\n            return;\n          }\n\n          previousPosition = null;\n          _this._offsetX = null;\n          _this._offsetY = null;\n        } else if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          if (!previousPosition) {\n            return;\n          }\n\n          var index = _this._pointerPressed.indexOf(evt.pointerId);\n\n          if (index != 0) {\n            return;\n          }\n\n          _this._offsetX = evt.clientX - previousPosition.x;\n          _this._offsetY = -(evt.clientY - previousPosition.y);\n        }\n      };\n    }\n\n    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n\n    if (this._onLostFocus) {\n      var engine = this.camera.getEngine();\n      var element = engine.getInputElement();\n      element && element.addEventListener(\"blur\", this._onLostFocus);\n    }\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  FreeCameraTouchInput.prototype.detachControl = function (ignored) {\n    if (this._pointerInput) {\n      if (this._observer) {\n        this.camera.getScene().onPointerObservable.remove(this._observer);\n        this._observer = null;\n      }\n\n      if (this._onLostFocus) {\n        var engine = this.camera.getEngine();\n        var element = engine.getInputElement();\n        element && element.removeEventListener(\"blur\", this._onLostFocus);\n        this._onLostFocus = null;\n      }\n\n      this._pointerPressed = [];\n      this._offsetX = null;\n      this._offsetY = null;\n    }\n  };\n  /**\r\n   * Update the current camera state depending on the inputs that have been used this frame.\r\n   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n   */\n\n\n  FreeCameraTouchInput.prototype.checkInputs = function () {\n    if (this._offsetX === null || this._offsetY === null) {\n      return;\n    }\n\n    if (this._offsetX === 0 && this._offsetY === 0) {\n      return;\n    }\n\n    var camera = this.camera;\n    camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\n\n    if (this._pointerPressed.length > 1) {\n      camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\n    } else {\n      var speed = camera._computeLocalCameraSpeed();\n\n      var direction = new Vector3(0, 0, speed * this._offsetY / this.touchMoveSensibility);\n      Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\n      camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\n    }\n  };\n  /**\r\n   * Gets the class name of the current intput.\r\n   * @returns the class name\r\n   */\n\n\n  FreeCameraTouchInput.prototype.getClassName = function () {\n    return \"FreeCameraTouchInput\";\n  };\n  /**\r\n   * Get the friendly name associated with the input class.\r\n   * @returns the input friendly name\r\n   */\n\n\n  FreeCameraTouchInput.prototype.getSimpleName = function () {\n    return \"touch\";\n  };\n\n  __decorate([serialize()], FreeCameraTouchInput.prototype, \"touchAngularSensibility\", void 0);\n\n  __decorate([serialize()], FreeCameraTouchInput.prototype, \"touchMoveSensibility\", void 0);\n\n  return FreeCameraTouchInput;\n}();\n\nexport { FreeCameraTouchInput };\nCameraInputTypes[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;","map":null,"metadata":{},"sourceType":"module"}