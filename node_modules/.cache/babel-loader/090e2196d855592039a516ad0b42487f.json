{"ast":null,"code":"import { Color4 } from '../Maths/math.color';\n/** Class used to store color4 gradient */\n\nvar ColorGradient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new color4 gradient\r\n   * @param gradient gets or sets the gradient value (between 0 and 1)\r\n   * @param color1 gets or sets first associated color\r\n   * @param color2 gets or sets first second color\r\n   */\n  function ColorGradient(\n  /**\r\n   * Gets or sets the gradient value (between 0 and 1)\r\n   */\n  gradient,\n  /**\r\n   * Gets or sets first associated color\r\n   */\n  color1,\n  /**\r\n   * Gets or sets second associated color\r\n   */\n  color2) {\n    this.gradient = gradient;\n    this.color1 = color1;\n    this.color2 = color2;\n  }\n  /**\r\n   * Will get a color picked randomly between color1 and color2.\r\n   * If color2 is undefined then color1 will be used\r\n   * @param result defines the target Color4 to store the result in\r\n   */\n\n\n  ColorGradient.prototype.getColorToRef = function (result) {\n    if (!this.color2) {\n      result.copyFrom(this.color1);\n      return;\n    }\n\n    Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\n  };\n\n  return ColorGradient;\n}();\n\nexport { ColorGradient };\n/** Class used to store color 3 gradient */\n\nvar Color3Gradient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new color3 gradient\r\n   * @param gradient gets or sets the gradient value (between 0 and 1)\r\n   * @param color gets or sets associated color\r\n   */\n  function Color3Gradient(\n  /**\r\n   * Gets or sets the gradient value (between 0 and 1)\r\n   */\n  gradient,\n  /**\r\n   * Gets or sets the associated color\r\n   */\n  color) {\n    this.gradient = gradient;\n    this.color = color;\n  }\n\n  return Color3Gradient;\n}();\n\nexport { Color3Gradient };\n/** Class used to store factor gradient */\n\nvar FactorGradient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new factor gradient\r\n   * @param gradient gets or sets the gradient value (between 0 and 1)\r\n   * @param factor1 gets or sets first associated factor\r\n   * @param factor2 gets or sets second associated factor\r\n   */\n  function FactorGradient(\n  /**\r\n   * Gets or sets the gradient value (between 0 and 1)\r\n   */\n  gradient,\n  /**\r\n   * Gets or sets first associated factor\r\n   */\n  factor1,\n  /**\r\n   * Gets or sets second associated factor\r\n   */\n  factor2) {\n    this.gradient = gradient;\n    this.factor1 = factor1;\n    this.factor2 = factor2;\n  }\n  /**\r\n   * Will get a number picked randomly between factor1 and factor2.\r\n   * If factor2 is undefined then factor1 will be used\r\n   * @returns the picked number\r\n   */\n\n\n  FactorGradient.prototype.getFactor = function () {\n    if (this.factor2 === undefined || this.factor2 === this.factor1) {\n      return this.factor1;\n    }\n\n    return this.factor1 + (this.factor2 - this.factor1) * Math.random();\n  };\n\n  return FactorGradient;\n}();\n\nexport { FactorGradient };\n/**\r\n * Helper used to simplify some generic gradient tasks\r\n */\n\nvar GradientHelper =\n/** @class */\nfunction () {\n  function GradientHelper() {}\n  /**\r\n   * Gets the current gradient from an array of IValueGradient\r\n   * @param ratio defines the current ratio to get\r\n   * @param gradients defines the array of IValueGradient\r\n   * @param updateFunc defines the callback function used to get the final value from the selected gradients\r\n   */\n\n\n  GradientHelper.GetCurrentGradient = function (ratio, gradients, updateFunc) {\n    // Use last index if over\n    if (gradients[0].gradient > ratio) {\n      updateFunc(gradients[0], gradients[0], 1.0);\n      return;\n    }\n\n    for (var gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\n      var currentGradient = gradients[gradientIndex];\n      var nextGradient = gradients[gradientIndex + 1];\n\n      if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\n        var scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\n        updateFunc(currentGradient, nextGradient, scale);\n        return;\n      }\n    } // Use last index if over\n\n\n    var lastIndex = gradients.length - 1;\n    updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\n  };\n\n  return GradientHelper;\n}();\n\nexport { GradientHelper };","map":null,"metadata":{},"sourceType":"module"}