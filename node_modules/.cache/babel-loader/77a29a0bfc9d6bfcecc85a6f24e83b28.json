{"ast":null,"code":"import _regeneratorRuntime from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { hashV1 } from '@dcl/hashing';\nimport { getContentsStorageUrl } from 'lib/api/builder';\nimport { NO_CACHE_HEADERS } from 'lib/headers';\n\nvar toBuffer = require('blob-to-buffer');\n\nexport var FILE_NAME_BLACKLIST = ['.dclignore', 'Dockerfile', 'builder.json', 'src/game.ts'];\nexport function computeHashes(_x) {\n  return _computeHashes.apply(this, arguments);\n}\n\nfunction _computeHashes() {\n  _computeHashes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(contents) {\n    var contentsAsHashes, path, blob, blobBuffer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            contentsAsHashes = {};\n            _context.t0 = _regeneratorRuntime.keys(contents);\n\n          case 2:\n            if ((_context.t1 = _context.t0()).done) {\n              _context.next = 13;\n              break;\n            }\n\n            path = _context.t1.value;\n            blob = contents[path];\n            _context.next = 7;\n            return blob.arrayBuffer();\n\n          case 7:\n            blobBuffer = _context.sent;\n            _context.next = 10;\n            return hashV1(new Uint8Array(blobBuffer));\n\n          case 10:\n            contentsAsHashes[path] = _context.sent;\n            _context.next = 2;\n            break;\n\n          case 13:\n            return _context.abrupt(\"return\", contentsAsHashes);\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _computeHashes.apply(this, arguments);\n}\n\nexport function computeHashFromContent(_x2) {\n  return _computeHashFromContent.apply(this, arguments);\n}\n\nfunction _computeHashFromContent() {\n  _computeHashFromContent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(content) {\n    var file;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return makeContentFile('', content);\n\n          case 2:\n            file = _context2.sent;\n            return _context2.abrupt(\"return\", hashV1(file.content));\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _computeHashFromContent.apply(this, arguments);\n}\n\nexport function makeContentFiles(_x3) {\n  return _makeContentFiles.apply(this, arguments);\n}\n\nfunction _makeContentFiles() {\n  _makeContentFiles = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(files) {\n    var makeRequests, _i, _Object$keys, fileName, isEmpty, contentFiles;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            makeRequests = [];\n            _i = 0, _Object$keys = Object.keys(files);\n\n          case 2:\n            if (!(_i < _Object$keys.length)) {\n              _context3.next = 11;\n              break;\n            }\n\n            fileName = _Object$keys[_i];\n            isEmpty = files[fileName] instanceof Blob && files[fileName].size === 0; // skip empty blobs, it breaks the catalyst\n\n            if (!(FILE_NAME_BLACKLIST.includes(fileName) || isEmpty)) {\n              _context3.next = 7;\n              break;\n            }\n\n            return _context3.abrupt(\"continue\", 8);\n\n          case 7:\n            makeRequests.push(makeContentFile(fileName, files[fileName]));\n\n          case 8:\n            _i++;\n            _context3.next = 2;\n            break;\n\n          case 11:\n            _context3.next = 13;\n            return Promise.all(makeRequests);\n\n          case 13:\n            contentFiles = _context3.sent;\n            return _context3.abrupt(\"return\", new Map(contentFiles.map(function (_ref) {\n              var name = _ref.name,\n                  content = _ref.content;\n              return [name, content];\n            })));\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _makeContentFiles.apply(this, arguments);\n}\n\nexport function makeContentFile(path, content) {\n  return new Promise(function (resolve, reject) {\n    if (typeof content === 'string') {\n      var buffer = Buffer.from(content);\n      resolve({\n        name: path,\n        content: buffer\n      });\n    } else if (content instanceof Blob) {\n      toBuffer(content, function (err, buffer) {\n        if (err) reject(err);\n        resolve({\n          name: path,\n          content: buffer\n        });\n      });\n    } else {\n      reject(new Error('Unable to create ContentFile: content must be a string or a Blob'));\n    }\n  });\n}\nexport function reHashContent(_x4, _x5) {\n  return _reHashContent.apply(this, arguments);\n}\n\nfunction _reHashContent() {\n  _reHashContent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(oldHash, filePath) {\n    var blob, file;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return fetch(getContentsStorageUrl(oldHash), {\n              headers: NO_CACHE_HEADERS\n            }).then(function (resp) {\n              return resp.blob();\n            });\n\n          case 2:\n            blob = _context4.sent;\n            _context4.next = 5;\n            return makeContentFile(filePath, blob);\n\n          case 5:\n            file = _context4.sent;\n            return _context4.abrupt(\"return\", hashV1(file.content));\n\n          case 7:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _reHashContent.apply(this, arguments);\n}","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/deployment/contentUtils.ts"],"names":["hashV1","getContentsStorageUrl","NO_CACHE_HEADERS","toBuffer","require","FILE_NAME_BLACKLIST","computeHashes","contents","contentsAsHashes","path","blob","arrayBuffer","blobBuffer","Uint8Array","computeHashFromContent","content","makeContentFile","file","makeContentFiles","files","makeRequests","Object","keys","fileName","isEmpty","Blob","size","includes","push","Promise","all","contentFiles","Map","map","name","resolve","reject","buffer","Buffer","from","err","Error","reHashContent","oldHash","filePath","fetch","headers","then","resp"],"mappings":"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","sourcesContent":["import { hashV1 } from '@dcl/hashing'\nimport { getContentsStorageUrl } from 'lib/api/builder'\nimport { NO_CACHE_HEADERS } from 'lib/headers'\nconst toBuffer = require('blob-to-buffer')\n\nexport const FILE_NAME_BLACKLIST = ['.dclignore', 'Dockerfile', 'builder.json', 'src/game.ts']\n\nexport async function computeHashes(contents: Record<string, Blob>): Promise<Record<string, string>> {\n  const contentsAsHashes: Record<string, string> = {}\n  for (const path in contents) {\n    const blob = contents[path]\n    const blobBuffer = await blob.arrayBuffer()\n    contentsAsHashes[path] = await hashV1(new Uint8Array(blobBuffer))\n  }\n  return contentsAsHashes\n}\n\nexport async function computeHashFromContent(content: Blob): Promise<string> {\n  const file = await makeContentFile('', content)\n  return hashV1(file.content)\n}\n\nexport async function makeContentFiles(files: Record<string, string | Blob>): Promise<Map<string, Buffer>> {\n  const makeRequests: Promise<{ name: string; content: Buffer }>[] = []\n  for (const fileName of Object.keys(files)) {\n    const isEmpty = files[fileName] instanceof Blob && (files[fileName] as Blob).size === 0 // skip empty blobs, it breaks the catalyst\n    if (FILE_NAME_BLACKLIST.includes(fileName) || isEmpty) continue\n    makeRequests.push(makeContentFile(fileName, files[fileName]))\n  }\n\n  const contentFiles: { name: string; content: Buffer }[] = await Promise.all(makeRequests)\n  return new Map(contentFiles.map(({ name, content }) => [name, content]))\n}\n\nexport function makeContentFile(path: string, content: string | Blob): Promise<{ name: string; content: Buffer }> {\n  return new Promise((resolve, reject) => {\n    if (typeof content === 'string') {\n      const buffer = Buffer.from(content)\n      resolve({ name: path, content: buffer })\n    } else if (content instanceof Blob) {\n      toBuffer(content, (err: Error, buffer: Buffer) => {\n        if (err) reject(err)\n        resolve({ name: path, content: buffer })\n      })\n    } else {\n      reject(new Error('Unable to create ContentFile: content must be a string or a Blob'))\n    }\n  })\n}\n\nexport async function reHashContent(oldHash: string, filePath: string): Promise<string> {\n  const blob = await fetch(getContentsStorageUrl(oldHash), { headers: NO_CACHE_HEADERS }).then(resp => resp.blob())\n  const file = await makeContentFile(filePath, blob)\n  return hashV1(file.content)\n}\n"]},"metadata":{},"sourceType":"module"}