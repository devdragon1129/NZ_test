{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Observable } from \"./observable\";\n/**\r\n * Defines the root class used to create scene optimization to use with SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar SceneOptimization =\n/** @class */\nfunction () {\n  /**\r\n   * Creates the SceneOptimization object\r\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n   * @param desc defines the description associated with the optimization\r\n   */\n  function SceneOptimization(\n  /**\r\n   * Defines the priority of this optimization (0 by default which means first in the list)\r\n   */\n  priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this.priority = priority;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @returns description string\r\n   */\n\n\n  SceneOptimization.prototype.getDescription = function () {\n    return \"\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  SceneOptimization.prototype.apply = function (scene, optimizer) {\n    return true;\n  };\n\n  return SceneOptimization;\n}();\n\nexport { SceneOptimization };\n/**\r\n * Defines an optimization used to reduce the size of render target textures\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar TextureOptimization =\n/** @class */\nfunction (_super) {\n  __extends(TextureOptimization, _super);\n  /**\r\n   * Creates the TextureOptimization object\r\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n   * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n   * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n   */\n\n\n  function TextureOptimization(\n  /**\r\n   * Defines the priority of this optimization (0 by default which means first in the list)\r\n   */\n  priority,\n  /**\r\n   * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n   */\n  maximumSize,\n  /**\r\n   * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n   */\n  step) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (maximumSize === void 0) {\n      maximumSize = 1024;\n    }\n\n    if (step === void 0) {\n      step = 0.5;\n    }\n\n    var _this = _super.call(this, priority) || this;\n\n    _this.priority = priority;\n    _this.maximumSize = maximumSize;\n    _this.step = step;\n    return _this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @returns description string\r\n   */\n\n\n  TextureOptimization.prototype.getDescription = function () {\n    return \"Reducing render target texture size to \" + this.maximumSize;\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  TextureOptimization.prototype.apply = function (scene, optimizer) {\n    var allDone = true;\n\n    for (var index = 0; index < scene.textures.length; index++) {\n      var texture = scene.textures[index];\n\n      if (!texture.canRescale || texture.getContext) {\n        continue;\n      }\n\n      var currentSize = texture.getSize();\n      var maxDimension = Math.max(currentSize.width, currentSize.height);\n\n      if (maxDimension > this.maximumSize) {\n        texture.scale(this.step);\n        allDone = false;\n      }\n    }\n\n    return allDone;\n  };\n\n  return TextureOptimization;\n}(SceneOptimization);\n\nexport { TextureOptimization };\n/**\r\n * Defines an optimization used to increase or decrease the rendering resolution\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar HardwareScalingOptimization =\n/** @class */\nfunction (_super) {\n  __extends(HardwareScalingOptimization, _super);\n  /**\r\n   * Creates the HardwareScalingOptimization object\r\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n   * @param maximumScale defines the maximum scale to use (2 by default)\r\n   * @param step defines the step to use between two passes (0.5 by default)\r\n   */\n\n\n  function HardwareScalingOptimization(\n  /**\r\n   * Defines the priority of this optimization (0 by default which means first in the list)\r\n   */\n  priority,\n  /**\r\n   * Defines the maximum scale to use (2 by default)\r\n   */\n  maximumScale,\n  /**\r\n   * Defines the step to use between two passes (0.5 by default)\r\n   */\n  step) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (maximumScale === void 0) {\n      maximumScale = 2;\n    }\n\n    if (step === void 0) {\n      step = 0.25;\n    }\n\n    var _this = _super.call(this, priority) || this;\n\n    _this.priority = priority;\n    _this.maximumScale = maximumScale;\n    _this.step = step;\n    _this._currentScale = -1;\n    _this._directionOffset = 1;\n    return _this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  HardwareScalingOptimization.prototype.getDescription = function () {\n    return \"Setting hardware scaling level to \" + this._currentScale;\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  HardwareScalingOptimization.prototype.apply = function (scene, optimizer) {\n    if (this._currentScale === -1) {\n      this._currentScale = scene.getEngine().getHardwareScalingLevel();\n\n      if (this._currentScale > this.maximumScale) {\n        this._directionOffset = -1;\n      }\n    }\n\n    this._currentScale += this._directionOffset * this.step;\n    scene.getEngine().setHardwareScalingLevel(this._currentScale);\n    return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\n  };\n\n  return HardwareScalingOptimization;\n}(SceneOptimization);\n\nexport { HardwareScalingOptimization };\n/**\r\n * Defines an optimization used to remove shadows\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar ShadowsOptimization =\n/** @class */\nfunction (_super) {\n  __extends(ShadowsOptimization, _super);\n\n  function ShadowsOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  ShadowsOptimization.prototype.getDescription = function () {\n    return \"Turning shadows on/off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  ShadowsOptimization.prototype.apply = function (scene, optimizer) {\n    scene.shadowsEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return ShadowsOptimization;\n}(SceneOptimization);\n\nexport { ShadowsOptimization };\n/**\r\n * Defines an optimization used to turn post-processes off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar PostProcessesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(PostProcessesOptimization, _super);\n\n  function PostProcessesOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  PostProcessesOptimization.prototype.getDescription = function () {\n    return \"Turning post-processes on/off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  PostProcessesOptimization.prototype.apply = function (scene, optimizer) {\n    scene.postProcessesEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return PostProcessesOptimization;\n}(SceneOptimization);\n\nexport { PostProcessesOptimization };\n/**\r\n * Defines an optimization used to turn lens flares off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar LensFlaresOptimization =\n/** @class */\nfunction (_super) {\n  __extends(LensFlaresOptimization, _super);\n\n  function LensFlaresOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  LensFlaresOptimization.prototype.getDescription = function () {\n    return \"Turning lens flares on/off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  LensFlaresOptimization.prototype.apply = function (scene, optimizer) {\n    scene.lensFlaresEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return LensFlaresOptimization;\n}(SceneOptimization);\n\nexport { LensFlaresOptimization };\n/**\r\n * Defines an optimization based on user defined callback.\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar CustomOptimization =\n/** @class */\nfunction (_super) {\n  __extends(CustomOptimization, _super);\n\n  function CustomOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @returns description string\r\n   */\n\n\n  CustomOptimization.prototype.getDescription = function () {\n    if (this.onGetDescription) {\n      return this.onGetDescription();\n    }\n\n    return \"Running user defined callback\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  CustomOptimization.prototype.apply = function (scene, optimizer) {\n    if (this.onApply) {\n      return this.onApply(scene, optimizer);\n    }\n\n    return true;\n  };\n\n  return CustomOptimization;\n}(SceneOptimization);\n\nexport { CustomOptimization };\n/**\r\n * Defines an optimization used to turn particles off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar ParticlesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(ParticlesOptimization, _super);\n\n  function ParticlesOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  ParticlesOptimization.prototype.getDescription = function () {\n    return \"Turning particles on/off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  ParticlesOptimization.prototype.apply = function (scene, optimizer) {\n    scene.particlesEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return ParticlesOptimization;\n}(SceneOptimization);\n\nexport { ParticlesOptimization };\n/**\r\n * Defines an optimization used to turn render targets off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar RenderTargetsOptimization =\n/** @class */\nfunction (_super) {\n  __extends(RenderTargetsOptimization, _super);\n\n  function RenderTargetsOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  RenderTargetsOptimization.prototype.getDescription = function () {\n    return \"Turning render targets off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  RenderTargetsOptimization.prototype.apply = function (scene, optimizer) {\n    scene.renderTargetsEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return RenderTargetsOptimization;\n}(SceneOptimization);\n\nexport { RenderTargetsOptimization };\n/**\r\n * Defines an optimization used to merge meshes with compatible materials\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar MergeMeshesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(MergeMeshesOptimization, _super);\n\n  function MergeMeshesOptimization() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._canBeMerged = function (abstractMesh) {\n      if (!(abstractMesh instanceof Mesh)) {\n        return false;\n      }\n\n      var mesh = abstractMesh;\n\n      if (mesh.isDisposed()) {\n        return false;\n      }\n\n      if (!mesh.isVisible || !mesh.isEnabled()) {\n        return false;\n      }\n\n      if (mesh.instances.length > 0) {\n        return false;\n      }\n\n      if (mesh.skeleton || mesh.hasLODLevels) {\n        return false;\n      }\n\n      return true;\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(MergeMeshesOptimization, \"UpdateSelectionTree\", {\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\n    get: function get() {\n      return MergeMeshesOptimization._UpdateSelectionTree;\n    },\n\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\n    set: function set(value) {\n      MergeMeshesOptimization._UpdateSelectionTree = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n  MergeMeshesOptimization.prototype.getDescription = function () {\n    return \"Merging similar meshes together\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  MergeMeshesOptimization.prototype.apply = function (scene, optimizer, updateSelectionTree) {\n    var globalPool = scene.meshes.slice(0);\n    var globalLength = globalPool.length;\n\n    for (var index = 0; index < globalLength; index++) {\n      var currentPool = new Array();\n      var current = globalPool[index]; // Checks\n\n      if (!this._canBeMerged(current)) {\n        continue;\n      }\n\n      currentPool.push(current); // Find compatible meshes\n\n      for (var subIndex = index + 1; subIndex < globalLength; subIndex++) {\n        var otherMesh = globalPool[subIndex];\n\n        if (!this._canBeMerged(otherMesh)) {\n          continue;\n        }\n\n        if (otherMesh.material !== current.material) {\n          continue;\n        }\n\n        if (otherMesh.checkCollisions !== current.checkCollisions) {\n          continue;\n        }\n\n        currentPool.push(otherMesh);\n        globalLength--;\n        globalPool.splice(subIndex, 1);\n        subIndex--;\n      }\n\n      if (currentPool.length < 2) {\n        continue;\n      } // Merge meshes\n\n\n      Mesh.MergeMeshes(currentPool, undefined, true);\n    } // Call the octree system optimization if it is defined.\n\n\n    var sceneAsAny = scene;\n\n    if (sceneAsAny.createOrUpdateSelectionOctree) {\n      if (updateSelectionTree != undefined) {\n        if (updateSelectionTree) {\n          sceneAsAny.createOrUpdateSelectionOctree();\n        }\n      } else if (MergeMeshesOptimization.UpdateSelectionTree) {\n        sceneAsAny.createOrUpdateSelectionOctree();\n      }\n    }\n\n    return true;\n  };\n\n  MergeMeshesOptimization._UpdateSelectionTree = false;\n  return MergeMeshesOptimization;\n}(SceneOptimization);\n\nexport { MergeMeshesOptimization };\n/**\r\n * Defines a list of options used by SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar SceneOptimizerOptions =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new list of options used by SceneOptimizer\r\n   * @param targetFrameRate defines the target frame rate to reach (60 by default)\r\n   * @param trackerDuration defines the interval between two checkes (2000ms by default)\r\n   */\n  function SceneOptimizerOptions(\n  /**\r\n   * Defines the target frame rate to reach (60 by default)\r\n   */\n  targetFrameRate,\n  /**\r\n   * Defines the interval between two checkes (2000ms by default)\r\n   */\n  trackerDuration) {\n    if (targetFrameRate === void 0) {\n      targetFrameRate = 60;\n    }\n\n    if (trackerDuration === void 0) {\n      trackerDuration = 2000;\n    }\n\n    this.targetFrameRate = targetFrameRate;\n    this.trackerDuration = trackerDuration;\n    /**\r\n     * Gets the list of optimizations to apply\r\n     */\n\n    this.optimizations = new Array();\n  }\n  /**\r\n   * Add a new optimization\r\n   * @param optimization defines the SceneOptimization to add to the list of active optimizations\r\n   * @returns the current SceneOptimizerOptions\r\n   */\n\n\n  SceneOptimizerOptions.prototype.addOptimization = function (optimization) {\n    this.optimizations.push(optimization);\n    return this;\n  };\n  /**\r\n   * Add a new custom optimization\r\n   * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\r\n   * @param onGetDescription defines the callback called to get the description attached with the optimization.\r\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n   * @returns the current SceneOptimizerOptions\r\n   */\n\n\n  SceneOptimizerOptions.prototype.addCustomOptimization = function (onApply, onGetDescription, priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    var optimization = new CustomOptimization(priority);\n    optimization.onApply = onApply;\n    optimization.onGetDescription = onGetDescription;\n    this.optimizations.push(optimization);\n    return this;\n  };\n  /**\r\n   * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\r\n   * @param targetFrameRate defines the target frame rate (60 by default)\r\n   * @returns a SceneOptimizerOptions object\r\n   */\n\n\n  SceneOptimizerOptions.LowDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 1024));\n    return result;\n  };\n  /**\r\n   * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\r\n   * @param targetFrameRate defines the target frame rate (60 by default)\r\n   * @returns a SceneOptimizerOptions object\r\n   */\n\n\n  SceneOptimizerOptions.ModerateDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 512)); // Next priority\n\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 2));\n    return result;\n  };\n  /**\r\n   * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\r\n   * @param targetFrameRate defines the target frame rate (60 by default)\r\n   * @returns a SceneOptimizerOptions object\r\n   */\n\n\n  SceneOptimizerOptions.HighDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 256)); // Next priority\n\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 4));\n    return result;\n  };\n\n  return SceneOptimizerOptions;\n}();\n\nexport { SceneOptimizerOptions };\n/**\r\n * Class used to run optimizations in order to reach a target frame rate\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar SceneOptimizer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new SceneOptimizer\r\n   * @param scene defines the scene to work on\r\n   * @param options defines the options to use with the SceneOptimizer\r\n   * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\r\n   * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\r\n   */\n  function SceneOptimizer(scene, options, autoGeneratePriorities, improvementMode) {\n    var _this = this;\n\n    if (autoGeneratePriorities === void 0) {\n      autoGeneratePriorities = true;\n    }\n\n    if (improvementMode === void 0) {\n      improvementMode = false;\n    }\n\n    this._isRunning = false;\n    this._currentPriorityLevel = 0;\n    this._targetFrameRate = 60;\n    this._trackerDuration = 2000;\n    this._currentFrameRate = 0;\n    this._improvementMode = false;\n    /**\r\n     * Defines an observable called when the optimizer reaches the target frame rate\r\n     */\n\n    this.onSuccessObservable = new Observable();\n    /**\r\n     * Defines an observable called when the optimizer enables an optimization\r\n     */\n\n    this.onNewOptimizationAppliedObservable = new Observable();\n    /**\r\n     * Defines an observable called when the optimizer is not able to reach the target frame rate\r\n     */\n\n    this.onFailureObservable = new Observable();\n\n    if (!options) {\n      this._options = new SceneOptimizerOptions();\n    } else {\n      this._options = options;\n    }\n\n    if (this._options.targetFrameRate) {\n      this._targetFrameRate = this._options.targetFrameRate;\n    }\n\n    if (this._options.trackerDuration) {\n      this._trackerDuration = this._options.trackerDuration;\n    }\n\n    if (autoGeneratePriorities) {\n      var priority = 0;\n\n      for (var _i = 0, _a = this._options.optimizations; _i < _a.length; _i++) {\n        var optim = _a[_i];\n        optim.priority = priority++;\n      }\n    }\n\n    this._improvementMode = improvementMode;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function () {\n      _this._sceneDisposeObserver = null;\n\n      _this.dispose();\n    });\n  }\n\n  Object.defineProperty(SceneOptimizer.prototype, \"isInImprovementMode\", {\n    /**\r\n     * Gets a boolean indicating if the optimizer is in improvement mode\r\n     */\n    get: function get() {\n      return this._improvementMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"currentPriorityLevel\", {\n    /**\r\n     * Gets the current priority level (0 at start)\r\n     */\n    get: function get() {\n      return this._currentPriorityLevel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"currentFrameRate\", {\n    /**\r\n     * Gets the current frame rate checked by the SceneOptimizer\r\n     */\n    get: function get() {\n      return this._currentFrameRate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"targetFrameRate\", {\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\n    get: function get() {\n      return this._targetFrameRate;\n    },\n\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\n    set: function set(value) {\n      this._targetFrameRate = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"trackerDuration\", {\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\n    get: function get() {\n      return this._trackerDuration;\n    },\n\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\n    set: function set(value) {\n      this._trackerDuration = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"optimizations\", {\n    /**\r\n     * Gets the list of active optimizations\r\n     */\n    get: function get() {\n      return this._options.optimizations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Stops the current optimizer\r\n   */\n\n  SceneOptimizer.prototype.stop = function () {\n    this._isRunning = false;\n  };\n  /**\r\n   * Reset the optimizer to initial step (current priority level = 0)\r\n   */\n\n\n  SceneOptimizer.prototype.reset = function () {\n    this._currentPriorityLevel = 0;\n  };\n  /**\r\n   * Start the optimizer. By default it will try to reach a specific framerate\r\n   * but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate\r\n   */\n\n\n  SceneOptimizer.prototype.start = function () {\n    var _this = this;\n\n    if (this._isRunning) {\n      return;\n    }\n\n    this._isRunning = true; // Let's wait for the scene to be ready before running our check\n\n    this._scene.executeWhenReady(function () {\n      setTimeout(function () {\n        _this._checkCurrentState();\n      }, _this._trackerDuration);\n    });\n  };\n\n  SceneOptimizer.prototype._checkCurrentState = function () {\n    var _this = this;\n\n    if (!this._isRunning) {\n      return;\n    }\n\n    var scene = this._scene;\n    var options = this._options;\n    this._currentFrameRate = Math.round(scene.getEngine().getFps());\n\n    if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {\n      this._isRunning = false;\n      this.onSuccessObservable.notifyObservers(this);\n      return;\n    } // Apply current level of optimizations\n\n\n    var allDone = true;\n    var noOptimizationApplied = true;\n\n    for (var index = 0; index < options.optimizations.length; index++) {\n      var optimization = options.optimizations[index];\n\n      if (optimization.priority === this._currentPriorityLevel) {\n        noOptimizationApplied = false;\n        allDone = allDone && optimization.apply(scene, this);\n        this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\n      }\n    } // If no optimization was applied, this is a failure :(\n\n\n    if (noOptimizationApplied) {\n      this._isRunning = false;\n      this.onFailureObservable.notifyObservers(this);\n      return;\n    } // If all optimizations were done, move to next level\n\n\n    if (allDone) {\n      this._currentPriorityLevel++;\n    } // Let's the system running for a specific amount of time before checking FPS\n\n\n    scene.executeWhenReady(function () {\n      setTimeout(function () {\n        _this._checkCurrentState();\n      }, _this._trackerDuration);\n    });\n  };\n  /**\r\n   * Release all resources\r\n   */\n\n\n  SceneOptimizer.prototype.dispose = function () {\n    this.stop();\n    this.onSuccessObservable.clear();\n    this.onFailureObservable.clear();\n    this.onNewOptimizationAppliedObservable.clear();\n\n    if (this._sceneDisposeObserver) {\n      this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n  };\n  /**\r\n   * Helper function to create a SceneOptimizer with one single line of code\r\n   * @param scene defines the scene to work on\r\n   * @param options defines the options to use with the SceneOptimizer\r\n   * @param onSuccess defines a callback to call on success\r\n   * @param onFailure defines a callback to call on failure\r\n   * @returns the new SceneOptimizer object\r\n   */\n\n\n  SceneOptimizer.OptimizeAsync = function (scene, options, onSuccess, onFailure) {\n    var optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\n\n    if (onSuccess) {\n      optimizer.onSuccessObservable.add(function () {\n        onSuccess();\n      });\n    }\n\n    if (onFailure) {\n      optimizer.onFailureObservable.add(function () {\n        onFailure();\n      });\n    }\n\n    optimizer.start();\n    return optimizer;\n  };\n\n  return SceneOptimizer;\n}();\n\nexport { SceneOptimizer };","map":null,"metadata":{},"sourceType":"module"}