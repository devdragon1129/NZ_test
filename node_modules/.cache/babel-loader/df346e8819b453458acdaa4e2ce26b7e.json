{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\nimport \"../../Engines/Extensions/engine.multiRender\";\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\n\nvar MultiRenderTarget =\n/** @class */\nfunction (_super) {\n  __extends(MultiRenderTarget, _super);\n  /**\r\n   * Instantiate a new multi render target texture.\r\n   * A multi render target, like a render target provides the ability to render to a texture.\r\n   * Unlike the render target, it can render to several draw buffers in one draw.\r\n   * This is specially interesting in deferred rendering or for any effects requiring more than\r\n   * just one color from a single pass.\r\n   * @param name Define the name of the texture\r\n   * @param size Define the size of the buffers to render to\r\n   * @param count Define the number of target we are rendering into\r\n   * @param scene Define the scene the texture belongs to\r\n   * @param options Define the options used to create the multi render target\r\n   */\n\n\n  function MultiRenderTarget(name, size, count, scene, options) {\n    var _this = this;\n\n    var generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\n    var generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\n    var doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n    _this = _super.call(this, name, size, scene, generateMipMaps, doNotChangeAspectRatio) || this;\n\n    if (!_this.isSupported) {\n      _this.dispose();\n\n      return;\n    }\n\n    var types = [];\n    var samplingModes = [];\n\n    _this._initTypes(count, types, samplingModes, options);\n\n    var generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    var generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    _this._size = size;\n    _this._multiRenderTargetOptions = {\n      samplingModes: samplingModes,\n      generateMipMaps: generateMipMaps,\n      generateDepthBuffer: generateDepthBuffer,\n      generateStencilBuffer: generateStencilBuffer,\n      generateDepthTexture: generateDepthTexture,\n      types: types,\n      textureCount: count\n    };\n    _this._count = count;\n\n    _this._createInternalTextures();\n\n    _this._createTextures();\n\n    return _this;\n  }\n\n  Object.defineProperty(MultiRenderTarget.prototype, \"isSupported\", {\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\n    get: function get() {\n      return this._getEngine().webGLVersion > 1 || this._getEngine().getCaps().drawBuffersExtension;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"textures\", {\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\n    get: function get() {\n      return this._textures;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"count\", {\n    /**\r\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\r\n     */\n    get: function get() {\n      return this._count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"depthTexture\", {\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\n    get: function get() {\n      return this._textures[this._textures.length - 1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"wrapU\", {\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\n    set: function set(wrap) {\n      if (this._textures) {\n        for (var i = 0; i < this._textures.length; i++) {\n          this._textures[i].wrapU = wrap;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"wrapV\", {\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\n    set: function set(wrap) {\n      if (this._textures) {\n        for (var i = 0; i < this._textures.length; i++) {\n          this._textures[i].wrapV = wrap;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MultiRenderTarget.prototype._initTypes = function (count, types, samplingModes, options) {\n    for (var i = 0; i < count; i++) {\n      if (options && options.types && options.types[i] !== undefined) {\n        types.push(options.types[i]);\n      } else {\n        types.push(options && options.defaultType ? options.defaultType : 0);\n      }\n\n      if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\n        samplingModes.push(options.samplingModes[i]);\n      } else {\n        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  MultiRenderTarget.prototype._rebuild = function (forceFullRebuild) {\n    if (forceFullRebuild === void 0) {\n      forceFullRebuild = false;\n    }\n\n    this.releaseInternalTextures();\n\n    this._createInternalTextures();\n\n    if (forceFullRebuild) {\n      this._createTextures();\n    }\n\n    for (var i = 0; i < this._internalTextures.length; i++) {\n      var texture = this._textures[i];\n      texture._texture = this._internalTextures[i];\n    } // Keeps references to frame buffer and stencil/depth buffer\n\n\n    this._texture = this._internalTextures[0];\n\n    if (this.samples !== 1) {\n      this._getEngine().updateMultipleRenderTargetTextureSampleCount(this._internalTextures, this.samples);\n    }\n  };\n\n  MultiRenderTarget.prototype._createInternalTextures = function () {\n    this._internalTextures = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions);\n  };\n\n  MultiRenderTarget.prototype._createTextures = function () {\n    this._textures = [];\n\n    for (var i = 0; i < this._internalTextures.length; i++) {\n      var texture = new Texture(null, this.getScene());\n      texture._texture = this._internalTextures[i];\n\n      this._textures.push(texture);\n    } // Keeps references to frame buffer and stencil/depth buffer\n\n\n    this._texture = this._internalTextures[0];\n  };\n  /**\r\n   * Replaces a texture within the MRT.\r\n   * @param texture The new texture to insert in the MRT\r\n   * @param index The index of the texture to replace\r\n   */\n\n\n  MultiRenderTarget.prototype.replaceTexture = function (texture, index) {\n    if (texture._texture) {\n      this._textures[index] = texture;\n      this._internalTextures[index] = texture._texture;\n    }\n  };\n\n  Object.defineProperty(MultiRenderTarget.prototype, \"samples\", {\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\n    get: function get() {\n      return this._samples;\n    },\n    set: function set(value) {\n      if (this._samples === value) {\n        return;\n      }\n\n      this._samples = this._getEngine().updateMultipleRenderTargetTextureSampleCount(this._internalTextures, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resize all the textures in the multi render target.\r\n   * Be careful as it will recreate all the data in the new texture.\r\n   * @param size Define the new size\r\n   */\n\n  MultiRenderTarget.prototype.resize = function (size) {\n    this._size = size;\n\n    this._rebuild();\n  };\n  /**\r\n   * Changes the number of render targets in this MRT\r\n   * Be careful as it will recreate all the data in the new texture.\r\n   * @param count new texture count\r\n   * @param options Specifies texture types and sampling modes for new textures\r\n   */\n\n\n  MultiRenderTarget.prototype.updateCount = function (count, options) {\n    this._multiRenderTargetOptions.textureCount = count;\n    this._count = count;\n    var types = [];\n    var samplingModes = [];\n\n    this._initTypes(count, types, samplingModes, options);\n\n    this._multiRenderTargetOptions.types = types;\n    this._multiRenderTargetOptions.samplingModes = samplingModes;\n\n    this._rebuild(true);\n  };\n\n  MultiRenderTarget.prototype.unbindFrameBuffer = function (engine, faceIndex) {\n    var _this = this;\n\n    engine.unBindMultiColorAttachmentFramebuffer(this._internalTextures, this.isCube, function () {\n      _this.onAfterRenderObservable.notifyObservers(faceIndex);\n    });\n  };\n  /**\r\n   * Dispose the render targets and their associated resources\r\n   */\n\n\n  MultiRenderTarget.prototype.dispose = function () {\n    this.releaseInternalTextures();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Release all the underlying texture used as draw buffers.\r\n   */\n\n\n  MultiRenderTarget.prototype.releaseInternalTextures = function () {\n    if (!this._internalTextures) {\n      return;\n    }\n\n    for (var i = this._internalTextures.length - 1; i >= 0; i--) {\n      if (this._internalTextures[i] !== undefined) {\n        this._internalTextures[i].dispose();\n\n        this._internalTextures.splice(i, 1);\n      }\n    }\n  };\n\n  return MultiRenderTarget;\n}(RenderTargetTexture);\n\nexport { MultiRenderTarget };","map":null,"metadata":{},"sourceType":"module"}