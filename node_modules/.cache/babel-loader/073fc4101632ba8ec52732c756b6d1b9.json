{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { PostProcess } from \"./postProcess\";\nimport { GeometryBufferRenderer } from '../Rendering/geometryBufferRenderer';\nimport { serialize, SerializationHelper } from '../Misc/decorators';\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration\";\nimport \"../Shaders/screenSpaceReflection.fragment\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\r\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\r\n */\n\nvar ScreenSpaceReflectionPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(ScreenSpaceReflectionPostProcess, _super);\n  /**\r\n   * Creates a new instance of ScreenSpaceReflectionPostProcess.\r\n   * @param name The name of the effect.\r\n   * @param scene The scene containing the objects to calculate reflections.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass.\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   * @param textureType Type of textures used when performing the post process. (default: 0)\r\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n   */\n\n\n  function ScreenSpaceReflectionPostProcess(name, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation, forceGeometryBuffer) {\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (forceGeometryBuffer === void 0) {\n      forceGeometryBuffer = true;\n    }\n\n    var _this = _super.call(this, name, \"screenSpaceReflection\", [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"step\", \"roughnessFactor\"], [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"], options, camera, samplingMode, engine, reusable, \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\", textureType, undefined, null, blockCompilation) || this;\n    /**\r\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\r\n     */\n\n\n    _this.threshold = 1.2;\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\r\n     */\n\n    _this.strength = 1;\n    /**\r\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\r\n     */\n\n    _this.reflectionSpecularFalloffExponent = 3;\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\r\n     */\n\n    _this.step = 1.0;\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     */\n\n    _this.roughnessFactor = 0.2;\n    _this._forceGeometryBuffer = false;\n    _this._enableSmoothReflections = false;\n    _this._reflectionSamples = 64;\n    _this._smoothSteps = 5;\n    _this._forceGeometryBuffer = forceGeometryBuffer;\n\n    if (_this._forceGeometryBuffer) {\n      // Get geometry buffer renderer and update effect\n      var geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n\n      if (geometryBufferRenderer) {\n        if (geometryBufferRenderer.isSupported) {\n          geometryBufferRenderer.enablePosition = true;\n          geometryBufferRenderer.enableReflectivity = true;\n          _this._geometryBufferRenderer = geometryBufferRenderer;\n        }\n      }\n    } else {\n      _this._prePassRenderer = scene.enablePrePassRenderer();\n\n      _this._prePassRenderer.markAsDirty();\n\n      _this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\n    }\n\n    _this._updateEffectDefines(); // On apply, send uniforms\n\n\n    _this.onApply = function (effect) {\n      var geometryBufferRenderer = _this._geometryBufferRenderer;\n      var prePassRenderer = _this._prePassRenderer;\n\n      if (!prePassRenderer && !geometryBufferRenderer) {\n        return;\n      }\n\n      if (geometryBufferRenderer) {\n        // Samplers\n        var positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        var roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\n        effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\n        effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\n      } else {\n        // Samplers\n        var positionIndex = prePassRenderer.getIndex(1);\n        var roughnessIndex = prePassRenderer.getIndex(3);\n        var normalIndex = prePassRenderer.getIndex(5);\n        effect.setTexture(\"normalSampler\", prePassRenderer.prePassRT.textures[normalIndex]);\n        effect.setTexture(\"positionSampler\", prePassRenderer.prePassRT.textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", prePassRenderer.prePassRT.textures[roughnessIndex]);\n      } // Uniforms\n\n\n      var camera = scene.activeCamera;\n\n      if (!camera) {\n        return;\n      }\n\n      var viewMatrix = camera.getViewMatrix();\n      var projectionMatrix = camera.getProjectionMatrix();\n      effect.setMatrix(\"projection\", projectionMatrix);\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setFloat(\"threshold\", _this.threshold);\n      effect.setFloat(\"reflectionSpecularFalloffExponent\", _this.reflectionSpecularFalloffExponent);\n      effect.setFloat(\"strength\", _this.strength);\n      effect.setFloat(\"step\", _this.step);\n      effect.setFloat(\"roughnessFactor\", _this.roughnessFactor);\n    };\n\n    return _this;\n  }\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"ScreenSpaceReflectionPostProcess\" string\r\n   */\n\n\n  ScreenSpaceReflectionPostProcess.prototype.getClassName = function () {\n    return \"ScreenSpaceReflectionPostProcess\";\n  };\n\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", {\n    /**\r\n     * Gets wether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\n    get: function get() {\n      return this._enableSmoothReflections;\n    },\n\n    /**\r\n     * Sets wether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\n    set: function set(enabled) {\n      if (enabled === this._enableSmoothReflections) {\n        return;\n      }\n\n      this._enableSmoothReflections = enabled;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", {\n    /**\r\n     * Gets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\n    get: function get() {\n      return this._reflectionSamples;\n    },\n\n    /**\r\n     * Sets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\n    set: function set(samples) {\n      if (samples === this._reflectionSamples) {\n        return;\n      }\n\n      this._reflectionSamples = samples;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", {\n    /**\r\n     * Gets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\n    get: function get() {\n      return this._smoothSteps;\n    },\n\n    /*\r\n     * Sets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\n    set: function set(steps) {\n      if (steps === this._smoothSteps) {\n        return;\n      }\n\n      this._smoothSteps = steps;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ScreenSpaceReflectionPostProcess.prototype._updateEffectDefines = function () {\n    var defines = [];\n\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      defines.push(\"#define SSR_SUPPORTED\");\n\n      if (this._prePassRenderer) {\n        defines.push(\"#define PREPASS_LAYOUT\");\n      }\n    }\n\n    if (this._enableSmoothReflections) {\n      defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\n    }\n\n    defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\n    defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\n    this.updateEffect(defines.join(\"\\n\"));\n  };\n  /** @hidden */\n\n\n  ScreenSpaceReflectionPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new ScreenSpaceReflectionPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"threshold\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"strength\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSpecularFalloffExponent\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"step\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"roughnessFactor\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", null);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", null);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", null);\n\n  return ScreenSpaceReflectionPostProcess;\n}(PostProcess);\n\nexport { ScreenSpaceReflectionPostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.ScreenSpaceReflectionPostProcess\"] = ScreenSpaceReflectionPostProcess;","map":null,"metadata":{},"sourceType":"module"}