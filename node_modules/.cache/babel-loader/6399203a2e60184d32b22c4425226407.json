{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { InputBlock } from '../Input/inputBlock';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction\";\nimport { CubeTexture } from '../../../Textures/cubeTexture';\nimport { Texture } from '../../../Textures/texture';\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\n\nvar ReflectionTextureBaseBlock =\n/** @class */\nfunction (_super) {\n  __extends(ReflectionTextureBaseBlock, _super);\n  /**\r\n   * Create a new ReflectionTextureBaseBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function ReflectionTextureBaseBlock(name) {\n    return _super.call(this, name, NodeMaterialBlockTargets.VertexAndFragment) || this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.getClassName = function () {\n    return \"ReflectionTextureBaseBlock\";\n  };\n\n  ReflectionTextureBaseBlock.prototype._getTexture = function () {\n    return this.texture;\n  };\n\n  ReflectionTextureBaseBlock.prototype.autoConfigure = function (material) {\n    if (!this.position.isConnected) {\n      var positionInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"position\";\n      });\n\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n\n      positionInput.output.connectTo(this.position);\n    }\n\n    if (!this.world.isConnected) {\n      var worldInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.World;\n      });\n\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n\n      worldInput.output.connectTo(this.world);\n    }\n\n    if (this.view && !this.view.isConnected) {\n      var viewInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.View;\n      });\n\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n\n      viewInput.output.connectTo(this.view);\n    }\n  };\n\n  ReflectionTextureBaseBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    var texture = this._getTexture();\n\n    if (!texture || !texture.getTextureMatrix) {\n      return;\n    }\n\n    defines.setValue(this._define3DName, texture.isCube, true);\n    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);\n    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\n    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\n    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\n    defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\n    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\n    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\n    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\n    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\n    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\n    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\n  };\n\n  ReflectionTextureBaseBlock.prototype.isReady = function () {\n    var texture = this._getTexture();\n\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ReflectionTextureBaseBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    var texture = this._getTexture();\n\n    if (!mesh || !texture) {\n      return;\n    }\n\n    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\n\n    if (texture.isCube) {\n      effect.setTexture(this._cubeSamplerName, texture);\n    } else {\n      effect.setTexture(this._2DSamplerName, texture);\n    }\n  };\n  /**\r\n   * Gets the code to inject in the vertex shader\r\n   * @param state current state of the node material building\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleVertexSide = function (state) {\n    this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\n    this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\n    this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\n    this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\n    this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\n    this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\n    this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n    this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\n    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n    this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n    this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\n    this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\n    this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\n\n    state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\n\n    var code = \"\";\n    var worldPosVaryingName = \"v_\" + this.worldPosition.associatedVariableName;\n\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      code += worldPosVaryingName + \" = \" + this.worldPosition.associatedVariableName + \";\\r\\n\";\n    }\n\n    this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\n    this._directionWName = state._getFreeVariableName(\"directionW\");\n\n    if (state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\n      code += \"#ifdef \" + this._defineSkyboxName + \"\\r\\n\";\n      code += this._positionUVWName + \" = \" + this.position.associatedVariableName + \".xyz;\\r\\n\";\n      code += \"#endif\\r\\n\";\n    }\n\n    if (state._emitVaryingFromString(this._directionWName, \"vec3\", \"defined(\" + this._defineEquirectangularFixedName + \") || defined(\" + this._defineMirroredEquirectangularFixedName + \")\")) {\n      code += \"#if defined(\" + this._defineEquirectangularFixedName + \") || defined(\" + this._defineMirroredEquirectangularFixedName + \")\\r\\n\";\n      code += this._directionWName + \" = normalize(vec3(\" + this.world.associatedVariableName + \" * vec4(\" + this.position.associatedVariableName + \".xyz, 0.0)));\\r\\n\";\n      code += \"#endif\\r\\n\";\n    }\n\n    return code;\n  };\n  /**\r\n   * Handles the inits for the fragment code path\r\n   * @param state node material build state\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideInits = function (state) {\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this); // Samplers\n\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    state._samplerDeclaration += \"#ifdef \" + this._define3DName + \"\\r\\n\";\n    state._samplerDeclaration += \"uniform samplerCube \" + this._cubeSamplerName + \";\\r\\n\";\n    state._samplerDeclaration += \"#else\\r\\n\";\n    state._samplerDeclaration += \"uniform sampler2D \" + this._2DSamplerName + \";\\r\\n\";\n    state._samplerDeclaration += \"#endif\\r\\n\"; // Fragment\n\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    var comments = \"//\" + this.name;\n\n    state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\n\n    state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\n      replaceStrings: [{\n        search: /vec3 computeReflectionCoords/g,\n        replace: \"void DUMMYFUNC\"\n      }]\n    });\n\n    this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\n    this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\n    this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\n  };\n  /**\r\n   * Generates the reflection coords code for the fragment code path\r\n   * @param worldNormalVarName name of the world normal variable\r\n   * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n   * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideCodeReflectionCoords = function (worldNormalVarName, worldPos, onlyReflectionVector) {\n    if (onlyReflectionVector === void 0) {\n      onlyReflectionVector = false;\n    }\n\n    if (!worldPos) {\n      worldPos = \"v_\" + this.worldPosition.associatedVariableName;\n    }\n\n    var reflectionMatrix = this._reflectionMatrixName;\n    var direction = \"normalize(\" + this._directionWName + \")\";\n    var positionUVW = \"\" + this._positionUVWName;\n    var vEyePosition = \"\" + this.cameraPosition.associatedVariableName;\n    var view = \"\" + this.view.associatedVariableName;\n    worldNormalVarName += \".xyz\";\n    var code = \"\\n            #ifdef \" + this._defineMirroredEquirectangularFixedName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeMirroredFixedEquirectangularCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + direction + \");\\n            #endif\\n\\n            #ifdef \" + this._defineEquirectangularFixedName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeFixedEquirectangularCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + direction + \");\\n            #endif\\n\\n            #ifdef \" + this._defineEquirectangularName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeEquirectangularCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + vEyePosition + \".xyz, \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._defineSphericalName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeSphericalCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + view + \", \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._definePlanarName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computePlanarCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + vEyePosition + \".xyz, \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._defineCubicName + \"\\n                #ifdef \" + this._defineLocalCubicName + \"\\n                    vec3 \" + this._reflectionVectorName + \" = computeCubicLocalCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + vEyePosition + \".xyz, \" + reflectionMatrix + \", vReflectionSize, vReflectionPosition);\\n                #else\\n                vec3 \" + this._reflectionVectorName + \" = computeCubicCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + vEyePosition + \".xyz, \" + reflectionMatrix + \");\\n                #endif\\n            #endif\\n\\n            #ifdef \" + this._defineProjectionName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeProjectionCoords(\" + worldPos + \", \" + view + \", \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._defineSkyboxName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeSkyBoxCoords(\" + positionUVW + \", \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._defineExplicitName + \"\\n                vec3 \" + this._reflectionVectorName + \" = vec3(0, 0, 0);\\n            #endif\\n\\n            #ifdef \" + this._defineOppositeZ + \"\\n                \" + this._reflectionVectorName + \".z *= -1.0;\\n            #endif\\r\\n\";\n\n    if (!onlyReflectionVector) {\n      code += \"\\n                #ifdef \" + this._define3DName + \"\\n                    vec3 \" + this._reflectionCoordsName + \" = \" + this._reflectionVectorName + \";\\n                #else\\n                    vec2 \" + this._reflectionCoordsName + \" = \" + this._reflectionVectorName + \".xy;\\n                    #ifdef \" + this._defineProjectionName + \"\\n                        \" + this._reflectionCoordsName + \" /= \" + this._reflectionVectorName + \".z;\\n                    #endif\\n                    \" + this._reflectionCoordsName + \".y = 1.0 - \" + this._reflectionCoordsName + \".y;\\n                #endif\\r\\n\";\n    }\n\n    return code;\n  };\n  /**\r\n   * Generates the reflection color code for the fragment code path\r\n   * @param lodVarName name of the lod variable\r\n   * @param swizzleLookupTexture swizzle to use for the final color variable\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideCodeReflectionColor = function (lodVarName, swizzleLookupTexture) {\n    if (swizzleLookupTexture === void 0) {\n      swizzleLookupTexture = \".rgb\";\n    }\n\n    var colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\n    var code = colorType + \" \" + this._reflectionColorName + \";\\n            #ifdef \" + this._define3DName + \"\\r\\n\";\n\n    if (lodVarName) {\n      code += this._reflectionColorName + \" = textureCubeLodEXT(\" + this._cubeSamplerName + \", \" + this._reflectionVectorName + \", \" + lodVarName + \")\" + swizzleLookupTexture + \";\\r\\n\";\n    } else {\n      code += this._reflectionColorName + \" = textureCube(\" + this._cubeSamplerName + \", \" + this._reflectionVectorName + \")\" + swizzleLookupTexture + \";\\r\\n\";\n    }\n\n    code += \"\\n            #else\\r\\n\";\n\n    if (lodVarName) {\n      code += this._reflectionColorName + \" = texture2DLodEXT(\" + this._2DSamplerName + \", \" + this._reflectionCoordsName + \", \" + lodVarName + \")\" + swizzleLookupTexture + \";\\r\\n\";\n    } else {\n      code += this._reflectionColorName + \" = texture2D(\" + this._2DSamplerName + \", \" + this._reflectionCoordsName + \")\" + swizzleLookupTexture + \";\\r\\n\";\n    }\n\n    code += \"#endif\\r\\n\";\n    return code;\n  };\n  /**\r\n   * Generates the code corresponding to the connected output points\r\n   * @param state node material build state\r\n   * @param varName name of the variable to output\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.writeOutputs = function (state, varName) {\n    var code = \"\";\n\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n        var output = _a[_i];\n\n        if (output.hasEndpoints) {\n          code += this._declareOutput(output, state) + \" = \" + varName + \".\" + output.name + \";\\r\\n\";\n        }\n      }\n    }\n\n    return code;\n  };\n\n  ReflectionTextureBaseBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    return this;\n  };\n\n  ReflectionTextureBaseBlock.prototype._dumpPropertiesCode = function () {\n    if (!this.texture) {\n      return \"\";\n    }\n\n    var codeString;\n\n    if (this.texture.isCube) {\n      codeString = this._codeVariableName + \".texture = new BABYLON.CubeTexture(\\\"\" + this.texture.name + \"\\\");\\r\\n\";\n    } else {\n      codeString = this._codeVariableName + \".texture = new BABYLON.Texture(\\\"\" + this.texture.name + \"\\\");\\r\\n\";\n    }\n\n    codeString += this._codeVariableName + \".texture.coordinatesMode = \" + this.texture.coordinatesMode + \";\\r\\n\";\n    return codeString;\n  };\n\n  ReflectionTextureBaseBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this.texture) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  ReflectionTextureBaseBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n  };\n\n  return ReflectionTextureBaseBlock;\n}(NodeMaterialBlock);\n\nexport { ReflectionTextureBaseBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.ReflectionTextureBaseBlock\"] = ReflectionTextureBaseBlock;","map":null,"metadata":{},"sourceType":"module"}