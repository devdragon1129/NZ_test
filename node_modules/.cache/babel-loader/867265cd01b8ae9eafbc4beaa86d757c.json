{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { GLTFLoaderExtension } from \"./glTFLoader\";\nimport { GLTFLoaderBase } from \"./glTFLoader\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight\";\nimport { GLTFLoader } from \"./glTFLoader\";\n/** @hidden */\n\nvar GLTFMaterialsCommonExtension =\n/** @class */\nfunction (_super) {\n  __extends(GLTFMaterialsCommonExtension, _super);\n\n  function GLTFMaterialsCommonExtension() {\n    return _super.call(this, \"KHR_materials_common\") || this;\n  }\n\n  GLTFMaterialsCommonExtension.prototype.loadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {\n    if (!gltfRuntime.extensions) {\n      return false;\n    }\n\n    var extension = gltfRuntime.extensions[this.name];\n\n    if (!extension) {\n      return false;\n    } // Create lights\n\n\n    var lights = extension.lights;\n\n    if (lights) {\n      for (var thing in lights) {\n        var light = lights[thing];\n\n        switch (light.type) {\n          case \"ambient\":\n            var ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\n            var ambient = light.ambient;\n\n            if (ambient) {\n              ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\n            }\n\n            break;\n\n          case \"point\":\n            var pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\n            var point = light.point;\n\n            if (point) {\n              pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\n            }\n\n            break;\n\n          case \"directional\":\n            var dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\n            var directional = light.directional;\n\n            if (directional) {\n              dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\n            }\n\n            break;\n\n          case \"spot\":\n            var spot = light.spot;\n\n            if (spot) {\n              var spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0.0, gltfRuntime.scene);\n              spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\n            }\n\n            break;\n\n          default:\n            Tools.Warn(\"GLTF Material Common extension: light type \\\"\" + light.type + \"\\‚Äù not supported\");\n            break;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  GLTFMaterialsCommonExtension.prototype.loadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {\n    var material = gltfRuntime.materials[id];\n\n    if (!material || !material.extensions) {\n      return false;\n    }\n\n    var extension = material.extensions[this.name];\n\n    if (!extension) {\n      return false;\n    }\n\n    var standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\n    standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n\n    if (extension.technique === \"CONSTANT\") {\n      standardMaterial.disableLighting = true;\n    }\n\n    standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\n    standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\n    standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess; // Ambient\n\n    if (typeof extension.values.ambient === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\n    } else {\n      standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\n    } // Diffuse\n\n\n    if (typeof extension.values.diffuse === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\n    } else {\n      standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\n    } // Emission\n\n\n    if (typeof extension.values.emission === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\n    } else {\n      standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\n    } // Specular\n\n\n    if (typeof extension.values.specular === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\n    } else {\n      standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\n    }\n\n    return true;\n  };\n\n  GLTFMaterialsCommonExtension.prototype._loadTexture = function (gltfRuntime, id, material, propertyPath, onError) {\n    // Create buffer from texture url\n    GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, function (buffer) {\n      // Create texture from buffer\n      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, function (texture) {\n        return material[propertyPath] = texture;\n      }, onError);\n    }, onError);\n  };\n\n  return GLTFMaterialsCommonExtension;\n}(GLTFLoaderExtension);\n\nexport { GLTFMaterialsCommonExtension };\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());","map":null,"metadata":{},"sourceType":"module"}