{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { AbstractScene } from \"../abstractScene\";\n\nAbstractScene.prototype.removeReflectionProbe = function (toRemove) {\n  if (!this.reflectionProbes) {\n    return -1;\n  }\n\n  var index = this.reflectionProbes.indexOf(toRemove);\n\n  if (index !== -1) {\n    this.reflectionProbes.splice(index, 1);\n  }\n\n  return index;\n};\n\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe) {\n  if (!this.reflectionProbes) {\n    this.reflectionProbes = [];\n  }\n\n  this.reflectionProbes.push(newReflectionProbe);\n};\n/**\r\n * Class used to generate realtime reflection / refraction cube textures\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes\r\n */\n\n\nvar ReflectionProbe =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new reflection probe\r\n   * @param name defines the name of the probe\r\n   * @param size defines the texture resolution (for each face)\r\n   * @param scene defines the hosting scene\r\n   * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\r\n   * @param useFloat defines if HDR data (flaot data) should be used to store colors (false by default)\r\n   */\n  function ReflectionProbe(\n  /** defines the name of the probe */\n  name, size, scene, generateMipMaps, useFloat) {\n    var _this = this;\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (useFloat === void 0) {\n      useFloat = false;\n    }\n\n    this.name = name;\n    this._viewMatrix = Matrix.Identity();\n    this._target = Vector3.Zero();\n    this._add = Vector3.Zero();\n    this._invertYAxis = false;\n    /** Gets or sets probe position (center of the cube map) */\n\n    this.position = Vector3.Zero();\n    this._scene = scene; // Create the scene field if not exist.\n\n    if (!this._scene.reflectionProbes) {\n      this._scene.reflectionProbes = new Array();\n    }\n\n    this._scene.reflectionProbes.push(this);\n\n    var textureType = 0;\n\n    if (useFloat) {\n      var caps = this._scene.getEngine().getCaps();\n\n      if (caps.textureHalfFloatRender) {\n        textureType = 2;\n      } else if (caps.textureFloatRender) {\n        textureType = 1;\n      }\n    }\n\n    this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\n\n    this._renderTargetTexture.onBeforeRenderObservable.add(function (faceIndex) {\n      switch (faceIndex) {\n        case 0:\n          _this._add.copyFromFloats(1, 0, 0);\n\n          break;\n\n        case 1:\n          _this._add.copyFromFloats(-1, 0, 0);\n\n          break;\n\n        case 2:\n          _this._add.copyFromFloats(0, _this._invertYAxis ? 1 : -1, 0);\n\n          break;\n\n        case 3:\n          _this._add.copyFromFloats(0, _this._invertYAxis ? -1 : 1, 0);\n\n          break;\n\n        case 4:\n          _this._add.copyFromFloats(0, 0, 1);\n\n          break;\n\n        case 5:\n          _this._add.copyFromFloats(0, 0, -1);\n\n          break;\n      }\n\n      if (_this._attachedMesh) {\n        _this.position.copyFrom(_this._attachedMesh.getAbsolutePosition());\n      }\n\n      _this.position.addToRef(_this._add, _this._target);\n\n      Matrix.LookAtLHToRef(_this.position, _this._target, Vector3.Up(), _this._viewMatrix);\n\n      if (scene.activeCamera) {\n        _this._projectionMatrix = Matrix.PerspectiveFovLH(Math.PI / 2, 1, scene.activeCamera.minZ, scene.activeCamera.maxZ);\n        scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);\n      }\n\n      scene._forcedViewPosition = _this.position;\n    });\n\n    this._renderTargetTexture.onAfterUnbindObservable.add(function () {\n      scene._forcedViewPosition = null;\n      scene.updateTransformMatrix(true);\n    });\n  }\n\n  Object.defineProperty(ReflectionProbe.prototype, \"samples\", {\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\n    get: function get() {\n      return this._renderTargetTexture.samples;\n    },\n    set: function set(value) {\n      this._renderTargetTexture.samples = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionProbe.prototype, \"refreshRate\", {\n    /** Gets or sets the refresh rate to use (on every frame by default) */\n    get: function get() {\n      return this._renderTargetTexture.refreshRate;\n    },\n    set: function set(value) {\n      this._renderTargetTexture.refreshRate = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the hosting scene\r\n   * @returns a Scene\r\n   */\n\n  ReflectionProbe.prototype.getScene = function () {\n    return this._scene;\n  };\n\n  Object.defineProperty(ReflectionProbe.prototype, \"cubeTexture\", {\n    /** Gets the internal CubeTexture used to render to */\n    get: function get() {\n      return this._renderTargetTexture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionProbe.prototype, \"renderList\", {\n    /** Gets the list of meshes to render */\n    get: function get() {\n      return this._renderTargetTexture.renderList;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\r\n   * @param mesh defines the mesh to attach to\r\n   */\n\n  ReflectionProbe.prototype.attachToMesh = function (mesh) {\n    this._attachedMesh = mesh;\n  };\n  /**\r\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n   */\n\n\n  ReflectionProbe.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {\n    this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n  };\n  /**\r\n   * Clean all associated resources\r\n   */\n\n\n  ReflectionProbe.prototype.dispose = function () {\n    var index = this._scene.reflectionProbes.indexOf(this);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this._scene.reflectionProbes.splice(index, 1);\n    }\n\n    if (this._renderTargetTexture) {\n      this._renderTargetTexture.dispose();\n\n      this._renderTargetTexture = null;\n    }\n  };\n  /**\r\n   * Converts the reflection probe information to a readable string for debug purpose.\r\n   * @param fullDetails Supports for multiple levels of logging within scene loading\r\n   * @returns the human readable reflection probe info\r\n   */\n\n\n  ReflectionProbe.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n\n    if (fullDetails) {\n      ret += \", position: \" + this.position.toString();\n\n      if (this._attachedMesh) {\n        ret += \", attached mesh: \" + this._attachedMesh.name;\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * Get the class name of the relfection probe.\r\n   * @returns \"ReflectionProbe\"\r\n   */\n\n\n  ReflectionProbe.prototype.getClassName = function () {\n    return \"ReflectionProbe\";\n  };\n  /**\r\n   * Serialize the reflection probe to a JSON representation we can easily use in the resepective Parse function.\r\n   * @returns The JSON representation of the texture\r\n   */\n\n\n  ReflectionProbe.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\n    serializationObject.isReflectionProbe = true;\n    return serializationObject;\n  };\n  /**\r\n   * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\r\n   * @param parsedReflectionProbe Define the JSON representation of the reflection probe\r\n   * @param scene Define the scene the parsed reflection probe should be instantiated in\r\n   * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n   * @returns The parsed reflection probe if successful\r\n   */\n\n\n  ReflectionProbe.Parse = function (parsedReflectionProbe, scene, rootUrl) {\n    var reflectionProbe = null;\n\n    if (scene.reflectionProbes) {\n      for (var index = 0; index < scene.reflectionProbes.length; index++) {\n        var rp = scene.reflectionProbes[index];\n\n        if (rp.name === parsedReflectionProbe.name) {\n          reflectionProbe = rp;\n          break;\n        }\n      }\n    }\n\n    reflectionProbe = SerializationHelper.Parse(function () {\n      return reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps);\n    }, parsedReflectionProbe, scene, rootUrl);\n    reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\n\n    if (parsedReflectionProbe._attachedMesh) {\n      reflectionProbe.attachToMesh(scene.getMeshByID(parsedReflectionProbe._attachedMesh));\n    }\n\n    return reflectionProbe;\n  };\n\n  __decorate([serializeAsMeshReference()], ReflectionProbe.prototype, \"_attachedMesh\", void 0);\n\n  __decorate([serializeAsVector3()], ReflectionProbe.prototype, \"position\", void 0);\n\n  return ReflectionProbe;\n}();\n\nexport { ReflectionProbe };","map":null,"metadata":{},"sourceType":"module"}