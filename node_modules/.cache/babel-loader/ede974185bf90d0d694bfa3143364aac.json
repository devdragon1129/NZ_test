{"ast":null,"code":"import { VertexBuffer } from \"../Meshes/buffer\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Scene } from \"../scene\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport \"../Shaders/outline.fragment\";\nimport \"../Shaders/outline.vertex\";\n/**\r\n * Gets the outline renderer associated with the scene\r\n * @returns a OutlineRenderer\r\n */\n\nScene.prototype.getOutlineRenderer = function () {\n  if (!this._outlineRenderer) {\n    this._outlineRenderer = new OutlineRenderer(this);\n  }\n\n  return this._outlineRenderer;\n};\n\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\n  get: function get() {\n    return this._renderOutline;\n  },\n  set: function set(value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n\n    this._renderOutline = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\n  get: function get() {\n    return this._renderOverlay;\n  },\n  set: function set(value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n\n    this._renderOverlay = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\r\n * This class is responsible to draw bothe outline/overlay of meshes.\r\n * It should not be used directly but through the available method on mesh.\r\n */\n\nvar OutlineRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new outline renderer. (There could be only one per scene).\r\n   * @param scene Defines the scene it belongs to\r\n   */\n  function OutlineRenderer(scene) {\n    /**\r\n     * The name of the component. Each component must have a unique name.\r\n     */\n    this.name = SceneComponentConstants.NAME_OUTLINERENDERER;\n    /**\r\n     * Defines a zOffset to prevent zFighting between the overlay and the mesh.\r\n     */\n\n    this.zOffset = 1;\n    this.scene = scene;\n    this._engine = scene.getEngine();\n\n    this.scene._addComponent(this);\n  }\n  /**\r\n   * Register the component to one instance of a scene.\r\n   */\n\n\n  OutlineRenderer.prototype.register = function () {\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\n\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  OutlineRenderer.prototype.rebuild = function () {// Nothing to do here.\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  OutlineRenderer.prototype.dispose = function () {// Nothing to do here.\n  };\n  /**\r\n   * Renders the outline in the canvas.\r\n   * @param subMesh Defines the sumesh to render\r\n   * @param batch Defines the batch of meshes in case of instances\r\n   * @param useOverlay Defines if the rendering is for the overlay or the outline\r\n   */\n\n\n  OutlineRenderer.prototype.render = function (subMesh, batch, useOverlay) {\n    var _this = this;\n\n    if (useOverlay === void 0) {\n      useOverlay = false;\n    }\n\n    var scene = this.scene;\n    var engine = scene.getEngine();\n    var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || subMesh.getRenderingMesh().hasThinInstances);\n\n    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n      return;\n    }\n\n    var ownerMesh = subMesh.getMesh();\n    var replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\n    var renderingMesh = subMesh.getRenderingMesh();\n    var effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\n    var material = subMesh.getMaterial();\n\n    if (!material || !scene.activeCamera) {\n      return;\n    }\n\n    engine.enableEffect(this._effect); // Logarithmic depth\n\n    if (material.useLogarithmicDepth) {\n      this._effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n    }\n\n    this._effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\n\n    this._effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\n\n    this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n    this._effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix()); // Bones\n\n\n    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n      this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n    } // Morph targets\n\n\n    MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effect);\n\n    renderingMesh._bind(subMesh, this._effect, material.fillMode); // Alpha test\n\n\n    if (material && material.needAlphaTesting()) {\n      var alphaTexture = material.getAlphaTestTexture();\n\n      if (alphaTexture) {\n        this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n\n        this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n      }\n    }\n\n    engine.setZOffset(-this.zOffset);\n\n    renderingMesh._processRendering(effectiveMesh, subMesh, this._effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n      _this._effect.setMatrix(\"world\", world);\n    });\n\n    engine.setZOffset(0);\n  };\n  /**\r\n   * Returns whether or not the outline renderer is ready for a given submesh.\r\n   * All the dependencies e.g. submeshes, texture, effect... mus be ready\r\n   * @param subMesh Defines the submesh to check readyness for\r\n   * @param useInstances Defines wheter wee are trying to render instances or not\r\n   * @returns true if ready otherwise false\r\n   */\n\n\n  OutlineRenderer.prototype.isReady = function (subMesh, useInstances) {\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n    var mesh = subMesh.getMesh();\n    var material = subMesh.getMaterial();\n\n    if (material) {\n      // Alpha test\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          attribs.push(VertexBuffer.UVKind);\n          defines.push(\"#define UV1\");\n        }\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n          attribs.push(VertexBuffer.UV2Kind);\n          defines.push(\"#define UV2\");\n        }\n      } //Logarithmic depth\n\n\n      if (material.useLogarithmicDepth) {\n        defines.push(\"#define LOGARITHMICDEPTH\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var morphTargetManager = mesh.morphTargetManager;\n    var numMorphInfluencers = 0;\n\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effect = this.scene.getEngine().createEffect(\"outline\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\", \"logarithmicDepthConstant\", \"morphTargetInfluences\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      });\n    }\n\n    return this._effect.isReady();\n  };\n\n  OutlineRenderer.prototype._beforeRenderingMesh = function (mesh, subMesh, batch) {\n    // Outline - step 1\n    this._savedDepthWrite = this._engine.getDepthWrite();\n\n    if (mesh.renderOutline) {\n      var material = subMesh.getMaterial();\n\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.cacheStencilState(); // Draw only to stencil buffer for the original mesh\n        // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\n\n\n        this._engine.setDepthWrite(false);\n\n        this._engine.setColorWrite(false);\n\n        this._engine.setStencilBuffer(true);\n\n        this._engine.setStencilOperationPass(7681);\n\n        this._engine.setStencilFunction(519);\n\n        this._engine.setStencilMask(OutlineRenderer._StencilReference);\n\n        this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\n\n        this.render(subMesh, batch,\n        /* This sets offset to 0 */\n        true);\n\n        this._engine.setColorWrite(true);\n\n        this._engine.setStencilFunction(517);\n      } // Draw the outline using the above stencil if needed to avoid drawing within the mesh\n\n\n      this._engine.setDepthWrite(false);\n\n      this.render(subMesh, batch);\n\n      this._engine.setDepthWrite(this._savedDepthWrite);\n\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.restoreStencilState();\n      }\n    }\n  };\n\n  OutlineRenderer.prototype._afterRenderingMesh = function (mesh, subMesh, batch) {\n    // Overlay\n    if (mesh.renderOverlay) {\n      var currentMode = this._engine.getAlphaMode();\n\n      var alphaBlendState = this._engine.alphaState.alphaBlend;\n\n      this._engine.setAlphaMode(2);\n\n      this.render(subMesh, batch, true);\n\n      this._engine.setAlphaMode(currentMode);\n\n      this._engine.setDepthWrite(this._savedDepthWrite);\n\n      this._engine.alphaState.alphaBlend = alphaBlendState;\n    } // Outline - step 2\n\n\n    if (mesh.renderOutline && this._savedDepthWrite) {\n      this._engine.setDepthWrite(true);\n\n      this._engine.setColorWrite(false);\n\n      this.render(subMesh, batch);\n\n      this._engine.setColorWrite(true);\n    }\n  };\n  /**\r\n   * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\r\n   */\n\n\n  OutlineRenderer._StencilReference = 0x04;\n  return OutlineRenderer;\n}();\n\nexport { OutlineRenderer };","map":null,"metadata":{},"sourceType":"module"}