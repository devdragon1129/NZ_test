{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\nimport { Scene } from \"../scene\";\nimport { Camera } from \"../Cameras/camera\";\n/**\r\n * Class representing a ray with position and direction\r\n */\n\nvar Ray =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new ray\r\n   * @param origin origin point\r\n   * @param direction direction\r\n   * @param length length of the ray\r\n   */\n  function Ray(\n  /** origin point */\n  origin,\n  /** direction */\n  direction,\n  /** length of the ray */\n  length) {\n    if (length === void 0) {\n      length = Number.MAX_VALUE;\n    }\n\n    this.origin = origin;\n    this.direction = direction;\n    this.length = length;\n  } // Methods\n\n  /**\r\n   * Checks if the ray intersects a box\r\n   * This does not account for the ray lenght by design to improve perfs.\r\n   * @param minimum bound of the box\r\n   * @param maximum bound of the box\r\n   * @param intersectionTreshold extra extend to be added to the box in all direction\r\n   * @returns if the box was hit\r\n   */\n\n\n  Ray.prototype.intersectsBoxMinMax = function (minimum, maximum, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    var newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\n\n    var newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\n\n    var d = 0.0;\n    var maxValue = Number.MAX_VALUE;\n    var inv;\n    var min;\n    var max;\n    var temp;\n\n    if (Math.abs(this.direction.x) < 0.0000001) {\n      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.x;\n      min = (newMinimum.x - this.origin.x) * inv;\n      max = (newMaximum.x - this.origin.x) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    if (Math.abs(this.direction.y) < 0.0000001) {\n      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.y;\n      min = (newMinimum.y - this.origin.y) * inv;\n      max = (newMaximum.y - this.origin.y) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    if (Math.abs(this.direction.z) < 0.0000001) {\n      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.z;\n      min = (newMinimum.z - this.origin.z) * inv;\n      max = (newMaximum.z - this.origin.z) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks if the ray intersects a box\r\n   * This does not account for the ray lenght by design to improve perfs.\r\n   * @param box the bounding box to check\r\n   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n   * @returns if the box was hit\r\n   */\n\n\n  Ray.prototype.intersectsBox = function (box, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\n  };\n  /**\r\n   * If the ray hits a sphere\r\n   * @param sphere the bounding sphere to check\r\n   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n   * @returns true if it hits the sphere\r\n   */\n\n\n  Ray.prototype.intersectsSphere = function (sphere, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    var x = sphere.center.x - this.origin.x;\n    var y = sphere.center.y - this.origin.y;\n    var z = sphere.center.z - this.origin.z;\n    var pyth = x * x + y * y + z * z;\n    var radius = sphere.radius + intersectionTreshold;\n    var rr = radius * radius;\n\n    if (pyth <= rr) {\n      return true;\n    }\n\n    var dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\n\n    if (dot < 0.0) {\n      return false;\n    }\n\n    var temp = pyth - dot * dot;\n    return temp <= rr;\n  };\n  /**\r\n   * If the ray hits a triange\r\n   * @param vertex0 triangle vertex\r\n   * @param vertex1 triangle vertex\r\n   * @param vertex2 triangle vertex\r\n   * @returns intersection information if hit\r\n   */\n\n\n  Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {\n    var edge1 = Ray._TmpVector3[0];\n    var edge2 = Ray._TmpVector3[1];\n    var pvec = Ray._TmpVector3[2];\n    var tvec = Ray._TmpVector3[3];\n    var qvec = Ray._TmpVector3[4];\n    vertex1.subtractToRef(vertex0, edge1);\n    vertex2.subtractToRef(vertex0, edge2);\n    Vector3.CrossToRef(this.direction, edge2, pvec);\n    var det = Vector3.Dot(edge1, pvec);\n\n    if (det === 0) {\n      return null;\n    }\n\n    var invdet = 1 / det;\n    this.origin.subtractToRef(vertex0, tvec);\n    var bv = Vector3.Dot(tvec, pvec) * invdet;\n\n    if (bv < 0 || bv > 1.0) {\n      return null;\n    }\n\n    Vector3.CrossToRef(tvec, edge1, qvec);\n    var bw = Vector3.Dot(this.direction, qvec) * invdet;\n\n    if (bw < 0 || bv + bw > 1.0) {\n      return null;\n    } //check if the distance is longer than the predefined length.\n\n\n    var distance = Vector3.Dot(edge2, qvec) * invdet;\n\n    if (distance > this.length) {\n      return null;\n    }\n\n    return new IntersectionInfo(1 - bv - bw, bv, distance);\n  };\n  /**\r\n   * Checks if ray intersects a plane\r\n   * @param plane the plane to check\r\n   * @returns the distance away it was hit\r\n   */\n\n\n  Ray.prototype.intersectsPlane = function (plane) {\n    var distance;\n    var result1 = Vector3.Dot(plane.normal, this.direction);\n\n    if (Math.abs(result1) < 9.99999997475243e-7) {\n      return null;\n    } else {\n      var result2 = Vector3.Dot(plane.normal, this.origin);\n      distance = (-plane.d - result2) / result1;\n\n      if (distance < 0.0) {\n        if (distance < -9.99999997475243e-7) {\n          return null;\n        } else {\n          return 0;\n        }\n      }\n\n      return distance;\n    }\n  };\n  /**\r\n   * Calculate the intercept of a ray on a given axis\r\n   * @param axis to check 'x' | 'y' | 'z'\r\n   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n   */\n\n\n  Ray.prototype.intersectsAxis = function (axis, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    switch (axis) {\n      case \"y\":\n        var t = (this.origin.y - offset) / this.direction.y;\n\n        if (t > 0) {\n          return null;\n        }\n\n        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\n\n      case \"x\":\n        var t = (this.origin.x - offset) / this.direction.x;\n\n        if (t > 0) {\n          return null;\n        }\n\n        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\n\n      case \"z\":\n        var t = (this.origin.z - offset) / this.direction.z;\n\n        if (t > 0) {\n          return null;\n        }\n\n        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\n\n      default:\n        return null;\n    }\n  };\n  /**\r\n   * Checks if ray intersects a mesh\r\n   * @param mesh the mesh to check\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @returns picking info of the intersecton\r\n   */\n\n\n  Ray.prototype.intersectsMesh = function (mesh, fastCheck) {\n    var tm = TmpVectors.Matrix[0];\n    mesh.getWorldMatrix().invertToRef(tm);\n\n    if (this._tmpRay) {\n      Ray.TransformToRef(this, tm, this._tmpRay);\n    } else {\n      this._tmpRay = Ray.Transform(this, tm);\n    }\n\n    return mesh.intersects(this._tmpRay, fastCheck);\n  };\n  /**\r\n   * Checks if ray intersects a mesh\r\n   * @param meshes the meshes to check\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param results array to store result in\r\n   * @returns Array of picking infos\r\n   */\n\n\n  Ray.prototype.intersectsMeshes = function (meshes, fastCheck, results) {\n    if (results) {\n      results.length = 0;\n    } else {\n      results = [];\n    }\n\n    for (var i = 0; i < meshes.length; i++) {\n      var pickInfo = this.intersectsMesh(meshes[i], fastCheck);\n\n      if (pickInfo.hit) {\n        results.push(pickInfo);\n      }\n    }\n\n    results.sort(this._comparePickingInfo);\n    return results;\n  };\n\n  Ray.prototype._comparePickingInfo = function (pickingInfoA, pickingInfoB) {\n    if (pickingInfoA.distance < pickingInfoB.distance) {\n      return -1;\n    } else if (pickingInfoA.distance > pickingInfoB.distance) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n  /**\r\n   * Intersection test between the ray and a given segment whithin a given tolerance (threshold)\r\n   * @param sega the first point of the segment to test the intersection against\r\n   * @param segb the second point of the segment to test the intersection against\r\n   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n   * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n   */\n\n\n  Ray.prototype.intersectionSegment = function (sega, segb, threshold) {\n    var o = this.origin;\n    var u = TmpVectors.Vector3[0];\n    var rsegb = TmpVectors.Vector3[1];\n    var v = TmpVectors.Vector3[2];\n    var w = TmpVectors.Vector3[3];\n    segb.subtractToRef(sega, u);\n    this.direction.scaleToRef(Ray.rayl, v);\n    o.addToRef(v, rsegb);\n    sega.subtractToRef(o, w);\n    var a = Vector3.Dot(u, u); // always >= 0\n\n    var b = Vector3.Dot(u, v);\n    var c = Vector3.Dot(v, v); // always >= 0\n\n    var d = Vector3.Dot(u, w);\n    var e = Vector3.Dot(v, w);\n    var D = a * c - b * b; // always >= 0\n\n    var sc,\n        sN,\n        sD = D; // sc = sN / sD, default sD = D >= 0\n\n    var tc,\n        tN,\n        tD = D; // tc = tN / tD, default tD = D >= 0\n    // compute the line parameters of the two closest points\n\n    if (D < Ray.smallnum) {\n      // the lines are almost parallel\n      sN = 0.0; // force using point P0 on segment S1\n\n      sD = 1.0; // to prevent possible division by 0.0 later\n\n      tN = e;\n      tD = c;\n    } else {\n      // get the closest points on the infinite lines\n      sN = b * e - c * d;\n      tN = a * e - b * d;\n\n      if (sN < 0.0) {\n        // sc < 0 => the s=0 edge is visible\n        sN = 0.0;\n        tN = e;\n        tD = c;\n      } else if (sN > sD) {\n        // sc > 1 => the s=1 edge is visible\n        sN = sD;\n        tN = e + b;\n        tD = c;\n      }\n    }\n\n    if (tN < 0.0) {\n      // tc < 0 => the t=0 edge is visible\n      tN = 0.0; // recompute sc for this edge\n\n      if (-d < 0.0) {\n        sN = 0.0;\n      } else if (-d > a) {\n        sN = sD;\n      } else {\n        sN = -d;\n        sD = a;\n      }\n    } else if (tN > tD) {\n      // tc > 1 => the t=1 edge is visible\n      tN = tD; // recompute sc for this edge\n\n      if (-d + b < 0.0) {\n        sN = 0;\n      } else if (-d + b > a) {\n        sN = sD;\n      } else {\n        sN = -d + b;\n        sD = a;\n      }\n    } // finally do the division to get sc and tc\n\n\n    sc = Math.abs(sN) < Ray.smallnum ? 0.0 : sN / sD;\n    tc = Math.abs(tN) < Ray.smallnum ? 0.0 : tN / tD; // get the difference of the two closest points\n\n    var qtc = TmpVectors.Vector3[4];\n    v.scaleToRef(tc, qtc);\n    var qsc = TmpVectors.Vector3[5];\n    u.scaleToRef(sc, qsc);\n    qsc.addInPlace(w);\n    var dP = TmpVectors.Vector3[6];\n    qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\n\n    var isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\n\n    if (isIntersected) {\n      return qsc.length();\n    }\n\n    return -1;\n  };\n  /**\r\n   * Update the ray from viewport position\r\n   * @param x position\r\n   * @param y y position\r\n   * @param viewportWidth viewport width\r\n   * @param viewportHeight viewport height\r\n   * @param world world matrix\r\n   * @param view view matrix\r\n   * @param projection projection matrix\r\n   * @returns this ray updated\r\n   */\n\n\n  Ray.prototype.update = function (x, y, viewportWidth, viewportHeight, world, view, projection) {\n    this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\n    return this;\n  }; // Statics\n\n  /**\r\n   * Creates a ray with origin and direction of 0,0,0\r\n   * @returns the new ray\r\n   */\n\n\n  Ray.Zero = function () {\n    return new Ray(Vector3.Zero(), Vector3.Zero());\n  };\n  /**\r\n   * Creates a new ray from screen space and viewport\r\n   * @param x position\r\n   * @param y y position\r\n   * @param viewportWidth viewport width\r\n   * @param viewportHeight viewport height\r\n   * @param world world matrix\r\n   * @param view view matrix\r\n   * @param projection projection matrix\r\n   * @returns new ray\r\n   */\n\n\n  Ray.CreateNew = function (x, y, viewportWidth, viewportHeight, world, view, projection) {\n    var result = Ray.Zero();\n    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\n  };\n  /**\r\n   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n   * transformed to the given world matrix.\r\n   * @param origin The origin point\r\n   * @param end The end point\r\n   * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n   * @returns the new ray\r\n   */\n\n\n  Ray.CreateNewFromTo = function (origin, end, world) {\n    if (world === void 0) {\n      world = Matrix.IdentityReadOnly;\n    }\n\n    var direction = end.subtract(origin);\n    var length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n    direction.normalize();\n    return Ray.Transform(new Ray(origin, direction, length), world);\n  };\n  /**\r\n   * Transforms a ray by a matrix\r\n   * @param ray ray to transform\r\n   * @param matrix matrix to apply\r\n   * @returns the resulting new ray\r\n   */\n\n\n  Ray.Transform = function (ray, matrix) {\n    var result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n    Ray.TransformToRef(ray, matrix, result);\n    return result;\n  };\n  /**\r\n   * Transforms a ray by a matrix\r\n   * @param ray ray to transform\r\n   * @param matrix matrix to apply\r\n   * @param result ray to store result in\r\n   */\n\n\n  Ray.TransformToRef = function (ray, matrix, result) {\n    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\n    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\n    result.length = ray.length;\n    var dir = result.direction;\n    var len = dir.length();\n\n    if (!(len === 0 || len === 1)) {\n      var num = 1.0 / len;\n      dir.x *= num;\n      dir.y *= num;\n      dir.z *= num;\n      result.length *= len;\n    }\n  };\n  /**\r\n   * Unproject a ray from screen space to object space\r\n   * @param sourceX defines the screen space x coordinate to use\r\n   * @param sourceY defines the screen space y coordinate to use\r\n   * @param viewportWidth defines the current width of the viewport\r\n   * @param viewportHeight defines the current height of the viewport\r\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n   * @param view defines the view matrix to use\r\n   * @param projection defines the projection matrix to use\r\n   */\n\n\n  Ray.prototype.unprojectRayToRef = function (sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {\n    var matrix = TmpVectors.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    matrix.invert();\n    var nearScreenSource = TmpVectors.Vector3[0];\n    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;\n    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);\n    nearScreenSource.z = -1.0;\n    var farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0);\n    var nearVec3 = TmpVectors.Vector3[2];\n    var farVec3 = TmpVectors.Vector3[3];\n\n    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\n\n    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\n\n    this.origin.copyFrom(nearVec3);\n    farVec3.subtractToRef(nearVec3, this.direction);\n    this.direction.normalize();\n  };\n\n  Ray._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\n  Ray.smallnum = 0.00000001;\n  Ray.rayl = 10e8;\n  return Ray;\n}();\n\nexport { Ray };\n\nScene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace) {\n  if (cameraViewSpace === void 0) {\n    cameraViewSpace = false;\n  }\n\n  var result = Ray.Zero();\n  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\n  return result;\n};\n\nScene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace) {\n  if (cameraViewSpace === void 0) {\n    cameraViewSpace = false;\n  }\n\n  var engine = this.getEngine();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return this;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  var cameraViewport = camera.viewport;\n  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight()); // Moving coordinates to local viewport world\n\n  x = x / engine.getHardwareScalingLevel() - viewport.x;\n  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n  result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix());\n  return this;\n};\n\nScene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n  var result = Ray.Zero();\n  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\n  return result;\n};\n\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n  if (!PickingInfo) {\n    return this;\n  }\n\n  var engine = this.getEngine();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    }\n\n    camera = this.activeCamera;\n  }\n\n  var cameraViewport = camera.viewport;\n  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n  var identity = Matrix.Identity(); // Moving coordinates to local viewport world\n\n  x = x / engine.getHardwareScalingLevel() - viewport.x;\n  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n  result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\n  return this;\n};\n\nScene.prototype._internalPickForMesh = function (pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {\n  var ray = rayFunction(world);\n  var result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\n\n  if (!result || !result.hit) {\n    return null;\n  }\n\n  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n    return null;\n  }\n\n  return result;\n};\n\nScene.prototype._internalPick = function (rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfo = null;\n\n  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    var mesh = this.meshes[meshIndex];\n\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n\n    var world = mesh.skeleton && mesh.skeleton.overrideMesh ? mesh.skeleton.overrideMesh.getWorldMatrix() : mesh.getWorldMatrix();\n\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      // first check if the ray intersects the whole bounding box/sphere of the mesh\n      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\n\n      if (result) {\n        if (onlyBoundingInfo) {\n          // the user only asked for a bounding info check so we can return\n          return pickingInfo;\n        }\n\n        var tmpMatrix = TmpVectors.Matrix[1];\n        var thinMatrices = mesh.thinInstanceGetWorldMatrices();\n\n        for (var index = 0; index < thinMatrices.length; index++) {\n          var thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n\n          var result_1 = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\n\n          if (result_1) {\n            pickingInfo = result_1;\n            pickingInfo.thinInstanceIndex = index;\n\n            if (fastCheck) {\n              return pickingInfo;\n            }\n          }\n        }\n      }\n    } else {\n      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\n\n      if (result) {\n        pickingInfo = result;\n\n        if (fastCheck) {\n          return pickingInfo;\n        }\n      }\n    }\n  }\n\n  return pickingInfo || new PickingInfo();\n};\n\nScene.prototype._internalMultiPick = function (rayFunction, predicate, trianglePredicate) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfos = new Array();\n\n  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    var mesh = this.meshes[meshIndex];\n\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n\n    var world = mesh.skeleton && mesh.skeleton.overrideMesh ? mesh.skeleton.overrideMesh.getWorldMatrix() : mesh.getWorldMatrix();\n\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      var result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\n\n      if (result) {\n        var tmpMatrix = TmpVectors.Matrix[1];\n        var thinMatrices = mesh.thinInstanceGetWorldMatrices();\n\n        for (var index = 0; index < thinMatrices.length; index++) {\n          var thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n\n          var result_2 = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\n\n          if (result_2) {\n            result_2.thinInstanceIndex = index;\n            pickingInfos.push(result_2);\n          }\n        }\n      }\n    } else {\n      var result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\n\n      if (result) {\n        pickingInfos.push(result);\n      }\n    }\n  }\n\n  return pickingInfos;\n};\n\nScene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n  var _this = this;\n\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var result = this._internalPick(function (world) {\n    if (!_this._tempPickingRay) {\n      _this._tempPickingRay = Ray.Zero();\n    }\n\n    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);\n\n    return _this._tempPickingRay;\n  }, predicate, fastCheck, true);\n\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n\n  return result;\n};\n\nScene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate) {\n  var _this = this;\n\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var result = this._internalPick(function (world) {\n    if (!_this._tempPickingRay) {\n      _this._tempPickingRay = Ray.Zero();\n    }\n\n    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);\n\n    return _this._tempPickingRay;\n  }, predicate, fastCheck, false, trianglePredicate);\n\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n\n  return result;\n};\n\nScene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n  var _this = this;\n\n  var result = this._internalPick(function (world) {\n    if (!_this._pickWithRayInverseMatrix) {\n      _this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n\n    world.invertToRef(_this._pickWithRayInverseMatrix);\n\n    if (!_this._cachedRayForTransform) {\n      _this._cachedRayForTransform = Ray.Zero();\n    }\n\n    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);\n    return _this._cachedRayForTransform;\n  }, predicate, fastCheck, false, trianglePredicate);\n\n  if (result) {\n    result.ray = ray;\n  }\n\n  return result;\n};\n\nScene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n  var _this = this;\n\n  return this._internalMultiPick(function (world) {\n    return _this.createPickingRay(x, y, world, camera || null);\n  }, predicate, trianglePredicate);\n};\n\nScene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n  var _this = this;\n\n  return this._internalMultiPick(function (world) {\n    if (!_this._pickWithRayInverseMatrix) {\n      _this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n\n    world.invertToRef(_this._pickWithRayInverseMatrix);\n\n    if (!_this._cachedRayForTransform) {\n      _this._cachedRayForTransform = Ray.Zero();\n    }\n\n    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);\n    return _this._cachedRayForTransform;\n  }, predicate, trianglePredicate);\n};\n\nCamera.prototype.getForwardRay = function (length, transform, origin) {\n  if (length === void 0) {\n    length = 100;\n  }\n\n  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\n};\n\nCamera.prototype.getForwardRayToRef = function (refRay, length, transform, origin) {\n  if (length === void 0) {\n    length = 100;\n  }\n\n  if (!transform) {\n    transform = this.getWorldMatrix();\n  }\n\n  refRay.length = length;\n\n  if (!origin) {\n    refRay.origin.copyFrom(this.position);\n  } else {\n    refRay.origin.copyFrom(origin);\n  }\n\n  TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n  Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\n  Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\n  return refRay;\n};","map":null,"metadata":{},"sourceType":"module"}