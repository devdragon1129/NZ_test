{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { Color3 } from '../Maths/math.color';\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { RotationGizmo } from \"./rotationGizmo\";\nimport { PositionGizmo } from \"./positionGizmo\";\nimport { ScaleGizmo } from \"./scaleGizmo\";\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo\";\n/**\r\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\r\n */\n\nvar GizmoManager =\n/** @class */\nfunction () {\n  /**\r\n   * Instatiates a gizmo manager\r\n   * @param scene the scene to overlay the gizmos on top of\r\n   * @param thickness display gizmo axis thickness\r\n   * @param utilityLayer the layer where gizmos are rendered\r\n   * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\r\n   */\n  function GizmoManager(scene, thickness, utilityLayer, keepDepthUtilityLayer) {\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    if (utilityLayer === void 0) {\n      utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (keepDepthUtilityLayer === void 0) {\n      keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer;\n    }\n\n    this.scene = scene;\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\n\n    this.clearGizmoOnEmptyPointerEvent = false;\n    /** Fires an event when the manager is attached to a mesh */\n\n    this.onAttachedToMeshObservable = new Observable();\n    /** Fires an event when the manager is attached to a node */\n\n    this.onAttachedToNodeObservable = new Observable();\n    this._gizmosEnabled = {\n      positionGizmo: false,\n      rotationGizmo: false,\n      scaleGizmo: false,\n      boundingBoxGizmo: false\n    };\n    this._pointerObservers = [];\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._boundingBoxColor = Color3.FromHexString(\"#0984e3\");\n    this._thickness = 1;\n    /** Node Caching for quick lookup */\n\n    this._gizmoAxisCache = new Map();\n    /**\r\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\r\n     */\n\n    this.boundingBoxDragBehavior = new SixDofDragBehavior();\n    /**\r\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\r\n     */\n\n    this.attachableMeshes = null;\n    /**\r\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\r\n     */\n\n    this.attachableNodes = null;\n    /**\r\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\r\n     */\n\n    this.usePointerToAttachGizmos = true;\n    this._defaultUtilityLayer = utilityLayer;\n    this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\n    this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n    this._thickness = thickness;\n    this.gizmos = {\n      positionGizmo: null,\n      rotationGizmo: null,\n      scaleGizmo: null,\n      boundingBoxGizmo: null\n    };\n\n    var attachToMeshPointerObserver = this._attachToMeshPointerObserver(scene);\n\n    var gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\n    this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\n  }\n\n  Object.defineProperty(GizmoManager.prototype, \"keepDepthUtilityLayer\", {\n    /**\r\n     * Utility layer that the bounding box gizmo belongs to\r\n     */\n    get: function get() {\n      return this._defaultKeepDepthUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"utilityLayer\", {\n    /**\r\n     * Utility layer that all gizmos besides bounding box belong to\r\n     */\n    get: function get() {\n      return this._defaultUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"isHovered\", {\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\n    get: function get() {\n      var hovered = false;\n\n      for (var key in this.gizmos) {\n        var gizmo = this.gizmos[key];\n\n        if (gizmo && gizmo.isHovered) {\n          hovered = true;\n          break;\n        }\n      }\n\n      return hovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Subscribes to pointer down events, for attaching and detaching mesh\r\n   * @param scene The sceme layer the observer will be added to\r\n   */\n\n  GizmoManager.prototype._attachToMeshPointerObserver = function (scene) {\n    var _this = this; // Instatiate/dispose gizmos based on pointer actions\n\n\n    var pointerObserver = scene.onPointerObservable.add(function (pointerInfo) {\n      if (!_this.usePointerToAttachGizmos) {\n        return;\n      }\n\n      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\n          var node = pointerInfo.pickInfo.pickedMesh;\n\n          if (_this.attachableMeshes == null) {\n            // Attach to the most parent node\n            while (node && node.parent != null) {\n              node = node.parent;\n            }\n          } else {\n            // Attach to the parent node that is an attachableMesh\n            var found = false;\n\n            _this.attachableMeshes.forEach(function (mesh) {\n              if (node && (node == mesh || node.isDescendantOf(mesh))) {\n                node = mesh;\n                found = true;\n              }\n            });\n\n            if (!found) {\n              node = null;\n            }\n          }\n\n          if (node instanceof AbstractMesh) {\n            if (_this._attachedMesh != node) {\n              _this.attachToMesh(node);\n            }\n          } else {\n            if (_this.clearGizmoOnEmptyPointerEvent) {\n              _this.attachToMesh(null);\n            }\n          }\n        } else {\n          if (_this.clearGizmoOnEmptyPointerEvent) {\n            _this.attachToMesh(null);\n          }\n        }\n      }\n    });\n    return pointerObserver;\n  };\n  /**\r\n   * Attaches a set of gizmos to the specified mesh\r\n   * @param mesh The mesh the gizmo's should be attached to\r\n   */\n\n\n  GizmoManager.prototype.attachToMesh = function (mesh) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this._attachedMesh = mesh;\n    this._attachedNode = null;\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedMesh = mesh;\n      }\n    }\n\n    if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\n      this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this.onAttachedToMeshObservable.notifyObservers(mesh);\n  };\n  /**\r\n   * Attaches a set of gizmos to the specified node\r\n   * @param node The node the gizmo's should be attached to\r\n   */\n\n\n  GizmoManager.prototype.attachToNode = function (node) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this._attachedMesh = null;\n    this._attachedNode = node;\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedNode = node;\n      }\n    }\n\n    if (this.boundingBoxGizmoEnabled && this._attachedNode) {\n      this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this.onAttachedToNodeObservable.notifyObservers(node);\n  };\n\n  Object.defineProperty(GizmoManager.prototype, \"positionGizmoEnabled\", {\n    get: function get() {\n      return this._gizmosEnabled.positionGizmo;\n    },\n\n    /**\r\n     * If the position gizmo is enabled\r\n     */\n    set: function set(value) {\n      if (value) {\n        if (!this.gizmos.positionGizmo) {\n          this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\n        }\n\n        if (this._attachedNode) {\n          this.gizmos.positionGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.positionGizmo) {\n        this.gizmos.positionGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.positionGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"rotationGizmoEnabled\", {\n    get: function get() {\n      return this._gizmosEnabled.rotationGizmo;\n    },\n\n    /**\r\n     * If the rotation gizmo is enabled\r\n     */\n    set: function set(value) {\n      if (value) {\n        if (!this.gizmos.rotationGizmo) {\n          this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\n        }\n\n        if (this._attachedNode) {\n          this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.rotationGizmo) {\n        this.gizmos.rotationGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.rotationGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"scaleGizmoEnabled\", {\n    get: function get() {\n      return this._gizmosEnabled.scaleGizmo;\n    },\n\n    /**\r\n     * If the scale gizmo is enabled\r\n     */\n    set: function set(value) {\n      if (value) {\n        this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\n\n        if (this._attachedNode) {\n          this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.scaleGizmo) {\n        this.gizmos.scaleGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.scaleGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"boundingBoxGizmoEnabled\", {\n    get: function get() {\n      return this._gizmosEnabled.boundingBoxGizmo;\n    },\n\n    /**\r\n     * If the boundingBox gizmo is enabled\r\n     */\n    set: function set(value) {\n      if (value) {\n        this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\n\n        if (this._attachedMesh) {\n          this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\n        } else {\n          this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\n        }\n\n        if (this._attachedMesh) {\n          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n\n          this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n        } else if (this._attachedNode) {\n          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n\n          this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n        }\n      } else if (this.gizmos.boundingBoxGizmo) {\n        if (this._attachedMesh) {\n          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        } else if (this._attachedNode) {\n          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        }\n\n        this.gizmos.boundingBoxGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.boundingBoxGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n   */\n\n  GizmoManager.prototype.addToAxisCache = function (gizmoAxisCache) {\n    var _this = this;\n\n    if (gizmoAxisCache.size > 0) {\n      gizmoAxisCache.forEach(function (v, k) {\n        _this._gizmoAxisCache.set(k, v);\n      });\n    }\n  };\n  /**\r\n   * Disposes of the gizmo manager\r\n   */\n\n\n  GizmoManager.prototype.dispose = function () {\n    var _this = this;\n\n    this._pointerObservers.forEach(function (observer) {\n      _this.scene.onPointerObservable.remove(observer);\n    });\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    }\n\n    this._defaultKeepDepthUtilityLayer.dispose();\n\n    this._defaultUtilityLayer.dispose();\n\n    this.boundingBoxDragBehavior.detach();\n    this.onAttachedToMeshObservable.clear();\n  };\n\n  return GizmoManager;\n}();\n\nexport { GizmoManager };","map":null,"metadata":{},"sourceType":"module"}