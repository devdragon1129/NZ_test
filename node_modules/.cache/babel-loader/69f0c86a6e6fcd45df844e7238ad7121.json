{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\nimport { Tools } from \"../Misc/tools\";\nvar idCount = 0;\n/**\r\n * Represents an XR controller\r\n */\n\nvar WebXRInputSource =\n/** @class */\nfunction () {\n  /**\r\n   * Creates the input source object\r\n   * @see https://doc.babylonjs.com/how_to/webxr_controllers_support\r\n   * @param _scene the scene which the controller should be associated to\r\n   * @param inputSource the underlying input source for the controller\r\n   * @param _options options for this controller creation\r\n   */\n  function WebXRInputSource(_scene,\n  /** The underlying input source for the controller  */\n  inputSource, _options) {\n    var _this = this;\n\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    this._scene = _scene;\n    this.inputSource = inputSource;\n    this._options = _options;\n    this._tmpVector = new Vector3();\n    this._disposed = false;\n    /**\r\n     * Event that fires when the controller is removed/disposed.\r\n     * The object provided as event data is this controller, after associated assets were disposed.\r\n     * uniqueId is still available.\r\n     */\n\n    this.onDisposeObservable = new Observable();\n    /**\r\n     * Will be triggered when the mesh associated with the motion controller is done loading.\r\n     * It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh\r\n     * A shortened version of controller -> motion controller -> on mesh loaded.\r\n     */\n\n    this.onMeshLoadedObservable = new Observable();\n    /**\r\n     * Observers registered here will trigger when a motion controller profile was assigned to this xr controller\r\n     */\n\n    this.onMotionControllerInitObservable = new Observable();\n    this._uniqueId = \"controller-\" + idCount++ + \"-\" + inputSource.targetRayMode + \"-\" + inputSource.handedness;\n    this.pointer = new AbstractMesh(this._uniqueId + \"-pointer\", _scene);\n    this.pointer.rotationQuaternion = new Quaternion();\n\n    if (this.inputSource.gripSpace) {\n      this.grip = new AbstractMesh(this._uniqueId + \"-grip\", this._scene);\n      this.grip.rotationQuaternion = new Quaternion();\n    }\n\n    this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0); // for now only load motion controllers if gamepad object available\n\n\n    if (this.inputSource.gamepad) {\n      WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then(function (motionController) {\n        _this.motionController = motionController;\n\n        _this.onMotionControllerInitObservable.notifyObservers(motionController); // should the model be loaded?\n\n\n        if (!_this._options.doNotLoadControllerMesh) {\n          _this.motionController.loadModel().then(function (success) {\n            var _a;\n\n            if (success && _this.motionController && _this.motionController.rootMesh) {\n              if (_this._options.renderingGroupId) {\n                // anything other than 0?\n                _this.motionController.rootMesh.renderingGroupId = _this._options.renderingGroupId;\n\n                _this.motionController.rootMesh.getChildMeshes(false).forEach(function (mesh) {\n                  return mesh.renderingGroupId = _this._options.renderingGroupId;\n                });\n              }\n\n              _this.onMeshLoadedObservable.notifyObservers(_this.motionController.rootMesh);\n\n              _this.motionController.rootMesh.parent = _this.grip || _this.pointer;\n              _this.motionController.disableAnimation = !!_this._options.disableMotionControllerAnimation;\n            } // make sure to dispose is the controller is already disposed\n\n\n            if (_this._disposed) {\n              (_a = _this.motionController) === null || _a === void 0 ? void 0 : _a.dispose();\n            }\n          });\n        }\n      }, function () {\n        Tools.Warn(\"Could not find a matching motion controller for the registered input source\");\n      });\n    }\n  }\n\n  Object.defineProperty(WebXRInputSource.prototype, \"uniqueId\", {\n    /**\r\n     * Get this controllers unique id\r\n     */\n    get: function get() {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes of the object\r\n   */\n\n  WebXRInputSource.prototype.dispose = function () {\n    if (this.grip) {\n      this.grip.dispose();\n    }\n\n    if (this.motionController) {\n      this.motionController.dispose();\n    }\n\n    this.pointer.dispose();\n    this.onMotionControllerInitObservable.clear();\n    this.onMeshLoadedObservable.clear();\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this._disposed = true;\n  };\n  /**\r\n   * Gets a world space ray coming from the pointer or grip\r\n   * @param result the resulting ray\r\n   * @param gripIfAvailable use the grip mesh instead of the pointer, if available\r\n   */\n\n\n  WebXRInputSource.prototype.getWorldPointerRayToRef = function (result, gripIfAvailable) {\n    if (gripIfAvailable === void 0) {\n      gripIfAvailable = false;\n    }\n\n    var object = gripIfAvailable && this.grip ? this.grip : this.pointer;\n    Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);\n    result.direction.normalize();\n    result.origin.copyFrom(object.absolutePosition);\n    result.length = 1000;\n  };\n  /**\r\n   * Updates the controller pose based on the given XRFrame\r\n   * @param xrFrame xr frame to update the pose with\r\n   * @param referenceSpace reference space to use\r\n   */\n\n\n  WebXRInputSource.prototype.updateFromXRFrame = function (xrFrame, referenceSpace) {\n    var pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace); // Update the pointer mesh\n\n    if (pose) {\n      var pos = pose.transform.position;\n      this.pointer.position.set(pos.x, pos.y, pos.z);\n      var orientation_1 = pose.transform.orientation;\n      this.pointer.rotationQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);\n\n      if (!this._scene.useRightHandedSystem) {\n        this.pointer.position.z *= -1;\n        this.pointer.rotationQuaternion.z *= -1;\n        this.pointer.rotationQuaternion.w *= -1;\n      }\n    } // Update the grip mesh if it exists\n\n\n    if (this.inputSource.gripSpace && this.grip) {\n      var pose_1 = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);\n\n      if (pose_1) {\n        var pos = pose_1.transform.position;\n        var orientation_2 = pose_1.transform.orientation;\n        this.grip.position.set(pos.x, pos.y, pos.z);\n        this.grip.rotationQuaternion.set(orientation_2.x, orientation_2.y, orientation_2.z, orientation_2.w);\n\n        if (!this._scene.useRightHandedSystem) {\n          this.grip.position.z *= -1;\n          this.grip.rotationQuaternion.z *= -1;\n          this.grip.rotationQuaternion.w *= -1;\n        }\n      }\n    }\n\n    if (this.motionController) {\n      // either update buttons only or also position, if in gamepad mode\n      this.motionController.updateFromXRFrame(xrFrame);\n    }\n  };\n\n  return WebXRInputSource;\n}();\n\nexport { WebXRInputSource };","map":null,"metadata":{},"sourceType":"module"}