{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialConnectionPointDirection } from '../../nodeMaterialBlockConnectionPoint';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { InputBlock } from '../Input/inputBlock';\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { CubeTexture } from '../../../Textures/cubeTexture';\nimport { Texture } from '../../../Textures/texture';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport { Scalar } from '../../../../Maths/math.scalar';\n/**\r\n * Block used to implement the refraction part of the sub surface module of the PBR material\r\n */\n\nvar RefractionBlock =\n/** @class */\nfunction (_super) {\n  __extends(RefractionBlock, _super);\n  /**\r\n   * Create a new RefractionBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function RefractionBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting aginst not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\n\n\n    _this.linkRefractionWithTransparency = false;\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\n\n    _this.invertRefractionY = false;\n    _this._isUnique = true;\n\n    _this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"refraction\", _this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\"));\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  RefractionBlock.prototype.getClassName = function () {\n    return \"RefractionBlock\";\n  };\n\n  Object.defineProperty(RefractionBlock.prototype, \"intensity\", {\n    /**\r\n     * Gets the intensity input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"tintAtDistance\", {\n    /**\r\n     * Gets the tint at distance input component\r\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"view\", {\n    /**\r\n     * Gets the view input component\r\n     */\n    get: function get() {\n      return this.viewConnectionPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"refraction\", {\n    /**\r\n     * Gets the refraction object output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"hasTexture\", {\n    /**\r\n     * Returns true if the block has a texture\r\n     */\n    get: function get() {\n      return !!this._getTexture();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RefractionBlock.prototype._getTexture = function () {\n    if (this.texture) {\n      return this.texture;\n    }\n\n    return this._scene.environmentTexture;\n  };\n\n  RefractionBlock.prototype.autoConfigure = function (material) {\n    if (!this.intensity.isConnected) {\n      var intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      intensityInput.value = 1;\n      intensityInput.output.connectTo(this.intensity);\n    }\n\n    if (this.view && !this.view.isConnected) {\n      var viewInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.View;\n      });\n\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n\n      viewInput.output.connectTo(this.view);\n    }\n  };\n\n  RefractionBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);\n\n    var refractionTexture = this._getTexture();\n\n    var refraction = refractionTexture && refractionTexture.getTextureMatrix;\n    defines.setValue(\"SS_REFRACTION\", refraction, true);\n\n    if (!refraction) {\n      return;\n    }\n\n    defines.setValue(this._define3DName, refractionTexture.isCube, true);\n    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture.invertZ : refractionTexture.invertZ, true);\n    defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\n    defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture.gammaSpace, true);\n    defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture.isRGBD, true);\n  };\n\n  RefractionBlock.prototype.isReady = function () {\n    var texture = this._getTexture();\n\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  RefractionBlock.prototype.bind = function (effect, nodeMaterial, mesh, subMesh) {\n    var _a, _b;\n\n    _super.prototype.bind.call(this, effect, nodeMaterial, mesh);\n\n    var refractionTexture = this._getTexture();\n\n    if (!refractionTexture) {\n      return;\n    }\n\n    if (refractionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, refractionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, refractionTexture);\n    }\n\n    effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());\n    var depth = 1.0;\n\n    if (!refractionTexture.isCube) {\n      if (refractionTexture.depth) {\n        depth = refractionTexture.depth;\n      }\n    }\n\n    var indexOfRefraction = (_b = (_a = this.indexOfRefractionConnectionPoint.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1.5;\n    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n    effect.setFloat3(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset);\n    var width = refractionTexture.getSize().width;\n    effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\n  };\n  /**\r\n   * Gets the main code of the block (fragment side)\r\n   * @param state current state of the node material building\r\n   * @returns the shader code\r\n   */\n\n\n  RefractionBlock.prototype.getCode = function (state) {\n    var code = \"\";\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this); // Samplers\n\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\n    state._samplerDeclaration += \"#ifdef \" + this._define3DName + \"\\r\\n\";\n    state._samplerDeclaration += \"uniform samplerCube \" + this._cubeSamplerName + \";\\r\\n\";\n    state._samplerDeclaration += \"#else\\r\\n\";\n    state._samplerDeclaration += \"uniform sampler2D \" + this._2DSamplerName + \";\\r\\n\";\n    state._samplerDeclaration += \"#endif\\r\\n\"; // Fragment\n\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\n    this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\n    this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\n    this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\n\n    state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\n\n    state._emitFunction(\"sampleRefraction\", \"\\n            #ifdef \" + this._define3DName + \"\\n                #define sampleRefraction(s, c) textureCube(s, c)\\n            #else\\n                #define sampleRefraction(s, c) texture2D(s, c)\\n            #endif\\r\\n\", \"//\" + this.name);\n\n    state._emitFunction(\"sampleRefractionLod\", \"\\n            #ifdef \" + this._define3DName + \"\\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\\n            #else\\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\\n            #endif\\r\\n\", \"//\" + this.name);\n\n    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\n\n    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec3\");\n\n    this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\n\n    state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\n\n    this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\n\n    state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\n\n    return code;\n  };\n\n  RefractionBlock.prototype._buildBlock = function (state) {\n    this._scene = state.sharedData.scene;\n    return this;\n  };\n\n  RefractionBlock.prototype._dumpPropertiesCode = function () {\n    var codeString = _super.prototype._dumpPropertiesCode.call(this);\n\n    if (this.texture) {\n      if (this.texture.isCube) {\n        codeString = this._codeVariableName + \".texture = new BABYLON.CubeTexture(\\\"\" + this.texture.name + \"\\\");\\r\\n\";\n      } else {\n        codeString = this._codeVariableName + \".texture = new BABYLON.Texture(\\\"\" + this.texture.name + \"\\\");\\r\\n\";\n      }\n\n      codeString += this._codeVariableName + \".texture.coordinatesMode = \" + this.texture.coordinatesMode + \";\\r\\n\";\n    }\n\n    codeString += this._codeVariableName + \".linkRefractionWithTransparency = \" + this.linkRefractionWithTransparency + \";\\r\\n\";\n    codeString += this._codeVariableName + \".invertRefractionY = \" + this.invertRefractionY + \";\\r\\n\";\n    return codeString;\n  };\n\n  RefractionBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this.texture) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\n    serializationObject.invertRefractionY = this.invertRefractionY;\n    return serializationObject;\n  };\n\n  RefractionBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n\n    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\n    this.invertRefractionY = serializationObject.invertRefractionY;\n  };\n\n  __decorate([editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    \"notifiers\": {\n      \"update\": true\n    }\n  })], RefractionBlock.prototype, \"linkRefractionWithTransparency\", void 0);\n\n  __decorate([editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    \"notifiers\": {\n      \"update\": true\n    }\n  })], RefractionBlock.prototype, \"invertRefractionY\", void 0);\n\n  return RefractionBlock;\n}(NodeMaterialBlock);\n\nexport { RefractionBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.RefractionBlock\"] = RefractionBlock;","map":null,"metadata":{},"sourceType":"module"}