{"ast":null,"code":"import { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector\";\nimport { Color4 } from '../Maths/math.color';\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { BoundingSphere } from \"../Culling/boundingSphere\";\nimport { AbstractMesh } from '../Meshes/abstractMesh';\n/**\r\n * Represents one particle of a solid particle system.\r\n */\n\nvar SolidParticle =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a Solid Particle object.\r\n   * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\r\n   * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\r\n   * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\r\n   * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\r\n   * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\r\n   * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\r\n   * @param shapeId (integer) is the model shape identifier in the SPS.\r\n   * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\r\n   * @param sps defines the sps it is associated to\r\n   * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\r\n   * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\r\n   */\n  function SolidParticle(particleIndex, particleId, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo, materialIndex) {\n    if (modelBoundingInfo === void 0) {\n      modelBoundingInfo = null;\n    }\n\n    if (materialIndex === void 0) {\n      materialIndex = null;\n    }\n    /**\r\n     * particle global index\r\n     */\n\n\n    this.idx = 0;\n    /**\r\n     * particle identifier\r\n     */\n\n    this.id = 0;\n    /**\r\n     * The color of the particle\r\n     */\n\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\r\n     * The world space position of the particle.\r\n     */\n\n    this.position = Vector3.Zero();\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\n\n    this.rotation = Vector3.Zero();\n    /**\r\n     * The scaling of the particle.\r\n     */\n\n    this.scaling = Vector3.One();\n    /**\r\n     * The uvs of the particle.\r\n     */\n\n    this.uvs = new Vector4(0.0, 0.0, 1.0, 1.0);\n    /**\r\n     * The current speed of the particle.\r\n     */\n\n    this.velocity = Vector3.Zero();\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\n\n    this.pivot = Vector3.Zero();\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\n\n    this.translateFromPivot = false;\n    /**\r\n     * Is the particle active or not ?\r\n     */\n\n    this.alive = true;\n    /**\r\n     * Is the particle visible or not ?\r\n     */\n\n    this.isVisible = true;\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @hidden\r\n     */\n\n    this._pos = 0;\n    /**\r\n     * @hidden Index of this particle in the global \"indices\" array (Internal use)\r\n     */\n\n    this._ind = 0;\n    /**\r\n     * ModelShape id of this particle\r\n     */\n\n    this.shapeId = 0;\n    /**\r\n     * Index of the particle in its shape id\r\n     */\n\n    this.idxInShape = 0;\n    /**\r\n     * @hidden Still set as invisible in order to skip useless computations (Internal use)\r\n     */\n\n    this._stillInvisible = false;\n    /**\r\n     * @hidden Last computed particle rotation matrix\r\n     */\n\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\n\n    this.parentId = null;\n    /**\r\n     * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\r\n     */\n\n    this.materialIndex = null;\n    /**\r\n     * Custom object or properties.\r\n     */\n\n    this.props = null;\n    /**\r\n     * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\r\n     * */\n\n    this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n    /**\r\n     * @hidden Internal global position in the SPS.\r\n     */\n\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this.id = particleId;\n    this._pos = positionIndex;\n    this._ind = indiceIndex;\n    this._model = model;\n    this.shapeId = shapeId;\n    this.idxInShape = idxInShape;\n    this._sps = sps;\n\n    if (modelBoundingInfo) {\n      this._modelBoundingInfo = modelBoundingInfo;\n      this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\n    }\n\n    if (materialIndex !== null) {\n      this.materialIndex = materialIndex;\n    }\n  }\n  /**\r\n   * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\r\n   * @param target the particle target\r\n   * @returns the current particle\r\n   */\n\n\n  SolidParticle.prototype.copyToRef = function (target) {\n    target.position.copyFrom(this.position);\n    target.rotation.copyFrom(this.rotation);\n\n    if (this.rotationQuaternion) {\n      if (target.rotationQuaternion) {\n        target.rotationQuaternion.copyFrom(this.rotationQuaternion);\n      } else {\n        target.rotationQuaternion = this.rotationQuaternion.clone();\n      }\n    }\n\n    target.scaling.copyFrom(this.scaling);\n\n    if (this.color) {\n      if (target.color) {\n        target.color.copyFrom(this.color);\n      } else {\n        target.color = this.color.clone();\n      }\n    }\n\n    target.uvs.copyFrom(this.uvs);\n    target.velocity.copyFrom(this.velocity);\n    target.pivot.copyFrom(this.pivot);\n    target.translateFromPivot = this.translateFromPivot;\n    target.alive = this.alive;\n    target.isVisible = this.isVisible;\n    target.parentId = this.parentId;\n    target.cullingStrategy = this.cullingStrategy;\n\n    if (this.materialIndex !== null) {\n      target.materialIndex = this.materialIndex;\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(SolidParticle.prototype, \"scale\", {\n    /**\r\n     * Legacy support, changed scale to scaling\r\n     */\n    get: function get() {\n      return this.scaling;\n    },\n\n    /**\r\n     * Legacy support, changed scale to scaling\r\n     */\n    set: function set(scale) {\n      this.scaling = scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticle.prototype, \"quaternion\", {\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\n    get: function get() {\n      return this.rotationQuaternion;\n    },\n\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\n    set: function set(q) {\n      this.rotationQuaternion = q;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\r\n   * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\r\n   * @param target is the object (solid particle or mesh) what the intersection is computed against.\r\n   * @returns true if it intersects\r\n   */\n\n  SolidParticle.prototype.intersectsMesh = function (target) {\n    if (!this._boundingInfo || !target._boundingInfo) {\n      return false;\n    }\n\n    if (this._sps._bSphereOnly) {\n      return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target._boundingInfo.boundingSphere);\n    }\n\n    return this._boundingInfo.intersects(target._boundingInfo, false);\n  };\n  /**\r\n   * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\r\n   * A particle is in the frustum if its bounding box intersects the frustum\r\n   * @param frustumPlanes defines the frustum to test\r\n   * @returns true if the particle is in the frustum planes\r\n   */\n\n\n  SolidParticle.prototype.isInFrustum = function (frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\n  };\n  /**\r\n   * get the rotation matrix of the particle\r\n   * @hidden\r\n   */\n\n\n  SolidParticle.prototype.getRotationMatrix = function (m) {\n    var quaternion;\n\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      var rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n\n    quaternion.toRotationMatrix(m);\n  };\n\n  return SolidParticle;\n}();\n\nexport { SolidParticle };\n/**\r\n * Represents the shape of the model used by one particle of a solid particle system.\r\n * SPS internal tool, don't use it manually.\r\n */\n\nvar ModelShape =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\r\n   * SPS internal tool, don't use it manually.\r\n   * @hidden\r\n   */\n  function ModelShape(id, shape, indices, normals, colors, shapeUV, posFunction, vtxFunction, material) {\n    /**\r\n     * length of the shape in the model indices array (internal use)\r\n     * @hidden\r\n     */\n    this._indicesLength = 0;\n    this.shapeID = id;\n    this._shape = shape;\n    this._indices = indices;\n    this._indicesLength = indices.length;\n    this._shapeUV = shapeUV;\n    this._shapeColors = colors;\n    this._normals = normals;\n    this._positionFunction = posFunction;\n    this._vertexFunction = vtxFunction;\n    this._material = material;\n  }\n\n  return ModelShape;\n}();\n\nexport { ModelShape };\n/**\r\n * Represents a Depth Sorted Particle in the solid particle system.\r\n * @hidden\r\n */\n\nvar DepthSortedParticle =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new sorted particle\r\n   * @param materialIndex\r\n   */\n  function DepthSortedParticle(idx, ind, indLength, materialIndex) {\n    /**\r\n     * Particle index\r\n     */\n    this.idx = 0;\n    /**\r\n     * Index of the particle in the \"indices\" array\r\n     */\n\n    this.ind = 0;\n    /**\r\n     * Length of the particle shape in the \"indices\" array\r\n     */\n\n    this.indicesLength = 0;\n    /**\r\n     * Squared distance from the particle to the camera\r\n     */\n\n    this.sqDistance = 0.0;\n    /**\r\n     * Material index when used with MultiMaterials\r\n     */\n\n    this.materialIndex = 0;\n    this.idx = idx;\n    this.ind = ind;\n    this.indicesLength = indLength;\n    this.materialIndex = materialIndex;\n  }\n\n  return DepthSortedParticle;\n}();\n\nexport { DepthSortedParticle };\n/**\r\n * Represents a solid particle vertex\r\n */\n\nvar SolidParticleVertex =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new solid particle vertex\r\n   */\n  function SolidParticleVertex() {\n    this.position = Vector3.Zero();\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    this.uv = Vector2.Zero();\n  }\n\n  Object.defineProperty(SolidParticleVertex.prototype, \"x\", {\n    // Getters and Setters for back-compatibility\n\n    /** Vertex x coordinate */\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(val) {\n      this.position.x = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleVertex.prototype, \"y\", {\n    /** Vertex y coordinate */\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(val) {\n      this.position.y = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleVertex.prototype, \"z\", {\n    /** Vertex z coordinate */\n    get: function get() {\n      return this.position.z;\n    },\n    set: function set(val) {\n      this.position.z = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return SolidParticleVertex;\n}();\n\nexport { SolidParticleVertex };","map":null,"metadata":{},"sourceType":"module"}