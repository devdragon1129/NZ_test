{"ast":null,"code":"import { BackEase, EasingFunction } from \"../../Animations/easing\";\nimport { Animation } from \"../../Animations/animation\";\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n */\n\nvar BouncingBehavior =\n/** @class */\nfunction () {\n  function BouncingBehavior() {\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\n    this.transitionDuration = 450;\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\n\n    this.lowerRadiusTransitionRange = 2;\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\n\n    this.upperRadiusTransitionRange = -2;\n    this._autoTransitionRange = false; // Animations\n\n    this._radiusIsAnimating = false;\n    this._radiusBounceTransition = null;\n    this._animatables = new Array();\n  }\n\n  Object.defineProperty(BouncingBehavior.prototype, \"name\", {\n    /**\r\n     * Gets the name of the behavior.\r\n     */\n    get: function get() {\n      return \"Bouncing\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BouncingBehavior.prototype, \"autoTransitionRange\", {\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\n    get: function get() {\n      return this._autoTransitionRange;\n    },\n\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this._autoTransitionRange === value) {\n        return;\n      }\n\n      this._autoTransitionRange = value;\n      var camera = this._attachedCamera;\n\n      if (!camera) {\n        return;\n      }\n\n      if (value) {\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {\n          if (!mesh) {\n            return;\n          }\n\n          mesh.computeWorldMatrix(true);\n          var diagonal = mesh.getBoundingInfo().diagonalLength;\n          _this.lowerRadiusTransitionRange = diagonal * 0.05;\n          _this.upperRadiusTransitionRange = diagonal * 0.05;\n        });\n      } else if (this._onMeshTargetChangedObserver) {\n        camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initializes the behavior.\r\n   */\n\n  BouncingBehavior.prototype.init = function () {// Do notihng\n  };\n  /**\r\n   * Attaches the behavior to its arc rotate camera.\r\n   * @param camera Defines the camera to attach the behavior to\r\n   */\n\n\n  BouncingBehavior.prototype.attach = function (camera) {\n    var _this = this;\n\n    this._attachedCamera = camera;\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\n      if (!_this._attachedCamera) {\n        return;\n      } // Add the bounce animation to the lower radius limit\n\n\n      if (_this._isRadiusAtLimit(_this._attachedCamera.lowerRadiusLimit)) {\n        _this._applyBoundRadiusAnimation(_this.lowerRadiusTransitionRange);\n      } // Add the bounce animation to the upper radius limit\n\n\n      if (_this._isRadiusAtLimit(_this._attachedCamera.upperRadiusLimit)) {\n        _this._applyBoundRadiusAnimation(_this.upperRadiusTransitionRange);\n      }\n    });\n  };\n  /**\r\n   * Detaches the behavior from its current arc rotate camera.\r\n   */\n\n\n  BouncingBehavior.prototype.detach = function () {\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n\n    this._attachedCamera = null;\n  };\n  /**\r\n   * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n   * @param radiusLimit The limit to check against.\r\n   * @return Bool to indicate if at limit.\r\n   */\n\n\n  BouncingBehavior.prototype._isRadiusAtLimit = function (radiusLimit) {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n   * @param radiusDelta The delta by which to animate to. Can be negative.\r\n   */\n\n\n  BouncingBehavior.prototype._applyBoundRadiusAnimation = function (radiusDelta) {\n    var _this = this;\n\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    if (!this._radiusBounceTransition) {\n      BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\n      this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\n    } // Prevent zoom until bounce has completed\n\n\n    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\n    this._attachedCamera.wheelPrecision = Infinity;\n    this._attachedCamera.inertialRadiusOffset = 0; // Animate to the radius limit\n\n    this.stopAllAnimations();\n    this._radiusIsAnimating = true;\n    var animatable = Animation.TransitionTo(\"radius\", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, function () {\n      return _this._clearAnimationLocks();\n    });\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  };\n  /**\r\n   * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n   */\n\n\n  BouncingBehavior.prototype._clearAnimationLocks = function () {\n    this._radiusIsAnimating = false;\n\n    if (this._attachedCamera) {\n      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\n    }\n  };\n  /**\r\n   * Stops and removes all animations that have been applied to the camera\r\n   */\n\n\n  BouncingBehavior.prototype.stopAllAnimations = function () {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n\n    while (this._animatables.length) {\n      this._animatables[0].onAnimationEnd = null;\n\n      this._animatables[0].stop();\n\n      this._animatables.shift();\n    }\n  };\n  /**\r\n   * The easing function used by animations\r\n   */\n\n\n  BouncingBehavior.EasingFunction = new BackEase(0.3);\n  /**\r\n   * The easing mode used by animations\r\n   */\n\n  BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;\n  return BouncingBehavior;\n}();\n\nexport { BouncingBehavior };","map":null,"metadata":{},"sourceType":"module"}