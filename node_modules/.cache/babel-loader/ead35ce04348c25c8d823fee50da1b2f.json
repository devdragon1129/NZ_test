{"ast":null,"code":"import { Bone } from \"./bone\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { Animation } from \"../Animations/animation\";\nimport { AnimationRange } from \"../Animations/animationRange\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"../Misc/logger\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\n\nvar Skeleton =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new skeleton\r\n   * @param name defines the skeleton name\r\n   * @param id defines the skeleton Id\r\n   * @param scene defines the hosting scene\r\n   */\n  function Skeleton(\n  /** defines the skeleton name */\n  name,\n  /** defines the skeleton Id */\n  id, scene) {\n    this.name = name;\n    this.id = id;\n    /**\r\n     * Defines the list of child bones\r\n     */\n\n    this.bones = new Array();\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\n\n    this.needInitialSkinMatrix = false;\n    /**\r\n     * Defines a mesh that override the matrix used to get the world matrix (null by default).\r\n     */\n\n    this.overrideMesh = null;\n    this._isDirty = true;\n    this._meshesWithPoseMatrix = new Array();\n    this._identity = Matrix.Identity();\n    this._ranges = {};\n    this._lastAbsoluteTransformsUpdateId = -1;\n    this._canUseTextureForBones = false;\n    this._uniqueId = 0;\n    /** @hidden */\n\n    this._numBonesWithLinkedTransformNode = 0;\n    /** @hidden */\n\n    this._hasWaitingData = null;\n    /** @hidden */\n\n    this._waitingOverrideMeshId = null;\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\n\n    this.doNotSerialize = false;\n    this._useTextureToStoreBoneMatrices = true;\n    this._animationPropertiesOverride = null; // Events\n\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\n\n    this.onBeforeComputeObservable = new Observable();\n    this.bones = [];\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._uniqueId = this._scene.getUniqueId();\n\n    this._scene.addSkeleton(this); //make sure it will recalculate the matrix next time prepare is called.\n\n\n    this._isDirty = true;\n\n    var engineCaps = this._scene.getEngine().getCaps();\n\n    this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n  }\n\n  Object.defineProperty(Skeleton.prototype, \"useTextureToStoreBoneMatrices\", {\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\n    get: function get() {\n      return this._useTextureToStoreBoneMatrices;\n    },\n    set: function set(value) {\n      this._useTextureToStoreBoneMatrices = value;\n\n      this._markAsDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"animationPropertiesOverride\", {\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\n    get: function get() {\n      if (!this._animationPropertiesOverride) {\n        return this._scene.animationPropertiesOverride;\n      }\n\n      return this._animationPropertiesOverride;\n    },\n    set: function set(value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"isUsingTextureForMatrices\", {\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\n    get: function get() {\n      return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"uniqueId\", {\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\n    get: function get() {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current object class name.\r\n   * @return the class name\r\n   */\n\n  Skeleton.prototype.getClassName = function () {\n    return \"Skeleton\";\n  };\n  /**\r\n   * Returns an array containing the root bones\r\n   * @returns an array containing the root bones\r\n   */\n\n\n  Skeleton.prototype.getChildren = function () {\n    return this.bones.filter(function (b) {\n      return !b.getParent();\n    });\n  }; // Members\n\n  /**\r\n   * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n   * @returns a Float32Array containing matrices data\r\n   */\n\n\n  Skeleton.prototype.getTransformMatrices = function (mesh) {\n    if (this.needInitialSkinMatrix && mesh._bonesTransformMatrices) {\n      return mesh._bonesTransformMatrices;\n    }\n\n    if (!this._transformMatrices) {\n      this.prepare();\n    }\n\n    return this._transformMatrices;\n  };\n  /**\r\n   * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n   * @returns a raw texture containing the data\r\n   */\n\n\n  Skeleton.prototype.getTransformMatrixTexture = function (mesh) {\n    if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n      return mesh._transformMatrixTexture;\n    }\n\n    return this._transformMatrixTexture;\n  };\n  /**\r\n   * Gets the current hosting scene\r\n   * @returns a scene object\r\n   */\n\n\n  Skeleton.prototype.getScene = function () {\n    return this._scene;\n  }; // Methods\n\n  /**\r\n   * Gets a string representing the current skeleton data\r\n   * @param fullDetails defines a boolean indicating if we want a verbose version\r\n   * @returns a string representing the current skeleton data\r\n   */\n\n\n  Skeleton.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name + \", nBones: \" + this.bones.length;\n    ret += \", nAnimationRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      var first = true;\n\n      for (var name_1 in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n\n        ret += name_1;\n      }\n\n      ret += \"}\";\n    }\n\n    return ret;\n  };\n  /**\r\n  * Get bone's index searching by name\r\n  * @param name defines bone's name to search for\r\n  * @return the indice of the bone. Returns -1 if not found\r\n  */\n\n\n  Skeleton.prototype.getBoneIndexByName = function (name) {\n    for (var boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n      if (this.bones[boneIndex].name === name) {\n        return boneIndex;\n      }\n    }\n\n    return -1;\n  };\n  /**\r\n   * Creater a new animation range\r\n   * @param name defines the name of the range\r\n   * @param from defines the start key\r\n   * @param to defines the end key\r\n   */\n\n\n  Skeleton.prototype.createAnimationRange = function (name, from, to) {\n    // check name not already in use\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n\n      for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n        if (this.bones[i].animations[0]) {\n          this.bones[i].animations[0].createRange(name, from, to);\n        }\n      }\n    }\n  };\n  /**\r\n   * Delete a specific animation range\r\n   * @param name defines the name of the range\r\n   * @param deleteFrames defines if frames must be removed as well\r\n   */\n\n\n  Skeleton.prototype.deleteAnimationRange = function (name, deleteFrames) {\n    if (deleteFrames === void 0) {\n      deleteFrames = true;\n    }\n\n    for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        this.bones[i].animations[0].deleteRange(name, deleteFrames);\n      }\n    }\n\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  };\n  /**\r\n   * Gets a specific animation range\r\n   * @param name defines the name of the range to look for\r\n   * @returns the requested animation range or null if not found\r\n   */\n\n\n  Skeleton.prototype.getAnimationRange = function (name) {\n    return this._ranges[name] || null;\n  };\n  /**\r\n   * Gets the list of all animation ranges defined on this skeleton\r\n   * @returns an array\r\n   */\n\n\n  Skeleton.prototype.getAnimationRanges = function () {\n    var animationRanges = [];\n    var name;\n\n    for (name in this._ranges) {\n      animationRanges.push(this._ranges[name]);\n    }\n\n    return animationRanges;\n  };\n  /**\r\n   * Copy animation range from a source skeleton.\r\n   * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n   * @param source defines the source skeleton\r\n   * @param name defines the name of the range to copy\r\n   * @param rescaleAsRequired defines if rescaling must be applied if required\r\n   * @returns true if operation was successful\r\n   */\n\n\n  Skeleton.prototype.copyAnimationRange = function (source, name, rescaleAsRequired) {\n    if (rescaleAsRequired === void 0) {\n      rescaleAsRequired = false;\n    }\n\n    if (this._ranges[name] || !source.getAnimationRange(name)) {\n      return false;\n    }\n\n    var ret = true;\n    var frameOffset = this._getHighestAnimationFrame() + 1; // make a dictionary of source skeleton's bones, so exact same order or doublely nested loop is not required\n\n    var boneDict = {};\n    var sourceBones = source.bones;\n    var nBones;\n    var i;\n\n    for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n      boneDict[sourceBones[i].name] = sourceBones[i];\n    }\n\n    if (this.bones.length !== sourceBones.length) {\n      Logger.Warn(\"copyAnimationRange: this rig has \" + this.bones.length + \" bones, while source as \" + sourceBones.length);\n      ret = false;\n    }\n\n    var skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n\n    for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n      var boneName = this.bones[i].name;\n      var sourceBone = boneDict[boneName];\n\n      if (sourceBone) {\n        ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n      } else {\n        Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n        ret = false;\n      }\n    } // do not call createAnimationRange(), since it also is done to bones, which was already done\n\n\n    var range = source.getAnimationRange(name);\n\n    if (range) {\n      this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n    }\n\n    return ret;\n  };\n  /**\r\n   * Forces the skeleton to go to rest pose\r\n   */\n\n\n  Skeleton.prototype.returnToRest = function () {\n    var _localScaling = TmpVectors.Vector3[0];\n    var _localRotation = TmpVectors.Quaternion[0];\n    var _localPosition = TmpVectors.Vector3[1];\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var bone = this.bones[index];\n\n      if (bone._index !== -1) {\n        bone.returnToRest();\n\n        if (bone._linkedTransformNode) {\n          bone.getRestPose().decompose(_localScaling, _localRotation, _localPosition);\n          bone._linkedTransformNode.position = _localPosition.clone();\n          bone._linkedTransformNode.rotationQuaternion = _localRotation.clone();\n          bone._linkedTransformNode.scaling = _localScaling.clone();\n        }\n      }\n    }\n  };\n\n  Skeleton.prototype._getHighestAnimationFrame = function () {\n    var ret = 0;\n\n    for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        var highest = this.bones[i].animations[0].getHighestFrame();\n\n        if (ret < highest) {\n          ret = highest;\n        }\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * Begin a specific animation range\r\n   * @param name defines the name of the range to start\r\n   * @param loop defines if looping must be turned on (false by default)\r\n   * @param speedRatio defines the speed ratio to apply (1 by default)\r\n   * @param onAnimationEnd defines a callback which will be called when animation will end\r\n   * @returns a new animatable\r\n   */\n\n\n  Skeleton.prototype.beginAnimation = function (name, loop, speedRatio, onAnimationEnd) {\n    var range = this.getAnimationRange(name);\n\n    if (!range) {\n      return null;\n    }\n\n    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n  };\n  /**\r\n   * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n   * @param skeleton defines the Skeleton containing the animation range to convert\r\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n   * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n   * @returns the original skeleton\r\n   */\n\n\n  Skeleton.MakeAnimationAdditive = function (skeleton, referenceFrame, range) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    var rangeValue = skeleton.getAnimationRange(range); // We can't make a range additive if it doesn't exist\n\n    if (!rangeValue) {\n      return null;\n    } // Find any current scene-level animatable belonging to the target that matches the range\n\n\n    var sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n\n    var rangeAnimatable = null;\n\n    for (var index = 0; index < sceneAnimatables.length; index++) {\n      var sceneAnimatable = sceneAnimatables[index];\n\n      if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {\n        rangeAnimatable = sceneAnimatable;\n        break;\n      }\n    } // Convert the animations belonging to the skeleton to additive keyframes\n\n\n    var animatables = skeleton.getAnimatables();\n\n    for (var index = 0; index < animatables.length; index++) {\n      var animatable = animatables[index];\n      var animations = animatable.animations;\n\n      if (!animations) {\n        continue;\n      }\n\n      for (var animIndex = 0; animIndex < animations.length; animIndex++) {\n        Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n      }\n    } // Mark the scene-level animatable as additive\n\n\n    if (rangeAnimatable) {\n      rangeAnimatable.isAdditive = true;\n    }\n\n    return skeleton;\n  };\n  /** @hidden */\n\n\n  Skeleton.prototype._markAsDirty = function () {\n    this._isDirty = true;\n  };\n  /** @hidden */\n\n\n  Skeleton.prototype._registerMeshWithPoseMatrix = function (mesh) {\n    this._meshesWithPoseMatrix.push(mesh);\n  };\n  /** @hidden */\n\n\n  Skeleton.prototype._unregisterMeshWithPoseMatrix = function (mesh) {\n    var index = this._meshesWithPoseMatrix.indexOf(mesh);\n\n    if (index > -1) {\n      this._meshesWithPoseMatrix.splice(index, 1);\n    }\n  };\n\n  Skeleton.prototype._computeTransformMatrices = function (targetMatrix, initialSkinMatrix) {\n    this.onBeforeComputeObservable.notifyObservers(this);\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var bone = this.bones[index];\n      bone._childUpdateId++;\n      var parentBone = bone.getParent();\n\n      if (parentBone) {\n        bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\n      } else {\n        if (initialSkinMatrix) {\n          bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\n        } else {\n          bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\n        }\n      }\n\n      if (bone._index !== -1) {\n        var mappedIndex = bone._index === null ? index : bone._index;\n        bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);\n      }\n    }\n\n    this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n  };\n  /**\r\n   * Build all resources required to render a skeleton\r\n   */\n\n\n  Skeleton.prototype.prepare = function () {\n    // Update the local matrix of bones with linked transform nodes.\n    if (this._numBonesWithLinkedTransformNode > 0) {\n      for (var _i = 0, _a = this.bones; _i < _a.length; _i++) {\n        var bone_1 = _a[_i];\n\n        if (bone_1._linkedTransformNode) {\n          // Computing the world matrix also computes the local matrix.\n          bone_1._linkedTransformNode.computeWorldMatrix();\n\n          bone_1._matrix = bone_1._linkedTransformNode._localMatrix;\n          bone_1.markAsDirty();\n        }\n      }\n    }\n\n    if (!this._isDirty) {\n      return;\n    }\n\n    if (this.needInitialSkinMatrix) {\n      for (var index = 0; index < this._meshesWithPoseMatrix.length; index++) {\n        var mesh = this._meshesWithPoseMatrix[index];\n        var poseMatrix = mesh.getPoseMatrix();\n\n        if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n          mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n        }\n\n        if (this._synchronizedWithMesh !== mesh) {\n          this._synchronizedWithMesh = mesh; // Prepare bones\n\n          for (var boneIndex = 0; boneIndex < this.bones.length; boneIndex++) {\n            var bone = this.bones[boneIndex];\n\n            if (!bone.getParent()) {\n              var matrix = bone.getBaseMatrix();\n              matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n\n              bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);\n            }\n          }\n\n          if (this.isUsingTextureForMatrices) {\n            var textureWidth = (this.bones.length + 1) * 4;\n\n            if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n              if (mesh._transformMatrixTexture) {\n                mesh._transformMatrixTexture.dispose();\n              }\n\n              mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n            }\n          }\n        }\n\n        this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n\n        if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n          mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n        }\n      }\n    } else {\n      if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n        this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n\n        if (this.isUsingTextureForMatrices) {\n          if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n          }\n\n          this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n        }\n      }\n\n      this._computeTransformMatrices(this._transformMatrices, null);\n\n      if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n        this._transformMatrixTexture.update(this._transformMatrices);\n      }\n    }\n\n    this._isDirty = false;\n\n    this._scene._activeBones.addCount(this.bones.length, false);\n  };\n  /**\r\n   * Gets the list of animatables currently running for this skeleton\r\n   * @returns an array of animatables\r\n   */\n\n\n  Skeleton.prototype.getAnimatables = function () {\n    if (!this._animatables || this._animatables.length !== this.bones.length) {\n      this._animatables = [];\n\n      for (var index = 0; index < this.bones.length; index++) {\n        this._animatables.push(this.bones[index]);\n      }\n    }\n\n    return this._animatables;\n  };\n  /**\r\n   * Clone the current skeleton\r\n   * @param name defines the name of the new skeleton\r\n   * @param id defines the id of the new skeleton\r\n   * @returns the new skeleton\r\n   */\n\n\n  Skeleton.prototype.clone = function (name, id) {\n    var result = new Skeleton(name, id || name, this._scene);\n    result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    result.overrideMesh = this.overrideMesh;\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var source = this.bones[index];\n      var parentBone = null;\n      var parent_1 = source.getParent();\n\n      if (parent_1) {\n        var parentIndex = this.bones.indexOf(parent_1);\n        parentBone = result.bones[parentIndex];\n      }\n\n      var bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\n      bone._index = source._index;\n\n      if (source._linkedTransformNode) {\n        bone.linkTransformNode(source._linkedTransformNode);\n      }\n\n      DeepCopier.DeepCopy(source.animations, bone.animations);\n    }\n\n    if (this._ranges) {\n      result._ranges = {};\n\n      for (var rangeName in this._ranges) {\n        var range = this._ranges[rangeName];\n\n        if (range) {\n          result._ranges[rangeName] = range.clone();\n        }\n      }\n    }\n\n    this._isDirty = true;\n    return result;\n  };\n  /**\r\n   * Enable animation blending for this skeleton\r\n   * @param blendingSpeed defines the blending speed to apply\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n   */\n\n\n  Skeleton.prototype.enableBlending = function (blendingSpeed) {\n    if (blendingSpeed === void 0) {\n      blendingSpeed = 0.01;\n    }\n\n    this.bones.forEach(function (bone) {\n      bone.animations.forEach(function (animation) {\n        animation.enableBlending = true;\n        animation.blendingSpeed = blendingSpeed;\n      });\n    });\n  };\n  /**\r\n   * Releases all resources associated with the current skeleton\r\n   */\n\n\n  Skeleton.prototype.dispose = function () {\n    this._meshesWithPoseMatrix = []; // Animations\n\n    this.getScene().stopAnimation(this); // Remove from scene\n\n    this.getScene().removeSkeleton(this);\n\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n\n      this._transformMatrixTexture = null;\n    }\n  };\n  /**\r\n   * Serialize the skeleton in a JSON object\r\n   * @returns a JSON object\r\n   */\n\n\n  Skeleton.prototype.serialize = function () {\n    var _a, _b;\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n\n    if (this.dimensionsAtRest) {\n      serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n    }\n\n    serializationObject.bones = [];\n    serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    serializationObject.overrideMeshId = (_a = this.overrideMesh) === null || _a === void 0 ? void 0 : _a.id;\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var bone = this.bones[index];\n      var parent_2 = bone.getParent();\n      var serializedBone = {\n        parentBoneIndex: parent_2 ? this.bones.indexOf(parent_2) : -1,\n        index: bone.getIndex(),\n        name: bone.name,\n        matrix: bone.getBaseMatrix().toArray(),\n        rest: bone.getRestPose().toArray(),\n        linkedTransformNodeId: (_b = bone.getTransformNode()) === null || _b === void 0 ? void 0 : _b.id\n      };\n      serializationObject.bones.push(serializedBone);\n\n      if (bone.length) {\n        serializedBone.length = bone.length;\n      }\n\n      if (bone.metadata) {\n        serializedBone.metadata = bone.metadata;\n      }\n\n      if (bone.animations && bone.animations.length > 0) {\n        serializedBone.animation = bone.animations[0].serialize();\n      }\n\n      serializationObject.ranges = [];\n\n      for (var name in this._ranges) {\n        var source = this._ranges[name];\n\n        if (!source) {\n          continue;\n        }\n\n        var range = {};\n        range.name = name;\n        range.from = source.from;\n        range.to = source.to;\n        serializationObject.ranges.push(range);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Creates a new skeleton from serialized data\r\n   * @param parsedSkeleton defines the serialized data\r\n   * @param scene defines the hosting scene\r\n   * @returns a new skeleton\r\n   */\n\n\n  Skeleton.Parse = function (parsedSkeleton, scene) {\n    var skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n\n    if (parsedSkeleton.dimensionsAtRest) {\n      skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n    }\n\n    skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n\n    if (parsedSkeleton.overrideMeshId) {\n      skeleton._hasWaitingData = true;\n      skeleton._waitingOverrideMeshId = parsedSkeleton.overrideMeshId;\n    }\n\n    var index;\n\n    for (index = 0; index < parsedSkeleton.bones.length; index++) {\n      var parsedBone = parsedSkeleton.bones[index];\n      var parsedBoneIndex = parsedSkeleton.bones[index].index;\n      var parentBone = null;\n\n      if (parsedBone.parentBoneIndex > -1) {\n        parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n      }\n\n      var rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n      var bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n\n      if (parsedBone.id !== undefined && parsedBone.id !== null) {\n        bone.id = parsedBone.id;\n      }\n\n      if (parsedBone.length) {\n        bone.length = parsedBone.length;\n      }\n\n      if (parsedBone.metadata) {\n        bone.metadata = parsedBone.metadata;\n      }\n\n      if (parsedBone.animation) {\n        bone.animations.push(Animation.Parse(parsedBone.animation));\n      }\n\n      if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n        skeleton._hasWaitingData = true;\n        bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n      }\n    } // placed after bones, so createAnimationRange can cascade down\n\n\n    if (parsedSkeleton.ranges) {\n      for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n        var data = parsedSkeleton.ranges[index];\n        skeleton.createAnimationRange(data.name, data.from, data.to);\n      }\n    }\n\n    return skeleton;\n  };\n  /**\r\n   * Compute all node absolute transforms\r\n   * @param forceUpdate defines if computation must be done even if cache is up to date\r\n   */\n\n\n  Skeleton.prototype.computeAbsoluteTransforms = function (forceUpdate) {\n    if (forceUpdate === void 0) {\n      forceUpdate = false;\n    }\n\n    var renderId = this._scene.getRenderId();\n\n    if (this._lastAbsoluteTransformsUpdateId != renderId || forceUpdate) {\n      this.bones[0].computeAbsoluteTransforms();\n      this._lastAbsoluteTransformsUpdateId = renderId;\n    }\n  };\n  /**\r\n   * Gets the root pose matrix\r\n   * @returns a matrix\r\n   */\n\n\n  Skeleton.prototype.getPoseMatrix = function () {\n    var poseMatrix = null;\n\n    if (this._meshesWithPoseMatrix.length > 0) {\n      poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n    }\n\n    return poseMatrix;\n  };\n  /**\r\n   * Sorts bones per internal index\r\n   */\n\n\n  Skeleton.prototype.sortBones = function () {\n    var bones = new Array();\n    var visited = new Array(this.bones.length);\n\n    for (var index = 0; index < this.bones.length; index++) {\n      this._sortBones(index, bones, visited);\n    }\n\n    this.bones = bones;\n  };\n\n  Skeleton.prototype._sortBones = function (index, bones, visited) {\n    if (visited[index]) {\n      return;\n    }\n\n    visited[index] = true;\n    var bone = this.bones[index];\n\n    if (bone._index === undefined) {\n      bone._index = index;\n    }\n\n    var parentBone = bone.getParent();\n\n    if (parentBone) {\n      this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n    }\n\n    bones.push(bone);\n  };\n  /**\r\n   * Set the current local matrix as the restPose for all bones in the skeleton.\r\n   */\n\n\n  Skeleton.prototype.setCurrentPoseAsRest = function () {\n    this.bones.forEach(function (b) {\n      b.setCurrentPoseAsRest();\n    });\n  };\n\n  return Skeleton;\n}();\n\nexport { Skeleton };","map":null,"metadata":{},"sourceType":"module"}