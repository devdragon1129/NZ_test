{"ast":null,"code":"import { Scalar } from \"../Maths/math.scalar\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { Logger } from \"../Misc/logger\";\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\nimport { BaseTexture } from '../Materials/Textures/baseTexture';\nimport \"../Engines/Extensions/engine.cubeTexture\";\nimport { ThinEngine } from '../Engines/thinEngine'; // Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\nvar DDS_MAGIC = 0x20534444;\nvar //DDSD_CAPS = 0x1,\n//DDSD_HEIGHT = 0x2,\n//DDSD_WIDTH = 0x4,\n//DDSD_PITCH = 0x8,\n//DDSD_PIXELFORMAT = 0x1000,\nDDSD_MIPMAPCOUNT = 0x20000; //DDSD_LINEARSIZE = 0x80000,\n//DDSD_DEPTH = 0x800000;\n// var DDSCAPS_COMPLEX = 0x8,\n//     DDSCAPS_MIPMAP = 0x400000,\n//     DDSCAPS_TEXTURE = 0x1000;\n\nvar DDSCAPS2_CUBEMAP = 0x200; // DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n// DDSCAPS2_VOLUME = 0x200000;\n\nvar //DDPF_ALPHAPIXELS = 0x1,\n//DDPF_ALPHA = 0x2,\nDDPF_FOURCC = 0x4,\n    DDPF_RGB = 0x40,\n    //DDPF_YUV = 0x200,\nDDPF_LUMINANCE = 0x20000;\n\nfunction FourCCToInt32(value) {\n  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\n\nfunction Int32ToFourCC(value) {\n  return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n}\n\nvar FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\nvar FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\nvar FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\nvar FOURCC_DX10 = FourCCToInt32(\"DX10\");\nvar FOURCC_D3DFMT_R16G16B16A16F = 113;\nvar FOURCC_D3DFMT_R32G32B32A32F = 116;\nvar DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\nvar DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\nvar DXGI_FORMAT_B8G8R8X8_UNORM = 88;\nvar headerLengthInt = 31; // The header length in 32 bit ints\n// Offsets into the header array\n\nvar off_magic = 0;\nvar off_size = 1;\nvar off_flags = 2;\nvar off_height = 3;\nvar off_width = 4;\nvar off_mipmapCount = 7;\nvar off_pfFlags = 20;\nvar off_pfFourCC = 21;\nvar off_RGBbpp = 22;\nvar off_RMask = 23;\nvar off_GMask = 24;\nvar off_BMask = 25;\nvar off_AMask = 26; // var off_caps1 = 27;\n\nvar off_caps2 = 28; // var off_caps3 = 29;\n// var off_caps4 = 30;\n\nvar off_dxgiFormat = 32;\n/**\r\n * Class used to provide DDS decompression tools\r\n */\n\nvar DDSTools =\n/** @class */\nfunction () {\n  function DDSTools() {}\n  /**\r\n   * Gets DDS information from an array buffer\r\n   * @param data defines the array buffer view to read data from\r\n   * @returns the DDS information\r\n   */\n\n\n  DDSTools.GetDDSInfo = function (data) {\n    var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    var extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\n    var mipmapCount = 1;\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n\n    var fourCC = header[off_pfFourCC];\n    var dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\n    var textureType = 0;\n\n    switch (fourCC) {\n      case FOURCC_D3DFMT_R16G16B16A16F:\n        textureType = 2;\n        break;\n\n      case FOURCC_D3DFMT_R32G32B32A32F:\n        textureType = 1;\n        break;\n\n      case FOURCC_DX10:\n        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n          textureType = 2;\n          break;\n        }\n\n        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\n          textureType = 1;\n          break;\n        }\n\n    }\n\n    return {\n      width: header[off_width],\n      height: header[off_height],\n      mipmapCount: mipmapCount,\n      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\n      dxgiFormat: dxgiFormat,\n      textureType: textureType\n    };\n  };\n\n  DDSTools._ToHalfFloat = function (value) {\n    if (!DDSTools._FloatView) {\n      DDSTools._FloatView = new Float32Array(1);\n      DDSTools._Int32View = new Int32Array(DDSTools._FloatView.buffer);\n    }\n\n    DDSTools._FloatView[0] = value;\n    var x = DDSTools._Int32View[0];\n    var bits = x >> 16 & 0x8000;\n    /* Get the sign */\n\n    var m = x >> 12 & 0x07ff;\n    /* Keep one extra bit for rounding */\n\n    var e = x >> 23 & 0xff;\n    /* Using int is faster here */\n\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n    * half, return signed zero. */\n\n    if (e < 103) {\n      return bits;\n    }\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n\n    if (e > 142) {\n      bits |= 0x7c00;\n      /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n      * not Inf, so make sure we set one mantissa bit too. */\n\n      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n      return bits;\n    }\n    /* If exponent underflows but not too much, return a denormal */\n\n\n    if (e < 113) {\n      m |= 0x0800;\n      /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n      * to 1, which is OK. */\n\n      bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n      return bits;\n    }\n\n    bits |= e - 112 << 10 | m >> 1;\n    bits += m & 1;\n    return bits;\n  };\n\n  DDSTools._FromHalfFloat = function (value) {\n    var s = (value & 0x8000) >> 15;\n    var e = (value & 0x7C00) >> 10;\n    var f = value & 0x03FF;\n\n    if (e === 0) {\n      return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n    } else if (e == 0x1F) {\n      return f ? NaN : (s ? -1 : 1) * Infinity;\n    }\n\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n  };\n\n  DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Float32Array(dataLength);\n    var srcData = new Uint16Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = DDSTools._FromHalfFloat(srcData[srcPos]);\n        destArray[index + 1] = DDSTools._FromHalfFloat(srcData[srcPos + 1]);\n        destArray[index + 2] = DDSTools._FromHalfFloat(srcData[srcPos + 2]);\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = DDSTools._FromHalfFloat(srcData[srcPos + 3]);\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetHalfFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      var destArray = new Uint16Array(dataLength);\n      var srcData = new Uint16Array(arrayBuffer, dataOffset);\n      var index = 0;\n\n      for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n          var srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = DDSTools._ToHalfFloat(lod);\n          index += 4;\n        }\n      }\n\n      return destArray;\n    }\n\n    return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n  };\n\n  DDSTools._GetFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      var destArray = new Float32Array(dataLength);\n      var srcData = new Float32Array(arrayBuffer, dataOffset);\n      var index = 0;\n\n      for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n          var srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = lod;\n          index += 4;\n        }\n      }\n\n      return destArray;\n    }\n\n    return new Float32Array(arrayBuffer, dataOffset, dataLength);\n  };\n\n  DDSTools._GetFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Uint8Array(dataLength);\n    var srcData = new Float32Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\n        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\n        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Uint8Array(dataLength);\n    var srcData = new Uint16Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos])) * 255;\n        destArray[index + 1] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 1])) * 255;\n        destArray[index + 2] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 2])) * 255;\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 3])) * 255;\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        byteArray[index + 3] = srcData[srcPos + aOffset];\n        index += 4;\n      }\n    }\n\n    return byteArray;\n  };\n\n  DDSTools._ExtractLongWordOrder = function (value) {\n    if (value === 0 || value === 255 || value === -16777216) {\n      return 0;\n    }\n\n    return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\n  };\n\n  DDSTools._GetRGBArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 3;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        index += 3;\n      }\n    }\n\n    return byteArray;\n  };\n\n  DDSTools._GetLuminanceArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = x + y * width;\n        byteArray[index] = srcData[srcPos];\n        index++;\n      }\n    }\n\n    return byteArray;\n  };\n  /**\r\n   * Uploads DDS Levels to a Babylon Texture\r\n   * @hidden\r\n   */\n\n\n  DDSTools.UploadDDSLevels = function (engine, texture, data, info, loadMipmaps, faces, lodIndex, currentFace) {\n    if (lodIndex === void 0) {\n      lodIndex = -1;\n    }\n\n    var sphericalPolynomialFaces = null;\n\n    if (info.sphericalPolynomial) {\n      sphericalPolynomialFaces = new Array();\n    }\n\n    var ext = engine.getCaps().s3tc;\n    var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    var fourCC,\n        width,\n        height,\n        dataLength = 0,\n        dataOffset;\n    var byteArray, mipmapCount, mip;\n    var internalCompressedFormat = 0;\n    var blockBytes = 1;\n\n    if (header[off_magic] !== DDS_MAGIC) {\n      Logger.Error(\"Invalid magic number in DDS header\");\n      return;\n    }\n\n    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n      Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n      return;\n    }\n\n    if (info.isCompressed && !ext) {\n      Logger.Error(\"Compressed textures are not supported on this platform.\");\n      return;\n    }\n\n    var bpp = header[off_RGBbpp];\n    dataOffset = header[off_size] + 4;\n    var computeFormats = false;\n\n    if (info.isFourCC) {\n      fourCC = header[off_pfFourCC];\n\n      switch (fourCC) {\n        case FOURCC_DXT1:\n          blockBytes = 8;\n          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n          break;\n\n        case FOURCC_DXT3:\n          blockBytes = 16;\n          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          break;\n\n        case FOURCC_DXT5:\n          blockBytes = 16;\n          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n          break;\n\n        case FOURCC_D3DFMT_R16G16B16A16F:\n          computeFormats = true;\n          break;\n\n        case FOURCC_D3DFMT_R32G32B32A32F:\n          computeFormats = true;\n          break;\n\n        case FOURCC_DX10:\n          // There is an additionnal header so dataOffset need to be changed\n          dataOffset += 5 * 4; // 5 uints\n\n          var supported = false;\n\n          switch (info.dxgiFormat) {\n            case DXGI_FORMAT_R16G16B16A16_FLOAT:\n            case DXGI_FORMAT_R32G32B32A32_FLOAT:\n              computeFormats = true;\n              supported = true;\n              break;\n\n            case DXGI_FORMAT_B8G8R8X8_UNORM:\n              info.isRGB = true;\n              info.isFourCC = false;\n              bpp = 32;\n              supported = true;\n              break;\n          }\n\n          if (supported) {\n            break;\n          }\n\n        default:\n          console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\n          return;\n      }\n    }\n\n    var rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\n\n    var gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\n\n    var bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\n\n    var aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\n\n    if (computeFormats) {\n      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n    }\n\n    mipmapCount = 1;\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n\n    var startFace = currentFace || 0;\n\n    for (var face = startFace; face < faces; face++) {\n      width = header[off_width];\n      height = header[off_height];\n\n      for (mip = 0; mip < mipmapCount; ++mip) {\n        if (lodIndex === -1 || lodIndex === mip) {\n          // In case of fixed LOD, if the lod has just been uploaded, early exit.\n          var i = lodIndex === -1 ? mip : 0;\n\n          if (!info.isCompressed && info.isFourCC) {\n            texture.format = 5;\n            dataLength = width * height * 4;\n            var floatArray = null;\n\n            if (engine._badOS || engine._badDesktopOS || !engine.getCaps().textureHalfFloat && !engine.getCaps().textureFloat) {\n              // Required because iOS has many issues with float and half float generation\n              if (bpp === 128) {\n                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              } else if (bpp === 64) {\n                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              }\n\n              texture.type = 0;\n            } else {\n              if (bpp === 128) {\n                texture.type = 1;\n                floatArray = DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(floatArray);\n                }\n              } else if (bpp === 64 && !engine.getCaps().textureHalfFloat) {\n                texture.type = 1;\n                floatArray = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(floatArray);\n                }\n              } else {\n                // 64\n                texture.type = 2;\n                floatArray = DDSTools._GetHalfFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, data.buffer, i));\n                }\n              }\n            }\n\n            if (floatArray) {\n              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\n            }\n          } else if (info.isRGB) {\n            texture.type = 0;\n\n            if (bpp === 24) {\n              texture.format = 4;\n              dataLength = width * height * 3;\n              byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\n\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            } else {\n              // 32\n              texture.format = 5;\n              dataLength = width * height * 4;\n              byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\n\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            }\n          } else if (info.isLuminance) {\n            var unpackAlignment = engine._getUnpackAlignement();\n\n            var unpaddedRowSize = width;\n            var paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n            byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\n            texture.format = 1;\n            texture.type = 0;\n\n            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n          } else {\n            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\n            texture.type = 0;\n\n            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\n          }\n        }\n\n        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\n        width *= 0.5;\n        height *= 0.5;\n        width = Math.max(1.0, width);\n        height = Math.max(1.0, height);\n      }\n\n      if (currentFace !== undefined) {\n        // Loading a single face\n        break;\n      }\n    }\n\n    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\n      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n        size: header[off_width],\n        right: sphericalPolynomialFaces[0],\n        left: sphericalPolynomialFaces[1],\n        up: sphericalPolynomialFaces[2],\n        down: sphericalPolynomialFaces[3],\n        front: sphericalPolynomialFaces[4],\n        back: sphericalPolynomialFaces[5],\n        format: 5,\n        type: 1,\n        gammaSpace: false\n      });\n    } else {\n      info.sphericalPolynomial = undefined;\n    }\n  };\n  /**\r\n   * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\r\n   */\n\n\n  DDSTools.StoreLODInAlphaChannel = false;\n  return DDSTools;\n}();\n\nexport { DDSTools };\n/**\r\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n * @param rootUrl defines the url where the file to load is located\r\n * @param scene defines the current scene\r\n * @param lodScale defines scale to apply to the mip map selection\r\n * @param lodOffset defines offset to apply to the mip map selection\r\n * @param onLoad defines an optional callback raised when the texture is loaded\r\n * @param onError defines an optional callback raised if there is an issue to load the texture\r\n * @param format defines the format of the data\r\n * @param forcedExtension defines the extension to use to pick the right loader\r\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n * @returns the cube texture as an InternalTexture\r\n */\n\nThinEngine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, createPolynomials) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (forcedExtension === void 0) {\n    forcedExtension = null;\n  }\n\n  if (createPolynomials === void 0) {\n    createPolynomials = true;\n  }\n\n  var callback = function callback(loadData) {\n    if (!loadData) {\n      if (onLoad) {\n        onLoad(null);\n      }\n\n      return;\n    }\n\n    var texture = loadData.texture;\n\n    if (!createPolynomials) {\n      texture._sphericalPolynomial = new SphericalPolynomial();\n    } else if (loadData.info.sphericalPolynomial) {\n      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\n    }\n\n    texture._source = InternalTextureSource.CubePrefiltered;\n\n    if (_this.getCaps().textureLOD) {\n      // Do not add extra process if texture lod is supported.\n      if (onLoad) {\n        onLoad(texture);\n      }\n\n      return;\n    }\n\n    var mipSlices = 3;\n    var gl = _this._gl;\n    var width = loadData.width;\n\n    if (!width) {\n      return;\n    }\n\n    var textures = [];\n\n    for (var i = 0; i < mipSlices; i++) {\n      //compute LOD from even spacing in smoothness (matching shader calculation)\n      var smoothness = i / (mipSlices - 1);\n      var roughness = 1 - smoothness;\n      var minLODIndex = lodOffset; // roughness = 0\n\n      var maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\n\n      var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n      var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n      var glTextureFromLod = new InternalTexture(_this, InternalTextureSource.Temp);\n      glTextureFromLod.type = texture.type;\n      glTextureFromLod.format = texture.format;\n      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\n      glTextureFromLod.height = glTextureFromLod.width;\n      glTextureFromLod.isCube = true;\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\n\n      glTextureFromLod.samplingMode = 2;\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      if (loadData.isDDS) {\n        var info = loadData.info;\n        var data = loadData.data;\n\n        _this._unpackFlipY(info.isCompressed);\n\n        DDSTools.UploadDDSLevels(_this, glTextureFromLod, data, info, true, 6, mipmapIndex);\n      } else {\n        Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null); // Wrap in a base texture for easy binding.\n\n\n      var lodTexture = new BaseTexture(scene);\n      lodTexture.isCube = true;\n      lodTexture._texture = glTextureFromLod;\n      glTextureFromLod.isReady = true;\n      textures.push(lodTexture);\n    }\n\n    texture._lodTextureHigh = textures[2];\n    texture._lodTextureMid = textures[1];\n    texture._lodTextureLow = textures[0];\n\n    if (onLoad) {\n      onLoad(texture);\n    }\n  };\n\n  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\n};","map":null,"metadata":{},"sourceType":"module"}