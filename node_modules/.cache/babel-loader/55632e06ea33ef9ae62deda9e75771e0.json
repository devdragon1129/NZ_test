{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PanoramaToCubeMapTools } from '../../Misc/HighDynamicRange/panoramaToCubemap';\nimport { BaseTexture } from './baseTexture';\nimport { Texture } from './texture';\nimport { Tools } from '../../Misc/tools';\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\r\n */\n\nvar EquiRectangularCubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(EquiRectangularCubeTexture, _super);\n  /**\r\n   * Instantiates an EquiRectangularCubeTexture from the following parameters.\r\n   * @param url The location of the image\r\n   * @param scene The scene the texture will be used in\r\n   * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n   * @param noMipmap Forces to not generate the mipmap if true\r\n   * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n   * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n   * @param onLoad — defines a callback called when texture is loaded\r\n   * @param onError — defines a callback called if there is an error\r\n   */\n\n\n  function EquiRectangularCubeTexture(url, scene, size, noMipmap, gammaSpace, onLoad, onError) {\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (gammaSpace === void 0) {\n      gammaSpace = true;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _this = _super.call(this, scene) || this;\n\n    _this._onLoad = null;\n    _this._onError = null;\n\n    if (!url) {\n      throw new Error('Image url is not set');\n    }\n\n    _this._coordinatesMode = Texture.CUBIC_MODE;\n    _this.name = url;\n    _this.url = url;\n    _this._size = size;\n    _this._noMipmap = noMipmap;\n    _this.gammaSpace = gammaSpace;\n    _this._onLoad = onLoad;\n    _this._onError = onError;\n    _this.hasAlpha = false;\n    _this.isCube = true;\n    _this._texture = _this._getFromCache(url, _this._noMipmap);\n\n    if (!_this._texture) {\n      if (!scene.useDelayedTextureLoading) {\n        _this.loadImage(_this.loadTexture.bind(_this), _this._onError);\n      } else {\n        _this.delayLoadState = 4;\n      }\n    } else if (onLoad) {\n      if (_this._texture.isReady) {\n        Tools.SetImmediate(function () {\n          return onLoad();\n        });\n      } else {\n        _this._texture.onLoadedObservable.add(onLoad);\n      }\n    }\n\n    return _this;\n  }\n  /**\r\n   * Load the image data, by putting the image on a canvas and extracting its buffer.\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.loadImage = function (loadTextureCallback, onError) {\n    var _this = this;\n\n    var canvas = document.createElement('canvas');\n    var image = new Image();\n    image.addEventListener('load', function () {\n      _this._width = image.width;\n      _this._height = image.height;\n      canvas.width = _this._width;\n      canvas.height = _this._height;\n      var ctx = canvas.getContext('2d');\n      ctx.drawImage(image, 0, 0);\n      var imageData = ctx.getImageData(0, 0, image.width, image.height);\n      _this._buffer = imageData.data.buffer;\n      canvas.remove();\n      loadTextureCallback();\n    });\n    image.addEventListener('error', function (error) {\n      if (onError) {\n        onError(_this.getClassName() + \" could not be loaded\", error);\n      }\n    });\n    image.src = this.url;\n  };\n  /**\r\n   * Convert the image buffer into a cubemap and create a CubeTexture.\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.loadTexture = function () {\n    var _this = this;\n\n    var scene = this.getScene();\n\n    var callback = function callback() {\n      var imageData = _this.getFloat32ArrayFromArrayBuffer(_this._buffer); // Extract the raw linear data.\n\n\n      var data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, _this._width, _this._height, _this._size);\n      var results = []; // Push each faces.\n\n      for (var i = 0; i < 6; i++) {\n        var dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];\n        results.push(dataFace);\n      }\n\n      return results;\n    };\n\n    if (!scene) {\n      return;\n    }\n\n    this._texture = scene.getEngine().createRawCubeTextureFromUrl(this.url, scene, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, callback, null, this._onLoad, this._onError);\n  };\n  /**\r\n   * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\r\n   * @param buffer The ArrayBuffer that should be converted.\r\n   * @returns The buffer as Float32Array.\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.getFloat32ArrayFromArrayBuffer = function (buffer) {\n    var dataView = new DataView(buffer);\n    var floatImageData = new Float32Array(buffer.byteLength * 3 / 4);\n    var k = 0;\n\n    for (var i = 0; i < buffer.byteLength; i++) {\n      // We drop the transparency channel, because we do not need/want it\n      if ((i + 1) % 4 !== 0) {\n        floatImageData[k++] = dataView.getUint8(i) / 255;\n      }\n    }\n\n    return floatImageData;\n  };\n  /**\r\n   * Get the current class name of the texture useful for serialization or dynamic coding.\r\n   * @returns \"EquiRectangularCubeTexture\"\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.getClassName = function () {\n    return \"EquiRectangularCubeTexture\";\n  };\n  /**\r\n   * Create a clone of the current EquiRectangularCubeTexture and return it.\r\n   * @returns A clone of the current EquiRectangularCubeTexture.\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.clone = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this;\n    }\n\n    var newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace); // Base texture\n\n    newTexture.level = this.level;\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    newTexture.coordinatesIndex = this.coordinatesIndex;\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  };\n  /** The six faces of the cube. */\n\n\n  EquiRectangularCubeTexture._FacesMapping = ['right', 'left', 'up', 'down', 'front', 'back'];\n  return EquiRectangularCubeTexture;\n}(BaseTexture);\n\nexport { EquiRectangularCubeTexture };","map":null,"metadata":{},"sourceType":"module"}