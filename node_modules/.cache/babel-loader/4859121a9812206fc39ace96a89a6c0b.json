{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Mesh } from \"../Meshes/mesh\";\n\nMesh._GroundMeshParser = function (parsedMesh, scene) {\n  return GroundMesh.Parse(parsedMesh, scene);\n};\n/**\r\n * Mesh representing the gorund\r\n */\n\n\nvar GroundMesh =\n/** @class */\nfunction (_super) {\n  __extends(GroundMesh, _super);\n\n  function GroundMesh(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /** If octree should be generated */\n\n\n    _this.generateOctree = false;\n    return _this;\n  }\n  /**\r\n   * \"GroundMesh\"\r\n   * @returns \"GroundMesh\"\r\n   */\n\n\n  GroundMesh.prototype.getClassName = function () {\n    return \"GroundMesh\";\n  };\n\n  Object.defineProperty(GroundMesh.prototype, \"subdivisions\", {\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\n    get: function get() {\n      return Math.min(this._subdivisionsX, this._subdivisionsY);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GroundMesh.prototype, \"subdivisionsX\", {\n    /**\r\n     * X subdivisions\r\n     */\n    get: function get() {\n      return this._subdivisionsX;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GroundMesh.prototype, \"subdivisionsY\", {\n    /**\r\n     * Y subdivisions\r\n     */\n    get: function get() {\n      return this._subdivisionsY;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n   * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n   * @param chunksCount the number of subdivisions for x and y\r\n   * @param octreeBlocksSize (Default: 32)\r\n   */\n\n  GroundMesh.prototype.optimize = function (chunksCount, octreeBlocksSize) {\n    if (octreeBlocksSize === void 0) {\n      octreeBlocksSize = 32;\n    }\n\n    this._subdivisionsX = chunksCount;\n    this._subdivisionsY = chunksCount;\n    this.subdivide(chunksCount); // Call the octree system optimization if it is defined.\n\n    var thisAsAny = this;\n\n    if (thisAsAny.createOrUpdateSubmeshesOctree) {\n      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\n    }\n  };\n  /**\r\n   * Returns a height (y) value in the Worl system :\r\n   * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n   * @param x x coordinate\r\n   * @param z z coordinate\r\n   * @returns the ground y position if (x, z) are outside the ground surface.\r\n   */\n\n\n  GroundMesh.prototype.getHeightAtCoordinates = function (x, z) {\n    var world = this.getWorldMatrix();\n    var invMat = TmpVectors.Matrix[5];\n    world.invertToRef(invMat);\n    var tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\n\n    x = tmpVect.x;\n    z = tmpVect.z;\n\n    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n      return this.position.y;\n    }\n\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n\n      this._computeHeightQuads();\n    }\n\n    var facet = this._getFacetAt(x, z);\n\n    var y = -(facet.x * x + facet.z * z + facet.w) / facet.y; // return y in the World system\n\n    Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\n    return tmpVect.y;\n  };\n  /**\r\n   * Returns a normalized vector (Vector3) orthogonal to the ground\r\n   * at the ground coordinates (x, z) expressed in the World system.\r\n   * @param x x coordinate\r\n   * @param z z coordinate\r\n   * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n   */\n\n\n  GroundMesh.prototype.getNormalAtCoordinates = function (x, z) {\n    var normal = new Vector3(0.0, 1.0, 0.0);\n    this.getNormalAtCoordinatesToRef(x, z, normal);\n    return normal;\n  };\n  /**\r\n   * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n   * at the ground coordinates (x, z) expressed in the World system.\r\n   * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.\r\n   * @param x x coordinate\r\n   * @param z z coordinate\r\n   * @param ref vector to store the result\r\n   * @returns the GroundMesh.\r\n   */\n\n\n  GroundMesh.prototype.getNormalAtCoordinatesToRef = function (x, z, ref) {\n    var world = this.getWorldMatrix();\n    var tmpMat = TmpVectors.Matrix[5];\n    world.invertToRef(tmpMat);\n    var tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\n\n    x = tmpVect.x;\n    z = tmpVect.z;\n\n    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n      return this;\n    }\n\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n\n      this._computeHeightQuads();\n    }\n\n    var facet = this._getFacetAt(x, z);\n\n    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\n    return this;\n  };\n  /**\r\n  * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n  * if the ground has been updated.\r\n  * This can be used in the render loop.\r\n  * @returns the GroundMesh.\r\n  */\n\n\n  GroundMesh.prototype.updateCoordinateHeights = function () {\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n    }\n\n    this._computeHeightQuads();\n\n    return this;\n  }; // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\n\n\n  GroundMesh.prototype._getFacetAt = function (x, z) {\n    // retrieve col and row from x, z coordinates in the ground local system\n    var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\n    var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\n    var quad = this._heightQuads[row * this._subdivisionsX + col];\n    var facet;\n\n    if (z < quad.slope.x * x + quad.slope.y) {\n      facet = quad.facet1;\n    } else {\n      facet = quad.facet2;\n    }\n\n    return facet;\n  }; //  Creates and populates the heightMap array with \"facet\" elements :\n  // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\n  // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n\n\n  GroundMesh.prototype._initHeightQuads = function () {\n    var subdivisionsX = this._subdivisionsX;\n    var subdivisionsY = this._subdivisionsY;\n    this._heightQuads = new Array();\n\n    for (var row = 0; row < subdivisionsY; row++) {\n      for (var col = 0; col < subdivisionsX; col++) {\n        var quad = {\n          slope: Vector2.Zero(),\n          facet1: new Vector4(0.0, 0.0, 0.0, 0.0),\n          facet2: new Vector4(0.0, 0.0, 0.0, 0.0)\n        };\n        this._heightQuads[row * subdivisionsX + col] = quad;\n      }\n    }\n\n    return this;\n  }; // Compute each quad element values and update the the heightMap array :\n  // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n\n\n  GroundMesh.prototype._computeHeightQuads = function () {\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (!positions) {\n      return this;\n    }\n\n    var v1 = TmpVectors.Vector3[3];\n    var v2 = TmpVectors.Vector3[2];\n    var v3 = TmpVectors.Vector3[1];\n    var v4 = TmpVectors.Vector3[0];\n    var v1v2 = TmpVectors.Vector3[4];\n    var v1v3 = TmpVectors.Vector3[5];\n    var v1v4 = TmpVectors.Vector3[6];\n    var norm1 = TmpVectors.Vector3[7];\n    var norm2 = TmpVectors.Vector3[8];\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var cd = 0; // 2D slope coefficient : z = cd * x + h\n\n    var h = 0;\n    var d1 = 0; // facet plane equation : ax + by + cz + d = 0\n\n    var d2 = 0;\n    var subdivisionsX = this._subdivisionsX;\n    var subdivisionsY = this._subdivisionsY;\n\n    for (var row = 0; row < subdivisionsY; row++) {\n      for (var col = 0; col < subdivisionsX; col++) {\n        i = col * 3;\n        j = row * (subdivisionsX + 1) * 3;\n        k = (row + 1) * (subdivisionsX + 1) * 3;\n        v1.x = positions[j + i];\n        v1.y = positions[j + i + 1];\n        v1.z = positions[j + i + 2];\n        v2.x = positions[j + i + 3];\n        v2.y = positions[j + i + 4];\n        v2.z = positions[j + i + 5];\n        v3.x = positions[k + i];\n        v3.y = positions[k + i + 1];\n        v3.z = positions[k + i + 2];\n        v4.x = positions[k + i + 3];\n        v4.y = positions[k + i + 4];\n        v4.z = positions[k + i + 5]; // 2D slope V1V4\n\n        cd = (v4.z - v1.z) / (v4.x - v1.x);\n        h = v1.z - cd * v1.x; // v1 belongs to the slope\n        // facet equations :\n        // we compute each facet normal vector\n        // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\n        // we compute the value d by applying the equation to v1 which belongs to the plane\n        // then we store the facet equation in a Vector4\n\n        v2.subtractToRef(v1, v1v2);\n        v3.subtractToRef(v1, v1v3);\n        v4.subtractToRef(v1, v1v4);\n        Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\n\n        Vector3.CrossToRef(v1v2, v1v4, norm2);\n        norm1.normalize();\n        norm2.normalize();\n        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\n        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\n        var quad = this._heightQuads[row * subdivisionsX + col];\n        quad.slope.copyFromFloats(cd, h);\n        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\n        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Serializes this ground mesh\r\n   * @param serializationObject object to write serialization to\r\n   */\n\n\n  GroundMesh.prototype.serialize = function (serializationObject) {\n    _super.prototype.serialize.call(this, serializationObject);\n\n    serializationObject.subdivisionsX = this._subdivisionsX;\n    serializationObject.subdivisionsY = this._subdivisionsY;\n    serializationObject.minX = this._minX;\n    serializationObject.maxX = this._maxX;\n    serializationObject.minZ = this._minZ;\n    serializationObject.maxZ = this._maxZ;\n    serializationObject.width = this._width;\n    serializationObject.height = this._height;\n  };\n  /**\r\n   * Parses a serialized ground mesh\r\n   * @param parsedMesh the serialized mesh\r\n   * @param scene the scene to create the ground mesh in\r\n   * @returns the created ground mesh\r\n   */\n\n\n  GroundMesh.Parse = function (parsedMesh, scene) {\n    var result = new GroundMesh(parsedMesh.name, scene);\n    result._subdivisionsX = parsedMesh.subdivisionsX || 1;\n    result._subdivisionsY = parsedMesh.subdivisionsY || 1;\n    result._minX = parsedMesh.minX;\n    result._maxX = parsedMesh.maxX;\n    result._minZ = parsedMesh.minZ;\n    result._maxZ = parsedMesh.maxZ;\n    result._width = parsedMesh.width;\n    result._height = parsedMesh.height;\n    return result;\n  };\n\n  return GroundMesh;\n}(Mesh);\n\nexport { GroundMesh };","map":null,"metadata":{},"sourceType":"module"}