{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport { Scene } from \"../scene\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Light } from \"../Lights/light\";\nimport { Color3 } from '../Maths/math.color';\nimport { ThinMaterialHelper } from './thinMaterialHelper';\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\n\nvar MaterialHelper =\n/** @class */\nfunction () {\n  function MaterialHelper() {}\n  /**\r\n   * Bind the current view position to an effect.\r\n   * @param effect The effect to be bound\r\n   * @param scene The scene the eyes position is used from\r\n   * @param variableName name of the shader variable that will hold the eye position\r\n   */\n\n\n  MaterialHelper.BindEyePosition = function (effect, scene, variableName) {\n    if (variableName === void 0) {\n      variableName = \"vEyePosition\";\n    }\n\n    if (scene._forcedViewPosition) {\n      effect.setVector3(variableName, scene._forcedViewPosition);\n      return;\n    }\n\n    var globalPosition = scene.activeCamera.globalPosition;\n\n    if (!globalPosition) {\n      // Use WebVRFreecamera's device position as global position is not it's actual position in babylon space\n      globalPosition = scene.activeCamera.devicePosition;\n    }\n\n    effect.setVector3(variableName, scene._mirroredCameraPosition ? scene._mirroredCameraPosition : globalPosition);\n  };\n  /**\r\n   * Helps preparing the defines values about the UVs in used in the effect.\r\n   * UVs are shared as much as we can accross channels in the shaders.\r\n   * @param texture The texture we are preparing the UVs for\r\n   * @param defines The defines to update\r\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForMergedUV = function (texture, defines, key) {\n    defines._needUVs = true;\n    defines[key] = true;\n\n    if (texture.getTextureMatrix().isIdentityAs3x2()) {\n      defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n\n      if (texture.coordinatesIndex === 0) {\n        defines[\"MAINUV1\"] = true;\n      } else {\n        defines[\"MAINUV2\"] = true;\n      }\n    } else {\n      defines[key + \"DIRECTUV\"] = 0;\n    }\n  };\n  /**\r\n   * Binds a texture matrix value to its corrsponding uniform\r\n   * @param texture The texture to bind the matrix for\r\n   * @param uniformBuffer The uniform buffer receivin the data\r\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n   */\n\n\n  MaterialHelper.BindTextureMatrix = function (texture, uniformBuffer, key) {\n    var matrix = texture.getTextureMatrix();\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n  };\n  /**\r\n   * Gets the current status of the fog (should it be enabled?)\r\n   * @param mesh defines the mesh to evaluate for fog support\r\n   * @param scene defines the hosting scene\r\n   * @returns true if fog must be enabled\r\n   */\n\n\n  MaterialHelper.GetFogState = function (mesh, scene) {\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;\n  };\n  /**\r\n   * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n   * @param mesh defines the current mesh\r\n   * @param scene defines the current scene\r\n   * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n   * @param pointsCloud defines if point cloud rendering has to be turned on\r\n   * @param fogEnabled defines if fog has to be turned on\r\n   * @param alphaTest defines if alpha testing has to be turned on\r\n   * @param defines defines the current list of defines\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForMisc = function (mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {\n    if (defines._areMiscDirty) {\n      defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n      defines[\"POINTSIZE\"] = pointsCloud;\n      defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\n      defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\n      defines[\"ALPHATEST\"] = alphaTest;\n    }\n  };\n  /**\r\n   * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n   * @param scene defines the current scene\r\n   * @param engine defines the current engine\r\n   * @param defines specifies the list of active defines\r\n   * @param useInstances defines if instances have to be turned on\r\n   * @param useClipPlane defines if clip plane have to be turned on\r\n   * @param useInstances defines if instances have to be turned on\r\n   * @param useThinInstances defines if thin instances have to be turned on\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForFrameBoundValues = function (scene, engine, defines, useInstances, useClipPlane, useThinInstances) {\n    if (useClipPlane === void 0) {\n      useClipPlane = null;\n    }\n\n    if (useThinInstances === void 0) {\n      useThinInstances = false;\n    }\n\n    var changed = false;\n    var useClipPlane1 = false;\n    var useClipPlane2 = false;\n    var useClipPlane3 = false;\n    var useClipPlane4 = false;\n    var useClipPlane5 = false;\n    var useClipPlane6 = false;\n    useClipPlane1 = useClipPlane == null ? scene.clipPlane !== undefined && scene.clipPlane !== null : useClipPlane;\n    useClipPlane2 = useClipPlane == null ? scene.clipPlane2 !== undefined && scene.clipPlane2 !== null : useClipPlane;\n    useClipPlane3 = useClipPlane == null ? scene.clipPlane3 !== undefined && scene.clipPlane3 !== null : useClipPlane;\n    useClipPlane4 = useClipPlane == null ? scene.clipPlane4 !== undefined && scene.clipPlane4 !== null : useClipPlane;\n    useClipPlane5 = useClipPlane == null ? scene.clipPlane5 !== undefined && scene.clipPlane5 !== null : useClipPlane;\n    useClipPlane6 = useClipPlane == null ? scene.clipPlane6 !== undefined && scene.clipPlane6 !== null : useClipPlane;\n\n    if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\n      defines[\"CLIPPLANE\"] = useClipPlane1;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\n      defines[\"CLIPPLANE2\"] = useClipPlane2;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\n      defines[\"CLIPPLANE3\"] = useClipPlane3;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\n      defines[\"CLIPPLANE4\"] = useClipPlane4;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE5\"] !== useClipPlane5) {\n      defines[\"CLIPPLANE5\"] = useClipPlane5;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE6\"] !== useClipPlane6) {\n      defines[\"CLIPPLANE6\"] = useClipPlane6;\n      changed = true;\n    }\n\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\n      defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\n      changed = true;\n    }\n\n    if (defines[\"INSTANCES\"] !== useInstances) {\n      defines[\"INSTANCES\"] = useInstances;\n      changed = true;\n    }\n\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\n      defines[\"THIN_INSTANCES\"] = useThinInstances;\n      changed = true;\n    }\n\n    if (changed) {\n      defines.markAsUnprocessed();\n    }\n  };\n  /**\r\n   * Prepares the defines for bones\r\n   * @param mesh The mesh containing the geometry data we will draw\r\n   * @param defines The defines to update\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForBones = function (mesh, defines) {\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n      var materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\n\n      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\n        defines[\"BONETEXTURE\"] = true;\n      } else {\n        defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\n        defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\n        var prePassRenderer = mesh.getScene().prePassRenderer;\n\n        if (prePassRenderer && prePassRenderer.enabled) {\n          var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\n          defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\n        }\n      }\n    } else {\n      defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n      defines[\"BonesPerMesh\"] = 0;\n    }\n  };\n  /**\r\n   * Prepares the defines for morph targets\r\n   * @param mesh The mesh containing the geometry data we will draw\r\n   * @param defines The defines to update\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForMorphTargets = function (mesh, defines) {\n    var manager = mesh.morphTargetManager;\n\n    if (manager) {\n      defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\n      defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n      defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n      defines[\"MORPHTARGETS\"] = manager.numInfluencers > 0;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\n    } else {\n      defines[\"MORPHTARGETS_UV\"] = false;\n      defines[\"MORPHTARGETS_TANGENT\"] = false;\n      defines[\"MORPHTARGETS_NORMAL\"] = false;\n      defines[\"MORPHTARGETS\"] = false;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n    }\n  };\n  /**\r\n   * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n   * @param mesh The mesh containing the geometry data we will draw\r\n   * @param defines The defines to update\r\n   * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n   * @param useBones Precise whether bones should be used or not (override mesh info)\r\n   * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n   * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n   * @returns false if defines are considered not dirty and have not been checked\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForAttributes = function (mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha) {\n    if (useMorphTargets === void 0) {\n      useMorphTargets = false;\n    }\n\n    if (useVertexAlpha === void 0) {\n      useVertexAlpha = true;\n    }\n\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n      return false;\n    }\n\n    defines._normals = defines._needNormals;\n    defines._uvs = defines._needUVs;\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n\n    if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      defines[\"TANGENT\"] = true;\n    }\n\n    if (defines._needUVs) {\n      defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\n      defines[\"UV2\"] = mesh.isVerticesDataPresent(VertexBuffer.UV2Kind);\n    } else {\n      defines[\"UV1\"] = false;\n      defines[\"UV2\"] = false;\n    }\n\n    if (useVertexColor) {\n      var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\n      defines[\"VERTEXCOLOR\"] = hasVertexColors;\n      defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\n    }\n\n    if (useBones) {\n      this.PrepareDefinesForBones(mesh, defines);\n    }\n\n    if (useMorphTargets) {\n      this.PrepareDefinesForMorphTargets(mesh, defines);\n    }\n\n    return true;\n  };\n  /**\r\n   * Prepares the defines related to multiview\r\n   * @param scene The scene we are intending to draw\r\n   * @param defines The defines to update\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForMultiview = function (scene, defines) {\n    if (scene.activeCamera) {\n      var previousMultiview = defines.MULTIVIEW;\n      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\n\n      if (defines.MULTIVIEW != previousMultiview) {\n        defines.markAsUnprocessed();\n      }\n    }\n  };\n  /**\r\n   * Prepares the defines related to the prepass\r\n   * @param scene The scene we are intending to draw\r\n   * @param defines The defines to update\r\n   * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForPrePass = function (scene, defines, canRenderToMRT) {\n    var previousPrePass = defines.PREPASS;\n\n    if (!defines._arePrePassDirty) {\n      return;\n    }\n\n    var texturesList = [{\n      type: 1,\n      define: \"PREPASS_POSITION\",\n      index: \"PREPASS_POSITION_INDEX\"\n    }, {\n      type: 2,\n      define: \"PREPASS_VELOCITY\",\n      index: \"PREPASS_VELOCITY_INDEX\"\n    }, {\n      type: 3,\n      define: \"PREPASS_REFLECTIVITY\",\n      index: \"PREPASS_REFLECTIVITY_INDEX\"\n    }, {\n      type: 0,\n      define: \"PREPASS_IRRADIANCE\",\n      index: \"PREPASS_IRRADIANCE_INDEX\"\n    }, {\n      type: 6,\n      define: \"PREPASS_ALBEDO\",\n      index: \"PREPASS_ALBEDO_INDEX\"\n    }, {\n      type: 5,\n      define: \"PREPASS_DEPTHNORMAL\",\n      index: \"PREPASS_DEPTHNORMAL_INDEX\"\n    }];\n\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\n      defines.PREPASS = true;\n      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\n\n      for (var i = 0; i < texturesList.length; i++) {\n        var index = scene.prePassRenderer.getIndex(texturesList[i].type);\n\n        if (index !== -1) {\n          defines[texturesList[i].define] = true;\n          defines[texturesList[i].index] = index;\n        } else {\n          defines[texturesList[i].define] = false;\n        }\n      }\n    } else {\n      defines.PREPASS = false;\n\n      for (var i = 0; i < texturesList.length; i++) {\n        defines[texturesList[i].define] = false;\n      }\n    }\n\n    if (defines.PREPASS != previousPrePass) {\n      defines.markAsUnprocessed();\n      defines.markAsImageProcessingDirty();\n    }\n  };\n  /**\r\n   * Prepares the defines related to the light information passed in parameter\r\n   * @param scene The scene we are intending to draw\r\n   * @param mesh The mesh the effect is compiling for\r\n   * @param light The light the effect is compiling for\r\n   * @param lightIndex The index of the light\r\n   * @param defines The defines to update\r\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n   * @param state Defines the current state regarding what is needed (normals, etc...)\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForLight = function (scene, mesh, light, lightIndex, defines, specularSupported, state) {\n    state.needNormals = true;\n\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\n      state.needRebuild = true;\n    }\n\n    defines[\"LIGHT\" + lightIndex] = true;\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\n    defines[\"HEMILIGHT\" + lightIndex] = false;\n    defines[\"POINTLIGHT\" + lightIndex] = false;\n    defines[\"DIRLIGHT\" + lightIndex] = false;\n    light.prepareLightSpecificDefines(defines, lightIndex); // FallOff.\n\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\n\n    switch (light.falloffType) {\n      case Light.FALLOFF_GLTF:\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\n        break;\n\n      case Light.FALLOFF_PHYSICAL:\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\n        break;\n\n      case Light.FALLOFF_STANDARD:\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\n        break;\n    } // Specular\n\n\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n      state.specularEnabled = true;\n    } // Shadows\n\n\n    defines[\"SHADOW\" + lightIndex] = false;\n    defines[\"SHADOWCSM\" + lightIndex] = false;\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\n    defines[\"SHADOWPCF\" + lightIndex] = false;\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\n    defines[\"SHADOWESM\" + lightIndex] = false;\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\n\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n      var shadowGenerator = light.getShadowGenerator();\n\n      if (shadowGenerator) {\n        var shadowMap = shadowGenerator.getShadowMap();\n\n        if (shadowMap) {\n          if (shadowMap.renderList && shadowMap.renderList.length > 0) {\n            state.shadowEnabled = true;\n            shadowGenerator.prepareDefines(defines, lightIndex);\n          }\n        }\n      }\n    }\n\n    if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\n      state.lightmapMode = true;\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY;\n    } else {\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n    }\n  };\n  /**\r\n   * Prepares the defines related to the light information passed in parameter\r\n   * @param scene The scene we are intending to draw\r\n   * @param mesh The mesh the effect is compiling for\r\n   * @param defines The defines to update\r\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n   * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max\r\n   * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n   * @returns true if normals will be required for the rest of the effect\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForLights = function (scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    if (disableLighting === void 0) {\n      disableLighting = false;\n    }\n\n    if (!defines._areLightsDirty) {\n      return defines._needNormals;\n    }\n\n    var lightIndex = 0;\n    var state = {\n      needNormals: false,\n      needRebuild: false,\n      lightmapMode: false,\n      shadowEnabled: false,\n      specularEnabled: false\n    };\n\n    if (scene.lightsEnabled && !disableLighting) {\n      for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {\n        var light = _a[_i];\n        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\n        lightIndex++;\n\n        if (lightIndex === maxSimultaneousLights) {\n          break;\n        }\n      }\n    }\n\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\n    defines[\"SHADOWS\"] = state.shadowEnabled; // Resetting all other lights if any\n\n    for (var index = lightIndex; index < maxSimultaneousLights; index++) {\n      if (defines[\"LIGHT\" + index] !== undefined) {\n        defines[\"LIGHT\" + index] = false;\n        defines[\"HEMILIGHT\" + index] = false;\n        defines[\"POINTLIGHT\" + index] = false;\n        defines[\"DIRLIGHT\" + index] = false;\n        defines[\"SPOTLIGHT\" + index] = false;\n        defines[\"SHADOW\" + index] = false;\n        defines[\"SHADOWCSM\" + index] = false;\n        defines[\"SHADOWCSMDEBUG\" + index] = false;\n        defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\n        defines[\"SHADOWCSMNOBLEND\" + index] = false;\n        defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\n        defines[\"SHADOWPCF\" + index] = false;\n        defines[\"SHADOWPCSS\" + index] = false;\n        defines[\"SHADOWPOISSON\" + index] = false;\n        defines[\"SHADOWESM\" + index] = false;\n        defines[\"SHADOWCLOSEESM\" + index] = false;\n        defines[\"SHADOWCUBE\" + index] = false;\n        defines[\"SHADOWLOWQUALITY\" + index] = false;\n        defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\n      }\n    }\n\n    var caps = scene.getEngine().getCaps();\n\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\n      state.needRebuild = true;\n    }\n\n    defines[\"SHADOWFLOAT\"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\n\n    if (state.needRebuild) {\n      defines.rebuild();\n    }\n\n    return state.needNormals;\n  };\n  /**\r\n   * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n   * @param lightIndex defines the light index\r\n   * @param uniformsList The uniform list\r\n   * @param samplersList The sampler list\r\n   * @param projectedLightTexture defines if projected texture must be used\r\n   * @param uniformBuffersList defines an optional list of uniform buffers\r\n   * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n   */\n\n\n  MaterialHelper.PrepareUniformsAndSamplersForLight = function (lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {\n    if (uniformBuffersList === void 0) {\n      uniformBuffersList = null;\n    }\n\n    if (updateOnlyBuffersList === void 0) {\n      updateOnlyBuffersList = false;\n    }\n\n    if (uniformBuffersList) {\n      uniformBuffersList.push(\"Light\" + lightIndex);\n    }\n\n    if (updateOnlyBuffersList) {\n      return;\n    }\n\n    uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n    samplersList.push(\"shadowSampler\" + lightIndex);\n    samplersList.push(\"depthSampler\" + lightIndex);\n    uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\n\n    if (projectedLightTexture) {\n      samplersList.push(\"projectionLightSampler\" + lightIndex);\n      uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\n    }\n  };\n  /**\r\n   * Prepares the uniforms and samplers list to be used in the effect\r\n   * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information\r\n   * @param samplersList The sampler list\r\n   * @param defines The defines helping in the list generation\r\n   * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect\r\n   */\n\n\n  MaterialHelper.PrepareUniformsAndSamplersList = function (uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    var uniformsList;\n    var uniformBuffersList = null;\n\n    if (uniformsListOrOptions.uniformsNames) {\n      var options = uniformsListOrOptions;\n      uniformsList = options.uniformsNames;\n      uniformBuffersList = options.uniformBuffersNames;\n      samplersList = options.samplers;\n      defines = options.defines;\n      maxSimultaneousLights = options.maxSimultaneousLights || 0;\n    } else {\n      uniformsList = uniformsListOrOptions;\n\n      if (!samplersList) {\n        samplersList = [];\n      }\n    }\n\n    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\n    }\n\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n      uniformsList.push(\"morphTargetInfluences\");\n    }\n  };\n  /**\r\n   * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n   * @param defines The defines to update while falling back\r\n   * @param fallbacks The authorized effect fallbacks\r\n   * @param maxSimultaneousLights The maximum number of lights allowed\r\n   * @param rank the current rank of the Effect\r\n   * @returns The newly affected rank\r\n   */\n\n\n  MaterialHelper.HandleFallbacksForShadows = function (defines, fallbacks, maxSimultaneousLights, rank) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    if (rank === void 0) {\n      rank = 0;\n    }\n\n    var lightFallbackRank = 0;\n\n    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      if (lightIndex > 0) {\n        lightFallbackRank = rank + lightIndex;\n        fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\n      }\n\n      if (!defines[\"SHADOWS\"]) {\n        if (defines[\"SHADOW\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPCF\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPCSS\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPOISSON\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\n        }\n      }\n    }\n\n    return lightFallbackRank++;\n  };\n  /**\r\n   * Prepares the list of attributes required for morph targets according to the effect defines.\r\n   * @param attribs The current list of supported attribs\r\n   * @param mesh The mesh to prepare the morph targets attributes for\r\n   * @param influencers The number of influencers\r\n   */\n\n\n  MaterialHelper.PrepareAttributesForMorphTargetsInfluencers = function (attribs, mesh, influencers) {\n    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\n    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\n  };\n  /**\r\n   * Prepares the list of attributes required for morph targets according to the effect defines.\r\n   * @param attribs The current list of supported attribs\r\n   * @param mesh The mesh to prepare the morph targets attributes for\r\n   * @param defines The current Defines of the effect\r\n   */\n\n\n  MaterialHelper.PrepareAttributesForMorphTargets = function (attribs, mesh, defines) {\n    var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\n      var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\n      var manager = mesh.morphTargetManager;\n      var normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\n      var tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\n      var uv = manager && manager.supportsUVs && defines[\"UV1\"];\n\n      for (var index = 0; index < influencers; index++) {\n        attribs.push(VertexBuffer.PositionKind + index);\n\n        if (normal) {\n          attribs.push(VertexBuffer.NormalKind + index);\n        }\n\n        if (tangent) {\n          attribs.push(VertexBuffer.TangentKind + index);\n        }\n\n        if (uv) {\n          attribs.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n\n        if (attribs.length > maxAttributesCount) {\n          Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n        }\n      }\n    }\n  };\n  /**\r\n   * Prepares the list of attributes required for bones according to the effect defines.\r\n   * @param attribs The current list of supported attribs\r\n   * @param mesh The mesh to prepare the bones attributes for\r\n   * @param defines The current Defines of the effect\r\n   * @param fallbacks The current efffect fallback strategy\r\n   */\n\n\n  MaterialHelper.PrepareAttributesForBones = function (attribs, mesh, defines, fallbacks) {\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n      fallbacks.addCPUSkinningFallback(0, mesh);\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n    }\n  };\n  /**\r\n   * Check and prepare the list of attributes required for instances according to the effect defines.\r\n   * @param attribs The current list of supported attribs\r\n   * @param defines The current MaterialDefines of the effect\r\n   */\n\n\n  MaterialHelper.PrepareAttributesForInstances = function (attribs, defines) {\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\n      this.PushAttributesForInstances(attribs);\n    }\n  };\n  /**\r\n   * Add the list of attributes required for instances to the attribs array.\r\n   * @param attribs The current list of supported attribs\r\n   */\n\n\n  MaterialHelper.PushAttributesForInstances = function (attribs) {\n    attribs.push(\"world0\");\n    attribs.push(\"world1\");\n    attribs.push(\"world2\");\n    attribs.push(\"world3\");\n  };\n  /**\r\n   * Binds the light information to the effect.\r\n   * @param light The light containing the generator\r\n   * @param effect The effect we are binding the data to\r\n   * @param lightIndex The light index in the effect used to render\r\n   */\n\n\n  MaterialHelper.BindLightProperties = function (light, effect, lightIndex) {\n    light.transferToEffect(effect, lightIndex + \"\");\n  };\n  /**\r\n   * Binds the lights information from the scene to the effect for the given mesh.\r\n   * @param light Light to bind\r\n   * @param lightIndex Light index\r\n   * @param scene The scene where the light belongs to\r\n   * @param effect The effect we are binding the data to\r\n   * @param useSpecular Defines if specular is supported\r\n   * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n   */\n\n\n  MaterialHelper.BindLight = function (light, lightIndex, scene, effect, useSpecular, rebuildInParallel) {\n    if (rebuildInParallel === void 0) {\n      rebuildInParallel = false;\n    }\n\n    light._bindLight(lightIndex, scene, effect, useSpecular, rebuildInParallel);\n  };\n  /**\r\n   * Binds the lights information from the scene to the effect for the given mesh.\r\n   * @param scene The scene the lights belongs to\r\n   * @param mesh The mesh we are binding the information to render\r\n   * @param effect The effect we are binding the data to\r\n   * @param defines The generated defines for the effect\r\n   * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n   * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n   */\n\n\n  MaterialHelper.BindLights = function (scene, mesh, effect, defines, maxSimultaneousLights, rebuildInParallel) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    if (rebuildInParallel === void 0) {\n      rebuildInParallel = false;\n    }\n\n    var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\n\n    for (var i = 0; i < len; i++) {\n      var light = mesh.lightSources[i];\n      this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], rebuildInParallel);\n    }\n  };\n  /**\r\n   * Binds the fog information from the scene to the effect for the given mesh.\r\n   * @param scene The scene the lights belongs to\r\n   * @param mesh The mesh we are binding the information to render\r\n   * @param effect The effect we are binding the data to\r\n   * @param linearSpace Defines if the fog effect is applied in linear space\r\n   */\n\n\n  MaterialHelper.BindFogParameters = function (scene, mesh, effect, linearSpace) {\n    if (linearSpace === void 0) {\n      linearSpace = false;\n    }\n\n    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity); // Convert fog color to linear space if used in a linear space computed shader.\n\n      if (linearSpace) {\n        scene.fogColor.toLinearSpaceToRef(this._tempFogColor);\n        effect.setColor3(\"vFogColor\", this._tempFogColor);\n      } else {\n        effect.setColor3(\"vFogColor\", scene.fogColor);\n      }\n    }\n  };\n  /**\r\n   * Binds the bones information from the mesh to the effect.\r\n   * @param mesh The mesh we are binding the information to render\r\n   * @param effect The effect we are binding the data to\r\n   * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n   */\n\n\n  MaterialHelper.BindBonesParameters = function (mesh, effect, prePassConfiguration) {\n    if (!effect || !mesh) {\n      return;\n    }\n\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\n      mesh.computeBonesUsingShaders = false;\n    }\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      var skeleton = mesh.skeleton;\n\n      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n        var boneTexture = skeleton.getTransformMatrixTexture(mesh);\n        effect.setTexture(\"boneSampler\", boneTexture);\n        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n      } else {\n        var matrices = skeleton.getTransformMatrices(mesh);\n\n        if (matrices) {\n          effect.setMatrices(\"mBones\", matrices);\n\n          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\n            if (prePassConfiguration.previousBones[mesh.uniqueId]) {\n              effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\n            }\n\n            MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\n          }\n        }\n      }\n    }\n  }; // Copies the bones transformation matrices into the target array and returns the target's reference\n\n\n  MaterialHelper._CopyBonesTransformationMatrices = function (source, target) {\n    target.set(source);\n    return target;\n  };\n  /**\r\n   * Binds the morph targets information from the mesh to the effect.\r\n   * @param abstractMesh The mesh we are binding the information to render\r\n   * @param effect The effect we are binding the data to\r\n   */\n\n\n  MaterialHelper.BindMorphTargetParameters = function (abstractMesh, effect) {\n    var manager = abstractMesh.morphTargetManager;\n\n    if (!abstractMesh || !manager) {\n      return;\n    }\n\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\n  };\n  /**\r\n   * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n   * @param defines The generated defines used in the effect\r\n   * @param effect The effect we are binding the data to\r\n   * @param scene The scene we are willing to render with logarithmic scale for\r\n   */\n\n\n  MaterialHelper.BindLogDepth = function (defines, effect, scene) {\n    if (defines[\"LOGARITHMICDEPTH\"]) {\n      effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n    }\n  };\n  /**\r\n   * Binds the clip plane information from the scene to the effect.\r\n   * @param scene The scene the clip plane information are extracted from\r\n   * @param effect The effect we are binding the data to\r\n   */\n\n\n  MaterialHelper.BindClipPlane = function (effect, scene) {\n    ThinMaterialHelper.BindClipPlane(effect, scene);\n  };\n\n  MaterialHelper._TmpMorphInfluencers = {\n    \"NUM_MORPH_INFLUENCERS\": 0\n  };\n  MaterialHelper._tempFogColor = Color3.Black();\n  return MaterialHelper;\n}();\n\nexport { MaterialHelper };","map":null,"metadata":{},"sourceType":"module"}