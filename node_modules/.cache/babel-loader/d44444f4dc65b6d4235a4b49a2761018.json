{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n */\n\nvar MorphTarget =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new MorphTarget\r\n   * @param name defines the name of the target\r\n   * @param influence defines the influence to use\r\n   * @param scene defines the scene the morphtarget belongs to\r\n   */\n  function MorphTarget(\n  /** defines the name of the target */\n  name, influence, scene) {\n    if (influence === void 0) {\n      influence = 0;\n    }\n\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this.name = name;\n    /**\r\n     * Gets or sets the list of animations\r\n     */\n\n    this.animations = new Array();\n    this._positions = null;\n    this._normals = null;\n    this._tangents = null;\n    this._uvs = null;\n    this._uniqueId = 0;\n    /**\r\n     * Observable raised when the influence changes\r\n     */\n\n    this.onInfluenceChanged = new Observable();\n    /** @hidden */\n\n    this._onDataLayoutChanged = new Observable();\n    this._animationPropertiesOverride = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.influence = influence;\n\n    if (this._scene) {\n      this._uniqueId = this._scene.getUniqueId();\n    }\n  }\n\n  Object.defineProperty(MorphTarget.prototype, \"influence\", {\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\n    get: function get() {\n      return this._influence;\n    },\n    set: function set(influence) {\n      if (this._influence === influence) {\n        return;\n      }\n\n      var previous = this._influence;\n      this._influence = influence;\n\n      if (this.onInfluenceChanged.hasObservers()) {\n        this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"animationPropertiesOverride\", {\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\n    get: function get() {\n      if (!this._animationPropertiesOverride && this._scene) {\n        return this._scene.animationPropertiesOverride;\n      }\n\n      return this._animationPropertiesOverride;\n    },\n    set: function set(value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"uniqueId\", {\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\n    get: function get() {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasPositions\", {\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\n    get: function get() {\n      return !!this._positions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasNormals\", {\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\n    get: function get() {\n      return !!this._normals;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasTangents\", {\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\n    get: function get() {\n      return !!this._tangents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasUVs\", {\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\n    get: function get() {\n      return !!this._uvs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Affects position data to this target\r\n   * @param data defines the position data to use\r\n   */\n\n  MorphTarget.prototype.setPositions = function (data) {\n    var hadPositions = this.hasPositions;\n    this._positions = data;\n\n    if (hadPositions !== this.hasPositions) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\r\n   * Gets the position data stored in this target\r\n   * @returns a FloatArray containing the position data (or null if not present)\r\n   */\n\n\n  MorphTarget.prototype.getPositions = function () {\n    return this._positions;\n  };\n  /**\r\n   * Affects normal data to this target\r\n   * @param data defines the normal data to use\r\n   */\n\n\n  MorphTarget.prototype.setNormals = function (data) {\n    var hadNormals = this.hasNormals;\n    this._normals = data;\n\n    if (hadNormals !== this.hasNormals) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\r\n   * Gets the normal data stored in this target\r\n   * @returns a FloatArray containing the normal data (or null if not present)\r\n   */\n\n\n  MorphTarget.prototype.getNormals = function () {\n    return this._normals;\n  };\n  /**\r\n   * Affects tangent data to this target\r\n   * @param data defines the tangent data to use\r\n   */\n\n\n  MorphTarget.prototype.setTangents = function (data) {\n    var hadTangents = this.hasTangents;\n    this._tangents = data;\n\n    if (hadTangents !== this.hasTangents) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\r\n   * Gets the tangent data stored in this target\r\n   * @returns a FloatArray containing the tangent data (or null if not present)\r\n   */\n\n\n  MorphTarget.prototype.getTangents = function () {\n    return this._tangents;\n  };\n  /**\r\n   * Affects texture coordinates data to this target\r\n   * @param data defines the texture coordinates data to use\r\n   */\n\n\n  MorphTarget.prototype.setUVs = function (data) {\n    var hadUVs = this.hasUVs;\n    this._uvs = data;\n\n    if (hadUVs !== this.hasUVs) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\r\n   * Gets the texture coordinates data stored in this target\r\n   * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n   */\n\n\n  MorphTarget.prototype.getUVs = function () {\n    return this._uvs;\n  };\n  /**\r\n   * Clone the current target\r\n   * @returns a new MorphTarget\r\n   */\n\n\n  MorphTarget.prototype.clone = function () {\n    var _this = this;\n\n    var newOne = SerializationHelper.Clone(function () {\n      return new MorphTarget(_this.name, _this.influence, _this._scene);\n    }, this);\n    newOne._positions = this._positions;\n    newOne._normals = this._normals;\n    newOne._tangents = this._tangents;\n    newOne._uvs = this._uvs;\n    return newOne;\n  };\n  /**\r\n   * Serializes the current target into a Serialization object\r\n   * @returns the serialized object\r\n   */\n\n\n  MorphTarget.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.influence = this.influence;\n    serializationObject.positions = Array.prototype.slice.call(this.getPositions());\n\n    if (this.id != null) {\n      serializationObject.id = this.id;\n    }\n\n    if (this.hasNormals) {\n      serializationObject.normals = Array.prototype.slice.call(this.getNormals());\n    }\n\n    if (this.hasTangents) {\n      serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\n    }\n\n    if (this.hasUVs) {\n      serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\n    } // Animations\n\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  };\n  /**\r\n   * Returns the string \"MorphTarget\"\r\n   * @returns \"MorphTarget\"\r\n   */\n\n\n  MorphTarget.prototype.getClassName = function () {\n    return \"MorphTarget\";\n  }; // Statics\n\n  /**\r\n   * Creates a new target from serialized data\r\n   * @param serializationObject defines the serialized data to use\r\n   * @returns a new MorphTarget\r\n   */\n\n\n  MorphTarget.Parse = function (serializationObject) {\n    var result = new MorphTarget(serializationObject.name, serializationObject.influence);\n    result.setPositions(serializationObject.positions);\n\n    if (serializationObject.id != null) {\n      result.id = serializationObject.id;\n    }\n\n    if (serializationObject.normals) {\n      result.setNormals(serializationObject.normals);\n    }\n\n    if (serializationObject.tangents) {\n      result.setTangents(serializationObject.tangents);\n    }\n\n    if (serializationObject.uvs) {\n      result.setUVs(serializationObject.uvs);\n    } // Animations\n\n\n    if (serializationObject.animations) {\n      for (var animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\n        var parsedAnimation = serializationObject.animations[animationIndex];\n\n        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          result.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Creates a MorphTarget from mesh data\r\n   * @param mesh defines the source mesh\r\n   * @param name defines the name to use for the new target\r\n   * @param influence defines the influence to attach to the target\r\n   * @returns a new MorphTarget\r\n   */\n\n\n  MorphTarget.FromMesh = function (mesh, name, influence) {\n    if (!name) {\n      name = mesh.name;\n    }\n\n    var result = new MorphTarget(name, influence, mesh.getScene());\n    result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));\n    }\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));\n    }\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));\n    }\n\n    return result;\n  };\n\n  __decorate([serialize()], MorphTarget.prototype, \"id\", void 0);\n\n  return MorphTarget;\n}();\n\nexport { MorphTarget };","map":null,"metadata":{},"sourceType":"module"}