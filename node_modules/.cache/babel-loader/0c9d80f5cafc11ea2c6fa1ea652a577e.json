{"ast":null,"code":"import _regeneratorRuntime from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { cleanAssetName } from 'modules/asset/utils';\nimport { CategoryName } from 'modules/ui/sidebar/utils';\nimport { buildAssetPath } from 'modules/project/export';\nexport var ASSET_MANIFEST = 'asset.json';\n/* \n  This RegEx searches for the beginning of the smart item's bundle, it's a comment that contains '! \"src/game.ts\" <commit-hash>'\n  We split the code and take everything that comes AFTER this comment\n*/\n\nexport var CODE_SEPARATOR = /\\/\\*! \\\"src(\\/|\\\\)([A-z0-9|\\/|\\\\|\\-|_])*\\.ts\\\" [a-f0-9]+ \\*\\//;\n/* \n  This separator searches for the end of the smart item's bundle, before the source maps start.\n  We split the code and take everything that comes BEFORE this comment\n*/\n\nexport var SOURCE_MAPS_SEPARATOR = '//# sourceMappingURL';\nexport function createDefaultImportedFile(id, assetPackId, file) {\n  return {\n    id: id,\n    fileName: file.name,\n    asset: {\n      id: id,\n      assetPackId: assetPackId,\n      thumbnail: '',\n      tags: [],\n      name: cleanAssetName(file.name),\n      category: CategoryName.DECORATIONS_CATEGORY,\n      model: file.name,\n      script: null,\n      contents: _defineProperty({}, file.name, file),\n      metrics: getMetrics(),\n      parameters: [],\n      actions: []\n    }\n  };\n}\nexport function getMetrics() {\n  return {\n    triangles: 0,\n    materials: 0,\n    meshes: 0,\n    bodies: 0,\n    entities: 0,\n    textures: 0\n  };\n}\nexport function prepareScript(_x, _x2, _x3) {\n  return _prepareScript.apply(this, arguments);\n}\n\nfunction _prepareScript() {\n  _prepareScript = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(scriptPath, namespace, contents) {\n    var blob, text, padding, parts, _i, _Object$keys, path;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            blob = contents[scriptPath];\n\n            if (!blob) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.next = 4;\n            return new Response(blob).text();\n\n          case 4:\n            text = _context.sent;\n\n            // remove ecs and amd loader\n            if (CODE_SEPARATOR.test(text)) {\n              text = text.split(CODE_SEPARATOR).pop();\n            } // remove source maps\n\n\n            if (text.includes(SOURCE_MAPS_SEPARATOR)) {\n              padding = text.trim().endsWith(';') ? 3 : 2;\n              parts = text.trim().slice(0, -padding).split(SOURCE_MAPS_SEPARATOR);\n              text = parts.shift() + text.slice(-padding);\n            }\n            /** Namespace module definitions\n             * It converts this:\n             * define(\"myModule\", ...\n             * Into this:\n             * define(\"namespace/myModule\")\n             */\n\n\n            text = text.replace(/define\\(\\\\?\\\"([\\w]*)/g, function (match, moduleName) {\n              var code = match.slice(0, -moduleName.length); // remove previous module name\n\n              code += \"\".concat(namespace, \"/\").concat(moduleName); // add namespaced module name\n\n              return code;\n            });\n            /** Namespace module definitions\n             * It converts this:\n             * [\"require\", \"exports\", \"myDependency\"]\n             * Into this:\n             * [\"require\", \"exports\", \"namespace/myDependency\"]\n             */\n\n            text = text.replace(/\\[\\\\?\\\"require\\\\?\\\", \\\\?\\\"exports\\\\?\\\", ([\\w|\\\\|\\/|\\\"|,|\\s|@]*)/g, function (match, dependencies) {\n              var code = match.slice(0, -dependencies.length); // remove previous dependencies\n\n              var newDependencies = dependencies.replace(/\\\\?\\\"(\\w.*?)\\\\?\\\"/g, \"\\\\\\\"\".concat(namespace, \"/$1\\\\\\\"\")); // adds the namespace to each dependency\n\n              return code + newDependencies;\n            });\n            /** Namespace mappings\n             *  It converts this:\n             *  new GLTFShape(\"path/to/model.gltf\")\n             *  Into this:\n             *  new GLTFShape(\"assets/:namespace/path/to/model.gltf\")\n             */\n\n            for (_i = 0, _Object$keys = Object.keys(contents); _i < _Object$keys.length; _i++) {\n              path = _Object$keys[_i];\n              text = text.replace(new RegExp(path, 'g'), buildAssetPath(namespace, path));\n            } // Remove extra src/\n\n\n            text = text.replace(/src(\\/|\\\\)/g, '');\n            contents[scriptPath] = new Blob([text], {\n              type: 'text/plain'\n            });\n\n          case 12:\n            return _context.abrupt(\"return\", contents);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _prepareScript.apply(this, arguments);\n}","map":{"version":3,"sources":["/opt/work/NZ_test/src/components/AssetImporter/utils.ts"],"names":["cleanAssetName","CategoryName","buildAssetPath","ASSET_MANIFEST","CODE_SEPARATOR","SOURCE_MAPS_SEPARATOR","createDefaultImportedFile","id","assetPackId","file","fileName","name","asset","thumbnail","tags","category","DECORATIONS_CATEGORY","model","script","contents","metrics","getMetrics","parameters","actions","triangles","materials","meshes","bodies","entities","textures","prepareScript","scriptPath","namespace","blob","Response","text","test","split","pop","includes","padding","trim","endsWith","parts","slice","shift","replace","match","moduleName","code","length","dependencies","newDependencies","Object","keys","path","RegExp","Blob","type"],"mappings":"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","sourcesContent":["import { cleanAssetName } from 'modules/asset/utils'\nimport { CategoryName } from 'modules/ui/sidebar/utils'\nimport { ImportedFile } from './AssetImporter.types'\nimport { ModelMetrics } from 'modules/models/types'\nimport { buildAssetPath } from 'modules/project/export'\n\nexport const ASSET_MANIFEST = 'asset.json'\n\n/* \n  This RegEx searches for the beginning of the smart item's bundle, it's a comment that contains '! \"src/game.ts\" <commit-hash>'\n  We split the code and take everything that comes AFTER this comment\n*/\nexport const CODE_SEPARATOR = /\\/\\*! \\\"src(\\/|\\\\)([A-z0-9|\\/|\\\\|\\-|_])*\\.ts\\\" [a-f0-9]+ \\*\\//\n\n/* \n  This separator searches for the end of the smart item's bundle, before the source maps start.\n  We split the code and take everything that comes BEFORE this comment\n*/\nexport const SOURCE_MAPS_SEPARATOR = '//# sourceMappingURL'\n\nexport function createDefaultImportedFile(id: string, assetPackId: string, file: File): ImportedFile {\n  return {\n    id,\n    fileName: file.name,\n    asset: {\n      id,\n      assetPackId,\n      thumbnail: '',\n      tags: [],\n      name: cleanAssetName(file.name),\n      category: CategoryName.DECORATIONS_CATEGORY,\n      model: file.name,\n      script: null,\n      contents: {\n        [file.name]: file\n      },\n      metrics: getMetrics(),\n      parameters: [],\n      actions: []\n    }\n  }\n}\n\nexport function getMetrics(): ModelMetrics {\n  return {\n    triangles: 0,\n    materials: 0,\n    meshes: 0,\n    bodies: 0,\n    entities: 0,\n    textures: 0\n  }\n}\n\nexport async function prepareScript(scriptPath: string, namespace: string, contents: Record<string, Blob>): Promise<Record<string, Blob>> {\n  const blob = contents[scriptPath]\n  if (blob) {\n    let text = await new Response(blob).text()\n\n    // remove ecs and amd loader\n    if (CODE_SEPARATOR.test(text)) {\n      text = text.split(CODE_SEPARATOR).pop()!\n    }\n\n    // remove source maps\n    if (text.includes(SOURCE_MAPS_SEPARATOR)) {\n      const padding = text.trim().endsWith(';') ? 3 : 2\n      const parts = text\n        .trim()\n        .slice(0, -padding)\n        .split(SOURCE_MAPS_SEPARATOR)\n      text = parts.shift()! + text.slice(-padding)\n    }\n\n    /** Namespace module definitions\n     * It converts this:\n     * define(\"myModule\", ...\n     * Into this:\n     * define(\"namespace/myModule\")\n     */\n    text = text.replace(/define\\(\\\\?\\\"([\\w]*)/g, (match, moduleName) => {\n      let code = match.slice(0, -moduleName.length) // remove previous module name\n      code += `${namespace}/${moduleName}` // add namespaced module name\n      return code\n    })\n\n    /** Namespace module definitions\n     * It converts this:\n     * [\"require\", \"exports\", \"myDependency\"]\n     * Into this:\n     * [\"require\", \"exports\", \"namespace/myDependency\"]\n     */\n    text = text.replace(/\\[\\\\?\\\"require\\\\?\\\", \\\\?\\\"exports\\\\?\\\", ([\\w|\\\\|\\/|\\\"|,|\\s|@]*)/g, (match, dependencies) => {\n      let code = match.slice(0, -dependencies.length) // remove previous dependencies\n      const newDependencies = dependencies.replace(/\\\\?\\\"(\\w.*?)\\\\?\\\"/g, `\\\\\\\"${namespace}/$1\\\\\\\"`) // adds the namespace to each dependency\n      return code + newDependencies\n    })\n\n    /** Namespace mappings\n     *  It converts this:\n     *  new GLTFShape(\"path/to/model.gltf\")\n     *  Into this:\n     *  new GLTFShape(\"assets/:namespace/path/to/model.gltf\")\n     */\n    for (const path of Object.keys(contents)) {\n      text = text.replace(new RegExp(path, 'g'), buildAssetPath(namespace, path))\n    }\n\n    // Remove extra src/\n    text = text.replace(/src(\\/|\\\\)/g, '')\n\n    contents[scriptPath] = new Blob([text], {\n      type: 'text/plain'\n    })\n  }\n  return contents\n}\n"]},"metadata":{},"sourceType":"module"}