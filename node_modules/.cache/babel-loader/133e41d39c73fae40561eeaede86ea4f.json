{"ast":null,"code":"import { WorkerPool } from './workerPool';\n/**\r\n * Class for loading KTX2 files\r\n */\n\nvar KhronosTextureContainer2 =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   * @param engine The engine to use\r\n   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n   */\n  function KhronosTextureContainer2(engine, numWorkers) {\n    if (numWorkers === void 0) {\n      numWorkers = KhronosTextureContainer2.DefaultNumWorkers;\n    }\n\n    this._engine = engine;\n\n    if (!KhronosTextureContainer2._Initialized) {\n      KhronosTextureContainer2._CreateWorkerPool(numWorkers);\n    }\n  }\n\n  KhronosTextureContainer2.GetDefaultNumWorkers = function () {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    } // Use 50% of the available logical processors but capped at 4.\n\n\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  };\n\n  KhronosTextureContainer2._CreateWorkerPool = function (numWorkers) {\n    this._Initialized = true;\n\n    if (numWorkers && typeof Worker === \"function\") {\n      KhronosTextureContainer2._WorkerPoolPromise = new Promise(function (resolve) {\n        var workerContent = \"(\" + workerFunc + \")()\";\n        var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        var workerPromises = new Array(numWorkers);\n\n        for (var i = 0; i < workerPromises.length; i++) {\n          workerPromises[i] = new Promise(function (resolve, reject) {\n            var worker = new Worker(workerBlobUrl);\n\n            var onError = function onError(error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n            };\n\n            var onMessage = function onMessage(message) {\n              if (message.data.action === \"init\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              action: \"init\",\n              urls: KhronosTextureContainer2.URLConfig\n            });\n          });\n        }\n\n        Promise.all(workerPromises).then(function (workers) {\n          resolve(new WorkerPool(workers));\n        });\n      });\n    } else {\n      KTX2DECODER.MSCTranscoder.UseFromWorkerThread = false;\n      KTX2DECODER.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n    }\n  };\n  /** @hidden */\n\n\n  KhronosTextureContainer2.prototype.uploadAsync = function (data, internalTexture, options) {\n    var _this = this;\n\n    var caps = this._engine.getCaps();\n\n    var compressedTexturesCaps = {\n      astc: !!caps.astc,\n      bptc: !!caps.bptc,\n      s3tc: !!caps.s3tc,\n      pvrtc: !!caps.pvrtc,\n      etc2: !!caps.etc2,\n      etc1: !!caps.etc1\n    };\n\n    if (KhronosTextureContainer2._WorkerPoolPromise) {\n      return KhronosTextureContainer2._WorkerPoolPromise.then(function (workerPool) {\n        return new Promise(function (resolve, reject) {\n          workerPool.push(function (worker, onComplete) {\n            var onError = function onError(error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n\n            var onMessage = function onMessage(message) {\n              if (message.data.action === \"decoded\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n\n                if (!message.data.success) {\n                  reject({\n                    message: message.data.msg\n                  });\n                } else {\n                  try {\n                    _this._createTexture(message.data.decodedData, internalTexture, options);\n\n                    resolve();\n                  } catch (err) {\n                    reject({\n                      message: err\n                    });\n                  }\n                }\n\n                onComplete();\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage); // note: we can't transfer the ownership of data.buffer because if using a fallback texture the data.buffer buffer will be used by the current thread\n\n            worker.postMessage({\n              action: \"decode\",\n              data: data,\n              caps: compressedTexturesCaps,\n              options: options\n            }\n            /*, [data.buffer]*/\n            );\n          });\n        });\n      });\n    }\n\n    return new Promise(function (resolve, reject) {\n      if (!KhronosTextureContainer2._Ktx2Decoder) {\n        KhronosTextureContainer2._Ktx2Decoder = new KTX2DECODER.KTX2Decoder();\n      }\n\n      KhronosTextureContainer2._Ktx2Decoder.decode(data, caps).then(function (data) {\n        _this._createTexture(data, internalTexture);\n\n        resolve();\n      }).catch(function (reason) {\n        reject({\n          message: reason\n        });\n      });\n    });\n  };\n  /**\r\n   * Stop all async operations and release resources.\r\n   */\n\n\n  KhronosTextureContainer2.prototype.dispose = function () {\n    if (KhronosTextureContainer2._WorkerPoolPromise) {\n      KhronosTextureContainer2._WorkerPoolPromise.then(function (workerPool) {\n        workerPool.dispose();\n      });\n    }\n\n    delete KhronosTextureContainer2._WorkerPoolPromise;\n  };\n\n  KhronosTextureContainer2.prototype._createTexture = function (data\n  /* IDecodedData */\n  , internalTexture, options) {\n    this._engine._bindTextureDirectly(this._engine._gl.TEXTURE_2D, internalTexture);\n\n    if (options) {\n      // return back some information about the decoded data\n      options.transcodedFormat = data.transcodedFormat;\n      options.isInGammaSpace = data.isInGammaSpace;\n      options.transcoderName = data.transcoderName;\n    }\n\n    if (data.transcodedFormat === 0x8058\n    /* RGBA8 */\n    ) {\n      internalTexture.type = 0;\n      internalTexture.format = 5;\n    } else {\n      internalTexture.format = data.transcodedFormat;\n    }\n\n    internalTexture._gammaSpace = data.isInGammaSpace;\n\n    if (data.errors) {\n      throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\n    }\n\n    for (var t = 0; t < data.mipmaps.length; ++t) {\n      var mipmap = data.mipmaps[t];\n\n      if (!mipmap || !mipmap.data) {\n        throw new Error(\"KTX2 container - could not transcode one of the image\");\n      }\n\n      if (data.transcodedFormat === 0x8058\n      /* RGBA8 */\n      ) {\n        // uncompressed RGBA\n        internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\n\n        internalTexture.height = mipmap.height;\n\n        this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\n      } else {\n        this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\n      }\n    }\n\n    internalTexture.width = data.mipmaps[0].width;\n    internalTexture.height = data.mipmaps[0].height;\n    internalTexture.generateMipMaps = data.mipmaps.length > 1;\n    internalTexture.isReady = true;\n\n    this._engine._bindTextureDirectly(this._engine._gl.TEXTURE_2D, null);\n  };\n  /**\r\n   * Checks if the given data starts with a KTX2 file identifier.\r\n   * @param data the data to check\r\n   * @returns true if the data is a KTX2 file or false otherwise\r\n   */\n\n\n  KhronosTextureContainer2.IsValid = function (data) {\n    if (data.byteLength >= 12) {\n      // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\\r', '\\n', '\\x1A', '\\n'\n      var identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\n\n      if (identifier[0] === 0xAB && identifier[1] === 0x4B && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x32 && identifier[6] === 0x30 && identifier[7] === 0xBB && identifier[8] === 0x0D && identifier[9] === 0x0A && identifier[10] === 0x1A && identifier[11] === 0x0A) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * URLs to use when loading the KTX2 decoder module as well as its dependencies\r\n   * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\r\n   * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\r\n   * Urls you can change:\r\n   *     URLConfig.jsDecoderModule\r\n   *     URLConfig.wasmUASTCToASTC\r\n   *     URLConfig.wasmUASTCToBC7\r\n   *     URLConfig.wasmUASTCToRGBA_UNORM\r\n   *     URLConfig.wasmUASTCToRGBA_SRGB\r\n   *     URLConfig.jsMSCTranscoder\r\n   *     URLConfig.wasmMSCTranscoder\r\n   * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#9\r\n   */\n\n\n  KhronosTextureContainer2.URLConfig = {\n    jsDecoderModule: \"https://preview.babylonjs.com/babylon.ktx2Decoder.js\",\n    wasmUASTCToASTC: null,\n    wasmUASTCToBC7: null,\n    wasmUASTCToRGBA_UNORM: null,\n    wasmUASTCToRGBA_SRGB: null,\n    jsMSCTranscoder: null,\n    wasmMSCTranscoder: null\n  };\n  /**\r\n   * Default number of workers used to handle data decoding\r\n   */\n\n  KhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\n  return KhronosTextureContainer2;\n}();\n\nexport { KhronosTextureContainer2 };\n\nfunction workerFunc() {\n  var ktx2Decoder;\n\n  onmessage = function onmessage(event) {\n    switch (event.data.action) {\n      case \"init\":\n        var urls = event.data.urls;\n        importScripts(urls.jsDecoderModule);\n\n        if (urls.wasmUASTCToASTC !== null) {\n          KTX2DECODER.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\n        }\n\n        if (urls.wasmUASTCToBC7 !== null) {\n          KTX2DECODER.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\n        }\n\n        if (urls.wasmUASTCToRGBA_UNORM !== null) {\n          KTX2DECODER.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\n        }\n\n        if (urls.wasmUASTCToRGBA_SRGB !== null) {\n          KTX2DECODER.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\n        }\n\n        if (urls.jsMSCTranscoder !== null) {\n          KTX2DECODER.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\n        }\n\n        if (urls.wasmMSCTranscoder !== null) {\n          KTX2DECODER.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\n        }\n\n        ktx2Decoder = new KTX2DECODER.KTX2Decoder();\n        postMessage({\n          action: \"init\"\n        });\n        break;\n\n      case \"decode\":\n        ktx2Decoder.decode(event.data.data, event.data.caps, event.data.options).then(function (data) {\n          var buffers = [];\n\n          for (var mip = 0; mip < data.mipmaps.length; ++mip) {\n            var mipmap = data.mipmaps[mip];\n\n            if (mipmap && mipmap.data) {\n              buffers.push(mipmap.data.buffer);\n            }\n          }\n\n          postMessage({\n            action: \"decoded\",\n            success: true,\n            decodedData: data\n          }, buffers);\n        }).catch(function (reason) {\n          postMessage({\n            action: \"decoded\",\n            success: false,\n            msg: reason\n          });\n        });\n        break;\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}