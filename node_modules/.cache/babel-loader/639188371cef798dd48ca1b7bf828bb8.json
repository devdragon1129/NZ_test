{"ast":null,"code":"import _toConsumableArray from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport { EmoteCategory, Locale } from '@dcl/schemas';\nimport { ItemType } from 'modules/item/types';\nimport { getSceneDefinition } from 'modules/project/export';\nimport { getContentsStorageUrl } from 'lib/api/builder';\nimport { capitalize } from 'lib/text';\nimport { getSkinHiddenCategories } from 'modules/item/utils';\nimport { base64ArrayBuffer } from './base64';\n\nvar script = require('raw-loader!../../ecsScene/scene.js');\n\nexport var THUMBNAIL_WIDTH = 984;\nexport var THUMBNAIL_HEIGHT = 728;\nexport var POSITION_GRID_RESOLUTION = 0.5;\nexport var ROTATION_GRID_RESOLUTION = Math.PI / 16;\nexport var SCALE_GRID_RESOLUTION = 0.5;\nexport var SCALE_MIN_LIMIT = 0.001;\nexport function getNewEditorScene(project) {\n  var encoder = new TextEncoder();\n  var mappings = {\n    'game.js': \"data:application/javascript;base64,\".concat(base64ArrayBuffer(encoder.encode(script))),\n    'scene.json': 'Qm' // stub required by the client\n\n  };\n  return _objectSpread({}, getSceneDefinition(project, {\n    x: 0,\n    y: 0\n  }, 'east', null, null), {\n    baseUrl: getContentsStorageUrl(),\n    display: {\n      title: project.title\n    },\n    owner: 'Decentraland',\n    contact: {\n      name: 'Decentraland',\n      email: 'support@decentraland.org'\n    },\n    main: 'game.js',\n    _mappings: mappings\n  });\n} // Screenshots\n\nexport function imageToDataUri(img, width, height) {\n  // create an off-screen canvas\n  var canvas = document.createElement('canvas');\n  var ctx = canvas.getContext('2d');\n  if (!ctx) return null; // set its dimension to target size\n\n  canvas.width = width;\n  canvas.height = height; // draw source image into the off-screen canvas:\n\n  ctx.drawImage(img, 0, 0, width, height); // encode image to data-uri with base64 version of compressed image\n\n  return canvas.toDataURL();\n}\nexport function resizeScreenshot(screenshot, maxWidth, maxHeight) {\n  return new Promise(function (resolve) {\n    var img = new Image();\n\n    img.onload = function () {\n      var width = img.width,\n          height = img.height;\n      var ratio = 0;\n\n      if (width > maxWidth) {\n        ratio = maxWidth / width;\n        width = maxWidth;\n        height *= ratio;\n      } else if (height > maxHeight) {\n        ratio = maxHeight / height;\n        width *= ratio;\n        height = maxHeight;\n      }\n\n      var newDataUri = imageToDataUri(img, width, height);\n      resolve(newDataUri);\n    };\n\n    img.src = screenshot;\n  });\n}\nexport function snapScale(scale) {\n  return {\n    x: scale.x === 0 ? SCALE_MIN_LIMIT : scale.x,\n    y: scale.y === 0 ? SCALE_MIN_LIMIT : scale.y,\n    z: scale.z === 0 ? SCALE_MIN_LIMIT : scale.z\n  };\n}\nexport function createReadyOnlyScene(scene) {\n  var readOnlyEntities = Object.values(scene.entities).reduce(function (newEntities, entity) {\n    newEntities[entity.id] = _objectSpread({}, entity, {\n      disableGizmos: true\n    });\n    return newEntities;\n  }, {});\n  return _objectSpread({}, scene, {\n    entities: readOnlyEntities\n  });\n}\nexport function convertToUnityKeyboardEvent(e) {\n  switch (e.key) {\n    case 'Down':\n    case 'ArrowDown':\n      return 'DownArrow';\n\n    case 'Up':\n    case 'ArrowUp':\n      return 'UpArrow';\n\n    case 'Left':\n    case 'ArrowLeft':\n      return 'LeftArrow';\n\n    case 'Right':\n    case 'ArrowRight':\n      return 'RightArrow';\n  }\n\n  return null;\n}\nexport function areEqualTransforms(a, b) {\n  return a.position.x === b.position.x && a.position.y === b.position.y && a.position.z === b.position.z && a.rotation.x === b.rotation.x && a.rotation.y === b.rotation.y && a.rotation.z === b.rotation.z && a.rotation.w === b.rotation.w && a.scale.x === b.scale.x && a.scale.y === b.scale.y && a.scale.z === b.scale.z;\n}\n/**\n * Makes runtime changes to wearable objects before sending them to the ECS scene. This is because we are using an outdated version of the ECS,\n * and certain tweaks need to be made in order to make the up-to-date wearables work on it.\n * @param wearables\n */\n\nexport function patchWearables(wearables) {\n  return wearables.map(function (wearable) {\n    // 1. if the category is \"skin\" we need to hide all the other categories\n    if (wearable.category === 'skin') {\n      var alreadyHidden = _toConsumableArray(wearable.hides || []); // The typing from decentraland-ecs is wrong and it misses the hides list\n\n\n      var hides = Array.from(new Set([].concat(_toConsumableArray(alreadyHidden), _toConsumableArray(getSkinHiddenCategories()))));\n      return _objectSpread({}, wearable, {\n        hides: hides,\n        representations: wearable.representations.map(function (representation) {\n          return _objectSpread({}, representation, {\n            overrideHides: hides\n          });\n        })\n      });\n    }\n\n    return wearable;\n  });\n}\nexport var pickRandom = function pickRandom(array) {\n  return array[Math.random() * array.length | 0];\n};\n/*\n * Converts stuff like \"f_jeans_00\" into \"Jeans\"\n */\n\nexport var getName = function getName(wearable) {\n  var name = wearable.id.split(':').pop();\n\n  if (name.startsWith('f_') || name.startsWith('m_')) {\n    // Remove prefixes f_ and m_\n    name = name.slice(2);\n  }\n\n  return name.split('_').map(function (strPart) {\n    var part = Number(strPart);\n    var isNumeric = !isNaN(part);\n    /*\n     * Numeric parts are like 00, 01, 02. This ignores the 00, and parses the other ones, like:\n     * hair_00 -> hair\n     * hair_01 -> hair 2\n     * hair_02 -> hair 3\n     */\n\n    return !isNumeric || part <= 0 ? strPart : null;\n  }).filter(function (part) {\n    return part != null;\n  }) // Filter out ignored parts\n  .map(function (part) {\n    return capitalize(part);\n  }).join(' ');\n};\n/**\n * Extracts the base URL from the catalyst items' URL.\n *\n * @param url - The catalyst wearable's URL.\n */\n\nexport function extractBaseUrl(url) {\n  var baseURLRegex = /(http[s]?:\\/\\/.+\\/content\\/contents\\/).+/;\n  var matches = baseURLRegex.exec(url);\n\n  if (matches && matches[1]) {\n    return matches[1];\n  }\n\n  throw new Error('No base URL found in th URL: ' + url);\n}\n/**\n * Extracts the wearable's hash from a catalyst wearable's URL.\n *\n * @param url - The catalyst item's URL.\n */\n\nexport function extractHash(url) {\n  var hashRegex = /http[s]?:\\/\\/.+\\/content\\/contents\\/([a-zA-Z0-9]+)/;\n  var matches = hashRegex.exec(url);\n\n  if (matches && matches[1]) {\n    return matches[1];\n  }\n\n  throw new Error('No hash found in the URL: ' + url);\n}\n/**\n * Converts a Catalyst's wearable into a Wearable.\n *\n * @param catalystWearable - The catalyst wearable to convert.\n */\n\nexport function fromCatalystWearableToWearable(catalystWearable) {\n  return {\n    id: catalystWearable.id,\n    type: 'wearable',\n    category: catalystWearable.data.category,\n    baseUrl: extractBaseUrl(catalystWearable.thumbnail),\n    tags: catalystWearable.data.tags,\n    representations: catalystWearable.data.representations.map(function (representation) {\n      return {\n        bodyShapes: representation.bodyShapes,\n        mainFile: representation.mainFile,\n        contents: representation.contents.map(function (content) {\n          return {\n            file: content.key,\n            hash: extractHash(content.url)\n          };\n        })\n      };\n    })\n  };\n}\n/**\n * Given a list of wearables, return those which category and body shape are the ones specified in the parameters.\n *\n * @param wearables - The catalyst wearable to convert.\n * @param category - The category to filter by.\n * @param bodyShape - The body shape to filter by.\n */\n\nexport function filterWearables(wearables, category, bodyShape) {\n  return wearables.filter(function (wearable) {\n    return wearable.category === category && wearable.representations.some(function (representation) {\n      return representation.bodyShapes.some(function (_bodyShape) {\n        return _bodyShape === bodyShape;\n      });\n    });\n  });\n}\n/**\n * Given a color return the hex value\n *\n * @param color - a Color4 value\n */\n\nexport function toHex(color) {\n  return color.toHexString().slice(1, 7).toLowerCase();\n}\n/**\n * Given an item convert it to a wearable definition\n *\n * @param item - an Item\n */\n\nexport function toWearable(item) {\n  return {\n    id: item.id,\n    name: item.name,\n    thumbnail: item.thumbnail,\n    image: item.thumbnail,\n    description: item.description,\n    i18n: [{\n      code: Locale.EN,\n      text: item.name\n    }],\n    data: _objectSpread({}, item.data, {\n      category: item.data.category,\n      representations: item.data.representations.map(function (representation) {\n        return _objectSpread({}, representation, {\n          contents: representation.contents.map(function (path) {\n            return {\n              key: path,\n              url: getContentsStorageUrl(item.contents[path])\n            };\n          })\n        });\n      })\n    }),\n    emoteDataV0: item.type === ItemType.EMOTE ? {\n      loop: item.data.category === EmoteCategory.LOOP\n    } : undefined\n  };\n}\n/**\n * Given an item return the base64 of its wearable definition\n *\n * @param item - an Item\n */\n\nexport function toBase64(item) {\n  var wearable = toWearable(item);\n  var stringified = JSON.stringify(wearable);\n  var sanitized = stringified.replace(/[\\u0250-\\ue007]/g, '');\n  return btoa(sanitized);\n}","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/editor/utils.ts"],"names":["EmoteCategory","Locale","ItemType","getSceneDefinition","getContentsStorageUrl","capitalize","getSkinHiddenCategories","base64ArrayBuffer","script","require","THUMBNAIL_WIDTH","THUMBNAIL_HEIGHT","POSITION_GRID_RESOLUTION","ROTATION_GRID_RESOLUTION","Math","PI","SCALE_GRID_RESOLUTION","SCALE_MIN_LIMIT","getNewEditorScene","project","encoder","TextEncoder","mappings","encode","x","y","baseUrl","display","title","owner","contact","name","email","main","_mappings","imageToDataUri","img","width","height","canvas","document","createElement","ctx","getContext","drawImage","toDataURL","resizeScreenshot","screenshot","maxWidth","maxHeight","Promise","resolve","Image","onload","ratio","newDataUri","src","snapScale","scale","z","createReadyOnlyScene","scene","readOnlyEntities","Object","values","entities","reduce","newEntities","entity","id","disableGizmos","convertToUnityKeyboardEvent","e","key","areEqualTransforms","a","b","position","rotation","w","patchWearables","wearables","map","wearable","category","alreadyHidden","hides","Array","from","Set","representations","representation","overrideHides","pickRandom","array","random","length","getName","split","pop","startsWith","slice","strPart","part","Number","isNumeric","isNaN","filter","join","extractBaseUrl","url","baseURLRegex","matches","exec","Error","extractHash","hashRegex","fromCatalystWearableToWearable","catalystWearable","type","data","thumbnail","tags","bodyShapes","mainFile","contents","content","file","hash","filterWearables","bodyShape","some","_bodyShape","toHex","color","toHexString","toLowerCase","toWearable","item","image","description","i18n","code","EN","text","path","emoteDataV0","EMOTE","loop","LOOP","undefined","toBase64","stringified","JSON","stringify","sanitized","replace","btoa"],"mappings":";;AACA,SAASA,aAAT,EAAwBC,MAAxB,QAA+F,cAA/F;AACA,SAAeC,QAAf,QAA+B,oBAA/B;AAGA,SAASC,kBAAT,QAAmC,wBAAnC;AACA,SAASC,qBAAT,QAAsC,iBAAtC;AACA,SAASC,UAAT,QAA2B,UAA3B;AAEA,SAASC,uBAAT,QAAwC,oBAAxC;AAEA,SAASC,iBAAT,QAAkC,UAAlC;;AAEA,IAAMC,MAAM,GAAGC,OAAO,CAAC,oCAAD,CAAtB;;AAEA,OAAO,IAAMC,eAAe,GAAG,GAAxB;AACP,OAAO,IAAMC,gBAAgB,GAAG,GAAzB;AACP,OAAO,IAAMC,wBAAwB,GAAG,GAAjC;AACP,OAAO,IAAMC,wBAAwB,GAAGC,IAAI,CAACC,EAAL,GAAU,EAA3C;AACP,OAAO,IAAMC,qBAAqB,GAAG,GAA9B;AACP,OAAO,IAAMC,eAAe,GAAG,KAAxB;AAEP,OAAO,SAASC,iBAAT,CAA2BC,OAA3B,EAA0D;AAC/D,MAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AACA,MAAMC,QAAQ,GAAG;AACf,4DAAiDf,iBAAiB,CAACa,OAAO,CAACG,MAAR,CAAef,MAAf,CAAD,CAAlE,CADe;AAEf,kBAAc,IAFC,CAEI;;AAFJ,GAAjB;AAKA,2BACKL,kBAAkB,CAACgB,OAAD,EAAU;AAAEK,IAAAA,CAAC,EAAE,CAAL;AAAQC,IAAAA,CAAC,EAAE;AAAX,GAAV,EAA0B,MAA1B,EAAkC,IAAlC,EAAwC,IAAxC,CADvB;AAEEC,IAAAA,OAAO,EAAEtB,qBAAqB,EAFhC;AAGEuB,IAAAA,OAAO,EAAE;AACPC,MAAAA,KAAK,EAAET,OAAO,CAACS;AADR,KAHX;AAMEC,IAAAA,KAAK,EAAE,cANT;AAOEC,IAAAA,OAAO,EAAE;AACPC,MAAAA,IAAI,EAAE,cADC;AAEPC,MAAAA,KAAK,EAAE;AAFA,KAPX;AAWEC,IAAAA,IAAI,EAAE,SAXR;AAYEC,IAAAA,SAAS,EAAEZ;AAZb;AAcD,C,CAED;;AAEA,OAAO,SAASa,cAAT,CAAwBC,GAAxB,EAA+CC,KAA/C,EAA8DC,MAA9D,EAA8E;AACnF;AACA,MAAMC,MAAyB,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAlC;AACA,MAAMC,GAAoC,GAAGH,MAAM,CAACI,UAAP,CAAkB,IAAlB,CAA7C;AAEA,MAAI,CAACD,GAAL,EAAU,OAAO,IAAP,CALyE,CAOnF;;AACAH,EAAAA,MAAM,CAACF,KAAP,GAAeA,KAAf;AACAE,EAAAA,MAAM,CAACD,MAAP,GAAgBA,MAAhB,CATmF,CAWnF;;AACAI,EAAAA,GAAG,CAACE,SAAJ,CAAcR,GAAd,EAAmB,CAAnB,EAAsB,CAAtB,EAAyBC,KAAzB,EAAgCC,MAAhC,EAZmF,CAcnF;;AACA,SAAOC,MAAM,CAACM,SAAP,EAAP;AACD;AAED,OAAO,SAASC,gBAAT,CAA0BC,UAA1B,EAA8CC,QAA9C,EAAgEC,SAAhE,EAAmF;AACxF,SAAO,IAAIC,OAAJ,CAA2B,UAAAC,OAAO,EAAI;AAC3C,QAAMf,GAAG,GAAG,IAAIgB,KAAJ,EAAZ;;AACAhB,IAAAA,GAAG,CAACiB,MAAJ,GAAa,YAAM;AAAA,UACXhB,KADW,GACOD,GADP,CACXC,KADW;AAAA,UACJC,MADI,GACOF,GADP,CACJE,MADI;AAEjB,UAAIgB,KAAK,GAAG,CAAZ;;AACA,UAAIjB,KAAK,GAAGW,QAAZ,EAAsB;AACpBM,QAAAA,KAAK,GAAGN,QAAQ,GAAGX,KAAnB;AACAA,QAAAA,KAAK,GAAGW,QAAR;AACAV,QAAAA,MAAM,IAAIgB,KAAV;AACD,OAJD,MAIO,IAAIhB,MAAM,GAAGW,SAAb,EAAwB;AAC7BK,QAAAA,KAAK,GAAGL,SAAS,GAAGX,MAApB;AACAD,QAAAA,KAAK,IAAIiB,KAAT;AACAhB,QAAAA,MAAM,GAAGW,SAAT;AACD;;AACD,UAAMM,UAAU,GAAGpB,cAAc,CAACC,GAAD,EAAMC,KAAN,EAAaC,MAAb,CAAjC;AACAa,MAAAA,OAAO,CAACI,UAAD,CAAP;AACD,KAdD;;AAeAnB,IAAAA,GAAG,CAACoB,GAAJ,GAAUT,UAAV;AACD,GAlBM,CAAP;AAmBD;AAED,OAAO,SAASU,SAAT,CAAmBC,KAAnB,EAA4C;AACjD,SAAO;AACLlC,IAAAA,CAAC,EAAEkC,KAAK,CAAClC,CAAN,KAAY,CAAZ,GAAgBP,eAAhB,GAAkCyC,KAAK,CAAClC,CADtC;AAELC,IAAAA,CAAC,EAAEiC,KAAK,CAACjC,CAAN,KAAY,CAAZ,GAAgBR,eAAhB,GAAkCyC,KAAK,CAACjC,CAFtC;AAGLkC,IAAAA,CAAC,EAAED,KAAK,CAACC,CAAN,KAAY,CAAZ,GAAgB1C,eAAhB,GAAkCyC,KAAK,CAACC;AAHtC,GAAP;AAKD;AAED,OAAO,SAASC,oBAAT,CAA8BC,KAA9B,EAAmD;AACxD,MAAMC,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAK,CAACI,QAApB,EAA8BC,MAA9B,CAAqC,UAACC,WAAD,EAAcC,MAAd,EAAyB;AACrFD,IAAAA,WAAW,CAACC,MAAM,CAACC,EAAR,CAAX,qBAA8BD,MAA9B;AAAsCE,MAAAA,aAAa,EAAE;AAArD;AACA,WAAOH,WAAP;AACD,GAHwB,EAGtB,EAHsB,CAAzB;AAKA,2BACKN,KADL;AAEEI,IAAAA,QAAQ,EAAEH;AAFZ;AAID;AAED,OAAO,SAASS,2BAAT,CAAqCC,CAArC,EAAkF;AACvF,UAAQA,CAAC,CAACC,GAAV;AACE,SAAK,MAAL;AACA,SAAK,WAAL;AACE,aAAO,WAAP;;AACF,SAAK,IAAL;AACA,SAAK,SAAL;AACE,aAAO,SAAP;;AACF,SAAK,MAAL;AACA,SAAK,WAAL;AACE,aAAO,WAAP;;AACF,SAAK,OAAL;AACA,SAAK,YAAL;AACE,aAAO,YAAP;AAZJ;;AAcA,SAAO,IAAP;AACD;AAED,OAAO,SAASC,kBAAT,CACLC,CADK,EAELC,CAFK,EAGL;AACA,SACED,CAAC,CAACE,QAAF,CAAWrD,CAAX,KAAiBoD,CAAC,CAACC,QAAF,CAAWrD,CAA5B,IACAmD,CAAC,CAACE,QAAF,CAAWpD,CAAX,KAAiBmD,CAAC,CAACC,QAAF,CAAWpD,CAD5B,IAEAkD,CAAC,CAACE,QAAF,CAAWlB,CAAX,KAAiBiB,CAAC,CAACC,QAAF,CAAWlB,CAF5B,IAGAgB,CAAC,CAACG,QAAF,CAAWtD,CAAX,KAAiBoD,CAAC,CAACE,QAAF,CAAWtD,CAH5B,IAIAmD,CAAC,CAACG,QAAF,CAAWrD,CAAX,KAAiBmD,CAAC,CAACE,QAAF,CAAWrD,CAJ5B,IAKAkD,CAAC,CAACG,QAAF,CAAWnB,CAAX,KAAiBiB,CAAC,CAACE,QAAF,CAAWnB,CAL5B,IAMAgB,CAAC,CAACG,QAAF,CAAWC,CAAX,KAAiBH,CAAC,CAACE,QAAF,CAAWC,CAN5B,IAOAJ,CAAC,CAACjB,KAAF,CAAQlC,CAAR,KAAcoD,CAAC,CAAClB,KAAF,CAAQlC,CAPtB,IAQAmD,CAAC,CAACjB,KAAF,CAAQjC,CAAR,KAAcmD,CAAC,CAAClB,KAAF,CAAQjC,CARtB,IASAkD,CAAC,CAACjB,KAAF,CAAQC,CAAR,KAAciB,CAAC,CAAClB,KAAF,CAAQC,CAVxB;AAYD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASqB,cAAT,CAAwBC,SAAxB,EAA+C;AACpD,SAAOA,SAAS,CAACC,GAAV,CAAc,UAAAC,QAAQ,EAAI;AAC/B;AACA,QAAIA,QAAQ,CAACC,QAAT,KAAsB,MAA1B,EAAkC;AAChC,UAAMC,aAAuB,sBAASF,QAAD,CAAkBG,KAAlB,IAA2B,EAAnC,CAA7B,CADgC,CACqC;;;AACrE,UAAMA,KAAK,GAAGC,KAAK,CAACC,IAAN,CACZ,IAAIC,GAAJ,8BAAoBJ,aAApB,sBAAsC/E,uBAAuB,EAA7D,GADY,CAAd;AAGA,+BACK6E,QADL;AAEEG,QAAAA,KAAK,EAALA,KAFF;AAGEI,QAAAA,eAAe,EAAEP,QAAQ,CAACO,eAAT,CAAyBR,GAAzB,CAA6B,UAAAS,cAAc;AAAA,mCACvDA,cADuD;AAE1DC,YAAAA,aAAa,EAAEN;AAF2C;AAAA,SAA3C;AAHnB;AAQD;;AACD,WAAOH,QAAP;AACD,GAjBM,CAAP;AAkBD;AAED,OAAO,IAAMU,UAAU,GAAG,SAAbA,UAAa,CAAIC,KAAJ,EAAsB;AAC9C,SAAOA,KAAK,CAAEhF,IAAI,CAACiF,MAAL,KAAgBD,KAAK,CAACE,MAAvB,GAAiC,CAAlC,CAAZ;AACD,CAFM;AAIP;AACA;AACA;;AACA,OAAO,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAACd,QAAD,EAAwB;AAC7C,MAAIpD,IAAI,GAAGoD,QAAQ,CAACd,EAAT,CAAY6B,KAAZ,CAAkB,GAAlB,EAAuBC,GAAvB,EAAX;;AACA,MAAIpE,IAAI,CAACqE,UAAL,CAAgB,IAAhB,KAAyBrE,IAAI,CAACqE,UAAL,CAAgB,IAAhB,CAA7B,EAAoD;AAClD;AACArE,IAAAA,IAAI,GAAGA,IAAI,CAACsE,KAAL,CAAW,CAAX,CAAP;AACD;;AACD,SAAOtE,IAAI,CACRmE,KADI,CACE,GADF,EAEJhB,GAFI,CAEA,UAAAoB,OAAO,EAAI;AACd,QAAMC,IAAI,GAAGC,MAAM,CAACF,OAAD,CAAnB;AACA,QAAMG,SAAS,GAAG,CAACC,KAAK,CAACH,IAAD,CAAxB;AACA;AACN;AACA;AACA;AACA;AACA;;AACM,WAAO,CAACE,SAAD,IAAcF,IAAI,IAAI,CAAtB,GAA0BD,OAA1B,GAAoC,IAA3C;AACD,GAZI,EAaJK,MAbI,CAaG,UAAAJ,IAAI;AAAA,WAAIA,IAAI,IAAI,IAAZ;AAAA,GAbP,EAayB;AAbzB,GAcJrB,GAdI,CAcA,UAAAqB,IAAI;AAAA,WAAIlG,UAAU,CAACkG,IAAD,CAAd;AAAA,GAdJ,EAeJK,IAfI,CAeC,GAfD,CAAP;AAgBD,CAtBM;AAwBP;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,GAAxB,EAA6C;AAClD,MAAMC,YAAY,GAAG,0CAArB;AACA,MAAMC,OAAO,GAAGD,YAAY,CAACE,IAAb,CAAkBH,GAAlB,CAAhB;;AACA,MAAIE,OAAO,IAAIA,OAAO,CAAC,CAAD,CAAtB,EAA2B;AACzB,WAAOA,OAAO,CAAC,CAAD,CAAd;AACD;;AACD,QAAM,IAAIE,KAAJ,CAAU,kCAAkCJ,GAA5C,CAAN;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,WAAT,CAAqBL,GAArB,EAA0C;AAC/C,MAAMM,SAAS,GAAG,oDAAlB;AACA,MAAMJ,OAAO,GAAGI,SAAS,CAACH,IAAV,CAAeH,GAAf,CAAhB;;AACA,MAAIE,OAAO,IAAIA,OAAO,CAAC,CAAD,CAAtB,EAA2B;AACzB,WAAOA,OAAO,CAAC,CAAD,CAAd;AACD;;AACD,QAAM,IAAIE,KAAJ,CAAU,+BAA+BJ,GAAzC,CAAN;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,8BAAT,CAAwCC,gBAAxC,EAAsF;AAC3F,SAAO;AACLjD,IAAAA,EAAE,EAAEiD,gBAAgB,CAACjD,EADhB;AAELkD,IAAAA,IAAI,EAAE,UAFD;AAGLnC,IAAAA,QAAQ,EAAEkC,gBAAgB,CAACE,IAAjB,CAAsBpC,QAH3B;AAIL1D,IAAAA,OAAO,EAAEmF,cAAc,CAACS,gBAAgB,CAACG,SAAlB,CAJlB;AAKLC,IAAAA,IAAI,EAAEJ,gBAAgB,CAACE,IAAjB,CAAsBE,IALvB;AAMLhC,IAAAA,eAAe,EAAE4B,gBAAgB,CAACE,IAAjB,CAAsB9B,eAAtB,CAAsCR,GAAtC,CAA0C,UAAAS,cAAc;AAAA,aAAK;AAC5EgC,QAAAA,UAAU,EAAEhC,cAAc,CAACgC,UADiD;AAE5EC,QAAAA,QAAQ,EAAEjC,cAAc,CAACiC,QAFmD;AAG5EC,QAAAA,QAAQ,EAAElC,cAAc,CAACkC,QAAf,CAAwB3C,GAAxB,CAA4B,UAAA4C,OAAO;AAAA,iBAAK;AAChDC,YAAAA,IAAI,EAAED,OAAO,CAACrD,GADkC;AAEhDuD,YAAAA,IAAI,EAAEb,WAAW,CAACW,OAAO,CAAChB,GAAT;AAF+B,WAAL;AAAA,SAAnC;AAHkE,OAAL;AAAA,KAAxD;AANZ,GAAP;AAeD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASmB,eAAT,CAAyBhD,SAAzB,EAAgDG,QAAhD,EAA4E8C,SAA5E,EAAsH;AAC3H,SAAOjD,SAAS,CAAC0B,MAAV,CACL,UAAAxB,QAAQ;AAAA,WACNA,QAAQ,CAACC,QAAT,KAAsBA,QAAtB,IACAD,QAAQ,CAACO,eAAT,CAAyByC,IAAzB,CAA8B,UAAAxC,cAAc;AAAA,aAAIA,cAAc,CAACgC,UAAf,CAA0BQ,IAA1B,CAA+B,UAAAC,UAAU;AAAA,eAAIA,UAAU,KAAKF,SAAnB;AAAA,OAAzC,CAAJ;AAAA,KAA5C,CAFM;AAAA,GADH,CAAP;AAKD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,KAAT,CAAeC,KAAf,EAA8B;AACnC,SAAOA,KAAK,CACTC,WADI,GAEJlC,KAFI,CAEE,CAFF,EAEK,CAFL,EAGJmC,WAHI,EAAP;AAID;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBC,IAApB,EAAoD;AACzD,SAAO;AACLrE,IAAAA,EAAE,EAAEqE,IAAI,CAACrE,EADJ;AAELtC,IAAAA,IAAI,EAAE2G,IAAI,CAAC3G,IAFN;AAGL0F,IAAAA,SAAS,EAAEiB,IAAI,CAACjB,SAHX;AAILkB,IAAAA,KAAK,EAAED,IAAI,CAACjB,SAJP;AAKLmB,IAAAA,WAAW,EAAEF,IAAI,CAACE,WALb;AAMLC,IAAAA,IAAI,EAAE,CACJ;AACEC,MAAAA,IAAI,EAAE7I,MAAM,CAAC8I,EADf;AAEEC,MAAAA,IAAI,EAAEN,IAAI,CAAC3G;AAFb,KADI,CAND;AAYLyF,IAAAA,IAAI,oBACCkB,IAAI,CAAClB,IADN;AAEFpC,MAAAA,QAAQ,EAAEsD,IAAI,CAAClB,IAAL,CAAUpC,QAFlB;AAGFM,MAAAA,eAAe,EAAEgD,IAAI,CAAClB,IAAL,CAAU9B,eAAV,CAA0BR,GAA1B,CAA8B,UAAAS,cAAc;AAAA,iCACxDA,cADwD;AAE3DkC,UAAAA,QAAQ,EAAElC,cAAc,CAACkC,QAAf,CAAwB3C,GAAxB,CAA4B,UAAA+D,IAAI;AAAA,mBAAK;AAAExE,cAAAA,GAAG,EAAEwE,IAAP;AAAanC,cAAAA,GAAG,EAAE1G,qBAAqB,CAACsI,IAAI,CAACb,QAAL,CAAcoB,IAAd,CAAD;AAAvC,aAAL;AAAA,WAAhC;AAFiD;AAAA,OAA5C;AAHf,MAZC;AAoBLC,IAAAA,WAAW,EACTR,IAAI,CAACnB,IAAL,KAAcrH,QAAQ,CAACiJ,KAAvB,GACI;AACEC,MAAAA,IAAI,EAAIV,IAAI,CAAClB,IAAL,CAAUpC,QAAZ,KAAuDpF,aAAa,CAACqJ;AAD7E,KADJ,GAIIC;AAzBD,GAAP;AA2BD;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBb,IAAlB,EAAsC;AAC3C,MAAMvD,QAAQ,GAAGsD,UAAU,CAACC,IAAD,CAA3B;AACA,MAAMc,WAAW,GAAGC,IAAI,CAACC,SAAL,CAAevE,QAAf,CAApB;AACA,MAAMwE,SAAS,GAAGH,WAAW,CAACI,OAAZ,CAAoB,kBAApB,EAAwC,EAAxC,CAAlB;AACA,SAAOC,IAAI,CAACF,SAAD,CAAX;AACD","sourcesContent":["import { Color4, Wearable } from 'decentraland-ecs'\nimport { EmoteCategory, Locale, WearableBodyShape, WearableCategory, WearableDefinition } from '@dcl/schemas'\nimport { Item, ItemType } from 'modules/item/types'\nimport { CatalystWearable, EditorScene, UnityKeyboardEvent } from 'modules/editor/types'\nimport { Project } from 'modules/project/types'\nimport { getSceneDefinition } from 'modules/project/export'\nimport { getContentsStorageUrl } from 'lib/api/builder'\nimport { capitalize } from 'lib/text'\nimport { Vector3 } from 'modules/models/types'\nimport { getSkinHiddenCategories } from 'modules/item/utils'\nimport { Scene, EntityDefinition, ComponentDefinition, ComponentType } from 'modules/scene/types'\nimport { base64ArrayBuffer } from './base64'\n\nconst script = require('raw-loader!../../ecsScene/scene.js')\n\nexport const THUMBNAIL_WIDTH = 984\nexport const THUMBNAIL_HEIGHT = 728\nexport const POSITION_GRID_RESOLUTION = 0.5\nexport const ROTATION_GRID_RESOLUTION = Math.PI / 16\nexport const SCALE_GRID_RESOLUTION = 0.5\nexport const SCALE_MIN_LIMIT = 0.001\n\nexport function getNewEditorScene(project: Project): EditorScene {\n  const encoder = new TextEncoder()\n  const mappings = {\n    'game.js': `data:application/javascript;base64,${base64ArrayBuffer(encoder.encode(script))}`,\n    'scene.json': 'Qm' // stub required by the client\n  }\n\n  return {\n    ...getSceneDefinition(project, { x: 0, y: 0 }, 'east', null, null),\n    baseUrl: getContentsStorageUrl(),\n    display: {\n      title: project.title\n    },\n    owner: 'Decentraland',\n    contact: {\n      name: 'Decentraland',\n      email: 'support@decentraland.org'\n    },\n    main: 'game.js',\n    _mappings: mappings\n  } as EditorScene\n}\n\n// Screenshots\n\nexport function imageToDataUri(img: HTMLImageElement, width: number, height: number) {\n  // create an off-screen canvas\n  const canvas: HTMLCanvasElement = document.createElement('canvas')\n  const ctx: CanvasRenderingContext2D | null = canvas.getContext('2d')\n\n  if (!ctx) return null\n\n  // set its dimension to target size\n  canvas.width = width\n  canvas.height = height\n\n  // draw source image into the off-screen canvas:\n  ctx.drawImage(img, 0, 0, width, height)\n\n  // encode image to data-uri with base64 version of compressed image\n  return canvas.toDataURL()\n}\n\nexport function resizeScreenshot(screenshot: string, maxWidth: number, maxHeight: number) {\n  return new Promise<string | null>(resolve => {\n    const img = new Image()\n    img.onload = () => {\n      let { width, height } = img\n      let ratio = 0\n      if (width > maxWidth) {\n        ratio = maxWidth / width\n        width = maxWidth\n        height *= ratio\n      } else if (height > maxHeight) {\n        ratio = maxHeight / height\n        width *= ratio\n        height = maxHeight\n      }\n      const newDataUri = imageToDataUri(img, width, height)\n      resolve(newDataUri)\n    }\n    img.src = screenshot\n  })\n}\n\nexport function snapScale(scale: Vector3): Vector3 {\n  return {\n    x: scale.x === 0 ? SCALE_MIN_LIMIT : scale.x,\n    y: scale.y === 0 ? SCALE_MIN_LIMIT : scale.y,\n    z: scale.z === 0 ? SCALE_MIN_LIMIT : scale.z\n  }\n}\n\nexport function createReadyOnlyScene(scene: Scene): Scene {\n  const readOnlyEntities = Object.values(scene.entities).reduce((newEntities, entity) => {\n    newEntities[entity.id] = { ...entity, disableGizmos: true }\n    return newEntities\n  }, {} as Record<string, EntityDefinition>)\n\n  return {\n    ...scene,\n    entities: readOnlyEntities\n  }\n}\n\nexport function convertToUnityKeyboardEvent(e: KeyboardEvent): UnityKeyboardEvent | null {\n  switch (e.key) {\n    case 'Down':\n    case 'ArrowDown':\n      return 'DownArrow'\n    case 'Up':\n    case 'ArrowUp':\n      return 'UpArrow'\n    case 'Left':\n    case 'ArrowLeft':\n      return 'LeftArrow'\n    case 'Right':\n    case 'ArrowRight':\n      return 'RightArrow'\n  }\n  return null\n}\n\nexport function areEqualTransforms(\n  a: ComponentDefinition<ComponentType.Transform>['data'],\n  b: ComponentDefinition<ComponentType.Transform>['data']\n) {\n  return (\n    a.position.x === b.position.x &&\n    a.position.y === b.position.y &&\n    a.position.z === b.position.z &&\n    a.rotation.x === b.rotation.x &&\n    a.rotation.y === b.rotation.y &&\n    a.rotation.z === b.rotation.z &&\n    a.rotation.w === b.rotation.w &&\n    a.scale.x === b.scale.x &&\n    a.scale.y === b.scale.y &&\n    a.scale.z === b.scale.z\n  )\n}\n\n/**\n * Makes runtime changes to wearable objects before sending them to the ECS scene. This is because we are using an outdated version of the ECS,\n * and certain tweaks need to be made in order to make the up-to-date wearables work on it.\n * @param wearables\n */\nexport function patchWearables(wearables: Wearable[]) {\n  return wearables.map(wearable => {\n    // 1. if the category is \"skin\" we need to hide all the other categories\n    if (wearable.category === 'skin') {\n      const alreadyHidden: string[] = [...((wearable as any).hides || [])] // The typing from decentraland-ecs is wrong and it misses the hides list\n      const hides = Array.from(\n        new Set<string>([...alreadyHidden, ...getSkinHiddenCategories()])\n      )\n      return {\n        ...wearable,\n        hides,\n        representations: wearable.representations.map(representation => ({\n          ...representation,\n          overrideHides: hides\n        }))\n      }\n    }\n    return wearable\n  })\n}\n\nexport const pickRandom = <T>(array: T[]): T => {\n  return array[(Math.random() * array.length) | 0]\n}\n\n/*\n * Converts stuff like \"f_jeans_00\" into \"Jeans\"\n */\nexport const getName = (wearable: Wearable) => {\n  let name = wearable.id.split(':').pop()!\n  if (name.startsWith('f_') || name.startsWith('m_')) {\n    // Remove prefixes f_ and m_\n    name = name.slice(2)\n  }\n  return name\n    .split('_')\n    .map(strPart => {\n      const part = Number(strPart)\n      const isNumeric = !isNaN(part)\n      /*\n       * Numeric parts are like 00, 01, 02. This ignores the 00, and parses the other ones, like:\n       * hair_00 -> hair\n       * hair_01 -> hair 2\n       * hair_02 -> hair 3\n       */\n      return !isNumeric || part <= 0 ? strPart : null\n    })\n    .filter(part => part != null) // Filter out ignored parts\n    .map(part => capitalize(part!))\n    .join(' ')\n}\n\n/**\n * Extracts the base URL from the catalyst items' URL.\n *\n * @param url - The catalyst wearable's URL.\n */\nexport function extractBaseUrl(url: string): string {\n  const baseURLRegex = /(http[s]?:\\/\\/.+\\/content\\/contents\\/).+/\n  const matches = baseURLRegex.exec(url)\n  if (matches && matches[1]) {\n    return matches[1]\n  }\n  throw new Error('No base URL found in th URL: ' + url)\n}\n\n/**\n * Extracts the wearable's hash from a catalyst wearable's URL.\n *\n * @param url - The catalyst item's URL.\n */\nexport function extractHash(url: string): string {\n  const hashRegex = /http[s]?:\\/\\/.+\\/content\\/contents\\/([a-zA-Z0-9]+)/\n  const matches = hashRegex.exec(url)\n  if (matches && matches[1]) {\n    return matches[1]\n  }\n  throw new Error('No hash found in the URL: ' + url)\n}\n\n/**\n * Converts a Catalyst's wearable into a Wearable.\n *\n * @param catalystWearable - The catalyst wearable to convert.\n */\nexport function fromCatalystWearableToWearable(catalystWearable: CatalystWearable): Wearable {\n  return {\n    id: catalystWearable.id,\n    type: 'wearable',\n    category: catalystWearable.data.category,\n    baseUrl: extractBaseUrl(catalystWearable.thumbnail),\n    tags: catalystWearable.data.tags,\n    representations: catalystWearable.data.representations.map(representation => ({\n      bodyShapes: representation.bodyShapes,\n      mainFile: representation.mainFile,\n      contents: representation.contents.map(content => ({\n        file: content.key,\n        hash: extractHash(content.url)\n      }))\n    }))\n  }\n}\n\n/**\n * Given a list of wearables, return those which category and body shape are the ones specified in the parameters.\n *\n * @param wearables - The catalyst wearable to convert.\n * @param category - The category to filter by.\n * @param bodyShape - The body shape to filter by.\n */\nexport function filterWearables(wearables: Wearable[], category: WearableCategory, bodyShape: WearableBodyShape): Wearable[] {\n  return wearables.filter(\n    wearable =>\n      wearable.category === category &&\n      wearable.representations.some(representation => representation.bodyShapes.some(_bodyShape => _bodyShape === bodyShape))\n  )\n}\n\n/**\n * Given a color return the hex value\n *\n * @param color - a Color4 value\n */\nexport function toHex(color: Color4) {\n  return color\n    .toHexString()\n    .slice(1, 7)\n    .toLowerCase()\n}\n\n/**\n * Given an item convert it to a wearable definition\n *\n * @param item - an Item\n */\nexport function toWearable(item: Item): WearableDefinition {\n  return {\n    id: item.id,\n    name: item.name,\n    thumbnail: item.thumbnail,\n    image: item.thumbnail,\n    description: item.description,\n    i18n: [\n      {\n        code: Locale.EN,\n        text: item.name\n      }\n    ],\n    data: {\n      ...item.data,\n      category: item.data.category as WearableCategory,\n      representations: item.data.representations.map(representation => ({\n        ...representation,\n        contents: representation.contents.map(path => ({ key: path, url: getContentsStorageUrl(item.contents[path]) }))\n      }))\n    },\n    emoteDataV0:\n      item.type === ItemType.EMOTE\n        ? {\n            loop: ((item.data.category as unknown) as EmoteCategory) === EmoteCategory.LOOP\n          }\n        : undefined\n  }\n}\n\n/**\n * Given an item return the base64 of its wearable definition\n *\n * @param item - an Item\n */\nexport function toBase64(item: Item): string {\n  const wearable = toWearable(item)\n  const stringified = JSON.stringify(wearable)\n  const sanitized = stringified.replace(/[\\u0250-\\ue007]/g, '')\n  return btoa(sanitized)\n}\n"]},"metadata":{},"sourceType":"module"}