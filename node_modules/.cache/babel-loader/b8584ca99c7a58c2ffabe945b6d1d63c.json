{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { MaterialHelper } from '../../../materialHelper';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"../../../../Shaders/ShadersInclude/lightFragment\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex\";\n/**\r\n * Block used to add light in the fragment shader\r\n */\n\nvar LightBlock =\n/** @class */\nfunction (_super) {\n  __extends(LightBlock, _super);\n  /**\r\n   * Create a new LightBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function LightBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.VertexAndFragment) || this;\n\n    _this._isUnique = true;\n\n    _this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n\n    _this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n\n    _this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  LightBlock.prototype.getClassName = function () {\n    return \"LightBlock\";\n  };\n\n  Object.defineProperty(LightBlock.prototype, \"worldPosition\", {\n    /**\r\n     * Gets the world position input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"worldNormal\", {\n    /**\r\n     * Gets the world normal input component\r\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"cameraPosition\", {\n    /**\r\n    * Gets the camera (or eye) position component\r\n    */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"glossiness\", {\n    /**\r\n    * Gets the glossiness component\r\n    */\n    get: function get() {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"glossPower\", {\n    /**\r\n    * Gets the glossinness power component\r\n    */\n    get: function get() {\n      return this._inputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"diffuseColor\", {\n    /**\r\n    * Gets the diffuse color component\r\n    */\n    get: function get() {\n      return this._inputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"specularColor\", {\n    /**\r\n    * Gets the specular color component\r\n    */\n    get: function get() {\n      return this._inputs[6];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"view\", {\n    /**\r\n    * Gets the view matrix component\r\n    */\n    get: function get() {\n      return this._inputs[7];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"diffuseOutput\", {\n    /**\r\n     * Gets the diffuse output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"specularOutput\", {\n    /**\r\n     * Gets the specular output component\r\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"shadow\", {\n    /**\r\n     * Gets the shadow output component\r\n     */\n    get: function get() {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  LightBlock.prototype.autoConfigure = function (material) {\n    if (!this.cameraPosition.isConnected) {\n      var cameraPositionInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.CameraPosition;\n      });\n\n      if (!cameraPositionInput) {\n        cameraPositionInput = new InputBlock(\"cameraPosition\");\n        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n      }\n\n      cameraPositionInput.output.connectTo(this.cameraPosition);\n    }\n  };\n\n  LightBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areLightsDirty) {\n      return;\n    }\n\n    var scene = mesh.getScene();\n\n    if (!this.light) {\n      MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      var state = {\n        needNormals: false,\n        needRebuild: false,\n        lightmapMode: false,\n        shadowEnabled: false,\n        specularEnabled: false\n      };\n      MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\n\n      if (state.needRebuild) {\n        defines.rebuild();\n      }\n    }\n  };\n\n  LightBlock.prototype.updateUniformsAndSamples = function (state, nodeMaterial, defines, uniformBuffers) {\n    for (var lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      var onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\n      MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffers, onlyUpdateBuffersList);\n    }\n  };\n\n  LightBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n\n    var scene = mesh.getScene();\n\n    if (!this.light) {\n      MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);\n    }\n  };\n\n  LightBlock.prototype._injectVertexCode = function (state) {\n    var worldPos = this.worldPosition;\n    var comments = \"//\" + this.name; // Declaration\n\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n\n      this._lightId = 0;\n      state.sharedData.dynamicUniformBlocks.push(this);\n    } else {\n      this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\n      state.counters[\"lightCounter\"] = this._lightId;\n\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    } // Inject code in vertex\n\n\n    var worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\n\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      state.compilationString += worldPosVaryingName + \" = \" + worldPos.associatedVariableName + \";\\r\\n\";\n    }\n\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }, {\n          search: /worldPos/g,\n          replace: worldPos.associatedVariableName\n        }]\n      });\n    } else {\n      state.compilationString += \"vec4 worldPos = \" + worldPos.associatedVariableName + \";\\r\\n\";\n\n      if (this.view.isConnected) {\n        state.compilationString += \"mat4 view = \" + this.view.associatedVariableName + \";\\r\\n\";\n      }\n\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n  };\n\n  LightBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n\n      return;\n    } // Fragment\n\n\n    state.sharedData.bindableBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    var comments = \"//\" + this.name;\n    var worldPos = this.worldPosition;\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: \"v_\" + worldPos.associatedVariableName + \".xyz\"\n      }]\n    });\n\n    state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: \"v_\" + worldPos.associatedVariableName + \".xyz\"\n      }]\n    });\n\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    } else {\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    } // Code\n\n\n    if (this._lightId === 0) {\n      if (state._registerTempVariable(\"viewDirectionW\")) {\n        state.compilationString += \"vec3 viewDirectionW = normalize(\" + this.cameraPosition.associatedVariableName + \" - \" + (\"v_\" + worldPos.associatedVariableName) + \".xyz);\\r\\n\";\n      }\n\n      state.compilationString += \"lightingInfo info;\\r\\n\";\n      state.compilationString += \"float shadow = 1.;\\r\\n\";\n      state.compilationString += \"float glossiness = \" + (this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\") + \" * \" + (this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\") + \";\\r\\n\";\n      state.compilationString += \"vec3 diffuseBase = vec3(0., 0., 0.);\\r\\n\";\n      state.compilationString += \"vec3 specularBase = vec3(0., 0., 0.);\\r\\n\";\n      state.compilationString += \"vec3 normalW = \" + this.worldNormal.associatedVariableName + \".xyz;\\r\\n\";\n    }\n\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      });\n    } else {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n\n    var diffuseOutput = this.diffuseOutput;\n    var specularOutput = this.specularOutput;\n    state.compilationString += this._declareOutput(diffuseOutput, state) + (\" = diffuseBase\" + (this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\") + \";\\r\\n\");\n\n    if (specularOutput.hasEndpoints) {\n      state.compilationString += this._declareOutput(specularOutput, state) + (\" = specularBase\" + (this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\") + \";\\r\\n\");\n    }\n\n    if (this.shadow.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.shadow, state) + \" = shadow;\\r\\n\";\n    }\n\n    return this;\n  };\n\n  LightBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this.light) {\n      serializationObject.lightId = this.light.id;\n    }\n\n    return serializationObject;\n  };\n\n  LightBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    if (serializationObject.lightId) {\n      this.light = scene.getLightByID(serializationObject.lightId);\n    }\n  };\n\n  return LightBlock;\n}(NodeMaterialBlock);\n\nexport { LightBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.LightBlock\"] = LightBlock;","map":null,"metadata":{},"sourceType":"module"}