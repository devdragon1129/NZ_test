{"ast":null,"code":"import { Vector3, Matrix, TmpVectors, Quaternion } from \"../Maths/math.vector\";\nimport { Color4 } from '../Maths/math.color';\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { DiscBuilder } from \"../Meshes/Builders/discBuilder\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { DepthSortedParticle, SolidParticle, ModelShape, SolidParticleVertex } from \"./solidParticle\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { Axis } from '../Maths/math.axis';\nimport { SubMesh } from '../Meshes/subMesh';\nimport { StandardMaterial } from '../Materials/standardMaterial';\nimport { MultiMaterial } from '../Materials/multiMaterial';\nimport { Tools } from '../Misc/tools';\n/**\r\n * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.\r\n *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The SPS is also a particle system. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : https://doc.babylonjs.com/how_to/Solid_Particle_System\r\n */\n\nvar SolidParticleSystem =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a SPS (Solid Particle System) object.\r\n   * @param name (String) is the SPS name, this will be the underlying mesh name.\r\n   * @param scene (Scene) is the scene in which the SPS is added.\r\n   * @param options defines the options of the sps e.g.\r\n   * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.\r\n   * * isPickable (optional boolean, default false) : if the solid particles must be pickable.\r\n   * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.\r\n   * * useModelMaterial (optional boolean, defaut false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.\r\n   * * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.\r\n   * * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.\r\n   * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.\r\n   * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\r\n   * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.\r\n   * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\r\n   */\n  function SolidParticleSystem(name, scene, options) {\n    /**\r\n     *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\n    this.particles = new Array();\n    /**\r\n     * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\r\n     */\n\n    this.nbParticles = 0;\n    /**\r\n     * If the particles must ever face the camera (default false). Useful for planar particles.\r\n     */\n\n    this.billboard = false;\n    /**\r\n     * Recompute normals when adding a shape\r\n     */\n\n    this.recomputeNormals = false;\n    /**\r\n     * This a counter ofr your own usage. It's not set by any SPS functions.\r\n     */\n\n    this.counter = 0;\n    /**\r\n     * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#garbage-collector-concerns\r\n     */\n\n    this.vars = {};\n    /**\r\n     * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)\r\n     * @hidden\r\n     */\n\n    this._bSphereOnly = false;\n    /**\r\n     * A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)\r\n     * @hidden\r\n     */\n\n    this._bSphereRadiusFactor = 1.0;\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._index = 0; // indices index\n\n    this._updatable = true;\n    this._pickable = false;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._depthSort = false;\n    this._expandable = false;\n    this._shapeCounter = 0;\n    this._copy = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);\n    this._color = new Color4(0, 0, 0, 0);\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeParticleVertex = false;\n    this._computeBoundingBox = false;\n    this._depthSortParticles = true;\n    this._mustUnrotateFixedNormals = false;\n    this._particlesIntersect = false;\n    this._needs32Bits = false;\n    this._isNotBuilt = true;\n    this._lastParticleId = 0;\n    this._idxOfId = []; // array : key = particle.id / value = particle.idx\n\n    this._multimaterialEnabled = false;\n    this._useModelMaterial = false;\n\n    this._depthSortFunction = function (p1, p2) {\n      return p2.sqDistance - p1.sqDistance;\n    };\n\n    this._materialSortFunction = function (p1, p2) {\n      return p1.materialIndex - p2.materialIndex;\n    };\n\n    this._autoUpdateSubMeshes = false;\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._camera = scene.activeCamera;\n    this._pickable = options ? options.isPickable : false;\n    this._depthSort = options ? options.enableDepthSort : false;\n    this._multimaterialEnabled = options ? options.enableMultiMaterial : false;\n    this._useModelMaterial = options ? options.useModelMaterial : false;\n    this._multimaterialEnabled = this._useModelMaterial ? true : this._multimaterialEnabled;\n    this._expandable = options ? options.expandable : false;\n    this._particlesIntersect = options ? options.particleIntersection : false;\n    this._bSphereOnly = options ? options.boundingSphereOnly : false;\n    this._bSphereRadiusFactor = options && options.bSphereRadiusFactor ? options.bSphereRadiusFactor : 1.0;\n\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n\n    if (this._pickable) {\n      this.pickedBySubMesh = [[]];\n      this.pickedParticles = this.pickedBySubMesh[0];\n    }\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      this.depthSortedParticles = [];\n    }\n\n    if (this._multimaterialEnabled) {\n      this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n      this._materials = [];\n      this._materialIndexesById = {};\n    }\n\n    this._tmpVertex = new SolidParticleVertex();\n  }\n  /**\r\n   * Builds the SPS underlying mesh. Returns a standard Mesh.\r\n   * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\r\n   * @returns the created mesh\r\n   */\n\n\n  SolidParticleSystem.prototype.buildMesh = function () {\n    if (!this._isNotBuilt && this.mesh) {\n      return this.mesh;\n    }\n\n    if (this.nbParticles === 0 && !this.mesh) {\n      var triangle = DiscBuilder.CreateDisc(\"\", {\n        radius: 1,\n        tessellation: 3\n      }, this._scene);\n      this.addShape(triangle, 1);\n      triangle.dispose();\n    }\n\n    this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices);\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n\n    if (!this.mesh) {\n      // in case it's already expanded\n      var mesh = new Mesh(this.name, this._scene);\n      this.mesh = mesh;\n    }\n\n    if (!this._updatable && this._multimaterialEnabled) {\n      this._sortParticlesByMaterial(); // this may reorder the indices32\n\n    }\n\n    if (this.recomputeNormals) {\n      VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);\n    }\n\n    this._normals32 = new Float32Array(this._normals);\n    this._fixedNormal32 = new Float32Array(this._normals);\n\n    if (this._mustUnrotateFixedNormals) {\n      // the particles could be created already rotated in the mesh with a positionFunction\n      this._unrotateFixedNormals();\n    }\n\n    var vertexData = new VertexData();\n    vertexData.indices = this._depthSort ? this._indices : this._indices32;\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n    vertexData.set(this._normals32, VertexBuffer.NormalKind);\n\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n\n    if (this._colors32.length > 0) {\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n\n    vertexData.applyToMesh(this.mesh, this._updatable);\n    this.mesh.isPickable = this._pickable;\n\n    if (this._pickable) {\n      var faceId = 0;\n\n      for (var p = 0; p < this.nbParticles; p++) {\n        var part = this.particles[p];\n        var lind = part._model._indicesLength;\n\n        for (var i = 0; i < lind; i++) {\n          var f = i % 3;\n\n          if (f == 0) {\n            var pickedData = {\n              idx: part.idx,\n              faceId: faceId\n            };\n            this.pickedParticles[faceId] = pickedData;\n            faceId++;\n          }\n        }\n      }\n    }\n\n    if (this._multimaterialEnabled) {\n      this.setMultiMaterial(this._materials);\n    }\n\n    if (!this._expandable) {\n      // free memory\n      if (!this._depthSort && !this._multimaterialEnabled) {\n        this._indices = null;\n      }\n\n      this._positions = null;\n      this._normals = null;\n      this._uvs = null;\n      this._colors = null;\n\n      if (!this._updatable) {\n        this.particles.length = 0;\n      }\n    }\n\n    this._isNotBuilt = false;\n    this.recomputeNormals = false;\n    return this.mesh;\n  };\n  /**\r\n   * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\r\n   * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\r\n   * Thus the particles generated from `digest()` have their property `position` set yet.\r\n   * @param mesh ( Mesh ) is the mesh to be digested\r\n   * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any\r\n   * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\r\n   * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\r\n   * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\r\n   * @returns the current SPS\r\n   */\n\n\n  SolidParticleSystem.prototype.digest = function (mesh, options) {\n    var size = options && options.facetNb || 1;\n    var number = options && options.number || 0;\n    var delta = options && options.delta || 0;\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n    var storage = options && options.storage ? options.storage : null;\n    var f = 0; // facet counter\n\n    var totalFacets = meshInd.length / 3; // a facet is a triangle, so 3 indices\n    // compute size from number\n\n    if (number) {\n      number = number > totalFacets ? totalFacets : number;\n      size = Math.round(totalFacets / number);\n      delta = 0;\n    } else {\n      size = size > totalFacets ? totalFacets : size;\n    }\n\n    var facetPos = []; // submesh positions\n\n    var facetNor = [];\n    var facetInd = []; // submesh indices\n\n    var facetUV = []; // submesh UV\n\n    var facetCol = []; // submesh colors\n\n    var barycenter = Vector3.Zero();\n    var sizeO = size;\n\n    while (f < totalFacets) {\n      size = sizeO + Math.floor((1 + delta) * Math.random());\n\n      if (f > totalFacets - size) {\n        size = totalFacets - f;\n      } // reset temp arrays\n\n\n      facetPos.length = 0;\n      facetNor.length = 0;\n      facetInd.length = 0;\n      facetUV.length = 0;\n      facetCol.length = 0; // iterate over \"size\" facets\n\n      var fi = 0;\n\n      for (var j = f * 3; j < (f + size) * 3; j++) {\n        facetInd.push(fi);\n        var i = meshInd[j];\n        var i3 = i * 3;\n        facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);\n        facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);\n\n        if (meshUV) {\n          var i2 = i * 2;\n          facetUV.push(meshUV[i2], meshUV[i2 + 1]);\n        }\n\n        if (meshCol) {\n          var i4 = i * 4;\n          facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);\n        }\n\n        fi++;\n      } // create a model shape for each single particle\n\n\n      var idx = this.nbParticles;\n\n      var shape = this._posToShape(facetPos);\n\n      var shapeUV = this._uvsToShapeUV(facetUV);\n\n      var shapeInd = Tools.Slice(facetInd);\n      var shapeCol = Tools.Slice(facetCol);\n      var shapeNor = Tools.Slice(facetNor); // compute the barycenter of the shape\n\n      barycenter.copyFromFloats(0, 0, 0);\n      var v;\n\n      for (v = 0; v < shape.length; v++) {\n        barycenter.addInPlace(shape[v]);\n      }\n\n      barycenter.scaleInPlace(1 / shape.length); // shift the shape from its barycenter to the origin\n      // and compute the BBox required for intersection.\n\n      var minimum = new Vector3(Infinity, Infinity, Infinity);\n      var maximum = new Vector3(-Infinity, -Infinity, -Infinity);\n\n      for (v = 0; v < shape.length; v++) {\n        shape[v].subtractInPlace(barycenter);\n        minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n        maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n      }\n\n      var bInfo;\n\n      if (this._particlesIntersect) {\n        bInfo = new BoundingInfo(minimum, maximum);\n      }\n\n      var material = null;\n\n      if (this._useModelMaterial) {\n        material = mesh.material ? mesh.material : this._setDefaultMaterial();\n      }\n\n      var modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material); // add the particle in the SPS\n\n      var currentPos = this._positions.length;\n      var currentInd = this._indices.length;\n\n      this._meshBuilder(this._index, currentInd, shape, this._positions, shapeInd, this._indices, facetUV, this._uvs, shapeCol, this._colors, shapeNor, this._normals, idx, 0, null, modelShape);\n\n      this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage); // initialize the particle position\n\n\n      this.particles[this.nbParticles].position.addInPlace(barycenter);\n\n      if (!storage) {\n        this._index += shape.length;\n        idx++;\n        this.nbParticles++;\n        this._lastParticleId++;\n      }\n\n      this._shapeCounter++;\n      f += size;\n    }\n\n    this._isNotBuilt = true; // buildMesh() is now expected for setParticles() to work\n\n    return this;\n  };\n  /**\r\n   * Unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._unrotateFixedNormals = function () {\n    var index = 0;\n    var idx = 0;\n    var tmpNormal = TmpVectors.Vector3[0];\n    var quaternion = TmpVectors.Quaternion[0];\n    var invertedRotMatrix = TmpVectors.Matrix[0];\n\n    for (var p = 0; p < this.particles.length; p++) {\n      var particle = this.particles[p];\n      var shape = particle._model._shape; // computing the inverse of the rotation matrix from the quaternion\n      // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion\n\n      if (particle.rotationQuaternion) {\n        particle.rotationQuaternion.conjugateToRef(quaternion);\n      } else {\n        var rotation = particle.rotation;\n        Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        quaternion.conjugateInPlace();\n      }\n\n      quaternion.toRotationMatrix(invertedRotMatrix);\n\n      for (var pt = 0; pt < shape.length; pt++) {\n        idx = index + pt * 3;\n        Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);\n        tmpNormal.toArray(this._fixedNormal32, idx);\n      }\n\n      index = idx + 3;\n    }\n  };\n  /**\r\n   * Resets the temporary working copy particle\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._resetCopy = function () {\n    var copy = this._copy;\n    copy.position.setAll(0);\n    copy.rotation.setAll(0);\n    copy.rotationQuaternion = null;\n    copy.scaling.setAll(1);\n    copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);\n    copy.color = null;\n    copy.translateFromPivot = false;\n    copy.shapeId = 0;\n    copy.materialIndex = null;\n  };\n  /**\r\n   * Inserts the shape model geometry in the global SPS mesh by updating the positions, indices, normals, colors, uvs arrays\r\n   * @param p the current index in the positions array to be updated\r\n   * @param ind the current index in the indices array\r\n   * @param shape a Vector3 array, the shape geometry\r\n   * @param positions the positions array to be updated\r\n   * @param meshInd the shape indices array\r\n   * @param indices the indices array to be updated\r\n   * @param meshUV the shape uv array\r\n   * @param uvs the uv array to be updated\r\n   * @param meshCol the shape color array\r\n   * @param colors the color array to be updated\r\n   * @param meshNor the shape normals array\r\n   * @param normals the normals array to be updated\r\n   * @param idx the particle index\r\n   * @param idxInShape the particle index in its shape\r\n   * @param options the addShape() method  passed options\r\n   * @model the particle model\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._meshBuilder = function (p, ind, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options, model) {\n    var i;\n    var u = 0;\n    var c = 0;\n    var n = 0;\n\n    this._resetCopy();\n\n    var copy = this._copy;\n    var storeApart = options && options.storage ? true : false;\n    copy.idx = idx;\n    copy.idxInShape = idxInShape;\n    copy.shapeId = model.shapeID;\n\n    if (this._useModelMaterial) {\n      var materialId = model._material.uniqueId;\n      var materialIndexesById = this._materialIndexesById;\n\n      if (!materialIndexesById.hasOwnProperty(materialId)) {\n        materialIndexesById[materialId] = this._materials.length;\n\n        this._materials.push(model._material);\n      }\n\n      var matIdx = materialIndexesById[materialId];\n      copy.materialIndex = matIdx;\n    }\n\n    if (options && options.positionFunction) {\n      // call to custom positionFunction\n      options.positionFunction(copy, idx, idxInShape);\n      this._mustUnrotateFixedNormals = true;\n    } // in case the particle geometry must NOT be inserted in the SPS mesh geometry\n\n\n    if (storeApart) {\n      return copy;\n    }\n\n    var rotMatrix = TmpVectors.Matrix[0];\n    var tmpVertex = this._tmpVertex;\n    var tmpVector = tmpVertex.position;\n    var tmpColor = tmpVertex.color;\n    var tmpUV = tmpVertex.uv;\n    var tmpRotated = TmpVectors.Vector3[1];\n    var pivotBackTranslation = TmpVectors.Vector3[2];\n    var scaledPivot = TmpVectors.Vector3[3];\n    Matrix.IdentityToRef(rotMatrix);\n    copy.getRotationMatrix(rotMatrix);\n    copy.pivot.multiplyToRef(copy.scaling, scaledPivot);\n\n    if (copy.translateFromPivot) {\n      pivotBackTranslation.setAll(0.0);\n    } else {\n      pivotBackTranslation.copyFrom(scaledPivot);\n    }\n\n    var someVertexFunction = options && options.vertexFunction;\n\n    for (i = 0; i < shape.length; i++) {\n      tmpVector.copyFrom(shape[i]);\n\n      if (copy.color) {\n        tmpColor.copyFrom(copy.color);\n      }\n\n      if (meshUV) {\n        tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);\n      }\n\n      if (someVertexFunction) {\n        options.vertexFunction(copy, tmpVertex, i);\n      }\n\n      tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n      Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);\n      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);\n      positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);\n\n      if (meshUV) {\n        var copyUvs = copy.uvs;\n        uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);\n        u += 2;\n      }\n\n      if (copy.color) {\n        this._color.copyFrom(tmpColor);\n      } else {\n        var color = this._color;\n\n        if (meshCol && meshCol[c] !== undefined) {\n          color.r = meshCol[c];\n          color.g = meshCol[c + 1];\n          color.b = meshCol[c + 2];\n          color.a = meshCol[c + 3];\n        } else {\n          color.r = 1.0;\n          color.g = 1.0;\n          color.b = 1.0;\n          color.a = 1.0;\n        }\n      }\n\n      colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\n      c += 4;\n\n      if (!this.recomputeNormals && meshNor) {\n        Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);\n        normals.push(tmpVector.x, tmpVector.y, tmpVector.z);\n        n += 3;\n      }\n    }\n\n    for (i = 0; i < meshInd.length; i++) {\n      var current_ind = p + meshInd[i];\n      indices.push(current_ind);\n\n      if (current_ind > 65535) {\n        this._needs32Bits = true;\n      }\n    }\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      var matIndex = copy.materialIndex !== null ? copy.materialIndex : 0;\n      this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));\n    }\n\n    return copy;\n  };\n  /**\r\n   * Returns a shape Vector3 array from positions float array\r\n   * @param positions float array\r\n   * @returns a vector3 array\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._posToShape = function (positions) {\n    var shape = [];\n\n    for (var i = 0; i < positions.length; i += 3) {\n      shape.push(Vector3.FromArray(positions, i));\n    }\n\n    return shape;\n  };\n  /**\r\n   * Returns a shapeUV array from a float uvs (array deep copy)\r\n   * @param uvs as a float array\r\n   * @returns a shapeUV array\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._uvsToShapeUV = function (uvs) {\n    var shapeUV = [];\n\n    if (uvs) {\n      for (var i = 0; i < uvs.length; i++) {\n        shapeUV.push(uvs[i]);\n      }\n    }\n\n    return shapeUV;\n  };\n  /**\r\n   * Adds a new particle object in the particles array\r\n   * @param idx particle index in particles array\r\n   * @param id particle id\r\n   * @param idxpos positionIndex : the starting index of the particle vertices in the SPS \"positions\" array\r\n   * @param idxind indiceIndex : he starting index of the particle indices in the SPS \"indices\" array\r\n   * @param model particle ModelShape object\r\n   * @param shapeId model shape identifier\r\n   * @param idxInShape index of the particle in the current model\r\n   * @param bInfo model bounding info object\r\n   * @param storage target storage array, if any\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._addParticle = function (idx, id, idxpos, idxind, model, shapeId, idxInShape, bInfo, storage) {\n    if (bInfo === void 0) {\n      bInfo = null;\n    }\n\n    if (storage === void 0) {\n      storage = null;\n    }\n\n    var sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);\n    var target = storage ? storage : this.particles;\n    target.push(sp);\n    return sp;\n  };\n  /**\r\n   * Adds some particles to the SPS from the model shape. Returns the shape id.\r\n   * Please read the doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#create-an-immutable-sps\r\n   * @param mesh is any Mesh object that will be used as a model for the solid particles.\r\n   * @param nb (positive integer) the number of particles to be created from this model\r\n   * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.\r\n   * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation\r\n   * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\r\n   * @returns the number of shapes in the system\r\n   */\n\n\n  SolidParticleSystem.prototype.addShape = function (mesh, nb, options) {\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n    this.recomputeNormals = meshNor ? false : true;\n    var indices = Tools.SliceToArray(meshInd);\n    var shapeNormals = Tools.SliceToArray(meshNor);\n    var shapeColors = meshCol ? Tools.SliceToArray(meshCol) : [];\n    var storage = options && options.storage ? options.storage : null;\n    var bbInfo = null;\n\n    if (this._particlesIntersect) {\n      bbInfo = mesh.getBoundingInfo();\n    }\n\n    var shape = this._posToShape(meshPos);\n\n    var shapeUV = this._uvsToShapeUV(meshUV);\n\n    var posfunc = options ? options.positionFunction : null;\n    var vtxfunc = options ? options.vertexFunction : null;\n    var material = null;\n\n    if (this._useModelMaterial) {\n      material = mesh.material ? mesh.material : this._setDefaultMaterial();\n    }\n\n    var modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material); // particles\n\n    for (var i = 0; i < nb; i++) {\n      this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);\n    }\n\n    this._shapeCounter++;\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return this._shapeCounter - 1;\n  };\n  /**\r\n   * Rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._rebuildParticle = function (particle, reset) {\n    if (reset === void 0) {\n      reset = false;\n    }\n\n    this._resetCopy();\n\n    var copy = this._copy;\n\n    if (particle._model._positionFunction) {\n      // recall to stored custom positionFunction\n      particle._model._positionFunction(copy, particle.idx, particle.idxInShape);\n    }\n\n    var rotMatrix = TmpVectors.Matrix[0];\n    var tmpVertex = TmpVectors.Vector3[0];\n    var tmpRotated = TmpVectors.Vector3[1];\n    var pivotBackTranslation = TmpVectors.Vector3[2];\n    var scaledPivot = TmpVectors.Vector3[3];\n    copy.getRotationMatrix(rotMatrix);\n    particle.pivot.multiplyToRef(particle.scaling, scaledPivot);\n\n    if (copy.translateFromPivot) {\n      pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);\n    } else {\n      pivotBackTranslation.copyFrom(scaledPivot);\n    }\n\n    var shape = particle._model._shape;\n\n    for (var pt = 0; pt < shape.length; pt++) {\n      tmpVertex.copyFrom(shape[pt]);\n\n      if (particle._model._vertexFunction) {\n        particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction\n\n      }\n\n      tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n      Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\n      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);\n    }\n\n    if (reset) {\n      particle.position.setAll(0.0);\n      particle.rotation.setAll(0.0);\n      particle.rotationQuaternion = null;\n      particle.scaling.setAll(1.0);\n      particle.uvs.setAll(0.0);\n      particle.pivot.setAll(0.0);\n      particle.translateFromPivot = false;\n      particle.parentId = null;\n    }\n  };\n  /**\r\n   * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\r\n   * @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.\r\n   * @returns the SPS.\r\n   */\n\n\n  SolidParticleSystem.prototype.rebuildMesh = function (reset) {\n    if (reset === void 0) {\n      reset = false;\n    }\n\n    for (var p = 0; p < this.particles.length; p++) {\n      this._rebuildParticle(this.particles[p], reset);\n    }\n\n    this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);\n    return this;\n  };\n  /** Removes the particles from the start-th to the end-th included from an expandable SPS (required).\r\n   *  Returns an array with the removed particles.\r\n   *  If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.\r\n   *  The SPS can't be empty so at least one particle needs to remain in place.\r\n   *  Under the hood, the VertexData array, so the VBO buffer, is recreated each call.\r\n   * @param start index of the first particle to remove\r\n   * @param end index of the last particle to remove (included)\r\n   * @returns an array populated with the removed particles\r\n   */\n\n\n  SolidParticleSystem.prototype.removeParticles = function (start, end) {\n    var nb = end - start + 1;\n\n    if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {\n      return [];\n    }\n\n    var particles = this.particles;\n    var currentNb = this.nbParticles;\n\n    if (end < currentNb - 1) {\n      // update the particle indexes in the positions array in case they're remaining particles after the last removed\n      var firstRemaining = end + 1;\n      var shiftPos = particles[firstRemaining]._pos - particles[start]._pos;\n      var shifInd = particles[firstRemaining]._ind - particles[start]._ind;\n\n      for (var i = firstRemaining; i < currentNb; i++) {\n        var part = particles[i];\n        part._pos -= shiftPos;\n        part._ind -= shifInd;\n      }\n    }\n\n    var removed = particles.splice(start, nb);\n    this._positions.length = 0;\n    this._indices.length = 0;\n    this._colors.length = 0;\n    this._uvs.length = 0;\n    this._normals.length = 0;\n    this._index = 0;\n    this._idxOfId.length = 0;\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      this.depthSortedParticles = [];\n    }\n\n    var ind = 0;\n    var particlesLength = particles.length;\n\n    for (var p = 0; p < particlesLength; p++) {\n      var particle = particles[p];\n      var model = particle._model;\n      var shape = model._shape;\n      var modelIndices = model._indices;\n      var modelNormals = model._normals;\n      var modelColors = model._shapeColors;\n      var modelUVs = model._shapeUV;\n      particle.idx = p;\n      this._idxOfId[particle.id] = p;\n\n      this._meshBuilder(this._index, ind, shape, this._positions, modelIndices, this._indices, modelUVs, this._uvs, modelColors, this._colors, modelNormals, this._normals, particle.idx, particle.idxInShape, null, model);\n\n      this._index += shape.length;\n      ind += modelIndices.length;\n    }\n\n    this.nbParticles -= nb;\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return removed;\n  };\n  /**\r\n   * Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().\r\n   * @param solidParticleArray an array populated with Solid Particles objects\r\n   * @returns the SPS\r\n   */\n\n\n  SolidParticleSystem.prototype.insertParticlesFromArray = function (solidParticleArray) {\n    if (!this._expandable) {\n      return this;\n    }\n\n    var idxInShape = 0;\n    var currentShapeId = solidParticleArray[0].shapeId;\n    var nb = solidParticleArray.length;\n\n    for (var i = 0; i < nb; i++) {\n      var sp = solidParticleArray[i];\n      var model = sp._model;\n      var shape = model._shape;\n      var meshInd = model._indices;\n      var meshUV = model._shapeUV;\n      var meshCol = model._shapeColors;\n      var meshNor = model._normals;\n      var noNor = meshNor ? false : true;\n      this.recomputeNormals = noNor || this.recomputeNormals;\n      var bbInfo = sp._boundingInfo;\n\n      var newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);\n\n      sp.copyToRef(newPart);\n      idxInShape++;\n\n      if (currentShapeId != sp.shapeId) {\n        currentShapeId = sp.shapeId;\n        idxInShape = 0;\n      }\n    }\n\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return this;\n  };\n  /**\r\n   * Creates a new particle and modifies the SPS mesh geometry :\r\n   * - calls _meshBuilder() to increase the SPS mesh geometry step by step\r\n   * - calls _addParticle() to populate the particle array\r\n   * factorized code from addShape() and insertParticlesFromArray()\r\n   * @param idx particle index in the particles array\r\n   * @param i particle index in its shape\r\n   * @param modelShape particle ModelShape object\r\n   * @param shape shape vertex array\r\n   * @param meshInd shape indices array\r\n   * @param meshUV shape uv array\r\n   * @param meshCol shape color array\r\n   * @param meshNor shape normals array\r\n   * @param bbInfo shape bounding info\r\n   * @param storage target particle storage\r\n   * @options addShape() passed options\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._insertNewParticle = function (idx, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options) {\n    var currentPos = this._positions.length;\n    var currentInd = this._indices.length;\n\n    var currentCopy = this._meshBuilder(this._index, currentInd, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options, modelShape);\n\n    var sp = null;\n\n    if (this._updatable) {\n      sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);\n      sp.position.copyFrom(currentCopy.position);\n      sp.rotation.copyFrom(currentCopy.rotation);\n\n      if (currentCopy.rotationQuaternion) {\n        if (sp.rotationQuaternion) {\n          sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\n        } else {\n          sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();\n        }\n      }\n\n      if (currentCopy.color) {\n        if (sp.color) {\n          sp.color.copyFrom(currentCopy.color);\n        } else {\n          sp.color = currentCopy.color.clone();\n        }\n      }\n\n      sp.scaling.copyFrom(currentCopy.scaling);\n      sp.uvs.copyFrom(currentCopy.uvs);\n\n      if (currentCopy.materialIndex !== null) {\n        sp.materialIndex = currentCopy.materialIndex;\n      }\n\n      if (this.expandable) {\n        this._idxOfId[sp.id] = sp.idx;\n      }\n    }\n\n    if (!storage) {\n      this._index += shape.length;\n      this.nbParticles++;\n      this._lastParticleId++;\n    }\n\n    return sp;\n  };\n  /**\r\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n   *  This method calls `updateParticle()` for each particle of the SPS.\r\n   *  For an animated SPS, it is usually called within the render loop.\r\n   * This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.\r\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n   * @returns the SPS.\r\n   */\n\n\n  SolidParticleSystem.prototype.setParticles = function (start, end, update) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (end === void 0) {\n      end = this.nbParticles - 1;\n    }\n\n    if (update === void 0) {\n      update = true;\n    }\n\n    if (!this._updatable || this._isNotBuilt) {\n      return this;\n    } // custom beforeUpdate\n\n\n    this.beforeUpdateParticles(start, end, update);\n    var rotMatrix = TmpVectors.Matrix[0];\n    var invertedMatrix = TmpVectors.Matrix[1];\n    var mesh = this.mesh;\n    var colors32 = this._colors32;\n    var positions32 = this._positions32;\n    var normals32 = this._normals32;\n    var uvs32 = this._uvs32;\n    var indices32 = this._indices32;\n    var indices = this._indices;\n    var fixedNormal32 = this._fixedNormal32;\n    var tempVectors = TmpVectors.Vector3;\n    var camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    var camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    var camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    var minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    var camInvertedPosition = tempVectors[10].setAll(0);\n    var tmpVertex = this._tmpVertex;\n    var tmpVector = tmpVertex.position;\n    var tmpColor = tmpVertex.color;\n    var tmpUV = tmpVertex.uv; // cases when the World Matrix is to be computed first\n\n    if (this.billboard || this._depthSort) {\n      this.mesh.computeWorldMatrix(true);\n\n      this.mesh._worldMatrix.invertToRef(invertedMatrix);\n    } // if the particles will always face the camera\n\n\n    if (this.billboard) {\n      // compute the camera position and un-rotate it by the current mesh rotation\n      var tmpVector0 = tempVectors[0];\n\n      this._camera.getDirectionToRef(Axis.Z, tmpVector0);\n\n      Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);\n      camAxisZ.normalize(); // same for camera up vector extracted from the cam view matrix\n\n      var view = this._camera.getViewMatrix(true);\n\n      Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);\n      Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);\n      camAxisY.normalize();\n      camAxisX.normalize();\n    } // if depthSort, compute the camera global position in the mesh local system\n\n\n    if (this._depthSort) {\n      Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera\n    }\n\n    Matrix.IdentityToRef(rotMatrix);\n    var idx = 0; // current position index in the global array positions32\n\n    var index = 0; // position start index in the global array positions32 of the current particle\n\n    var colidx = 0; // current color index in the global array colors32\n\n    var colorIndex = 0; // color start index in the global array colors32 of the current particle\n\n    var uvidx = 0; // current uv index in the global array uvs32\n\n    var uvIndex = 0; // uv start index in the global array uvs32 of the current particle\n\n    var pt = 0; // current index in the particle model shape\n\n    if (this.mesh.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        var boundingInfo = this.mesh._boundingInfo;\n\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    } // particle loop\n\n\n    index = this.particles[start]._pos;\n    var vpos = index / 3 | 0;\n    colorIndex = vpos * 4;\n    uvIndex = vpos * 2;\n\n    for (var p = start; p <= end; p++) {\n      var particle = this.particles[p]; // call to custom user function to update the particle properties\n\n      this.updateParticle(particle);\n      var shape = particle._model._shape;\n      var shapeUV = particle._model._shapeUV;\n      var particleRotationMatrix = particle._rotationMatrix;\n      var particlePosition = particle.position;\n      var particleRotation = particle.rotation;\n      var particleScaling = particle.scaling;\n      var particleGlobalPosition = particle._globalPosition; // camera-particle distance for depth sorting\n\n      if (this._depthSort && this._depthSortParticles) {\n        var dsp = this.depthSortedParticles[p];\n        dsp.idx = particle.idx;\n        dsp.ind = particle._ind;\n        dsp.indicesLength = particle._model._indicesLength;\n        dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);\n      } // skip the computations for inactive or already invisible particles\n\n\n      if (!particle.alive || particle._stillInvisible && !particle.isVisible) {\n        // increment indexes for the next particle\n        pt = shape.length;\n        index += pt * 3;\n        colorIndex += pt * 4;\n        uvIndex += pt * 2;\n        continue;\n      }\n\n      if (particle.isVisible) {\n        particle._stillInvisible = false; // un-mark permanent invisibility\n\n        var scaledPivot = tempVectors[12];\n        particle.pivot.multiplyToRef(particleScaling, scaledPivot); // particle rotation matrix\n\n        if (this.billboard) {\n          particleRotation.x = 0.0;\n          particleRotation.y = 0.0;\n        }\n\n        if (this._computeParticleRotation || this.billboard) {\n          particle.getRotationMatrix(rotMatrix);\n        }\n\n        var particleHasParent = particle.parentId !== null;\n\n        if (particleHasParent) {\n          var parent_1 = this.getParticleById(particle.parentId);\n\n          if (parent_1) {\n            var parentRotationMatrix = parent_1._rotationMatrix;\n            var parentGlobalPosition = parent_1._globalPosition;\n            var rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n            var rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n            var rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n            particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n            particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n            particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n\n            if (this._computeParticleRotation || this.billboard) {\n              var rotMatrixValues = rotMatrix.m;\n              particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n              particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n              particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n              particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n              particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n              particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n              particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n              particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n              particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n            }\n          } else {\n            // in case the parent were removed at some moment\n            particle.parentId = null;\n          }\n        } else {\n          particleGlobalPosition.x = particlePosition.x;\n          particleGlobalPosition.y = particlePosition.y;\n          particleGlobalPosition.z = particlePosition.z;\n\n          if (this._computeParticleRotation || this.billboard) {\n            var rotMatrixValues = rotMatrix.m;\n            particleRotationMatrix[0] = rotMatrixValues[0];\n            particleRotationMatrix[1] = rotMatrixValues[1];\n            particleRotationMatrix[2] = rotMatrixValues[2];\n            particleRotationMatrix[3] = rotMatrixValues[4];\n            particleRotationMatrix[4] = rotMatrixValues[5];\n            particleRotationMatrix[5] = rotMatrixValues[6];\n            particleRotationMatrix[6] = rotMatrixValues[8];\n            particleRotationMatrix[7] = rotMatrixValues[9];\n            particleRotationMatrix[8] = rotMatrixValues[10];\n          }\n        }\n\n        var pivotBackTranslation = tempVectors[11];\n\n        if (particle.translateFromPivot) {\n          pivotBackTranslation.setAll(0.0);\n        } else {\n          pivotBackTranslation.copyFrom(scaledPivot);\n        } // particle vertex loop\n\n\n        for (pt = 0; pt < shape.length; pt++) {\n          idx = index + pt * 3;\n          colidx = colorIndex + pt * 4;\n          uvidx = uvIndex + pt * 2;\n          var iu = 2 * pt;\n          var iv = iu + 1;\n          tmpVector.copyFrom(shape[pt]);\n\n          if (this._computeParticleColor && particle.color) {\n            tmpColor.copyFrom(particle.color);\n          }\n\n          if (this._computeParticleTexture) {\n            tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);\n          }\n\n          if (this._computeParticleVertex) {\n            this.updateParticleVertex(particle, tmpVertex, pt);\n          } // positions\n\n\n          var vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;\n          var vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;\n          var vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;\n          var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n          var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n          var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n          rotatedX += pivotBackTranslation.x;\n          rotatedY += pivotBackTranslation.y;\n          rotatedZ += pivotBackTranslation.z;\n          var px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n          var py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n          var pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n\n          if (this._computeBoundingBox) {\n            minimum.minimizeInPlaceFromFloats(px, py, pz);\n            maximum.maximizeInPlaceFromFloats(px, py, pz);\n          } // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\n\n\n          if (!this._computeParticleVertex) {\n            var normalx = fixedNormal32[idx];\n            var normaly = fixedNormal32[idx + 1];\n            var normalz = fixedNormal32[idx + 2];\n            var rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];\n            var rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];\n            var rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];\n            normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;\n            normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;\n            normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;\n          }\n\n          if (this._computeParticleColor && particle.color) {\n            var colors32_1 = this._colors32;\n            colors32_1[colidx] = tmpColor.r;\n            colors32_1[colidx + 1] = tmpColor.g;\n            colors32_1[colidx + 2] = tmpColor.b;\n            colors32_1[colidx + 3] = tmpColor.a;\n          }\n\n          if (this._computeParticleTexture) {\n            var uvs = particle.uvs;\n            uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;\n            uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;\n          }\n        }\n      } // particle just set invisible : scaled to zero and positioned at the origin\n      else {\n        particle._stillInvisible = true; // mark the particle as invisible\n\n        for (pt = 0; pt < shape.length; pt++) {\n          idx = index + pt * 3;\n          colidx = colorIndex + pt * 4;\n          uvidx = uvIndex + pt * 2;\n          positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;\n          normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;\n\n          if (this._computeParticleColor && particle.color) {\n            var color = particle.color;\n            colors32[colidx] = color.r;\n            colors32[colidx + 1] = color.g;\n            colors32[colidx + 2] = color.b;\n            colors32[colidx + 3] = color.a;\n          }\n\n          if (this._computeParticleTexture) {\n            var uvs = particle.uvs;\n            uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\n            uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\n          }\n        }\n      } // if the particle intersections must be computed : update the bbInfo\n\n\n      if (this._particlesIntersect) {\n        var bInfo = particle._boundingInfo;\n        var bBox = bInfo.boundingBox;\n        var bSphere = bInfo.boundingSphere;\n        var modelBoundingInfo = particle._modelBoundingInfo;\n\n        if (!this._bSphereOnly) {\n          // place, scale and rotate the particle bbox within the SPS local system, then update it\n          var modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;\n          var tempMin = tempVectors[1];\n          var tempMax = tempVectors[2];\n          tempMin.setAll(Number.MAX_VALUE);\n          tempMax.setAll(-Number.MAX_VALUE);\n\n          for (var b = 0; b < 8; b++) {\n            var scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;\n            var scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;\n            var scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;\n            var rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];\n            var rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];\n            var rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];\n            var x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n            var y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n            var z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n            tempMin.minimizeInPlaceFromFloats(x, y, z);\n            tempMax.maximizeInPlaceFromFloats(x, y, z);\n          }\n\n          bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);\n        } // place and scale the particle bouding sphere in the SPS local system, then update it\n\n\n        var minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);\n        var maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);\n        var bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);\n        var halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);\n        var bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);\n        var bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);\n        bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);\n      } // increment indexes for the next particle\n\n\n      index = idx + 3;\n      colorIndex = colidx + 4;\n      uvIndex = uvidx + 2;\n    } // if the VBO must be updated\n\n\n    if (update) {\n      if (this._computeParticleColor) {\n        mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n      }\n\n      if (this._computeParticleTexture) {\n        mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n      }\n\n      mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n\n      if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {\n        if (this._computeParticleVertex || mesh.isFacetDataEnabled) {\n          // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\n          var params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;\n          VertexData.ComputeNormals(positions32, indices32, normals32, params);\n\n          for (var i = 0; i < normals32.length; i++) {\n            fixedNormal32[i] = normals32[i];\n          }\n        }\n\n        if (!mesh.areNormalsFrozen) {\n          mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);\n        }\n      }\n\n      if (this._depthSort && this._depthSortParticles) {\n        var depthSortedParticles = this.depthSortedParticles;\n        depthSortedParticles.sort(this._depthSortFunction);\n        var dspl = depthSortedParticles.length;\n        var sid = 0;\n        var faceId = 0;\n\n        for (var sorted = 0; sorted < dspl; sorted++) {\n          var sortedParticle = depthSortedParticles[sorted];\n          var lind = sortedParticle.indicesLength;\n          var sind = sortedParticle.ind;\n\n          for (var i = 0; i < lind; i++) {\n            indices32[sid] = indices[sind + i];\n            sid++;\n\n            if (this._pickable) {\n              var f = i % 3;\n\n              if (f == 0) {\n                var pickedData = this.pickedParticles[faceId];\n                pickedData.idx = sortedParticle.idx;\n                pickedData.faceId = faceId;\n                faceId++;\n              }\n            }\n          }\n        }\n\n        mesh.updateIndices(indices32);\n      }\n    }\n\n    if (this._computeBoundingBox) {\n      if (mesh._boundingInfo) {\n        mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);\n      } else {\n        mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);\n      }\n    }\n\n    if (this._autoUpdateSubMeshes) {\n      this.computeSubMeshes();\n    }\n\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  };\n  /**\r\n  * Disposes the SPS.\r\n  */\n\n\n  SolidParticleSystem.prototype.dispose = function () {\n    this.mesh.dispose();\n    this.vars = null; // drop references to internal big arrays for the GC\n\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._normals32 = null;\n    this._fixedNormal32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n    this.pickedParticles = null;\n    this.pickedBySubMesh = null;\n    this._materials = null;\n    this._materialIndexes = null;\n    this._indicesByMaterial = null;\n    this._idxOfId = null;\n  };\n  /** Returns an object {idx: numbern faceId: number} for the picked particle from the passed pickingInfo object.\r\n   * idx is the particle index in the SPS\r\n   * faceId is the picked face index counted within this particle.\r\n   * Returns null if the pickInfo can't identify a picked particle.\r\n   * @param pickingInfo (PickingInfo object)\r\n   * @returns {idx: number, faceId: number} or null\r\n   */\n\n\n  SolidParticleSystem.prototype.pickedParticle = function (pickingInfo) {\n    if (pickingInfo.hit) {\n      var subMesh = pickingInfo.subMeshId;\n      var faceId = pickingInfo.faceId;\n      var picked = this.pickedBySubMesh;\n\n      if (picked[subMesh] && picked[subMesh][faceId]) {\n        return picked[subMesh][faceId];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Returns a SolidParticle object from its identifier : particle.id\r\n   * @param id (integer) the particle Id\r\n   * @returns the searched particle or null if not found in the SPS.\r\n   */\n\n\n  SolidParticleSystem.prototype.getParticleById = function (id) {\n    var p = this.particles[id];\n\n    if (p && p.id == id) {\n      return p;\n    }\n\n    var particles = this.particles;\n    var idx = this._idxOfId[id];\n\n    if (idx !== undefined) {\n      return particles[idx];\n    }\n\n    var i = 0;\n    var nb = this.nbParticles;\n\n    while (i < nb) {\n      var particle = particles[i];\n\n      if (particle.id == id) {\n        return particle;\n      }\n\n      i++;\n    }\n\n    return null;\n  };\n  /**\r\n   * Returns a new array populated with the particles having the passed shapeId.\r\n   * @param shapeId (integer) the shape identifier\r\n   * @returns a new solid particle array\r\n   */\n\n\n  SolidParticleSystem.prototype.getParticlesByShapeId = function (shapeId) {\n    var ref = [];\n    this.getParticlesByShapeIdToRef(shapeId, ref);\n    return ref;\n  };\n  /**\r\n   * Populates the passed array \"ref\" with the particles having the passed shapeId.\r\n   * @param shapeId the shape identifier\r\n   * @returns the SPS\r\n   * @param ref\r\n   */\n\n\n  SolidParticleSystem.prototype.getParticlesByShapeIdToRef = function (shapeId, ref) {\n    ref.length = 0;\n\n    for (var i = 0; i < this.nbParticles; i++) {\n      var p = this.particles[i];\n\n      if (p.shapeId == shapeId) {\n        ref.push(p);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Computes the required SubMeshes according the materials assigned to the particles.\r\n   * @returns the solid particle system.\r\n   * Does nothing if called before the SPS mesh is built.\r\n   */\n\n\n  SolidParticleSystem.prototype.computeSubMeshes = function () {\n    if (!this.mesh || !this._multimaterialEnabled) {\n      return this;\n    }\n\n    var depthSortedParticles = this.depthSortedParticles;\n\n    if (this.particles.length > 0) {\n      for (var p = 0; p < this.particles.length; p++) {\n        var part = this.particles[p];\n\n        if (!part.materialIndex) {\n          part.materialIndex = 0;\n        }\n\n        var sortedPart = depthSortedParticles[p];\n        sortedPart.materialIndex = part.materialIndex;\n        sortedPart.ind = part._ind;\n        sortedPart.indicesLength = part._model._indicesLength;\n        sortedPart.idx = part.idx;\n      }\n    }\n\n    this._sortParticlesByMaterial();\n\n    var indicesByMaterial = this._indicesByMaterial;\n    var materialIndexes = this._materialIndexes;\n    var mesh = this.mesh;\n    mesh.subMeshes = [];\n    var vcount = mesh.getTotalVertices();\n\n    for (var m = 0; m < materialIndexes.length; m++) {\n      var start = indicesByMaterial[m];\n      var count = indicesByMaterial[m + 1] - start;\n      var matIndex = materialIndexes[m];\n      new SubMesh(matIndex, 0, vcount, start, count, mesh);\n    }\n\n    return this;\n  };\n  /**\r\n   * Sorts the solid particles by material when MultiMaterial is enabled.\r\n   * Updates the indices32 array.\r\n   * Updates the indicesByMaterial array.\r\n   * Updates the mesh indices array.\r\n   * @returns the SPS\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._sortParticlesByMaterial = function () {\n    var indicesByMaterial = [0];\n    this._indicesByMaterial = indicesByMaterial;\n    var materialIndexes = [];\n    this._materialIndexes = materialIndexes;\n    var depthSortedParticles = this.depthSortedParticles;\n    depthSortedParticles.sort(this._materialSortFunction);\n    var length = depthSortedParticles.length;\n    var indices32 = this._indices32;\n    var indices = this._indices;\n    var subMeshIndex = 0;\n    var subMeshFaceId = 0;\n    var sid = 0;\n    var lastMatIndex = depthSortedParticles[0].materialIndex;\n    materialIndexes.push(lastMatIndex);\n\n    if (this._pickable) {\n      this.pickedBySubMesh = [[]];\n      this.pickedParticles = this.pickedBySubMesh[0];\n    }\n\n    for (var sorted = 0; sorted < length; sorted++) {\n      var sortedPart = depthSortedParticles[sorted];\n      var lind = sortedPart.indicesLength;\n      var sind = sortedPart.ind;\n\n      if (sortedPart.materialIndex !== lastMatIndex) {\n        lastMatIndex = sortedPart.materialIndex;\n        indicesByMaterial.push(sid);\n        materialIndexes.push(lastMatIndex);\n\n        if (this._pickable) {\n          subMeshIndex++;\n          this.pickedBySubMesh[subMeshIndex] = [];\n          subMeshFaceId = 0;\n        }\n      }\n\n      var faceId = 0;\n\n      for (var i = 0; i < lind; i++) {\n        indices32[sid] = indices[sind + i];\n\n        if (this._pickable) {\n          var f = i % 3;\n\n          if (f == 0) {\n            var pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];\n\n            if (pickedData) {\n              pickedData.idx = sortedPart.idx;\n              pickedData.faceId = faceId;\n            } else {\n              this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = {\n                idx: sortedPart.idx,\n                faceId: faceId\n              };\n            }\n\n            subMeshFaceId++;\n            faceId++;\n          }\n        }\n\n        sid++;\n      }\n    }\n\n    indicesByMaterial.push(indices32.length); // add the last number to ease the indices start/count values for subMeshes creation\n\n    if (this._updatable) {\n      this.mesh.updateIndices(indices32);\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets the material indexes by id materialIndexesById[id] = materialIndex\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._setMaterialIndexesById = function () {\n    this._materialIndexesById = {};\n\n    for (var i = 0; i < this._materials.length; i++) {\n      var id = this._materials[i].uniqueId;\n      this._materialIndexesById[id] = i;\n    }\n  };\n  /**\r\n   * Returns an array with unique values of Materials from the passed array\r\n   * @param array the material array to be checked and filtered\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._filterUniqueMaterialId = function (array) {\n    var filtered = array.filter(function (value, index, self) {\n      return self.indexOf(value) === index;\n    });\n    return filtered;\n  };\n  /**\r\n   * Sets a new Standard Material as _defaultMaterial if not already set.\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._setDefaultMaterial = function () {\n    if (!this._defaultMaterial) {\n      this._defaultMaterial = new StandardMaterial(this.name + \"DefaultMaterial\", this._scene);\n    }\n\n    return this._defaultMaterial;\n  };\n  /**\r\n   * Visibilty helper : Recomputes the visible size according to the mesh bounding box\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n   * @returns the SPS.\r\n   */\n\n\n  SolidParticleSystem.prototype.refreshVisibleSize = function () {\n    if (!this._isVisibilityBoxLocked) {\n      this.mesh.refreshBoundingInfo();\n    }\n\n    return this;\n  };\n  /**\r\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n   * @param size the size (float) of the visibility box\r\n   * note : this doesn't lock the SPS mesh bounding box.\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n   */\n\n\n  SolidParticleSystem.prototype.setVisibilityBox = function (size) {\n    var vis = size / 2;\n    this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  };\n\n  Object.defineProperty(SolidParticleSystem.prototype, \"isAlwaysVisible\", {\n    /**\r\n     * Gets whether the SPS as always visible or not\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\n    get: function get() {\n      return this._alwaysVisible;\n    },\n\n    /**\r\n     * Sets the SPS as always visible or not\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\n    set: function set(val) {\n      this._alwaysVisible = val;\n      this.mesh.alwaysSelectAsActiveMesh = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"isVisibilityBoxLocked\", {\n    /**\r\n     * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\n    get: function get() {\n      return this._isVisibilityBoxLocked;\n    },\n\n    /**\r\n     * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\n    set: function set(val) {\n      this._isVisibilityBoxLocked = val;\n      var boundingInfo = this.mesh.getBoundingInfo();\n      boundingInfo.isLocked = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleRotation\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\n    get: function get() {\n      return this._computeParticleRotation;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\n    set: function set(val) {\n      this._computeParticleRotation = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleColor\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\n    get: function get() {\n      return this._computeParticleColor;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\n    set: function set(val) {\n      this._computeParticleColor = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleTexture\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\n    get: function get() {\n      return this._computeParticleTexture;\n    },\n    set: function set(val) {\n      this._computeParticleTexture = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleVertex\", {\n    /**\r\n     * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\n    get: function get() {\n      return this._computeParticleVertex;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\n    set: function set(val) {\n      this._computeParticleVertex = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeBoundingBox\", {\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\n    get: function get() {\n      return this._computeBoundingBox;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\n    set: function set(val) {\n      this._computeBoundingBox = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"depthSortParticles\", {\n    /**\r\n     * Gets if `setParticles()` sorts or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\n    get: function get() {\n      return this._depthSortParticles;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to sort or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\n    set: function set(val) {\n      this._depthSortParticles = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"expandable\", {\n    /**\r\n     * Gets if the SPS is created as expandable at construction time.\r\n     * Default : `false`\r\n     */\n    get: function get() {\n      return this._expandable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"multimaterialEnabled\", {\n    /**\r\n     * Gets if the SPS supports the Multi Materials\r\n     */\n    get: function get() {\n      return this._multimaterialEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"useModelMaterial\", {\n    /**\r\n     * Gets if the SPS uses the model materials for its own multimaterial.\r\n     */\n    get: function get() {\n      return this._useModelMaterial;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"materials\", {\n    /**\r\n     * The SPS used material array.\r\n    */\n    get: function get() {\n      return this._materials;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the SPS MultiMaterial from the passed materials.\r\n   * Note : the passed array is internally copied and not used then by reference.\r\n   * @param materials an array of material objects. This array indexes are the materialIndex values of the particles.\r\n   */\n\n  SolidParticleSystem.prototype.setMultiMaterial = function (materials) {\n    this._materials = this._filterUniqueMaterialId(materials);\n\n    this._setMaterialIndexesById();\n\n    if (this._multimaterial) {\n      this._multimaterial.dispose();\n    }\n\n    this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n\n    for (var m = 0; m < this._materials.length; m++) {\n      this._multimaterial.subMaterials.push(this._materials[m]);\n    }\n\n    this.computeSubMeshes();\n    this.mesh.material = this._multimaterial;\n  };\n\n  Object.defineProperty(SolidParticleSystem.prototype, \"multimaterial\", {\n    /**\r\n     * The SPS computed multimaterial object\r\n     */\n    get: function get() {\n      return this._multimaterial;\n    },\n    set: function set(mm) {\n      this._multimaterial = mm;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"autoUpdateSubMeshes\", {\n    /**\r\n     * If the subMeshes must be updated on the next call to setParticles()\r\n     */\n    get: function get() {\n      return this._autoUpdateSubMeshes;\n    },\n    set: function set(val) {\n      this._autoUpdateSubMeshes = val;\n    },\n    enumerable: false,\n    configurable: true\n  }); // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by the user to fit his needs\n\n  /**\r\n   * This function does nothing. It may be overwritten to set all the particle first values.\r\n   * The SPS doesn't call this function, you may have to call it by your own.\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n   */\n\n  SolidParticleSystem.prototype.initParticles = function () {};\n  /**\r\n   * This function does nothing. It may be overwritten to recycle a particle.\r\n   * The SPS doesn't call this function, you may have to call it by your own.\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n   * @param particle The particle to recycle\r\n   * @returns the recycled particle\r\n   */\n\n\n  SolidParticleSystem.prototype.recycleParticle = function (particle) {\n    return particle;\n  };\n  /**\r\n   * Updates a particle : this function should  be overwritten by the user.\r\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n   * @example : just set a particle position or velocity and recycle conditions\r\n   * @param particle The particle to update\r\n   * @returns the updated particle\r\n   */\n\n\n  SolidParticleSystem.prototype.updateParticle = function (particle) {\n    return particle;\n  };\n  /**\r\n   * Updates a vertex of a particle : it can be overwritten by the user.\r\n   * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\r\n   * @param particle the current particle\r\n   * @param vertex the current vertex of the current particle : a SolidParticleVertex object\r\n   * @param pt the index of the current vertex in the particle shape\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#update-each-particle-shape\r\n   * @example : just set a vertex particle position or color\r\n   * @returns the sps\r\n   */\n\n\n  SolidParticleSystem.prototype.updateParticleVertex = function (particle, vertex, pt) {\n    return this;\n  };\n  /**\r\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n   * This does nothing and may be overwritten by the user.\r\n   * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param update the boolean update value actually passed to setParticles()\r\n   */\n\n\n  SolidParticleSystem.prototype.beforeUpdateParticles = function (start, stop, update) {};\n  /**\r\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n   * This will be passed three parameters.\r\n   * This does nothing and may be overwritten by the user.\r\n   * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param update the boolean update value actually passed to setParticles()\r\n   */\n\n\n  SolidParticleSystem.prototype.afterUpdateParticles = function (start, stop, update) {};\n\n  return SolidParticleSystem;\n}();\n\nexport { SolidParticleSystem };","map":null,"metadata":{},"sourceType":"module"}