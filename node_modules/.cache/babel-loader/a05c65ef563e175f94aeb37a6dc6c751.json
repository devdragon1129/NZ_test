{"ast":null,"code":"import { Logger } from \"../../Misc/logger\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\nimport { PhysicsJoint } from \"../../Physics/physicsJoint\";\nimport { PhysicsEngine } from \"../../Physics/physicsEngine\";\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\n/** @hidden */\n\nvar CannonJSPlugin =\n/** @class */\nfunction () {\n  function CannonJSPlugin(_useDeltaForWorldStep, iterations, cannonInjection) {\n    if (_useDeltaForWorldStep === void 0) {\n      _useDeltaForWorldStep = true;\n    }\n\n    if (iterations === void 0) {\n      iterations = 10;\n    }\n\n    if (cannonInjection === void 0) {\n      cannonInjection = CANNON;\n    }\n\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"CannonJSPlugin\";\n    this._physicsMaterials = new Array();\n    this._fixedTimeStep = 1 / 60;\n    this._physicsBodysToRemoveAfterStep = new Array();\n    this._firstFrame = true;\n    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._tmpPosition = Vector3.Zero();\n    this._tmpDeltaPosition = Vector3.Zero();\n    this._tmpUnityRotation = new Quaternion();\n    this.BJSCANNON = cannonInjection;\n\n    if (!this.isSupported()) {\n      Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n\n    this._extendNamespace();\n\n    this.world = new this.BJSCANNON.World();\n    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\n    this.world.solver.iterations = iterations;\n    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n\n  CannonJSPlugin.prototype.setGravity = function (gravity) {\n    var vec = gravity;\n    this.world.gravity.set(vec.x, vec.y, vec.z);\n  };\n\n  CannonJSPlugin.prototype.setTimeStep = function (timeStep) {\n    this._fixedTimeStep = timeStep;\n  };\n\n  CannonJSPlugin.prototype.getTimeStep = function () {\n    return this._fixedTimeStep;\n  };\n\n  CannonJSPlugin.prototype.executeStep = function (delta, impostors) {\n    // due to cannon's architecture, the first frame's before-step is skipped.\n    if (this._firstFrame) {\n      this._firstFrame = false;\n\n      for (var _i = 0, impostors_1 = impostors; _i < impostors_1.length; _i++) {\n        var impostor = impostors_1[_i];\n\n        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\n          impostor.beforeStep();\n        }\n      }\n    }\n\n    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\n\n    this._removeMarkedPhysicsBodiesFromWorld();\n  };\n\n  CannonJSPlugin.prototype._removeMarkedPhysicsBodiesFromWorld = function () {\n    var _this = this;\n\n    if (this._physicsBodysToRemoveAfterStep.length > 0) {\n      this._physicsBodysToRemoveAfterStep.forEach(function (physicsBody) {\n        _this.world.remove(physicsBody);\n      });\n\n      this._physicsBodysToRemoveAfterStep = [];\n    }\n  };\n\n  CannonJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n    var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyImpulse(impulse, worldPoint);\n  };\n\n  CannonJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n    var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyForce(impulse, worldPoint);\n  };\n\n  CannonJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n    // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\n    this._removeMarkedPhysicsBodiesFromWorld(); //parent-child relationship. Does this impostor has a parent impostor?\n\n\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor); //TODO is that needed?\n\n        impostor.forceUpdate();\n      }\n\n      return;\n    } //should a new body be created for this impostor?\n\n\n    if (impostor.isBodyInitRequired()) {\n      var shape = this._createShape(impostor); //unregister events, if body is being changed\n\n\n      var oldBody = impostor.physicsBody;\n\n      if (oldBody) {\n        this.removePhysicsBody(impostor);\n      } //create the body and material\n\n\n      var material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\n\n      var bodyCreationObject = {\n        mass: impostor.getParam(\"mass\"),\n        material: material\n      }; // A simple extend, in case native options were used.\n\n      var nativeOptions = impostor.getParam(\"nativeOptions\");\n\n      for (var key in nativeOptions) {\n        if (nativeOptions.hasOwnProperty(key)) {\n          bodyCreationObject[key] = nativeOptions[key];\n        }\n      }\n\n      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\n      impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\n      this.world.addEventListener(\"preStep\", impostor.beforeStep);\n      this.world.addEventListener(\"postStep\", impostor.afterStep);\n      impostor.physicsBody.addShape(shape);\n      this.world.add(impostor.physicsBody); //try to keep the body moving in the right direction by taking old properties.\n      //Should be tested!\n\n      if (oldBody) {\n        [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\n          var vec = oldBody[param];\n          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\n        });\n      }\n\n      this._processChildMeshes(impostor);\n    } //now update the body's transformation\n\n\n    this._updatePhysicsBodyTransformation(impostor);\n  };\n\n  CannonJSPlugin.prototype._processChildMeshes = function (mainImpostor) {\n    var _this = this;\n\n    var meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\n    var currentRotation = mainImpostor.object.rotationQuaternion;\n\n    if (meshChildren.length) {\n      var processMesh_1 = function processMesh_1(mesh) {\n        if (!currentRotation || !mesh.rotationQuaternion) {\n          return;\n        }\n\n        var childImpostor = mesh.getPhysicsImpostor();\n\n        if (childImpostor) {\n          var parent = childImpostor.parent;\n\n          if (parent !== mainImpostor) {\n            var pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());\n            var q = mesh.rotationQuaternion;\n\n            if (childImpostor.physicsBody) {\n              _this.removePhysicsBody(childImpostor);\n\n              childImpostor.physicsBody = null;\n            }\n\n            childImpostor.parent = mainImpostor;\n            childImpostor.resetUpdateFlags();\n            mainImpostor.physicsBody.addShape(_this._createShape(childImpostor), new _this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new _this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w)); //Add the mass of the children.\n\n            mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\n          }\n        }\n\n        currentRotation.multiplyInPlace(mesh.rotationQuaternion);\n        mesh.getChildMeshes(true).filter(function (m) {\n          return !!m.physicsImpostor;\n        }).forEach(processMesh_1);\n      };\n\n      meshChildren.filter(function (m) {\n        return !!m.physicsImpostor;\n      }).forEach(processMesh_1);\n    }\n  };\n\n  CannonJSPlugin.prototype.removePhysicsBody = function (impostor) {\n    impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\n    this.world.removeEventListener(\"preStep\", impostor.beforeStep);\n    this.world.removeEventListener(\"postStep\", impostor.afterStep); // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\n\n    if (this._physicsBodysToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\n      this._physicsBodysToRemoveAfterStep.push(impostor.physicsBody);\n    }\n  };\n\n  CannonJSPlugin.prototype.generateJoint = function (impostorJoint) {\n    var mainBody = impostorJoint.mainImpostor.physicsBody;\n    var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n\n    var constraint;\n    var jointData = impostorJoint.joint.jointData; //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\n\n    var constraintData = {\n      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\n      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\n      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\n      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\n      maxForce: jointData.nativeParams.maxForce,\n      collideConnected: !!jointData.collision\n    };\n\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.HingeJoint:\n      case PhysicsJoint.Hinge2Joint:\n        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\n        break;\n\n      case PhysicsJoint.DistanceJoint:\n        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);\n        break;\n\n      case PhysicsJoint.SpringJoint:\n        var springData = jointData;\n        constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\n          restLength: springData.length,\n          stiffness: springData.stiffness,\n          damping: springData.damping,\n          localAnchorA: constraintData.pivotA,\n          localAnchorB: constraintData.pivotB\n        });\n        break;\n\n      case PhysicsJoint.LockJoint:\n        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\n        break;\n\n      case PhysicsJoint.PointToPointJoint:\n      case PhysicsJoint.BallAndSocketJoint:\n      default:\n        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\n        break;\n    } //set the collideConnected flag after the creation, since DistanceJoint ignores it.\n\n\n    constraint.collideConnected = !!jointData.collision;\n    impostorJoint.joint.physicsJoint = constraint; //don't add spring as constraint, as it is not one.\n\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.addConstraint(constraint);\n    } else {\n      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function () {\n        constraint.applyForce();\n      };\n\n      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  };\n\n  CannonJSPlugin.prototype.removeJoint = function (impostorJoint) {\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    } else {\n      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  };\n\n  CannonJSPlugin.prototype._addMaterial = function (name, friction, restitution) {\n    var index;\n    var mat;\n\n    for (index = 0; index < this._physicsMaterials.length; index++) {\n      mat = this._physicsMaterials[index];\n\n      if (mat.friction === friction && mat.restitution === restitution) {\n        return mat;\n      }\n    }\n\n    var currentMat = new this.BJSCANNON.Material(name);\n    currentMat.friction = friction;\n    currentMat.restitution = restitution;\n\n    this._physicsMaterials.push(currentMat);\n\n    return currentMat;\n  };\n\n  CannonJSPlugin.prototype._checkWithEpsilon = function (value) {\n    return value < PhysicsEngine.Epsilon ? PhysicsEngine.Epsilon : value;\n  };\n\n  CannonJSPlugin.prototype._createShape = function (impostor) {\n    var object = impostor.object;\n    var returnValue;\n    var extendSize = impostor.getObjectExtendSize();\n\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        var radiusX = extendSize.x;\n        var radiusY = extendSize.y;\n        var radiusZ = extendSize.z;\n        returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\n        break;\n      //TMP also for cylinder - TODO Cannon supports cylinder natively.\n\n      case PhysicsImpostor.CylinderImpostor:\n        var nativeParams = impostor.getParam(\"nativeOptions\");\n\n        if (!nativeParams) {\n          nativeParams = {};\n        }\n\n        var radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;\n        var radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;\n        var height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(extendSize.y);\n        var numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\n        returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments); // Rotate 90 degrees as this shape is horizontal in cannon\n\n        var quat = new this.BJSCANNON.Quaternion();\n        quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\n        var translation = new this.BJSCANNON.Vec3(0, 0, 0);\n        returnValue.transformAllPoints(translation, quat);\n        break;\n\n      case PhysicsImpostor.BoxImpostor:\n        var box = extendSize.scale(0.5);\n        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\n        break;\n\n      case PhysicsImpostor.PlaneImpostor:\n        Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\n        returnValue = new this.BJSCANNON.Plane();\n        break;\n\n      case PhysicsImpostor.MeshImpostor:\n        // should transform the vertex data to world coordinates!!\n        var rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\n        var rawFaces = object.getIndices ? object.getIndices() : [];\n\n        if (!rawVerts) {\n          return;\n        } // get only scale! so the object could transform correctly.\n\n\n        var oldPosition = object.position.clone();\n        var oldRotation = object.rotation && object.rotation.clone();\n        var oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\n        object.position.copyFromFloats(0, 0, 0);\n        object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n        var transform = object.computeWorldMatrix(true); // convert rawVerts to object space\n\n        var temp = new Array();\n        var index;\n\n        for (index = 0; index < rawVerts.length; index += 3) {\n          Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(temp, index);\n        }\n\n        Logger.Warn(\"MeshImpostor only collides against spheres.\");\n        returnValue = new this.BJSCANNON.Trimesh(temp, rawFaces); //now set back the transformation!\n\n        object.position.copyFrom(oldPosition);\n        oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\n        oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\n        break;\n\n      case PhysicsImpostor.HeightmapImpostor:\n        var oldPosition2 = object.position.clone();\n        var oldRotation2 = object.rotation && object.rotation.clone();\n        var oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\n        object.position.copyFromFloats(0, 0, 0);\n        object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n        object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\n        returnValue = this._createHeightmap(object);\n        object.position.copyFrom(oldPosition2);\n        oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\n        oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\n        object.computeWorldMatrix(true);\n        break;\n\n      case PhysicsImpostor.ParticleImpostor:\n        returnValue = new this.BJSCANNON.Particle();\n        break;\n\n      case PhysicsImpostor.NoImpostor:\n        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\n        break;\n    }\n\n    return returnValue;\n  };\n\n  CannonJSPlugin.prototype._createHeightmap = function (object, pointDepth) {\n    var pos = object.getVerticesData(VertexBuffer.PositionKind);\n    var transform = object.computeWorldMatrix(true); // convert rawVerts to object space\n\n    var temp = new Array();\n    var index;\n\n    for (index = 0; index < pos.length; index += 3) {\n      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);\n    }\n\n    pos = temp;\n    var matrix = new Array(); //For now pointDepth will not be used and will be automatically calculated.\n    //Future reference - try and find the best place to add a reference to the pointDepth variable.\n\n    var arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\n    var boundingInfo = object.getBoundingInfo();\n    var dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\n    var minY = boundingInfo.boundingBox.extendSizeWorld.z;\n    var elementSize = dim * 2 / arraySize;\n\n    for (var i = 0; i < pos.length; i = i + 3) {\n      var x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\n      var z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\n      var y = -pos[i + 2] + minY;\n\n      if (!matrix[x]) {\n        matrix[x] = [];\n      }\n\n      if (!matrix[x][z]) {\n        matrix[x][z] = y;\n      }\n\n      matrix[x][z] = Math.max(y, matrix[x][z]);\n    }\n\n    for (var x = 0; x <= arraySize; ++x) {\n      if (!matrix[x]) {\n        var loc = 1;\n\n        while (!matrix[(x + loc) % arraySize]) {\n          loc++;\n        }\n\n        matrix[x] = matrix[(x + loc) % arraySize].slice(); //console.log(\"missing x\", x);\n      }\n\n      for (var z = 0; z <= arraySize; ++z) {\n        if (!matrix[x][z]) {\n          var loc = 1;\n          var newValue;\n\n          while (newValue === undefined) {\n            newValue = matrix[x][(z + loc++) % arraySize];\n          }\n\n          matrix[x][z] = newValue;\n        }\n      }\n    }\n\n    var shape = new this.BJSCANNON.Heightfield(matrix, {\n      elementSize: elementSize\n    }); //For future reference, needed for body transformation\n\n    shape.minY = minY;\n    return shape;\n  };\n\n  CannonJSPlugin.prototype._updatePhysicsBodyTransformation = function (impostor) {\n    var object = impostor.object; //make sure it is updated...\n\n    object.computeWorldMatrix && object.computeWorldMatrix(true); // The delta between the mesh position and the mesh bounding box center\n\n    if (!object.getBoundingInfo()) {\n      return;\n    }\n\n    var center = impostor.getObjectCenter(); //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\n\n    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\n\n    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\n\n    this._tmpPosition.copyFrom(center);\n\n    var quaternion = object.rotationQuaternion;\n\n    if (!quaternion) {\n      return;\n    } //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\n    //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\n\n\n    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      //-90 DEG in X, precalculated\n      quaternion = quaternion.multiply(this._minus90X); //Invert! (Precalculated, 90 deg in X)\n      //No need to clone. this will never change.\n\n      impostor.setDeltaRotation(this._plus90X);\n    } //If it is a heightfield, if should be centered.\n\n\n    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      var mesh = object;\n      var boundingInfo = mesh.getBoundingInfo(); //calculate the correct body position:\n\n      var rotationQuaternion = mesh.rotationQuaternion;\n      mesh.rotationQuaternion = this._tmpUnityRotation;\n      mesh.computeWorldMatrix(true); //get original center with no rotation\n\n      var c = center.clone();\n      var oldPivot = mesh.getPivotMatrix();\n\n      if (oldPivot) {\n        // create a copy the pivot Matrix as it is modified in place\n        oldPivot = oldPivot.clone();\n      } else {\n        oldPivot = Matrix.Identity();\n      } //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\n\n\n      var p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\n      mesh.setPreTransformMatrix(p);\n      mesh.computeWorldMatrix(true); //calculate the translation\n\n      var translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\n\n      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z); //add it inverted to the delta\n\n\n      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\n\n      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y; //rotation is back\n\n      mesh.rotationQuaternion = rotationQuaternion;\n      mesh.setPreTransformMatrix(oldPivot);\n      mesh.computeWorldMatrix(true);\n    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\n      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\n    }\n\n    impostor.setDeltaPosition(this._tmpDeltaPosition); //Now update the impostor object\n\n    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\n    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  };\n\n  CannonJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\n\n    if (impostor.object.rotationQuaternion) {\n      var q = impostor.physicsBody.quaternion;\n      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\n    }\n  };\n\n  CannonJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\n    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n  };\n\n  CannonJSPlugin.prototype.isSupported = function () {\n    return this.BJSCANNON !== undefined;\n  };\n\n  CannonJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  CannonJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  CannonJSPlugin.prototype.getLinearVelocity = function (impostor) {\n    var v = impostor.physicsBody.velocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  CannonJSPlugin.prototype.getAngularVelocity = function (impostor) {\n    var v = impostor.physicsBody.angularVelocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  CannonJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n    impostor.physicsBody.mass = mass;\n    impostor.physicsBody.updateMassProperties();\n  };\n\n  CannonJSPlugin.prototype.getBodyMass = function (impostor) {\n    return impostor.physicsBody.mass;\n  };\n\n  CannonJSPlugin.prototype.getBodyFriction = function (impostor) {\n    return impostor.physicsBody.material.friction;\n  };\n\n  CannonJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n    impostor.physicsBody.material.friction = friction;\n  };\n\n  CannonJSPlugin.prototype.getBodyRestitution = function (impostor) {\n    return impostor.physicsBody.material.restitution;\n  };\n\n  CannonJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n    impostor.physicsBody.material.restitution = restitution;\n  };\n\n  CannonJSPlugin.prototype.sleepBody = function (impostor) {\n    impostor.physicsBody.sleep();\n  };\n\n  CannonJSPlugin.prototype.wakeUpBody = function (impostor) {\n    impostor.physicsBody.wakeUp();\n  };\n\n  CannonJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance) {\n    joint.physicsJoint.distance = maxDistance;\n  };\n\n  CannonJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {\n    if (!motorIndex) {\n      joint.physicsJoint.enableMotor();\n      joint.physicsJoint.setMotorSpeed(speed);\n\n      if (maxForce) {\n        this.setLimit(joint, maxForce);\n      }\n    }\n  };\n\n  CannonJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {\n    joint.physicsJoint.motorEquation.maxForce = upperLimit;\n    joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;\n  };\n\n  CannonJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n    var body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.quaternion.x;\n      mesh.rotationQuaternion.y = body.quaternion.y;\n      mesh.rotationQuaternion.z = body.quaternion.z;\n      mesh.rotationQuaternion.w = body.quaternion.w;\n    }\n  };\n\n  CannonJSPlugin.prototype.getRadius = function (impostor) {\n    var shape = impostor.physicsBody.shapes[0];\n    return shape.boundingSphereRadius;\n  };\n\n  CannonJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n    var shape = impostor.physicsBody.shapes[0];\n    result.x = shape.halfExtents.x * 2;\n    result.y = shape.halfExtents.y * 2;\n    result.z = shape.halfExtents.z * 2;\n  };\n\n  CannonJSPlugin.prototype.dispose = function () {};\n\n  CannonJSPlugin.prototype._extendNamespace = function () {\n    //this will force cannon to execute at least one step when using interpolation\n    var step_tmp1 = new this.BJSCANNON.Vec3();\n    var Engine = this.BJSCANNON;\n\n    this.BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {\n      maxSubSteps = maxSubSteps || 10;\n      timeSinceLastCalled = timeSinceLastCalled || 0;\n\n      if (timeSinceLastCalled === 0) {\n        this.internalStep(dt);\n        this.time += dt;\n      } else {\n        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\n        var t0 = performance.now();\n\n        for (var i = 0; i !== internalSteps; i++) {\n          this.internalStep(dt);\n\n          if (performance.now() - t0 > dt * 1000) {\n            break;\n          }\n        }\n\n        this.time += timeSinceLastCalled;\n        var h = this.time % dt;\n        var h_div_dt = h / dt;\n        var interpvelo = step_tmp1;\n        var bodies = this.bodies;\n\n        for (var j = 0; j !== bodies.length; j++) {\n          var b = bodies[j];\n\n          if (b.type !== Engine.Body.STATIC && b.sleepState !== Engine.Body.SLEEPING) {\n            b.position.vsub(b.previousPosition, interpvelo);\n            interpvelo.scale(h_div_dt, interpvelo);\n            b.position.vadd(interpvelo, b.interpolatedPosition);\n          } else {\n            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\n            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\n          }\n        }\n      }\n    };\n  };\n  /**\r\n   * Does a raycast in the physics world\r\n   * @param from when should the ray start?\r\n   * @param to when should the ray end?\r\n   * @returns PhysicsRaycastResult\r\n   */\n\n\n  CannonJSPlugin.prototype.raycast = function (from, to) {\n    this._cannonRaycastResult.reset();\n\n    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\n\n    this._raycastResult.reset(from, to);\n\n    if (this._cannonRaycastResult.hasHit) {\n      // TODO: do we also want to get the body it hit?\n      this._raycastResult.setHitData({\n        x: this._cannonRaycastResult.hitNormalWorld.x,\n        y: this._cannonRaycastResult.hitNormalWorld.y,\n        z: this._cannonRaycastResult.hitNormalWorld.z\n      }, {\n        x: this._cannonRaycastResult.hitPointWorld.x,\n        y: this._cannonRaycastResult.hitPointWorld.y,\n        z: this._cannonRaycastResult.hitPointWorld.z\n      });\n\n      this._raycastResult.setHitDistance(this._cannonRaycastResult.distance);\n    }\n\n    return this._raycastResult;\n  };\n\n  return CannonJSPlugin;\n}();\n\nexport { CannonJSPlugin };\n\nPhysicsEngine.DefaultPluginFactory = function () {\n  return new CannonJSPlugin();\n};","map":null,"metadata":{},"sourceType":"module"}