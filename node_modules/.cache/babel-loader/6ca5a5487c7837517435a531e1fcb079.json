{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar browserify_aes_1 = tslib_1.__importDefault(require(\"browserify-aes\"));\n\nvar randombytes_1 = tslib_1.__importDefault(require(\"randombytes\"));\n\nvar util_1 = require(\"util\");\n\nvar uuid_1 = tslib_1.__importDefault(require(\"uuid\"));\n\nvar _1 = require(\".\");\n\nfunction decrypt(_x, _x2) {\n  return _decrypt.apply(this, arguments);\n}\n\nfunction _decrypt() {\n  _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(v3Keystore, password) {\n    var nonStrict,\n        json,\n        derivedKey,\n        _json$crypto$kdfparam,\n        n,\n        r,\n        p,\n        dklen,\n        salt,\n        _json$crypto$kdfparam2,\n        prf,\n        c,\n        _dklen,\n        _salt,\n        ciphertext,\n        mac,\n        iv,\n        aesKey,\n        decipher,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            nonStrict = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n\n            if (util_1.isString(password)) {\n              _context.next = 3;\n              break;\n            }\n\n            throw new Error('No password given.');\n\n          case 3:\n            json = !util_1.isString(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n            if (!(json.version !== 3)) {\n              _context.next = 6;\n              break;\n            }\n\n            throw new Error('Not a valid V3 wallet');\n\n          case 6:\n            if (!(json.crypto.kdf === 'scrypt')) {\n              _context.next = 13;\n              break;\n            }\n\n            _json$crypto$kdfparam = json.crypto.kdfparams, n = _json$crypto$kdfparam.n, r = _json$crypto$kdfparam.r, p = _json$crypto$kdfparam.p, dklen = _json$crypto$kdfparam.dklen, salt = _json$crypto$kdfparam.salt;\n            _context.next = 10;\n            return _1.scrypt(Buffer.from(password), Buffer.from(salt, 'hex'), n, r, p, dklen);\n\n          case 10:\n            derivedKey = _context.sent;\n            _context.next = 23;\n            break;\n\n          case 13:\n            if (!(json.crypto.kdf === 'pbkdf2')) {\n              _context.next = 22;\n              break;\n            }\n\n            _json$crypto$kdfparam2 = json.crypto.kdfparams, prf = _json$crypto$kdfparam2.prf, c = _json$crypto$kdfparam2.c, _dklen = _json$crypto$kdfparam2.dklen, _salt = _json$crypto$kdfparam2.salt;\n\n            if (!(prf !== 'hmac-sha256')) {\n              _context.next = 17;\n              break;\n            }\n\n            throw new Error('Unsupported parameters to PBKDF2');\n\n          case 17:\n            _context.next = 19;\n            return _1.pbkdf2(Buffer.from(password), Buffer.from(_salt, 'hex'), c, _dklen);\n\n          case 19:\n            derivedKey = _context.sent;\n            _context.next = 23;\n            break;\n\n          case 22:\n            throw new Error('Unsupported key derivation scheme');\n\n          case 23:\n            ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');\n            mac = _1.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n            if (!(mac !== json.crypto.mac)) {\n              _context.next = 27;\n              break;\n            }\n\n            throw new Error('Key derivation failed - possibly wrong password');\n\n          case 27:\n            iv = Buffer.from(json.crypto.cipherparams.iv, 'hex');\n            aesKey = derivedKey.slice(0, 16);\n            decipher = browserify_aes_1.default.createDecipheriv(json.crypto.cipher, aesKey, iv);\n            return _context.abrupt(\"return\", Buffer.concat([decipher.update(ciphertext), decipher.final()]));\n\n          case 31:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decrypt.apply(this, arguments);\n}\n\nexports.decrypt = decrypt;\n\nfunction encrypt(_x3, _x4, _x5) {\n  return _encrypt.apply(this, arguments);\n}\n\nfunction _encrypt() {\n  _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(privateKey, address, password) {\n    var options,\n        cipherAlgo,\n        salt,\n        iv,\n        kdf,\n        id,\n        derivedKey,\n        kdfparams,\n        _options$c,\n        c,\n        _options$dklen,\n        dklen,\n        _options$n,\n        n,\n        _options$r,\n        r,\n        _options$p,\n        p,\n        _options$dklen2,\n        _dklen2,\n        aesKey,\n        cipher,\n        ciphertext,\n        mac,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};\n            cipherAlgo = options.cipher || 'aes-128-ctr';\n            salt = options.salt ? Buffer.from(options.salt, 'hex') : randombytes_1.default(32);\n            iv = options.iv ? Buffer.from(options.iv, 'hex') : randombytes_1.default(16);\n            kdf = options.kdf || 'scrypt';\n            id = options.id || uuid_1.default.v4({\n              random: options.uuid || randombytes_1.default(16)\n            });\n\n            if (!(cipherAlgo !== 'aes-128-ctr')) {\n              _context2.next = 8;\n              break;\n            }\n\n            throw new Error('Unsupported cipher');\n\n          case 8:\n            if (!(kdf === 'pbkdf2')) {\n              _context2.next = 16;\n              break;\n            }\n\n            _options$c = options.c, c = _options$c === void 0 ? 262144 : _options$c, _options$dklen = options.dklen, dklen = _options$dklen === void 0 ? 32 : _options$dklen;\n            _context2.next = 12;\n            return _1.pbkdf2(Buffer.from(password), salt, c, dklen);\n\n          case 12:\n            derivedKey = _context2.sent;\n            kdfparams = {\n              c: c,\n              dklen: dklen,\n              prf: 'hmac-sha256',\n              salt: salt.toString('hex')\n            };\n            _context2.next = 25;\n            break;\n\n          case 16:\n            if (!(kdf === 'scrypt')) {\n              _context2.next = 24;\n              break;\n            }\n\n            _options$n = options.n, n = _options$n === void 0 ? 8192 : _options$n, _options$r = options.r, r = _options$r === void 0 ? 8 : _options$r, _options$p = options.p, p = _options$p === void 0 ? 1 : _options$p, _options$dklen2 = options.dklen, _dklen2 = _options$dklen2 === void 0 ? 32 : _options$dklen2;\n            _context2.next = 20;\n            return _1.scrypt(Buffer.from(password), salt, n, r, p, _dklen2);\n\n          case 20:\n            derivedKey = _context2.sent;\n            kdfparams = {\n              n: n,\n              r: r,\n              p: p,\n              dklen: _dklen2,\n              salt: salt.toString('hex')\n            };\n            _context2.next = 25;\n            break;\n\n          case 24:\n            throw new Error('Unsupported kdf');\n\n          case 25:\n            aesKey = derivedKey.slice(0, 16);\n            cipher = browserify_aes_1.default.createCipheriv(cipherAlgo, aesKey, iv);\n\n            if (cipher) {\n              _context2.next = 29;\n              break;\n            }\n\n            throw new Error('Unsupported cipher');\n\n          case 29:\n            ciphertext = Buffer.concat([cipher.update(privateKey), cipher.final()]);\n            mac = _1.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n            return _context2.abrupt(\"return\", {\n              version: 3,\n              id: id,\n              address: address.toString().toLowerCase().replace('0x', ''),\n              crypto: {\n                ciphertext: ciphertext.toString('hex'),\n                cipherparams: {\n                  iv: iv.toString('hex')\n                },\n                cipher: 'aes-128-ctr',\n                kdf: kdf,\n                kdfparams: kdfparams,\n                mac: mac.toString()\n              }\n            });\n\n          case 32:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _encrypt.apply(this, arguments);\n}\n\nexports.encrypt = encrypt;","map":null,"metadata":{},"sourceType":"script"}