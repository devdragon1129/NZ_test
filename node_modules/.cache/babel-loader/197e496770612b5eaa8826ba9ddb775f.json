{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Matrix } from \"../../Maths/math.vector\";\nimport { EngineStore } from \"../../Engines/engineStore\";\nimport { GUID } from '../../Misc/guid';\nimport \"../../Misc/fileTools\";\nimport { ThinTexture } from './thinTexture';\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\n\nvar BaseTexture =\n/** @class */\nfunction (_super) {\n  __extends(BaseTexture, _super);\n  /**\r\n   * Instantiates a new BaseTexture.\r\n   * Base class of all the textures in babylon.\r\n   * It groups all the common properties the materials, post process, lights... might need\r\n   * in order to make a correct use of the texture.\r\n   * @param sceneOrEngine Define the scene or engine the texture blongs to\r\n   */\n\n\n  function BaseTexture(sceneOrEngine) {\n    var _this = _super.call(this, null) || this;\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\n\n\n    _this.metadata = null;\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\n\n    _this.reservedDataStore = null;\n    _this._hasAlpha = false;\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\n\n    _this.getAlphaFromRGB = false;\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\n\n    _this.level = 1;\n    /**\r\n     * Define the UV chanel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\n\n    _this.coordinatesIndex = 0;\n    _this._coordinatesMode = 0;\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\n\n    _this.wrapR = 1;\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\n\n    _this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n    _this._isCube = false;\n    _this._gammaSpace = true;\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\n\n    _this.invertZ = false;\n    /**\r\n     * @hidden\r\n     */\n\n    _this.lodLevelInAlpha = false;\n    /**\r\n     * Define if the texture is a render target.\r\n     */\n\n    _this.isRenderTarget = false;\n    /** @hidden */\n\n    _this._prefiltered = false;\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\n\n    _this.animations = new Array();\n    /**\r\n    * An event triggered when the texture is disposed.\r\n    */\n\n    _this.onDisposeObservable = new Observable();\n    _this._onDisposeObserver = null;\n    _this._scene = null;\n    /** @hidden */\n\n    _this._texture = null;\n    _this._uid = null;\n\n    if (sceneOrEngine) {\n      if (BaseTexture._isScene(sceneOrEngine)) {\n        _this._scene = sceneOrEngine;\n      } else {\n        _this._engine = sceneOrEngine;\n      }\n    } else {\n      _this._scene = EngineStore.LastCreatedScene;\n    }\n\n    if (_this._scene) {\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.addTexture(_this);\n\n      _this._engine = _this._scene.getEngine();\n    }\n\n    _this._uid = null;\n    return _this;\n  }\n\n  Object.defineProperty(BaseTexture.prototype, \"hasAlpha\", {\n    get: function get() {\n      return this._hasAlpha;\n    },\n\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\n    set: function set(value) {\n      if (this._hasAlpha === value) {\n        return;\n      }\n\n      this._hasAlpha = value;\n\n      if (this._scene) {\n        this._scene.markAllMaterialsAsDirty(1 | 16);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"coordinatesMode\", {\n    get: function get() {\n      return this._coordinatesMode;\n    },\n\n    /**\r\n    * How a texture is mapped.\r\n    *\r\n    * | Value | Type                                | Description |\r\n    * | ----- | ----------------------------------- | ----------- |\r\n    * | 0     | EXPLICIT_MODE                       |             |\r\n    * | 1     | SPHERICAL_MODE                      |             |\r\n    * | 2     | PLANAR_MODE                         |             |\r\n    * | 3     | CUBIC_MODE                          |             |\r\n    * | 4     | PROJECTION_MODE                     |             |\r\n    * | 5     | SKYBOX_MODE                         |             |\r\n    * | 6     | INVCUBIC_MODE                       |             |\r\n    * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n    * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n    * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n    */\n    set: function set(value) {\n      if (this._coordinatesMode === value) {\n        return;\n      }\n\n      this._coordinatesMode = value;\n\n      if (this._scene) {\n        this._scene.markAllMaterialsAsDirty(1);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"wrapU\", {\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\n    get: function get() {\n      return this._wrapU;\n    },\n    set: function set(value) {\n      this._wrapU = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"wrapV\", {\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\n    get: function get() {\n      return this._wrapV;\n    },\n    set: function set(value) {\n      this._wrapV = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isCube\", {\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return this._isCube;\n      }\n\n      return this._texture.isCube;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        this._isCube = value;\n      } else {\n        this._texture.isCube = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"is3D\", {\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is3D;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is3D = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"is2DArray\", {\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is2DArray;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is2DArray = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"gammaSpace\", {\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return this._gammaSpace;\n      } else {\n        if (this._texture._gammaSpace === null) {\n          this._texture._gammaSpace = this._gammaSpace;\n        }\n      }\n\n      return this._texture._gammaSpace;\n    },\n    set: function set(gamma) {\n      if (!this._texture) {\n        if (this._gammaSpace === gamma) {\n          return;\n        }\n\n        this._gammaSpace = gamma;\n      } else {\n        if (this._texture._gammaSpace === gamma) {\n          return;\n        }\n\n        this._texture._gammaSpace = gamma;\n      }\n\n      this._markAllSubMeshesAsTexturesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isRGBD\", {\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\n    get: function get() {\n      return this._texture != null && this._texture._isRGBD;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._isRGBD = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"noMipmap\", {\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"lodGenerationOffset\", {\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodGenerationOffset;\n      }\n\n      return 0.0;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._lodGenerationOffset = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"lodGenerationScale\", {\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodGenerationScale;\n      }\n\n      return 0.0;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._lodGenerationScale = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"linearSpecularLOD\", {\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._linearSpecularLOD;\n      }\n\n      return false;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._linearSpecularLOD = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"irradianceTexture\", {\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._irradianceTexture;\n      }\n\n      return null;\n    },\n    set: function set(value) {\n      if (this._texture) {\n        this._texture._irradianceTexture = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"uid\", {\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\n    get: function get() {\n      if (!this._uid) {\n        this._uid = GUID.RandomId();\n      }\n\n      return this._uid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Return a string representation of the texture.\r\n   * @returns the texture as a string\r\n   */\n\n  BaseTexture.prototype.toString = function () {\n    return this.name;\n  };\n  /**\r\n   * Get the class name of the texture.\r\n   * @returns \"BaseTexture\"\r\n   */\n\n\n  BaseTexture.prototype.getClassName = function () {\n    return \"BaseTexture\";\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"onDispose\", {\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isBlocking\", {\n    /**\r\n     * Define if the texture is preventinga material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the scene the texture belongs to.\r\n   * @returns the scene or null if undefined\r\n   */\n\n  BaseTexture.prototype.getScene = function () {\n    return this._scene;\n  };\n  /** @hidden */\n\n\n  BaseTexture.prototype._getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * Checks if the texture has the same transform matrix than another texture\r\n   * @param texture texture to check against\r\n   * @returns true if the transforms are the same, else false\r\n   */\n\n\n  BaseTexture.prototype.checkTransformsAreIdentical = function (texture) {\n    return texture !== null;\n  };\n  /**\r\n   * Get the texture transform matrix used to offset tile the texture for istance.\r\n   * @returns the transformation matrix\r\n   */\n\n\n  BaseTexture.prototype.getTextureMatrix = function () {\n    return Matrix.IdentityReadOnly;\n  };\n  /**\r\n   * Get the texture reflection matrix used to rotate/transform the reflection.\r\n   * @returns the reflection matrix\r\n   */\n\n\n  BaseTexture.prototype.getReflectionTextureMatrix = function () {\n    return Matrix.IdentityReadOnly;\n  };\n  /**\r\n   * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n   * @returns true if ready or not blocking\r\n   */\n\n\n  BaseTexture.prototype.isReadyOrNotBlocking = function () {\n    return !this.isBlocking || this.isReady();\n  };\n  /**\r\n   * Scales the texture if is `canRescale()`\r\n   * @param ratio the resize factor we want to use to rescale\r\n   */\n\n\n  BaseTexture.prototype.scale = function (ratio) {};\n\n  Object.defineProperty(BaseTexture.prototype, \"canRescale\", {\n    /**\r\n     * Get if the texture can rescale.\r\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  BaseTexture.prototype._getFromCache = function (url, noMipmap, sampling, invertY) {\n    var engine = this._getEngine();\n\n    if (!engine) {\n      return null;\n    }\n\n    var texturesCache = engine.getLoadedTexturesCache();\n\n    for (var index = 0; index < texturesCache.length; index++) {\n      var texturesCacheEntry = texturesCache[index];\n\n      if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\n        if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n          if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n            texturesCacheEntry.incrementReferences();\n            return texturesCacheEntry;\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n  /** @hidden */\n\n\n  BaseTexture.prototype._rebuild = function () {};\n  /**\r\n   * Clones the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  BaseTexture.prototype.clone = function () {\n    return null;\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"textureType\", {\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return 0;\n      }\n\n      return this._texture.type !== undefined ? this._texture.type : 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"textureFormat\", {\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return 5;\n      }\n\n      return this._texture.format !== undefined ? this._texture.format : 5;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Indicates that textures need to be re-calculated for all materials\r\n   */\n\n  BaseTexture.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    scene.markAllMaterialsAsDirty(1);\n  };\n  /**\r\n   * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n   * This will returns an RGBA array buffer containing either in values (0-255) or\r\n   * float values (0-1) depending of the underlying buffer type.\r\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n   * @param buffer defines a user defined buffer to fill with data (can be null)\r\n   * @returns The Array buffer containing the pixels data.\r\n   */\n\n\n  BaseTexture.prototype.readPixels = function (faceIndex, level, buffer) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (!this._texture) {\n      return null;\n    }\n\n    var size = this.getSize();\n    var width = size.width;\n    var height = size.height;\n\n    var engine = this._getEngine();\n\n    if (!engine) {\n      return null;\n    }\n\n    if (level != 0) {\n      width = width / Math.pow(2, level);\n      height = height / Math.pow(2, level);\n      width = Math.round(width);\n      height = Math.round(height);\n    }\n\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer);\n      }\n\n      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer);\n    } catch (e) {\n      return null;\n    }\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureHigh\", {\n    /** @hidden */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodTextureHigh;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureMid\", {\n    /** @hidden */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodTextureMid;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureLow\", {\n    /** @hidden */\n    get: function get() {\n      if (this._texture) {\n        return this._texture._lodTextureLow;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Dispose the texture and release its associated resources.\r\n   */\n\n  BaseTexture.prototype.dispose = function () {\n    if (this._scene) {\n      // Animations\n      if (this._scene.stopAnimation) {\n        this._scene.stopAnimation(this);\n      } // Remove from scene\n\n\n      this._scene._removePendingData(this);\n\n      var index = this._scene.textures.indexOf(this);\n\n      if (index >= 0) {\n        this._scene.textures.splice(index, 1);\n      }\n\n      this._scene.onTextureRemovedObservable.notifyObservers(this);\n\n      this._scene = null;\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Serialize the texture into a JSON representation that can be parsed later on.\r\n   * @returns the JSON representation of the texture\r\n   */\n\n\n  BaseTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = SerializationHelper.Serialize(this); // Animations\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  };\n  /**\r\n   * Helper function to be called back once a list of texture contains only ready textures.\r\n   * @param textures Define the list of textures to wait for\r\n   * @param callback Define the callback triggered once the entire list will be ready\r\n   */\n\n\n  BaseTexture.WhenAllReady = function (textures, callback) {\n    var numRemaining = textures.length;\n\n    if (numRemaining === 0) {\n      callback();\n      return;\n    }\n\n    for (var i = 0; i < textures.length; i++) {\n      var texture = textures[i];\n\n      if (texture.isReady()) {\n        if (--numRemaining === 0) {\n          callback();\n        }\n      } else {\n        var onLoadObservable = texture.onLoadObservable;\n\n        if (onLoadObservable) {\n          onLoadObservable.addOnce(function () {\n            if (--numRemaining === 0) {\n              callback();\n            }\n          });\n        }\n      }\n    }\n  };\n\n  BaseTexture._isScene = function (sceneOrEngine) {\n    return sceneOrEngine.getClassName() === \"Scene\";\n  };\n  /**\r\n   * Default anisotropic filtering level for the application.\r\n   * It is set to 4 as a good tradeoff between perf and quality.\r\n   */\n\n\n  BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n\n  __decorate([serialize()], BaseTexture.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"name\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"metadata\", void 0);\n\n  __decorate([serialize(\"hasAlpha\")], BaseTexture.prototype, \"_hasAlpha\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"getAlphaFromRGB\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"level\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"coordinatesIndex\", void 0);\n\n  __decorate([serialize(\"coordinatesMode\")], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapU\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapV\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapR\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"isCube\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"is3D\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"is2DArray\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"gammaSpace\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"invertZ\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodGenerationOffset\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodGenerationScale\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"linearSpecularLOD\", null);\n\n  __decorate([serializeAsTexture()], BaseTexture.prototype, \"irradianceTexture\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"isRenderTarget\", void 0);\n\n  return BaseTexture;\n}(ThinTexture);\n\nexport { BaseTexture };","map":null,"metadata":{},"sourceType":"module"}