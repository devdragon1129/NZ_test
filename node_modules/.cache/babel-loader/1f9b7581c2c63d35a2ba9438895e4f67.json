{"ast":null,"code":"import { Observable } from \"./observable\";\nimport { DomManagement } from \"./domManagement\";\nimport { Logger } from \"./logger\";\nimport { DeepCopier } from \"./deepCopier\";\nimport { PrecisionDate } from \"./precisionDate\";\nimport { _DevTools } from \"./devTools\";\nimport { WebRequest } from \"./webRequest\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { FileTools } from \"./fileTools\";\nimport { PromisePolyfill } from \"./promise\";\nimport { TimingTools } from \"./timingTools\";\nimport { InstantiationTools } from \"./instantiationTools\";\nimport { GUID } from \"./guid\";\n/**\r\n * Class containing a set of static utilities functions\r\n */\n\nvar Tools =\n/** @class */\nfunction () {\n  function Tools() {}\n\n  Object.defineProperty(Tools, \"BaseUrl\", {\n    /**\r\n     * Gets or sets the base URL to use to load assets\r\n     */\n    get: function get() {\n      return FileTools.BaseUrl;\n    },\n    set: function set(value) {\n      FileTools.BaseUrl = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Tools, \"DefaultRetryStrategy\", {\n    /**\r\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset\r\n     */\n    get: function get() {\n      return FileTools.DefaultRetryStrategy;\n    },\n    set: function set(strategy) {\n      FileTools.DefaultRetryStrategy = strategy;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Tools, \"CorsBehavior\", {\n    /**\r\n     * Default behaviour for cors in the application.\r\n     * It can be a string if the expected behavior is identical in the entire app.\r\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\r\n     */\n    get: function get() {\n      return FileTools.CorsBehavior;\n    },\n    set: function set(value) {\n      FileTools.CorsBehavior = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Tools, \"UseFallbackTexture\", {\n    /**\r\n     * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded\r\n     * @ignorenaming\r\n     */\n    get: function get() {\n      return EngineStore.UseFallbackTexture;\n    },\n    set: function set(value) {\n      EngineStore.UseFallbackTexture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Tools, \"RegisteredExternalClasses\", {\n    /**\r\n     * Use this object to register external classes like custom textures or material\r\n     * to allow the laoders to instantiate them\r\n     */\n    get: function get() {\n      return InstantiationTools.RegisteredExternalClasses;\n    },\n    set: function set(classes) {\n      InstantiationTools.RegisteredExternalClasses = classes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Tools, \"fallbackTexture\", {\n    /**\r\n     * Texture content used if a texture cannot loaded\r\n     * @ignorenaming\r\n     */\n    get: function get() {\n      return EngineStore.FallbackTexture;\n    },\n    set: function set(value) {\n      EngineStore.FallbackTexture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Read the content of a byte array at a specified coordinates (taking in account wrapping)\r\n   * @param u defines the coordinate on X axis\r\n   * @param v defines the coordinate on Y axis\r\n   * @param width defines the width of the source data\r\n   * @param height defines the height of the source data\r\n   * @param pixels defines the source byte array\r\n   * @param color defines the output color\r\n   */\n\n  Tools.FetchToRef = function (u, v, width, height, pixels, color) {\n    var wrappedU = Math.abs(u) * width % width | 0;\n    var wrappedV = Math.abs(v) * height % height | 0;\n    var position = (wrappedU + wrappedV * width) * 4;\n    color.r = pixels[position] / 255;\n    color.g = pixels[position + 1] / 255;\n    color.b = pixels[position + 2] / 255;\n    color.a = pixels[position + 3] / 255;\n  };\n  /**\r\n   * Interpolates between a and b via alpha\r\n   * @param a The lower value (returned when alpha = 0)\r\n   * @param b The upper value (returned when alpha = 1)\r\n   * @param alpha The interpolation-factor\r\n   * @return The mixed value\r\n   */\n\n\n  Tools.Mix = function (a, b, alpha) {\n    return a * (1 - alpha) + b * alpha;\n  };\n  /**\r\n   * Tries to instantiate a new object from a given class name\r\n   * @param className defines the class name to instantiate\r\n   * @returns the new object or null if the system was not able to do the instantiation\r\n   */\n\n\n  Tools.Instantiate = function (className) {\n    return InstantiationTools.Instantiate(className);\n  };\n  /**\r\n   * Provides a slice function that will work even on IE\r\n   * @param data defines the array to slice\r\n   * @param start defines the start of the data (optional)\r\n   * @param end defines the end of the data (optional)\r\n   * @returns the new sliced array\r\n   */\n\n\n  Tools.Slice = function (data, start, end) {\n    if (data.slice) {\n      return data.slice(start, end);\n    }\n\n    return Array.prototype.slice.call(data, start, end);\n  };\n  /**\r\n   * Provides a slice function that will work even on IE\r\n   * The difference between this and Slice is that this will force-convert to array\r\n   * @param data defines the array to slice\r\n   * @param start defines the start of the data (optional)\r\n   * @param end defines the end of the data (optional)\r\n   * @returns the new sliced array\r\n   */\n\n\n  Tools.SliceToArray = function (data, start, end) {\n    if (Array.isArray(data)) {\n      return data.slice(start, end);\n    }\n\n    return Array.prototype.slice.call(data, start, end);\n  };\n  /**\r\n   * Polyfill for setImmediate\r\n   * @param action defines the action to execute after the current execution block\r\n   */\n\n\n  Tools.SetImmediate = function (action) {\n    TimingTools.SetImmediate(action);\n  };\n  /**\r\n   * Function indicating if a number is an exponent of 2\r\n   * @param value defines the value to test\r\n   * @returns true if the value is an exponent of 2\r\n   */\n\n\n  Tools.IsExponentOfTwo = function (value) {\n    var count = 1;\n\n    do {\n      count *= 2;\n    } while (count < value);\n\n    return count === value;\n  };\n  /**\r\n   * Returns the nearest 32-bit single precision float representation of a Number\r\n   * @param value A Number.  If the parameter is of a different type, it will get converted\r\n   * to a number or to NaN if it cannot be converted\r\n   * @returns number\r\n   */\n\n\n  Tools.FloatRound = function (value) {\n    if (Math.fround) {\n      return Math.fround(value);\n    }\n\n    return Tools._tmpFloatArray[0] = value;\n  };\n  /**\r\n   * Extracts the filename from a path\r\n   * @param path defines the path to use\r\n   * @returns the filename\r\n   */\n\n\n  Tools.GetFilename = function (path) {\n    var index = path.lastIndexOf(\"/\");\n\n    if (index < 0) {\n      return path;\n    }\n\n    return path.substring(index + 1);\n  };\n  /**\r\n   * Extracts the \"folder\" part of a path (everything before the filename).\r\n   * @param uri The URI to extract the info from\r\n   * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present\r\n   * @returns The \"folder\" part of the path\r\n   */\n\n\n  Tools.GetFolderPath = function (uri, returnUnchangedIfNoSlash) {\n    if (returnUnchangedIfNoSlash === void 0) {\n      returnUnchangedIfNoSlash = false;\n    }\n\n    var index = uri.lastIndexOf(\"/\");\n\n    if (index < 0) {\n      if (returnUnchangedIfNoSlash) {\n        return uri;\n      }\n\n      return \"\";\n    }\n\n    return uri.substring(0, index + 1);\n  };\n  /**\r\n   * Convert an angle in radians to degrees\r\n   * @param angle defines the angle to convert\r\n   * @returns the angle in degrees\r\n   */\n\n\n  Tools.ToDegrees = function (angle) {\n    return angle * 180 / Math.PI;\n  };\n  /**\r\n   * Convert an angle in degrees to radians\r\n   * @param angle defines the angle to convert\r\n   * @returns the angle in radians\r\n   */\n\n\n  Tools.ToRadians = function (angle) {\n    return angle * Math.PI / 180;\n  };\n  /**\r\n   * Returns an array if obj is not an array\r\n   * @param obj defines the object to evaluate as an array\r\n   * @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined\r\n   * @returns either obj directly if obj is an array or a new array containing obj\r\n   */\n\n\n  Tools.MakeArray = function (obj, allowsNullUndefined) {\n    if (allowsNullUndefined !== true && (obj === undefined || obj == null)) {\n      return null;\n    }\n\n    return Array.isArray(obj) ? obj : [obj];\n  };\n  /**\r\n   * Gets the pointer prefix to use\r\n   * @param engine defines the engine we are finding the prefix for\r\n   * @returns \"pointer\" if touch is enabled. Else returns \"mouse\"\r\n   */\n\n\n  Tools.GetPointerPrefix = function (engine) {\n    var eventPrefix = \"pointer\"; // Check if pointer events are supported\n\n    if (DomManagement.IsWindowObjectExist() && !window.PointerEvent && DomManagement.IsNavigatorAvailable() && !navigator.pointerEnabled) {\n      eventPrefix = \"mouse\";\n    } // Special Fallback MacOS Safari...\n\n\n    if (engine._badDesktopOS && !engine._badOS && // And not ipad pros who claim to be macs...\n    !(document && \"ontouchend\" in document)) {\n      eventPrefix = \"mouse\";\n    }\n\n    return eventPrefix;\n  };\n  /**\r\n   * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\r\n   * @param url define the url we are trying\r\n   * @param element define the dom element where to configure the cors policy\r\n   */\n\n\n  Tools.SetCorsBehavior = function (url, element) {\n    FileTools.SetCorsBehavior(url, element);\n  }; // External files\n\n  /**\r\n   * Removes unwanted characters from an url\r\n   * @param url defines the url to clean\r\n   * @returns the cleaned url\r\n   */\n\n\n  Tools.CleanUrl = function (url) {\n    url = url.replace(/#/gm, \"%23\");\n    return url;\n  };\n\n  Object.defineProperty(Tools, \"PreprocessUrl\", {\n    /**\r\n     * Gets or sets a function used to pre-process url before using them to load assets\r\n     */\n    get: function get() {\n      return FileTools.PreprocessUrl;\n    },\n    set: function set(processor) {\n      FileTools.PreprocessUrl = processor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Loads an image as an HTMLImageElement.\r\n   * @param input url string, ArrayBuffer, or Blob to load\r\n   * @param onLoad callback called when the image successfully loads\r\n   * @param onError callback called when the image fails to load\r\n   * @param offlineProvider offline provider for caching\r\n   * @param mimeType optional mime type\r\n   * @returns the HTMLImageElement of the loaded image\r\n   */\n\n  Tools.LoadImage = function (input, onLoad, onError, offlineProvider, mimeType) {\n    return FileTools.LoadImage(input, onLoad, onError, offlineProvider, mimeType);\n  };\n  /**\r\n   * Loads a file from a url\r\n   * @param url url string, ArrayBuffer, or Blob to load\r\n   * @param onSuccess callback called when the file successfully loads\r\n   * @param onProgress callback called while file is loading (if the server supports this mode)\r\n   * @param offlineProvider defines the offline provider for caching\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @param onError callback called when the file fails to load\r\n   * @returns a file request object\r\n   */\n\n\n  Tools.LoadFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    return FileTools.LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\n  };\n  /**\r\n   * Loads a file from a url\r\n   * @param url the file url to load\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @returns a promise containing an ArrayBuffer corresponding to the loaded file\r\n   */\n\n\n  Tools.LoadFileAsync = function (url, useArrayBuffer) {\n    if (useArrayBuffer === void 0) {\n      useArrayBuffer = true;\n    }\n\n    return new Promise(function (resolve, reject) {\n      FileTools.LoadFile(url, function (data) {\n        resolve(data);\n      }, undefined, undefined, useArrayBuffer, function (request, exception) {\n        reject(exception);\n      });\n    });\n  };\n  /**\r\n   * Load a script (identified by an url). When the url returns, the\r\n   * content of this file is added into a new script element, attached to the DOM (body element)\r\n   * @param scriptUrl defines the url of the script to laod\r\n   * @param onSuccess defines the callback called when the script is loaded\r\n   * @param onError defines the callback to call if an error occurs\r\n   * @param scriptId defines the id of the script element\r\n   */\n\n\n  Tools.LoadScript = function (scriptUrl, onSuccess, onError, scriptId) {\n    if (!DomManagement.IsWindowObjectExist()) {\n      return;\n    }\n\n    var head = document.getElementsByTagName(\"head\")[0];\n    var script = document.createElement(\"script\");\n    script.setAttribute(\"type\", \"text/javascript\");\n    script.setAttribute(\"src\", scriptUrl);\n\n    if (scriptId) {\n      script.id = scriptId;\n    }\n\n    script.onload = function () {\n      if (onSuccess) {\n        onSuccess();\n      }\n    };\n\n    script.onerror = function (e) {\n      if (onError) {\n        onError(\"Unable to load script '\" + scriptUrl + \"'\", e);\n      }\n    };\n\n    head.appendChild(script);\n  };\n  /**\r\n   * Load an asynchronous script (identified by an url). When the url returns, the\r\n   * content of this file is added into a new script element, attached to the DOM (body element)\r\n   * @param scriptUrl defines the url of the script to laod\r\n   * @param scriptId defines the id of the script element\r\n   * @returns a promise request object\r\n   */\n\n\n  Tools.LoadScriptAsync = function (scriptUrl, scriptId) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.LoadScript(scriptUrl, function () {\n        resolve();\n      }, function (message, exception) {\n        reject(exception);\n      });\n    });\n  };\n  /**\r\n   * Loads a file from a blob\r\n   * @param fileToLoad defines the blob to use\r\n   * @param callback defines the callback to call when data is loaded\r\n   * @param progressCallback defines the callback to call during loading process\r\n   * @returns a file request object\r\n   */\n\n\n  Tools.ReadFileAsDataURL = function (fileToLoad, callback, progressCallback) {\n    var reader = new FileReader();\n    var request = {\n      onCompleteObservable: new Observable(),\n      abort: function abort() {\n        return reader.abort();\n      }\n    };\n\n    reader.onloadend = function (e) {\n      request.onCompleteObservable.notifyObservers(request);\n    };\n\n    reader.onload = function (e) {\n      //target doesn't have result from ts 1.3\n      callback(e.target[\"result\"]);\n    };\n\n    reader.onprogress = progressCallback;\n    reader.readAsDataURL(fileToLoad);\n    return request;\n  };\n  /**\r\n   * Reads a file from a File object\r\n   * @param file defines the file to load\r\n   * @param onSuccess defines the callback to call when data is loaded\r\n   * @param onProgress defines the callback to call during loading process\r\n   * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n   * @param onError defines the callback to call when an error occurs\r\n   * @returns a file request object\r\n   */\n\n\n  Tools.ReadFile = function (file, onSuccess, onProgress, useArrayBuffer, onError) {\n    return FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n  };\n  /**\r\n   * Creates a data url from a given string content\r\n   * @param content defines the content to convert\r\n   * @returns the new data url link\r\n   */\n\n\n  Tools.FileAsURL = function (content) {\n    var fileBlob = new Blob([content]);\n    var url = window.URL || window.webkitURL;\n    var link = url.createObjectURL(fileBlob);\n    return link;\n  };\n  /**\r\n   * Format the given number to a specific decimal format\r\n   * @param value defines the number to format\r\n   * @param decimals defines the number of decimals to use\r\n   * @returns the formatted string\r\n   */\n\n\n  Tools.Format = function (value, decimals) {\n    if (decimals === void 0) {\n      decimals = 2;\n    }\n\n    return value.toFixed(decimals);\n  };\n  /**\r\n   * Tries to copy an object by duplicating every property\r\n   * @param source defines the source object\r\n   * @param destination defines the target object\r\n   * @param doNotCopyList defines a list of properties to avoid\r\n   * @param mustCopyList defines a list of properties to copy (even if they start with _)\r\n   */\n\n\n  Tools.DeepCopy = function (source, destination, doNotCopyList, mustCopyList) {\n    DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);\n  };\n  /**\r\n   * Gets a boolean indicating if the given object has no own property\r\n   * @param obj defines the object to test\r\n   * @returns true if object has no own property\r\n   */\n\n\n  Tools.IsEmpty = function (obj) {\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Function used to register events at window level\r\n   * @param windowElement defines the Window object to use\r\n   * @param events defines the events to register\r\n   */\n\n\n  Tools.RegisterTopRootEvents = function (windowElement, events) {\n    for (var index = 0; index < events.length; index++) {\n      var event = events[index];\n      windowElement.addEventListener(event.name, event.handler, false);\n\n      try {\n        if (window.parent) {\n          window.parent.addEventListener(event.name, event.handler, false);\n        }\n      } catch (e) {// Silently fails...\n      }\n    }\n  };\n  /**\r\n   * Function used to unregister events from window level\r\n   * @param windowElement defines the Window object to use\r\n   * @param events defines the events to unregister\r\n   */\n\n\n  Tools.UnregisterTopRootEvents = function (windowElement, events) {\n    for (var index = 0; index < events.length; index++) {\n      var event = events[index];\n      windowElement.removeEventListener(event.name, event.handler);\n\n      try {\n        if (windowElement.parent) {\n          windowElement.parent.removeEventListener(event.name, event.handler);\n        }\n      } catch (e) {// Silently fails...\n      }\n    }\n  };\n  /**\r\n   * Dumps the current bound framebuffer\r\n   * @param width defines the rendering width\r\n   * @param height defines the rendering height\r\n   * @param engine defines the hosting engine\r\n   * @param successCallback defines the callback triggered once the data are available\r\n   * @param mimeType defines the mime type of the result\r\n   * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n   */\n\n\n  Tools.DumpFramebuffer = function (width, height, engine, successCallback, mimeType, fileName) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    } // Read the contents of the framebuffer\n\n\n    var numberOfChannelsByLine = width * 4;\n    var halfHeight = height / 2; //Reading datas from WebGL\n\n    var data = engine.readPixels(0, 0, width, height); //To flip image on Y axis.\n\n    for (var i = 0; i < halfHeight; i++) {\n      for (var j = 0; j < numberOfChannelsByLine; j++) {\n        var currentCell = j + i * numberOfChannelsByLine;\n        var targetLine = height - i - 1;\n        var targetCell = j + targetLine * numberOfChannelsByLine;\n        var temp = data[currentCell];\n        data[currentCell] = data[targetCell];\n        data[targetCell] = temp;\n      }\n    } // Create a 2D canvas to store the result\n\n\n    if (!Tools._ScreenshotCanvas) {\n      Tools._ScreenshotCanvas = document.createElement(\"canvas\");\n    }\n\n    Tools._ScreenshotCanvas.width = width;\n    Tools._ScreenshotCanvas.height = height;\n\n    var context = Tools._ScreenshotCanvas.getContext(\"2d\");\n\n    if (context) {\n      // Copy the pixels to a 2D canvas\n      var imageData = context.createImageData(width, height);\n      var castData = imageData.data;\n      castData.set(data);\n      context.putImageData(imageData, 0, 0);\n      Tools.EncodeScreenshotCanvasData(successCallback, mimeType, fileName);\n    }\n  };\n  /**\r\n   * Converts the canvas data to blob.\r\n   * This acts as a polyfill for browsers not supporting the to blob function.\r\n   * @param canvas Defines the canvas to extract the data from\r\n   * @param successCallback Defines the callback triggered once the data are available\r\n   * @param mimeType Defines the mime type of the result\r\n   */\n\n\n  Tools.ToBlob = function (canvas, successCallback, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    } // We need HTMLCanvasElement.toBlob for HD screenshots\n\n\n    if (!canvas.toBlob) {\n      //  low performance polyfill based on toDataURL (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob)\n      canvas.toBlob = function (callback, type, quality) {\n        var _this = this;\n\n        setTimeout(function () {\n          var binStr = atob(_this.toDataURL(type, quality).split(\",\")[1]),\n              len = binStr.length,\n              arr = new Uint8Array(len);\n\n          for (var i = 0; i < len; i++) {\n            arr[i] = binStr.charCodeAt(i);\n          }\n\n          callback(new Blob([arr]));\n        });\n      };\n    }\n\n    canvas.toBlob(function (blob) {\n      successCallback(blob);\n    }, mimeType);\n  };\n  /**\r\n   * Encodes the canvas data to base 64 or automatically download the result if filename is defined\r\n   * @param successCallback defines the callback triggered once the data are available\r\n   * @param mimeType defines the mime type of the result\r\n   * @param fileName defines he filename to download. If present, the result will automatically be downloaded\r\n   */\n\n\n  Tools.EncodeScreenshotCanvasData = function (successCallback, mimeType, fileName) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    if (successCallback) {\n      var base64Image = Tools._ScreenshotCanvas.toDataURL(mimeType);\n\n      successCallback(base64Image);\n    } else {\n      this.ToBlob(Tools._ScreenshotCanvas, function (blob) {\n        //Creating a link if the browser have the download attribute on the a tag, to automatically start download generated image.\n        if (\"download\" in document.createElement(\"a\")) {\n          if (!fileName) {\n            var date = new Date();\n            var stringDate = (date.getFullYear() + \"-\" + (date.getMonth() + 1)).slice(2) + \"-\" + date.getDate() + \"_\" + date.getHours() + \"-\" + (\"0\" + date.getMinutes()).slice(-2);\n            fileName = \"screenshot_\" + stringDate + \".png\";\n          }\n\n          Tools.Download(blob, fileName);\n        } else {\n          var url = URL.createObjectURL(blob);\n          var newWindow = window.open(\"\");\n\n          if (!newWindow) {\n            return;\n          }\n\n          var img = newWindow.document.createElement(\"img\");\n\n          img.onload = function () {\n            // no longer need to read the blob so it's revoked\n            URL.revokeObjectURL(url);\n          };\n\n          img.src = url;\n          newWindow.document.body.appendChild(img);\n        }\n      }, mimeType);\n    }\n  };\n  /**\r\n   * Downloads a blob in the browser\r\n   * @param blob defines the blob to download\r\n   * @param fileName defines the name of the downloaded file\r\n   */\n\n\n  Tools.Download = function (blob, fileName) {\n    if (navigator && navigator.msSaveBlob) {\n      navigator.msSaveBlob(blob, fileName);\n      return;\n    }\n\n    var url = window.URL.createObjectURL(blob);\n    var a = document.createElement(\"a\");\n    document.body.appendChild(a);\n    a.style.display = \"none\";\n    a.href = url;\n    a.download = fileName;\n    a.addEventListener(\"click\", function () {\n      if (a.parentElement) {\n        a.parentElement.removeChild(a);\n      }\n    });\n    a.click();\n    window.URL.revokeObjectURL(url);\n  };\n  /**\r\n   * Will return the right value of the noPreventDefault variable\r\n   * Needed to keep backwards compatibility to the old API.\r\n   *\r\n   * @param args arguments passed to the attachControl function\r\n   * @returns the correct value for noPreventDefault\r\n   */\n\n\n  Tools.BackCompatCameraNoPreventDefault = function (args) {\n    // is it used correctly?\n    if (typeof args[0] === \"boolean\") {\n      return args[0];\n    } else if (typeof args[1] === \"boolean\") {\n      return args[1];\n    }\n\n    return false;\n  };\n  /**\r\n   * Captures a screenshot of the current rendering\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine defines the rendering engine\r\n   * @param camera defines the source camera\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param successCallback defines the callback receives a single parameter which contains the\r\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n   * src parameter of an <img> to display it\r\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   */\n\n\n  Tools.CreateScreenshot = function (engine, camera, size, successCallback, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    throw _DevTools.WarnImport(\"ScreenshotTools\");\n  };\n  /**\r\n   * Captures a screenshot of the current rendering\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine defines the rendering engine\r\n   * @param camera defines the source camera\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n   * to the src parameter of an <img> to display it\r\n   */\n\n\n  Tools.CreateScreenshotAsync = function (engine, camera, size, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    throw _DevTools.WarnImport(\"ScreenshotTools\");\n  };\n  /**\r\n   * Generates an image screenshot from the specified camera.\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine The engine to use for rendering\r\n   * @param camera The camera to use for rendering\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param successCallback The callback receives a single parameter which contains the\r\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n   * src parameter of an <img> to display it\r\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @param samples Texture samples (default: 1)\r\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n   * @param fileName A name for for the downloaded file.\r\n   */\n\n\n  Tools.CreateScreenshotUsingRenderTarget = function (engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    if (samples === void 0) {\n      samples = 1;\n    }\n\n    if (antialiasing === void 0) {\n      antialiasing = false;\n    }\n\n    throw _DevTools.WarnImport(\"ScreenshotTools\");\n  };\n  /**\r\n   * Generates an image screenshot from the specified camera.\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine The engine to use for rendering\r\n   * @param camera The camera to use for rendering\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @param samples Texture samples (default: 1)\r\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n   * @param fileName A name for for the downloaded file.\r\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n   * to the src parameter of an <img> to display it\r\n   */\n\n\n  Tools.CreateScreenshotUsingRenderTargetAsync = function (engine, camera, size, mimeType, samples, antialiasing, fileName) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    if (samples === void 0) {\n      samples = 1;\n    }\n\n    if (antialiasing === void 0) {\n      antialiasing = false;\n    }\n\n    throw _DevTools.WarnImport(\"ScreenshotTools\");\n  };\n  /**\r\n   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n   * Be aware Math.random() could cause collisions, but:\r\n   * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n   * @returns a pseudo random id\r\n   */\n\n\n  Tools.RandomId = function () {\n    return GUID.RandomId();\n  };\n  /**\r\n   * Test if the given uri is a base64 string\r\n   * @param uri The uri to test\r\n   * @return True if the uri is a base64 string or false otherwise\r\n   */\n\n\n  Tools.IsBase64 = function (uri) {\n    return uri.length < 5 ? false : uri.substr(0, 5) === \"data:\";\n  };\n  /**\r\n   * Decode the given base64 uri.\r\n   * @param uri The uri to decode\r\n   * @return The decoded base64 data.\r\n   */\n\n\n  Tools.DecodeBase64 = function (uri) {\n    var decodedString = atob(uri.split(\",\")[1]);\n    var bufferLength = decodedString.length;\n    var bufferView = new Uint8Array(new ArrayBuffer(bufferLength));\n\n    for (var i = 0; i < bufferLength; i++) {\n      bufferView[i] = decodedString.charCodeAt(i);\n    }\n\n    return bufferView.buffer;\n  };\n  /**\r\n   * Gets the absolute url.\r\n   * @param url the input url\r\n   * @return the absolute url\r\n   */\n\n\n  Tools.GetAbsoluteUrl = function (url) {\n    var a = document.createElement(\"a\");\n    a.href = url;\n    return a.href;\n  };\n\n  Object.defineProperty(Tools, \"errorsCount\", {\n    /**\r\n     * Gets a value indicating the number of loading errors\r\n     * @ignorenaming\r\n     */\n    get: function get() {\n      return Logger.errorsCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Log a message to the console\r\n   * @param message defines the message to log\r\n   */\n\n  Tools.Log = function (message) {\n    Logger.Log(message);\n  };\n  /**\r\n   * Write a warning message to the console\r\n   * @param message defines the message to log\r\n   */\n\n\n  Tools.Warn = function (message) {\n    Logger.Warn(message);\n  };\n  /**\r\n   * Write an error message to the console\r\n   * @param message defines the message to log\r\n   */\n\n\n  Tools.Error = function (message) {\n    Logger.Error(message);\n  };\n\n  Object.defineProperty(Tools, \"LogCache\", {\n    /**\r\n     * Gets current log cache (list of logs)\r\n     */\n    get: function get() {\n      return Logger.LogCache;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Clears the log cache\r\n   */\n\n  Tools.ClearLogCache = function () {\n    Logger.ClearLogCache();\n  };\n\n  Object.defineProperty(Tools, \"LogLevels\", {\n    /**\r\n     * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)\r\n     */\n    set: function set(level) {\n      Logger.LogLevels = level;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Tools, \"PerformanceLogLevel\", {\n    /**\r\n     * Sets the current performance log level\r\n     */\n    set: function set(level) {\n      if ((level & Tools.PerformanceUserMarkLogLevel) === Tools.PerformanceUserMarkLogLevel) {\n        Tools.StartPerformanceCounter = Tools._StartUserMark;\n        Tools.EndPerformanceCounter = Tools._EndUserMark;\n        return;\n      }\n\n      if ((level & Tools.PerformanceConsoleLogLevel) === Tools.PerformanceConsoleLogLevel) {\n        Tools.StartPerformanceCounter = Tools._StartPerformanceConsole;\n        Tools.EndPerformanceCounter = Tools._EndPerformanceConsole;\n        return;\n      }\n\n      Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\n      Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Tools._StartPerformanceCounterDisabled = function (counterName, condition) {};\n\n  Tools._EndPerformanceCounterDisabled = function (counterName, condition) {};\n\n  Tools._StartUserMark = function (counterName, condition) {\n    if (condition === void 0) {\n      condition = true;\n    }\n\n    if (!Tools._performance) {\n      if (!DomManagement.IsWindowObjectExist()) {\n        return;\n      }\n\n      Tools._performance = window.performance;\n    }\n\n    if (!condition || !Tools._performance.mark) {\n      return;\n    }\n\n    Tools._performance.mark(counterName + \"-Begin\");\n  };\n\n  Tools._EndUserMark = function (counterName, condition) {\n    if (condition === void 0) {\n      condition = true;\n    }\n\n    if (!condition || !Tools._performance.mark) {\n      return;\n    }\n\n    Tools._performance.mark(counterName + \"-End\");\n\n    Tools._performance.measure(counterName, counterName + \"-Begin\", counterName + \"-End\");\n  };\n\n  Tools._StartPerformanceConsole = function (counterName, condition) {\n    if (condition === void 0) {\n      condition = true;\n    }\n\n    if (!condition) {\n      return;\n    }\n\n    Tools._StartUserMark(counterName, condition);\n\n    if (console.time) {\n      console.time(counterName);\n    }\n  };\n\n  Tools._EndPerformanceConsole = function (counterName, condition) {\n    if (condition === void 0) {\n      condition = true;\n    }\n\n    if (!condition) {\n      return;\n    }\n\n    Tools._EndUserMark(counterName, condition);\n\n    console.timeEnd(counterName);\n  };\n\n  Object.defineProperty(Tools, \"Now\", {\n    /**\r\n     * Gets either window.performance.now() if supported or Date.now() else\r\n     */\n    get: function get() {\n      return PrecisionDate.Now;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * This method will return the name of the class used to create the instance of the given object.\r\n   * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.\r\n   * @param object the object to get the class name from\r\n   * @param isType defines if the object is actually a type\r\n   * @returns the name of the class, will be \"object\" for a custom data type not using the @className decorator\r\n   */\n\n  Tools.GetClassName = function (object, isType) {\n    if (isType === void 0) {\n      isType = false;\n    }\n\n    var name = null;\n\n    if (!isType && object.getClassName) {\n      name = object.getClassName();\n    } else {\n      if (object instanceof Object) {\n        var classObj = isType ? object : Object.getPrototypeOf(object);\n        name = classObj.constructor[\"__bjsclassName__\"];\n      }\n\n      if (!name) {\n        name = typeof object;\n      }\n    }\n\n    return name;\n  };\n  /**\r\n   * Gets the first element of an array satisfying a given predicate\r\n   * @param array defines the array to browse\r\n   * @param predicate defines the predicate to use\r\n   * @returns null if not found or the element\r\n   */\n\n\n  Tools.First = function (array, predicate) {\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n      var el = array_1[_i];\n\n      if (predicate(el)) {\n        return el;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * This method will return the name of the full name of the class, including its owning module (if any).\r\n   * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).\r\n   * @param object the object to get the class name from\r\n   * @param isType defines if the object is actually a type\r\n   * @return a string that can have two forms: \"moduleName.className\" if module was specified when the class' Name was registered or \"className\" if there was not module specified.\r\n   * @ignorenaming\r\n   */\n\n\n  Tools.getFullClassName = function (object, isType) {\n    if (isType === void 0) {\n      isType = false;\n    }\n\n    var className = null;\n    var moduleName = null;\n\n    if (!isType && object.getClassName) {\n      className = object.getClassName();\n    } else {\n      if (object instanceof Object) {\n        var classObj = isType ? object : Object.getPrototypeOf(object);\n        className = classObj.constructor[\"__bjsclassName__\"];\n        moduleName = classObj.constructor[\"__bjsmoduleName__\"];\n      }\n\n      if (!className) {\n        className = typeof object;\n      }\n    }\n\n    if (!className) {\n      return null;\n    }\n\n    return (moduleName != null ? moduleName + \".\" : \"\") + className;\n  };\n  /**\r\n   * Returns a promise that resolves after the given amount of time.\r\n   * @param delay Number of milliseconds to delay\r\n   * @returns Promise that resolves after the given amount of time\r\n   */\n\n\n  Tools.DelayAsync = function (delay) {\n    return new Promise(function (resolve) {\n      setTimeout(function () {\n        resolve();\n      }, delay);\n    });\n  };\n  /**\r\n   * Utility function to detect if the current user agent is Safari\r\n   * @returns whether or not the current user agent is safari\r\n   */\n\n\n  Tools.IsSafari = function () {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  };\n  /**\r\n   * Enable/Disable Custom HTTP Request Headers globally.\r\n   * default = false\r\n   * @see CustomRequestHeaders\r\n   */\n\n\n  Tools.UseCustomRequestHeaders = false;\n  /**\r\n   * Custom HTTP Request Headers to be sent with XMLHttpRequests\r\n   * i.e. when loading files, where the server/service expects an Authorization header\r\n   */\n\n  Tools.CustomRequestHeaders = WebRequest.CustomRequestHeaders;\n  Tools._tmpFloatArray = new Float32Array(1);\n  /**\r\n   * Extracts text content from a DOM element hierarchy\r\n   * Back Compat only, please use DomManagement.GetDOMTextContent instead.\r\n   */\n\n  Tools.GetDOMTextContent = DomManagement.GetDOMTextContent; // Logs\n\n  /**\r\n   * No log\r\n   */\n\n  Tools.NoneLogLevel = Logger.NoneLogLevel;\n  /**\r\n   * Only message logs\r\n   */\n\n  Tools.MessageLogLevel = Logger.MessageLogLevel;\n  /**\r\n   * Only warning logs\r\n   */\n\n  Tools.WarningLogLevel = Logger.WarningLogLevel;\n  /**\r\n   * Only error logs\r\n   */\n\n  Tools.ErrorLogLevel = Logger.ErrorLogLevel;\n  /**\r\n   * All logs\r\n   */\n\n  Tools.AllLogLevel = Logger.AllLogLevel;\n  /**\r\n   * Checks if the window object exists\r\n   * Back Compat only, please use DomManagement.IsWindowObjectExist instead.\r\n   */\n\n  Tools.IsWindowObjectExist = DomManagement.IsWindowObjectExist; // Performances\n\n  /**\r\n   * No performance log\r\n   */\n\n  Tools.PerformanceNoneLogLevel = 0;\n  /**\r\n   * Use user marks to log performance\r\n   */\n\n  Tools.PerformanceUserMarkLogLevel = 1;\n  /**\r\n   * Log performance to the console\r\n   */\n\n  Tools.PerformanceConsoleLogLevel = 2;\n  /**\r\n   * Starts a performance counter\r\n   */\n\n  Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\n  /**\r\n   * Ends a specific performance coutner\r\n   */\n\n  Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\n  return Tools;\n}();\n\nexport { Tools };\n/**\r\n * Use this className as a decorator on a given class definition to add it a name and optionally its module.\r\n * You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.\r\n * This method is the only way to get it done in all cases, even if the .js file declaring the class is minified\r\n * @param name The name of the class, case should be preserved\r\n * @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.\r\n */\n\nexport function className(name, module) {\n  return function (target) {\n    target[\"__bjsclassName__\"] = name;\n    target[\"__bjsmoduleName__\"] = module != null ? module : null;\n  };\n}\n/**\r\n * An implementation of a loop for asynchronous functions.\r\n */\n\nvar AsyncLoop =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor.\r\n   * @param iterations the number of iterations.\r\n   * @param func the function to run each iteration\r\n   * @param successCallback the callback that will be called upon succesful execution\r\n   * @param offset starting offset.\r\n   */\n  function AsyncLoop(\n  /**\r\n   * Defines the number of iterations for the loop\r\n   */\n  iterations, func, successCallback, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    this.iterations = iterations;\n    this.index = offset - 1;\n    this._done = false;\n    this._fn = func;\n    this._successCallback = successCallback;\n  }\n  /**\r\n   * Execute the next iteration. Must be called after the last iteration was finished.\r\n   */\n\n\n  AsyncLoop.prototype.executeNext = function () {\n    if (!this._done) {\n      if (this.index + 1 < this.iterations) {\n        ++this.index;\n\n        this._fn(this);\n      } else {\n        this.breakLoop();\n      }\n    }\n  };\n  /**\r\n   * Break the loop and run the success callback.\r\n   */\n\n\n  AsyncLoop.prototype.breakLoop = function () {\n    this._done = true;\n\n    this._successCallback();\n  };\n  /**\r\n   * Create and run an async loop.\r\n   * @param iterations the number of iterations.\r\n   * @param fn the function to run each iteration\r\n   * @param successCallback the callback that will be called upon succesful execution\r\n   * @param offset starting offset.\r\n   * @returns the created async loop object\r\n   */\n\n\n  AsyncLoop.Run = function (iterations, fn, successCallback, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var loop = new AsyncLoop(iterations, fn, successCallback, offset);\n    loop.executeNext();\n    return loop;\n  };\n  /**\r\n   * A for-loop that will run a given number of iterations synchronous and the rest async.\r\n   * @param iterations total number of iterations\r\n   * @param syncedIterations number of synchronous iterations in each async iteration.\r\n   * @param fn the function to call each iteration.\r\n   * @param callback a success call back that will be called when iterating stops.\r\n   * @param breakFunction a break condition (optional)\r\n   * @param timeout timeout settings for the setTimeout function. default - 0.\r\n   * @returns the created async loop object\r\n   */\n\n\n  AsyncLoop.SyncAsyncForLoop = function (iterations, syncedIterations, fn, callback, breakFunction, timeout) {\n    if (timeout === void 0) {\n      timeout = 0;\n    }\n\n    return AsyncLoop.Run(Math.ceil(iterations / syncedIterations), function (loop) {\n      if (breakFunction && breakFunction()) {\n        loop.breakLoop();\n      } else {\n        setTimeout(function () {\n          for (var i = 0; i < syncedIterations; ++i) {\n            var iteration = loop.index * syncedIterations + i;\n\n            if (iteration >= iterations) {\n              break;\n            }\n\n            fn(iteration);\n\n            if (breakFunction && breakFunction()) {\n              loop.breakLoop();\n              break;\n            }\n          }\n\n          loop.executeNext();\n        }, timeout);\n      }\n    }, callback);\n  };\n\n  return AsyncLoop;\n}();\n\nexport { AsyncLoop }; // Will only be define if Tools is imported freeing up some space when only engine is required\n\nEngineStore.FallbackTexture = \"data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z\"; // Register promise fallback for IE\n\nPromisePolyfill.Apply();","map":null,"metadata":{},"sourceType":"module"}