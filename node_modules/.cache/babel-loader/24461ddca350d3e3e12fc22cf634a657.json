{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3 } from \"../../Maths/math.vector\";\nimport { Scalar } from \"../../Maths/math.scalar\";\nimport { DeepCopier } from \"../../Misc/deepCopier\";\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\r\n */\n\nvar CylinderParticleEmitter =\n/** @class */\nfunction () {\n  /**\r\n  * Creates a new instance CylinderParticleEmitter\r\n  * @param radius the radius of the emission cylinder (1 by default)\r\n  * @param height the height of the emission cylinder (1 by default)\r\n  * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n  * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n  */\n  function CylinderParticleEmitter(\n  /**\r\n   * The radius of the emission cylinder.\r\n   */\n  radius,\n  /**\r\n   * The height of the emission cylinder.\r\n   */\n  height,\n  /**\r\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n   */\n  radiusRange,\n  /**\r\n   * How much to randomize the particle direction [0-1].\r\n   */\n  directionRandomizer) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (height === void 0) {\n      height = 1;\n    }\n\n    if (radiusRange === void 0) {\n      radiusRange = 1;\n    }\n\n    if (directionRandomizer === void 0) {\n      directionRandomizer = 0;\n    }\n\n    this.radius = radius;\n    this.height = height;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n  }\n  /**\r\n   * Called by the particle System when the direction is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param directionToUpdate is the direction vector to update with the result\r\n   * @param particle is the particle we are computed the direction for\r\n   * @param isLocal defines if the direction should be set in local space\r\n   */\n\n\n  CylinderParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n    var randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\n    var angle = Math.atan2(direction.x, direction.z);\n    angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\n    direction.y = randY; // set direction y to rand y to mirror normal of cylinder surface\n\n    direction.x = Math.sin(angle);\n    direction.z = Math.cos(angle);\n    direction.normalize();\n\n    if (isLocal) {\n      directionToUpdate.copyFrom(direction);\n      return;\n    }\n\n    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n  };\n  /**\r\n   * Called by the particle System when the position is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param positionToUpdate is the position vector to update with the result\r\n   * @param particle is the particle we are computed the position for\r\n   * @param isLocal defines if the position should be set in local space\r\n   */\n\n\n  CylinderParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\n    var angle = Scalar.RandomRange(0, 2 * Math.PI); // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\n\n    var radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\n    var positionRadius = Math.sqrt(radiusDistribution) * this.radius;\n    var xPos = positionRadius * Math.cos(angle);\n    var zPos = positionRadius * Math.sin(angle);\n\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(xPos, yPos, zPos);\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\n  };\n  /**\r\n   * Clones the current emitter and returns a copy of it\r\n   * @returns the new emitter\r\n   */\n\n\n  CylinderParticleEmitter.prototype.clone = function () {\n    var newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\r\n   * Called by the GPUParticleSystem to setup the update shader\r\n   * @param effect defines the update shader\r\n   */\n\n\n  CylinderParticleEmitter.prototype.applyToShader = function (effect) {\n    effect.setFloat(\"radius\", this.radius);\n    effect.setFloat(\"height\", this.height);\n    effect.setFloat(\"radiusRange\", this.radiusRange);\n    effect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  };\n  /**\r\n   * Returns a string to use to update the GPU particles update shader\r\n   * @returns a string containng the defines string\r\n   */\n\n\n  CylinderParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define CYLINDEREMITTER\";\n  };\n  /**\r\n   * Returns the string \"CylinderParticleEmitter\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  CylinderParticleEmitter.prototype.getClassName = function () {\n    return \"CylinderParticleEmitter\";\n  };\n  /**\r\n   * Serializes the particle system to a JSON object.\r\n   * @returns the JSON object\r\n   */\n\n\n  CylinderParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.height = this.height;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  };\n  /**\r\n   * Parse properties from a JSON object\r\n   * @param serializationObject defines the JSON object\r\n   */\n\n\n  CylinderParticleEmitter.prototype.parse = function (serializationObject) {\n    this.radius = serializationObject.radius;\n    this.height = serializationObject.height;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  };\n\n  return CylinderParticleEmitter;\n}();\n\nexport { CylinderParticleEmitter };\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles randomly between two vectors.\r\n */\n\nvar CylinderDirectedParticleEmitter =\n/** @class */\nfunction (_super) {\n  __extends(CylinderDirectedParticleEmitter, _super);\n  /**\r\n   * Creates a new instance CylinderDirectedParticleEmitter\r\n   * @param radius the radius of the emission cylinder (1 by default)\r\n   * @param height the height of the emission cylinder (1 by default)\r\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n   * @param direction1 the min limit of the emission direction (up vector by default)\r\n   * @param direction2 the max limit of the emission direction (up vector by default)\r\n   */\n\n\n  function CylinderDirectedParticleEmitter(radius, height, radiusRange,\n  /**\r\n   * The min limit of the emission direction.\r\n   */\n  direction1,\n  /**\r\n   * The max limit of the emission direction.\r\n   */\n  direction2) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (height === void 0) {\n      height = 1;\n    }\n\n    if (radiusRange === void 0) {\n      radiusRange = 1;\n    }\n\n    if (direction1 === void 0) {\n      direction1 = new Vector3(0, 1, 0);\n    }\n\n    if (direction2 === void 0) {\n      direction2 = new Vector3(0, 1, 0);\n    }\n\n    var _this = _super.call(this, radius, height, radiusRange) || this;\n\n    _this.direction1 = direction1;\n    _this.direction2 = direction2;\n    return _this;\n  }\n  /**\r\n   * Called by the particle System when the direction is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param directionToUpdate is the direction vector to update with the result\r\n   * @param particle is the particle we are computed the direction for\r\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {\n    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  };\n  /**\r\n   * Clones the current emitter and returns a copy of it\r\n   * @returns the new emitter\r\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.clone = function () {\n    var newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\r\n   * Called by the GPUParticleSystem to setup the update shader\r\n   * @param effect defines the update shader\r\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.applyToShader = function (effect) {\n    effect.setFloat(\"radius\", this.radius);\n    effect.setFloat(\"height\", this.height);\n    effect.setFloat(\"radiusRange\", this.radiusRange);\n    effect.setVector3(\"direction1\", this.direction1);\n    effect.setVector3(\"direction2\", this.direction2);\n  };\n  /**\r\n   * Returns a string to use to update the GPU particles update shader\r\n   * @returns a string containng the defines string\r\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\n  };\n  /**\r\n   * Returns the string \"CylinderDirectedParticleEmitter\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.getClassName = function () {\n    return \"CylinderDirectedParticleEmitter\";\n  };\n  /**\r\n   * Serializes the particle system to a JSON object.\r\n   * @returns the JSON object\r\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  };\n  /**\r\n   * Parse properties from a JSON object\r\n   * @param serializationObject defines the JSON object\r\n   */\n\n\n  CylinderDirectedParticleEmitter.prototype.parse = function (serializationObject) {\n    _super.prototype.parse.call(this, serializationObject);\n\n    this.direction1.copyFrom(serializationObject.direction1);\n    this.direction2.copyFrom(serializationObject.direction2);\n  };\n\n  return CylinderDirectedParticleEmitter;\n}(CylinderParticleEmitter);\n\nexport { CylinderDirectedParticleEmitter };","map":null,"metadata":{},"sourceType":"module"}