{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator } from \"tslib\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { SphereBuilder } from \"../../Meshes/Builders/sphereBuilder\";\nimport { Quaternion } from \"../../Maths/math.vector\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\nimport { WebXRFeaturesManager } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\nimport { Color3 } from \"../../Maths/math.color\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\nimport { Material } from \"../../Materials/material\";\nimport { Engine } from \"../../Engines/engine\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Axis } from \"../../Maths/math.axis\";\n/**\r\n * Representing a single hand (with its corresponding native XRHand object)\r\n */\n\nvar WebXRHand =\n/** @class */\nfunction () {\n  /**\r\n   * Construct a new hand object\r\n   * @param xrController the controller to which the hand correlates\r\n   * @param trackedMeshes the meshes to be used to track the hand joints\r\n   * @param _handMesh an optional hand mesh. if not provided, ours will be used\r\n   * @param _rigMapping an optional rig mapping for the hand mesh. if not provided, ours will be used\r\n   * @param disableDefaultHandMesh should the default mesh creation be disabled\r\n   */\n  function WebXRHand(\n  /** the controller to which the hand correlates */\n  xrController,\n  /** the meshes to be used to track the hand joints */\n  trackedMeshes, _handMesh, _rigMapping, disableDefaultHandMesh) {\n    this.xrController = xrController;\n    this.trackedMeshes = trackedMeshes;\n    this._handMesh = _handMesh;\n    this._rigMapping = _rigMapping;\n    this._defaultHandMesh = false;\n    this._transformNodeMapping = [];\n    this.handPartsDefinition = this.generateHandPartsDefinition(xrController.inputSource.hand);\n    this._scene = trackedMeshes[0].getScene();\n\n    if (this._handMesh && this._rigMapping) {\n      this._defaultHandMesh = false;\n    } else {\n      if (!disableDefaultHandMesh) {\n        this._generateDefaultHandMesh();\n      }\n    } // hide the motion controller, if available/loaded\n\n\n    if (this.xrController.motionController) {\n      if (this.xrController.motionController.rootMesh) {\n        this.xrController.motionController.rootMesh.setEnabled(false);\n      } else {\n        this.xrController.motionController.onModelLoadedObservable.add(function (controller) {\n          if (controller.rootMesh) {\n            controller.rootMesh.setEnabled(false);\n          }\n        });\n      }\n    }\n\n    this.xrController.onMotionControllerInitObservable.add(function (motionController) {\n      motionController.onModelLoadedObservable.add(function (controller) {\n        if (controller.rootMesh) {\n          controller.rootMesh.setEnabled(false);\n        }\n      });\n\n      if (motionController.rootMesh) {\n        motionController.rootMesh.setEnabled(false);\n      }\n    });\n  }\n  /**\r\n   * Populate the HandPartsDefinition object.\r\n   * This is called as a side effect since certain browsers don't have XRHand defined.\r\n   */\n\n\n  WebXRHand.prototype.generateHandPartsDefinition = function (hand) {\n    var _a;\n\n    return _a = {}, _a[\"wrist\"\n    /* WRIST */\n    ] = [hand.WRIST], _a[\"thumb\"\n    /* THUMB */\n    ] = [hand.THUMB_METACARPAL, hand.THUMB_PHALANX_PROXIMAL, hand.THUMB_PHALANX_DISTAL, hand.THUMB_PHALANX_TIP], _a[\"index\"\n    /* INDEX */\n    ] = [hand.INDEX_METACARPAL, hand.INDEX_PHALANX_PROXIMAL, hand.INDEX_PHALANX_INTERMEDIATE, hand.INDEX_PHALANX_DISTAL, hand.INDEX_PHALANX_TIP], _a[\"middle\"\n    /* MIDDLE */\n    ] = [hand.MIDDLE_METACARPAL, hand.MIDDLE_PHALANX_PROXIMAL, hand.MIDDLE_PHALANX_INTERMEDIATE, hand.MIDDLE_PHALANX_DISTAL, hand.MIDDLE_PHALANX_TIP], _a[\"ring\"\n    /* RING */\n    ] = [hand.RING_METACARPAL, hand.RING_PHALANX_PROXIMAL, hand.RING_PHALANX_INTERMEDIATE, hand.RING_PHALANX_DISTAL, hand.RING_PHALANX_TIP], _a[\"little\"\n    /* LITTLE */\n    ] = [hand.LITTLE_METACARPAL, hand.LITTLE_PHALANX_PROXIMAL, hand.LITTLE_PHALANX_INTERMEDIATE, hand.LITTLE_PHALANX_DISTAL, hand.LITTLE_PHALANX_TIP], _a;\n  };\n  /**\r\n   * Update this hand from the latest xr frame\r\n   * @param xrFrame xrFrame to update from\r\n   * @param referenceSpace The current viewer reference space\r\n   * @param scaleFactor optional scale factor for the meshes\r\n   */\n\n\n  WebXRHand.prototype.updateFromXRFrame = function (xrFrame, referenceSpace, scaleFactor) {\n    var _this = this;\n\n    if (scaleFactor === void 0) {\n      scaleFactor = 2;\n    }\n\n    var hand = this.xrController.inputSource.hand;\n\n    if (!hand) {\n      return;\n    }\n\n    this.trackedMeshes.forEach(function (mesh, idx) {\n      var xrJoint = hand[idx];\n\n      if (xrJoint) {\n        var pose = xrFrame.getJointPose(xrJoint, referenceSpace);\n\n        if (!pose || !pose.transform) {\n          return;\n        } // get the transformation. can be done with matrix decomposition as well\n\n\n        var pos = pose.transform.position;\n        var orientation_1 = pose.transform.orientation;\n        mesh.position.set(pos.x, pos.y, pos.z);\n        mesh.rotationQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w); // left handed system conversion\n        // get the radius of the joint. In general it is static, but just in case it does change we update it on each frame.\n\n        var radius = (pose.radius || 0.008) * scaleFactor;\n        mesh.scaling.set(radius, radius, radius); // now check for the hand mesh\n\n        if (_this._handMesh && _this._rigMapping) {\n          if (_this._rigMapping[idx]) {\n            _this._transformNodeMapping[idx] = _this._transformNodeMapping[idx] || _this._scene.getTransformNodeByName(_this._rigMapping[idx]);\n\n            if (_this._transformNodeMapping[idx]) {\n              _this._transformNodeMapping[idx].position.copyFrom(mesh.position);\n\n              _this._transformNodeMapping[idx].rotationQuaternion.copyFrom(mesh.rotationQuaternion); // no scaling at the moment\n              // this._transformNodeMapping[idx].scaling.copyFrom(mesh.scaling).scaleInPlace(20);\n\n\n              mesh.isVisible = false;\n            }\n          }\n        }\n\n        if (!mesh.getScene().useRightHandedSystem) {\n          mesh.position.z *= -1;\n          mesh.rotationQuaternion.z *= -1;\n          mesh.rotationQuaternion.w *= -1;\n        }\n      }\n    });\n  };\n  /**\r\n   * Get meshes of part of the hand\r\n   * @param part the part of hand to get\r\n   * @returns An array of meshes that correlate to the hand part requested\r\n   */\n\n\n  WebXRHand.prototype.getHandPartMeshes = function (part) {\n    var _this = this;\n\n    return this.handPartsDefinition[part].map(function (idx) {\n      return _this.trackedMeshes[idx];\n    });\n  };\n  /**\r\n   * Dispose this Hand object\r\n   */\n\n\n  WebXRHand.prototype.dispose = function () {\n    this.trackedMeshes.forEach(function (mesh) {\n      return mesh.dispose();\n    }); // dispose the hand mesh, if it is the default one\n\n    if (this._defaultHandMesh && this._handMesh) {\n      this._handMesh.dispose();\n    }\n  };\n\n  WebXRHand.prototype._generateDefaultHandMesh = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handedness_1, filename, loaded, handColors, handShader, handNodes, tm, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            handedness_1 = this.xrController.inputSource.handedness === \"right\" ? \"right\" : \"left\";\n            filename = (handedness_1 === \"right\" ? \"r\" : \"l\") + \"_hand_\" + (this._scene.useRightHandedSystem ? \"r\" : \"l\") + \"hs.glb\";\n            return [4\n            /*yield*/\n            , SceneLoader.ImportMeshAsync(\"\", \"https://assets.babylonjs.com/meshes/HandMeshes/\", filename, this._scene)];\n\n          case 1:\n            loaded = _a.sent();\n            handColors = {\n              base: Color3.FromInts(116, 63, 203),\n              fresnel: Color3.FromInts(149, 102, 229),\n              fingerColor: Color3.FromInts(177, 130, 255),\n              tipFresnel: Color3.FromInts(220, 200, 255)\n            };\n            handShader = new NodeMaterial(\"leftHandShader\", this._scene, {\n              emitComments: false\n            });\n            return [4\n            /*yield*/\n            , handShader.loadAsync(\"https://patrickryanms.github.io/BabylonJStextures/Demos/xrHandMesh/handsShader.json\")];\n\n          case 2:\n            _a.sent(); // build node materials\n\n\n            handShader.build(false); // depth prepass and alpha mode\n\n            handShader.needDepthPrePass = true;\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\n            handShader.alphaMode = Engine.ALPHA_COMBINE;\n            handNodes = {\n              base: handShader.getBlockByName(\"baseColor\"),\n              fresnel: handShader.getBlockByName(\"fresnelColor\"),\n              fingerColor: handShader.getBlockByName(\"fingerColor\"),\n              tipFresnel: handShader.getBlockByName(\"tipFresnelColor\")\n            };\n            handNodes.base.value = handColors.base;\n            handNodes.fresnel.value = handColors.fresnel;\n            handNodes.fingerColor.value = handColors.fingerColor;\n            handNodes.tipFresnel.value = handColors.tipFresnel;\n            loaded.meshes[1].material = handShader;\n            this._defaultHandMesh = true;\n            this._handMesh = loaded.meshes[0];\n            this._rigMapping = [\"wrist_\", \"thumb_metacarpal_\", \"thumb_proxPhalanx_\", \"thumb_distPhalanx_\", \"thumb_tip_\", \"index_metacarpal_\", \"index_proxPhalanx_\", \"index_intPhalanx_\", \"index_distPhalanx_\", \"index_tip_\", \"middle_metacarpal_\", \"middle_proxPhalanx_\", \"middle_intPhalanx_\", \"middle_distPhalanx_\", \"middle_tip_\", \"ring_metacarpal_\", \"ring_proxPhalanx_\", \"ring_intPhalanx_\", \"ring_distPhalanx_\", \"ring_tip_\", \"little_metacarpal_\", \"little_proxPhalanx_\", \"little_intPhalanx_\", \"little_distPhalanx_\", \"little_tip_\"].map(function (joint) {\n              return \"\" + joint + (handedness_1 === \"right\" ? \"R\" : \"L\");\n            });\n            tm = this._scene.getTransformNodeByName(this._rigMapping[0]);\n\n            if (!tm) {\n              throw new Error(\"could not find the wrist node\");\n            } else {\n              tm.parent && tm.parent.rotate(Axis.Y, Math.PI);\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            Tools.Error(\"error loading hand mesh\");\n            console.log(e_1);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return WebXRHand;\n}();\n\nexport { WebXRHand };\n/**\r\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\r\n */\n\nvar WebXRHandTracking =\n/** @class */\nfunction (_super) {\n  __extends(WebXRHandTracking, _super);\n  /**\r\n   * Creates a new instance of the hit test feature\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param options options to use when constructing this feature\r\n   */\n\n\n  function WebXRHandTracking(_xrSessionManager,\n  /**\r\n   * options to use when constructing this feature\r\n   */\n  options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options;\n    /**\r\n     * This observable will notify registered observers when a new hand object was added and initialized\r\n     */\n\n    _this.onHandAddedObservable = new Observable();\n    /**\r\n     * This observable will notify its observers right before the hand object is disposed\r\n     */\n\n    _this.onHandRemovedObservable = new Observable();\n    _this._hands = {};\n\n    _this._attachHand = function (xrController) {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n      if (!xrController.inputSource.hand || _this._hands[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      var hand = xrController.inputSource.hand;\n      var trackedMeshes = [];\n      var originalMesh = ((_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || SphereBuilder.CreateSphere(\"jointParent\", {\n        diameter: 1\n      });\n      originalMesh.isVisible = !!((_b = _this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);\n\n      for (var i = 0; i < hand.length; ++i) {\n        var newInstance = originalMesh.createInstance(xrController.uniqueId + \"-handJoint-\" + i);\n\n        if ((_c = _this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {\n          var returnedMesh = _this.options.jointMeshes.onHandJointMeshGenerated(newInstance, i, xrController.uniqueId);\n\n          if (returnedMesh) {\n            if (returnedMesh !== newInstance) {\n              newInstance.dispose();\n              newInstance = returnedMesh;\n            }\n          }\n        }\n\n        newInstance.isPickable = false;\n\n        if ((_d = _this.options.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {\n          var props = _this.options.jointMeshes.physicsProps || {};\n          var type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\n          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, __assign({\n            mass: 0\n          }, props));\n        }\n\n        newInstance.rotationQuaternion = new Quaternion();\n\n        if ((_e = _this.options.jointMeshes) === null || _e === void 0 ? void 0 : _e.invisible) {\n          newInstance.isVisible = false;\n        }\n\n        trackedMeshes.push(newInstance);\n      }\n\n      var handedness = xrController.inputSource.handedness === \"right\" ? \"right\" : \"left\";\n      var handMesh = ((_f = _this.options.jointMeshes) === null || _f === void 0 ? void 0 : _f.handMeshes) && ((_g = _this.options.jointMeshes) === null || _g === void 0 ? void 0 : _g.handMeshes[handedness]);\n      var rigMapping = ((_h = _this.options.jointMeshes) === null || _h === void 0 ? void 0 : _h.rigMapping) && ((_j = _this.options.jointMeshes) === null || _j === void 0 ? void 0 : _j.rigMapping[handedness]);\n      var webxrHand = new WebXRHand(xrController, trackedMeshes, handMesh, rigMapping, (_k = _this.options.jointMeshes) === null || _k === void 0 ? void 0 : _k.disableDefaultHandMesh); // get two new meshes\n\n      _this._hands[xrController.uniqueId] = {\n        handObject: webxrHand,\n        id: WebXRHandTracking._idCounter++\n      };\n\n      _this.onHandAddedObservable.notifyObservers(webxrHand);\n    };\n\n    _this.xrNativeFeatureName = \"hand-tracking\";\n    return _this;\n  }\n  /**\r\n   * Check if the needed objects are defined.\r\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n   */\n\n\n  WebXRHandTracking.prototype.isCompatible = function () {\n    return typeof XRHand !== \"undefined\";\n  };\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHandTracking.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this.options.xrInput.controllers.forEach(this._attachHand);\n\n    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\n\n    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachHand(controller.uniqueId);\n    });\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHandTracking.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._hands).forEach(function (controllerId) {\n      _this._detachHand(controllerId);\n    });\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRHandTracking.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onHandAddedObservable.clear();\n  };\n  /**\r\n   * Get the hand object according to the controller id\r\n   * @param controllerId the controller id to which we want to get the hand\r\n   * @returns null if not found or the WebXRHand object if found\r\n   */\n\n\n  WebXRHandTracking.prototype.getHandByControllerId = function (controllerId) {\n    var _a;\n\n    return ((_a = this._hands[controllerId]) === null || _a === void 0 ? void 0 : _a.handObject) || null;\n  };\n  /**\r\n   * Get a hand object according to the requested handedness\r\n   * @param handedness the handedness to request\r\n   * @returns null if not found or the WebXRHand object if found\r\n   */\n\n\n  WebXRHandTracking.prototype.getHandByHandedness = function (handedness) {\n    var _this = this;\n\n    var handednesses = Object.keys(this._hands).map(function (key) {\n      return _this._hands[key].handObject.xrController.inputSource.handedness;\n    });\n    var found = handednesses.indexOf(handedness);\n\n    if (found !== -1) {\n      return this._hands[found].handObject;\n    }\n\n    return null;\n  };\n\n  WebXRHandTracking.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this; // iterate over the hands object\n\n\n    Object.keys(this._hands).forEach(function (id) {\n      var _a;\n\n      _this._hands[id].handObject.updateFromXRFrame(_xrFrame, _this._xrSessionManager.referenceSpace, (_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.scaleFactor);\n    });\n  };\n\n  WebXRHandTracking.prototype._detachHand = function (controllerId) {\n    if (this._hands[controllerId]) {\n      this.onHandRemovedObservable.notifyObservers(this._hands[controllerId].handObject);\n\n      this._hands[controllerId].handObject.dispose();\n    }\n  };\n\n  WebXRHandTracking._idCounter = 0;\n  /**\r\n   * The module's name\r\n   */\n\n  WebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRHandTracking.Version = 1;\n  return WebXRHandTracking;\n}(WebXRAbstractFeature);\n\nexport { WebXRHandTracking }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRHandTracking(xrSessionManager, options);\n  };\n}, WebXRHandTracking.Version, false);","map":null,"metadata":{},"sourceType":"module"}