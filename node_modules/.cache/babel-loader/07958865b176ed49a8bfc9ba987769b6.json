{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh\";\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\nimport { SerializationHelper } from \"./decorators\";\nvar serializedGeometries = [];\n\nvar serializeGeometry = function serializeGeometry(geometry, serializationGeometries) {\n  if (serializedGeometries[geometry.id]) {\n    return;\n  }\n\n  if (geometry.doNotSerialize) {\n    return;\n  }\n\n  serializationGeometries.vertexData.push(geometry.serializeVerticeData());\n  serializedGeometries[geometry.id] = true;\n};\n\nvar serializeMesh = function serializeMesh(mesh, serializationScene) {\n  var serializationObject = {}; // Geometry\n\n  var geometry = mesh._geometry;\n\n  if (geometry) {\n    if (!mesh.getScene().getGeometryByID(geometry.id)) {\n      // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\n      serializeGeometry(geometry, serializationScene.geometries);\n    }\n  } // Custom\n\n\n  if (mesh.serialize) {\n    mesh.serialize(serializationObject);\n  }\n\n  return serializationObject;\n};\n\nvar finalizeSingleMesh = function finalizeSingleMesh(mesh, serializationObject) {\n  //only works if the mesh is already loaded\n  if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n    //serialize material\n    if (mesh.material && !mesh.material.doNotSerialize) {\n      if (mesh.material instanceof MultiMaterial) {\n        serializationObject.multiMaterials = serializationObject.multiMaterials || [];\n        serializationObject.materials = serializationObject.materials || [];\n\n        if (!serializationObject.multiMaterials.some(function (mat) {\n          return mat.id === mesh.material.id;\n        })) {\n          serializationObject.multiMaterials.push(mesh.material.serialize());\n\n          var _loop_1 = function _loop_1(submaterial) {\n            if (submaterial) {\n              if (!serializationObject.materials.some(function (mat) {\n                return mat.id === submaterial.id;\n              })) {\n                serializationObject.materials.push(submaterial.serialize());\n              }\n            }\n          };\n\n          for (var _i = 0, _a = mesh.material.subMaterials; _i < _a.length; _i++) {\n            var submaterial = _a[_i];\n\n            _loop_1(submaterial);\n          }\n        }\n      } else {\n        serializationObject.materials = serializationObject.materials || [];\n\n        if (!serializationObject.materials.some(function (mat) {\n          return mat.id === mesh.material.id;\n        })) {\n          serializationObject.materials.push(mesh.material.serialize());\n        }\n      }\n    } //serialize geometry\n\n\n    var geometry = mesh._geometry;\n\n    if (geometry) {\n      if (!serializationObject.geometries) {\n        serializationObject.geometries = {};\n        serializationObject.geometries.boxes = [];\n        serializationObject.geometries.spheres = [];\n        serializationObject.geometries.cylinders = [];\n        serializationObject.geometries.toruses = [];\n        serializationObject.geometries.grounds = [];\n        serializationObject.geometries.planes = [];\n        serializationObject.geometries.torusKnots = [];\n        serializationObject.geometries.vertexData = [];\n      }\n\n      serializeGeometry(geometry, serializationObject.geometries);\n    } // Skeletons\n\n\n    if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\n      serializationObject.skeletons = serializationObject.skeletons || [];\n      serializationObject.skeletons.push(mesh.skeleton.serialize());\n    } //serialize the actual mesh\n\n\n    serializationObject.meshes = serializationObject.meshes || [];\n    serializationObject.meshes.push(serializeMesh(mesh, serializationObject));\n  }\n};\n/**\r\n * Class used to serialize a scene into a string\r\n */\n\n\nvar SceneSerializer =\n/** @class */\nfunction () {\n  function SceneSerializer() {}\n  /**\r\n   * Clear cache used by a previous serialization\r\n   */\n\n\n  SceneSerializer.ClearCache = function () {\n    serializedGeometries = [];\n  };\n  /**\r\n   * Serialize a scene into a JSON compatible object\r\n   * @param scene defines the scene to serialize\r\n   * @returns a JSON compatible object\r\n   */\n\n\n  SceneSerializer.Serialize = function (scene) {\n    var serializationObject = {};\n    SceneSerializer.ClearCache(); // Scene\n\n    serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\n    serializationObject.autoClear = scene.autoClear;\n    serializationObject.clearColor = scene.clearColor.asArray();\n    serializationObject.ambientColor = scene.ambientColor.asArray();\n    serializationObject.gravity = scene.gravity.asArray();\n    serializationObject.collisionsEnabled = scene.collisionsEnabled; // Fog\n\n    if (scene.fogMode && scene.fogMode !== 0) {\n      serializationObject.fogMode = scene.fogMode;\n      serializationObject.fogColor = scene.fogColor.asArray();\n      serializationObject.fogStart = scene.fogStart;\n      serializationObject.fogEnd = scene.fogEnd;\n      serializationObject.fogDensity = scene.fogDensity;\n    } //Physics\n\n\n    if (scene.isPhysicsEnabled()) {\n      var physicEngine = scene.getPhysicsEngine();\n\n      if (physicEngine) {\n        serializationObject.physicsEnabled = true;\n        serializationObject.physicsGravity = physicEngine.gravity.asArray();\n        serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\n      }\n    } // Metadata\n\n\n    if (scene.metadata) {\n      serializationObject.metadata = scene.metadata;\n    } // Morph targets\n\n\n    serializationObject.morphTargetManagers = [];\n\n    for (var _i = 0, _a = scene.meshes; _i < _a.length; _i++) {\n      var abstractMesh = _a[_i];\n      var manager = abstractMesh.morphTargetManager;\n\n      if (manager) {\n        serializationObject.morphTargetManagers.push(manager.serialize());\n      }\n    } // Lights\n\n\n    serializationObject.lights = [];\n    var index;\n    var light;\n\n    for (index = 0; index < scene.lights.length; index++) {\n      light = scene.lights[index];\n\n      if (!light.doNotSerialize) {\n        serializationObject.lights.push(light.serialize());\n      }\n    } // Cameras\n\n\n    serializationObject.cameras = [];\n\n    for (index = 0; index < scene.cameras.length; index++) {\n      var camera = scene.cameras[index];\n\n      if (!camera.doNotSerialize) {\n        serializationObject.cameras.push(camera.serialize());\n      }\n    }\n\n    if (scene.activeCamera) {\n      serializationObject.activeCameraID = scene.activeCamera.id;\n    } // Animations\n\n\n    SerializationHelper.AppendSerializedAnimations(scene, serializationObject); // Animation Groups\n\n    if (scene.animationGroups && scene.animationGroups.length > 0) {\n      serializationObject.animationGroups = [];\n\n      for (var animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\n        var animationGroup = scene.animationGroups[animationGroupIndex];\n        serializationObject.animationGroups.push(animationGroup.serialize());\n      }\n    } // Reflection probes\n\n\n    if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\n      serializationObject.reflectionProbes = [];\n\n      for (index = 0; index < scene.reflectionProbes.length; index++) {\n        var reflectionProbe = scene.reflectionProbes[index];\n        serializationObject.reflectionProbes.push(reflectionProbe.serialize());\n      }\n    } // Materials\n\n\n    serializationObject.materials = [];\n    serializationObject.multiMaterials = [];\n    var material;\n\n    for (index = 0; index < scene.materials.length; index++) {\n      material = scene.materials[index];\n\n      if (!material.doNotSerialize) {\n        serializationObject.materials.push(material.serialize());\n      }\n    } // MultiMaterials\n\n\n    serializationObject.multiMaterials = [];\n\n    for (index = 0; index < scene.multiMaterials.length; index++) {\n      var multiMaterial = scene.multiMaterials[index];\n      serializationObject.multiMaterials.push(multiMaterial.serialize());\n    } // Environment texture\n\n\n    if (scene.environmentTexture) {\n      serializationObject.environmentTexture = scene.environmentTexture.name;\n    } // Environment Intensity\n\n\n    serializationObject.environmentIntensity = scene.environmentIntensity; // Skeletons\n\n    serializationObject.skeletons = [];\n\n    for (index = 0; index < scene.skeletons.length; index++) {\n      var skeleton = scene.skeletons[index];\n\n      if (!skeleton.doNotSerialize) {\n        serializationObject.skeletons.push(skeleton.serialize());\n      }\n    } // Transform nodes\n\n\n    serializationObject.transformNodes = [];\n\n    for (index = 0; index < scene.transformNodes.length; index++) {\n      if (!scene.transformNodes[index].doNotSerialize) {\n        serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\n      }\n    } // Geometries\n\n\n    serializationObject.geometries = {};\n    serializationObject.geometries.boxes = [];\n    serializationObject.geometries.spheres = [];\n    serializationObject.geometries.cylinders = [];\n    serializationObject.geometries.toruses = [];\n    serializationObject.geometries.grounds = [];\n    serializationObject.geometries.planes = [];\n    serializationObject.geometries.torusKnots = [];\n    serializationObject.geometries.vertexData = [];\n    serializedGeometries = [];\n    var geometries = scene.getGeometries();\n\n    for (index = 0; index < geometries.length; index++) {\n      var geometry = geometries[index];\n\n      if (geometry.isReady()) {\n        serializeGeometry(geometry, serializationObject.geometries);\n      }\n    } // Meshes\n\n\n    serializationObject.meshes = [];\n\n    for (index = 0; index < scene.meshes.length; index++) {\n      var abstractMesh = scene.meshes[index];\n\n      if (abstractMesh instanceof Mesh) {\n        var mesh = abstractMesh;\n\n        if (!mesh.doNotSerialize) {\n          if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n            serializationObject.meshes.push(serializeMesh(mesh, serializationObject));\n          }\n        }\n      }\n    } // Particles Systems\n\n\n    serializationObject.particleSystems = [];\n\n    for (index = 0; index < scene.particleSystems.length; index++) {\n      serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\n    } // Post processes\n\n\n    serializationObject.postProcesses = [];\n\n    for (index = 0; index < scene.postProcesses.length; index++) {\n      serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\n    } // Action Manager\n\n\n    if (scene.actionManager) {\n      serializationObject.actions = scene.actionManager.serialize(\"scene\");\n    } // Components\n\n\n    for (var _b = 0, _c = scene._serializableComponents; _b < _c.length; _b++) {\n      var component = _c[_b];\n      component.serialize(serializationObject);\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Serialize a mesh into a JSON compatible object\r\n   * @param toSerialize defines the mesh to serialize\r\n   * @param withParents defines if parents must be serialized as well\r\n   * @param withChildren defines if children must be serialized as well\r\n   * @returns a JSON compatible object\r\n   */\n\n\n  SceneSerializer.SerializeMesh = function (toSerialize\n  /* Mesh || Mesh[] */\n  , withParents, withChildren) {\n    if (withParents === void 0) {\n      withParents = false;\n    }\n\n    if (withChildren === void 0) {\n      withChildren = false;\n    }\n\n    var serializationObject = {};\n    SceneSerializer.ClearCache();\n    toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\n\n    if (withParents || withChildren) {\n      //deliberate for loop! not for each, appended should be processed as well.\n      for (var i = 0; i < toSerialize.length; ++i) {\n        if (withChildren) {\n          toSerialize[i].getDescendants().forEach(function (node) {\n            if (node instanceof Mesh && toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\n              toSerialize.push(node);\n            }\n          });\n        } //make sure the array doesn't contain the object already\n\n\n        if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\n          toSerialize.push(toSerialize[i].parent);\n        }\n      }\n    }\n\n    toSerialize.forEach(function (mesh) {\n      finalizeSingleMesh(mesh, serializationObject);\n    });\n    return serializationObject;\n  };\n\n  return SceneSerializer;\n}();\n\nexport { SceneSerializer };","map":null,"metadata":{},"sourceType":"module"}