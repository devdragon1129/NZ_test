{"ast":null,"code":"import { Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { VertexBuffer } from \"../buffer\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { PositionNormalVertex } from '../../Maths/math.vertexFormat';\n\nMesh.CreateDecal = function (name, sourceMesh, position, normal, size, angle) {\n  var options = {\n    position: position,\n    normal: normal,\n    size: size,\n    angle: angle\n  };\n  return DecalBuilder.CreateDecal(name, sourceMesh, options);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar DecalBuilder =\n/** @class */\nfunction () {\n  function DecalBuilder() {}\n  /**\r\n   * Creates a decal mesh.\r\n   * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n   * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n   * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n   * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n   * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n   * @param name defines the name of the mesh\r\n   * @param sourceMesh defines the mesh where the decal must be applied\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the decal mesh\r\n   * @see https://doc.babylonjs.com/how_to/decals\r\n   */\n\n\n  DecalBuilder.CreateDecal = function (name, sourceMesh, options) {\n    var indices = sourceMesh.getIndices();\n    var positions = sourceMesh.getVerticesData(VertexBuffer.PositionKind);\n    var normals = sourceMesh.getVerticesData(VertexBuffer.NormalKind);\n    var position = options.position || Vector3.Zero();\n    var normal = options.normal || Vector3.Up();\n    var size = options.size || Vector3.One();\n    var angle = options.angle || 0; // Getting correct rotation\n\n    if (!normal) {\n      var target = new Vector3(0, 0, 1);\n      var camera = sourceMesh.getScene().activeCamera;\n      var cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n      normal = camera.globalPosition.subtract(cameraWorldTarget);\n    }\n\n    var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n    var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n    var pitch = Math.atan2(normal.y, len); // Matrix\n\n    var decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\n    var inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\n    var meshWorldMatrix = sourceMesh.getWorldMatrix();\n    var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\n    var vertexData = new VertexData();\n    vertexData.indices = [];\n    vertexData.positions = [];\n    vertexData.normals = [];\n    vertexData.uvs = [];\n    var currentVertexDataIndex = 0;\n\n    var extractDecalVector3 = function extractDecalVector3(indexId) {\n      var result = new PositionNormalVertex();\n\n      if (!indices || !positions || !normals) {\n        return result;\n      }\n\n      var vertexId = indices[indexId];\n      result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]); // Send vector to decal local world\n\n      result.position = Vector3.TransformCoordinates(result.position, transformMatrix); // Get normal\n\n      result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n      result.normal = Vector3.TransformNormal(result.normal, transformMatrix);\n      return result;\n    }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n\n\n    var clip = function clip(vertices, axis) {\n      if (vertices.length === 0) {\n        return vertices;\n      }\n\n      var clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\n\n      var clipVertices = function clipVertices(v0, v1) {\n        var clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n        return new PositionNormalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor));\n      };\n\n      var result = new Array();\n\n      for (var index = 0; index < vertices.length; index += 3) {\n        var v1Out;\n        var v2Out;\n        var v3Out;\n        var total = 0;\n        var nV1 = null;\n        var nV2 = null;\n        var nV3 = null;\n        var nV4 = null;\n        var d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\n        var d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n        var d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0;\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n\n        switch (total) {\n          case 0:\n            result.push(vertices[index]);\n            result.push(vertices[index + 1]);\n            result.push(vertices[index + 2]);\n            break;\n\n          case 1:\n            if (v1Out) {\n              nV1 = vertices[index + 1];\n              nV2 = vertices[index + 2];\n              nV3 = clipVertices(vertices[index], nV1);\n              nV4 = clipVertices(vertices[index], nV2);\n            }\n\n            if (v2Out) {\n              nV1 = vertices[index];\n              nV2 = vertices[index + 2];\n              nV3 = clipVertices(vertices[index + 1], nV1);\n              nV4 = clipVertices(vertices[index + 1], nV2);\n              result.push(nV3);\n              result.push(nV2.clone());\n              result.push(nV1.clone());\n              result.push(nV2.clone());\n              result.push(nV3.clone());\n              result.push(nV4);\n              break;\n            }\n\n            if (v3Out) {\n              nV1 = vertices[index];\n              nV2 = vertices[index + 1];\n              nV3 = clipVertices(vertices[index + 2], nV1);\n              nV4 = clipVertices(vertices[index + 2], nV2);\n            }\n\n            if (nV1 && nV2 && nV3 && nV4) {\n              result.push(nV1.clone());\n              result.push(nV2.clone());\n              result.push(nV3);\n              result.push(nV4);\n              result.push(nV3.clone());\n              result.push(nV2.clone());\n            }\n\n            break;\n\n          case 2:\n            if (!v1Out) {\n              nV1 = vertices[index].clone();\n              nV2 = clipVertices(nV1, vertices[index + 1]);\n              nV3 = clipVertices(nV1, vertices[index + 2]);\n              result.push(nV1);\n              result.push(nV2);\n              result.push(nV3);\n            }\n\n            if (!v2Out) {\n              nV1 = vertices[index + 1].clone();\n              nV2 = clipVertices(nV1, vertices[index + 2]);\n              nV3 = clipVertices(nV1, vertices[index]);\n              result.push(nV1);\n              result.push(nV2);\n              result.push(nV3);\n            }\n\n            if (!v3Out) {\n              nV1 = vertices[index + 2].clone();\n              nV2 = clipVertices(nV1, vertices[index]);\n              nV3 = clipVertices(nV1, vertices[index + 1]);\n              result.push(nV1);\n              result.push(nV2);\n              result.push(nV3);\n            }\n\n            break;\n\n          case 3:\n            break;\n        }\n      }\n\n      return result;\n    };\n\n    for (var index = 0; index < indices.length; index += 3) {\n      var faceVertices = new Array();\n      faceVertices.push(extractDecalVector3(index));\n      faceVertices.push(extractDecalVector3(index + 1));\n      faceVertices.push(extractDecalVector3(index + 2)); // Clip\n\n      faceVertices = clip(faceVertices, new Vector3(1, 0, 0));\n      faceVertices = clip(faceVertices, new Vector3(-1, 0, 0));\n      faceVertices = clip(faceVertices, new Vector3(0, 1, 0));\n      faceVertices = clip(faceVertices, new Vector3(0, -1, 0));\n      faceVertices = clip(faceVertices, new Vector3(0, 0, 1));\n      faceVertices = clip(faceVertices, new Vector3(0, 0, -1));\n\n      if (faceVertices.length === 0) {\n        continue;\n      } // Add UVs and get back to world\n\n\n      for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n        var vertex = faceVertices[vIndex]; //TODO check for Int32Array | Uint32Array | Uint16Array\n\n        vertexData.indices.push(currentVertexDataIndex);\n        vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n        vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n        vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n        vertexData.uvs.push(0.5 + vertex.position.y / size.y);\n        currentVertexDataIndex++;\n      }\n    } // Return mesh\n\n\n    var decal = new Mesh(name, sourceMesh.getScene());\n    vertexData.applyToMesh(decal);\n    decal.position = position.clone();\n    decal.rotation = new Vector3(pitch, yaw, angle);\n    return decal;\n  };\n\n  return DecalBuilder;\n}();\n\nexport { DecalBuilder };","map":null,"metadata":{},"sourceType":"module"}