{"ast":null,"code":"import { Scene } from \"../scene\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { Collider } from \"./collider\";\n/** @hidden */\n\nvar DefaultCollisionCoordinator =\n/** @class */\nfunction () {\n  function DefaultCollisionCoordinator() {\n    this._scaledPosition = Vector3.Zero();\n    this._scaledVelocity = Vector3.Zero();\n    this._finalPosition = Vector3.Zero();\n  }\n\n  DefaultCollisionCoordinator.prototype.getNewPosition = function (position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n    position.divideToRef(collider._radius, this._scaledPosition);\n    displacement.divideToRef(collider._radius, this._scaledVelocity);\n    collider.collidedMesh = null;\n    collider._retry = 0;\n    collider._initialVelocity = this._scaledVelocity;\n    collider._initialPosition = this._scaledPosition;\n\n    this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n\n    this._finalPosition.multiplyInPlace(collider._radius); //run the callback\n\n\n    onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n  };\n\n  DefaultCollisionCoordinator.prototype.createCollider = function () {\n    return new Collider();\n  };\n\n  DefaultCollisionCoordinator.prototype.init = function (scene) {\n    this._scene = scene;\n  };\n\n  DefaultCollisionCoordinator.prototype._collideWithWorld = function (position, velocity, collider, maximumRetry, finalPosition, excludedMesh) {\n    if (excludedMesh === void 0) {\n      excludedMesh = null;\n    }\n\n    var closeDistance = Engine.CollisionsEpsilon * 10.0;\n\n    if (collider._retry >= maximumRetry) {\n      finalPosition.copyFrom(position);\n      return;\n    } // Check if this is a mesh else camera or -1\n\n\n    var collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\n\n    collider._initialize(position, velocity, closeDistance); // Check if collision detection should happen against specified list of meshes or,\n    // if not specified, against all meshes in the scene\n\n\n    var meshes = excludedMesh && excludedMesh.surroundingMeshes || this._scene.meshes;\n\n    for (var index = 0; index < meshes.length; index++) {\n      var mesh = meshes[index];\n\n      if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\n        mesh._checkCollision(collider);\n      }\n    }\n\n    if (!collider.collisionFound) {\n      position.addToRef(velocity, finalPosition);\n      return;\n    }\n\n    if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n      collider._getResponse(position, velocity);\n    }\n\n    if (velocity.length() <= closeDistance) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n\n    collider._retry++;\n\n    this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n  };\n\n  return DefaultCollisionCoordinator;\n}();\n\nexport { DefaultCollisionCoordinator };\n\nScene.CollisionCoordinatorFactory = function () {\n  return new DefaultCollisionCoordinator();\n};","map":null,"metadata":{},"sourceType":"module"}