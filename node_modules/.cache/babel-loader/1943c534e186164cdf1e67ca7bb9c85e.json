{"ast":null,"code":"import { Observable } from '../Misc/observable';\n/**\r\n * The current state of the timer\r\n */\n\nexport var TimerState;\n\n(function (TimerState) {\n  /**\r\n   * Timer initialized, not yet started\r\n   */\n  TimerState[TimerState[\"INIT\"] = 0] = \"INIT\";\n  /**\r\n   * Timer started and counting\r\n   */\n\n  TimerState[TimerState[\"STARTED\"] = 1] = \"STARTED\";\n  /**\r\n   * Timer ended (whether aborted or time reached)\r\n   */\n\n  TimerState[TimerState[\"ENDED\"] = 2] = \"ENDED\";\n})(TimerState || (TimerState = {}));\n/**\r\n * A simple version of the timer. Will take options and start the timer immediately after calling it\r\n *\r\n * @param options options with which to initialize this timer\r\n */\n\n\nexport function setAndStartTimer(options) {\n  var _a;\n\n  var timer = 0;\n  var startTime = Date.now();\n  options.observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};\n  var observer = options.contextObservable.add(function (payload) {\n    var now = Date.now();\n    timer = now - startTime;\n    var data = {\n      startTime: startTime,\n      currentTime: now,\n      deltaTime: timer,\n      completeRate: timer / options.timeout,\n      payload: payload\n    };\n    options.onTick && options.onTick(data);\n\n    if (options.breakCondition && options.breakCondition()) {\n      options.contextObservable.remove(observer);\n      options.onAborted && options.onAborted(data);\n    }\n\n    if (timer >= options.timeout) {\n      options.contextObservable.remove(observer);\n      options.onEnded && options.onEnded(data);\n    }\n  }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);\n  return observer;\n}\n/**\r\n * An advanced implementation of a timer class\r\n */\n\nvar AdvancedTimer =\n/** @class */\nfunction () {\n  /**\r\n   * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\r\n   * @param options construction options for this advanced timer\r\n   */\n  function AdvancedTimer(options) {\n    var _this = this;\n\n    var _a, _b;\n    /**\r\n     * Will notify each time the timer calculates the remaining time\r\n     */\n\n\n    this.onEachCountObservable = new Observable();\n    /**\r\n     * Will trigger when the timer was aborted due to the break condition\r\n     */\n\n    this.onTimerAbortedObservable = new Observable();\n    /**\r\n     * Will trigger when the timer ended successfully\r\n     */\n\n    this.onTimerEndedObservable = new Observable();\n    /**\r\n     * Will trigger when the timer state has changed\r\n     */\n\n    this.onStateChangedObservable = new Observable();\n    this._observer = null;\n    this._breakOnNextTick = false;\n\n    this._tick = function (payload) {\n      var now = Date.now();\n      _this._timer = now - _this._startTime;\n      var data = {\n        startTime: _this._startTime,\n        currentTime: now,\n        deltaTime: _this._timer,\n        completeRate: _this._timer / _this._timeToEnd,\n        payload: payload\n      };\n\n      var shouldBreak = _this._breakOnNextTick || _this._breakCondition(data);\n\n      if (shouldBreak || _this._timer >= _this._timeToEnd) {\n        _this._stop(data, shouldBreak);\n      } else {\n        _this.onEachCountObservable.notifyObservers(data);\n      }\n    };\n\n    this._setState(TimerState.INIT);\n\n    this._contextObservable = options.contextObservable;\n    this._observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};\n    this._breakCondition = (_b = options.breakCondition) !== null && _b !== void 0 ? _b : function () {\n      return false;\n    };\n\n    if (options.onEnded) {\n      this.onTimerEndedObservable.add(options.onEnded);\n    }\n\n    if (options.onTick) {\n      this.onEachCountObservable.add(options.onTick);\n    }\n\n    if (options.onAborted) {\n      this.onTimerAbortedObservable.add(options.onAborted);\n    }\n  }\n\n  Object.defineProperty(AdvancedTimer.prototype, \"breakCondition\", {\n    /**\r\n     * set a breaking condition for this timer. Default is to never break during count\r\n     * @param predicate the new break condition. Returns true to break, false otherwise\r\n     */\n    set: function set(predicate) {\n      this._breakCondition = predicate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Reset ALL associated observables in this advanced timer\r\n   */\n\n  AdvancedTimer.prototype.clearObservables = function () {\n    this.onEachCountObservable.clear();\n    this.onTimerAbortedObservable.clear();\n    this.onTimerEndedObservable.clear();\n    this.onStateChangedObservable.clear();\n  };\n  /**\r\n   * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\r\n   *\r\n   * @param timeToEnd how much time to measure until timer ended\r\n   */\n\n\n  AdvancedTimer.prototype.start = function (timeToEnd) {\n    if (timeToEnd === void 0) {\n      timeToEnd = this._timeToEnd;\n    }\n\n    if (this._state === TimerState.STARTED) {\n      throw new Error('Timer already started. Please stop it before starting again');\n    }\n\n    this._timeToEnd = timeToEnd;\n    this._startTime = Date.now();\n    this._timer = 0;\n    this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\n\n    this._setState(TimerState.STARTED);\n  };\n  /**\r\n   * Will force a stop on the next tick.\r\n   */\n\n\n  AdvancedTimer.prototype.stop = function () {\n    if (this._state !== TimerState.STARTED) {\n      return;\n    }\n\n    this._breakOnNextTick = true;\n  };\n  /**\r\n   * Dispose this timer, clearing all resources\r\n   */\n\n\n  AdvancedTimer.prototype.dispose = function () {\n    if (this._observer) {\n      this._contextObservable.remove(this._observer);\n    }\n\n    this.clearObservables();\n  };\n\n  AdvancedTimer.prototype._setState = function (newState) {\n    this._state = newState;\n    this.onStateChangedObservable.notifyObservers(this._state);\n  };\n\n  AdvancedTimer.prototype._stop = function (data, aborted) {\n    if (aborted === void 0) {\n      aborted = false;\n    }\n\n    this._contextObservable.remove(this._observer);\n\n    this._setState(TimerState.ENDED);\n\n    if (aborted) {\n      this.onTimerAbortedObservable.notifyObservers(data);\n    } else {\n      this.onTimerEndedObservable.notifyObservers(data);\n    }\n  };\n\n  return AdvancedTimer;\n}();\n\nexport { AdvancedTimer };","map":null,"metadata":{},"sourceType":"module"}