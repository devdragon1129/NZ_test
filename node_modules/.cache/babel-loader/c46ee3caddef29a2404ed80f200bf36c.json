{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.add5H = exports.add5L = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;\nvar U32_MASK64 = BigInt(Math.pow(2, 32) - 1);\n\nvar _32n = BigInt(32);\n\nfunction fromBig(n) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (le) return {\n    h: Number(n & U32_MASK64),\n    l: Number(n >> _32n & U32_MASK64)\n  };\n  return {\n    h: Number(n >> _32n & U32_MASK64) | 0,\n    l: Number(n & U32_MASK64) | 0\n  };\n}\n\nexports.fromBig = fromBig;\n\nfunction split(lst) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var Ah = new Uint32Array(lst.length);\n  var Al = new Uint32Array(lst.length);\n\n  for (var i = 0; i < lst.length; i++) {\n    var _fromBig = fromBig(lst[i], le),\n        h = _fromBig.h,\n        l = _fromBig.l;\n\n    var _ref = [h, l];\n    Ah[i] = _ref[0];\n    Al[i] = _ref[1];\n  }\n\n  return [Ah, Al];\n}\n\nexports.split = split;\n\nvar toBig = function toBig(h, l) {\n  return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n};\n\nexports.toBig = toBig; // for Shift in [0, 32)\n\nvar shrSH = function shrSH(h, l, s) {\n  return h >>> s;\n};\n\nexports.shrSH = shrSH;\n\nvar shrSL = function shrSL(h, l, s) {\n  return h << 32 - s | l >>> s;\n};\n\nexports.shrSL = shrSL; // Right rotate for Shift in [1, 32)\n\nvar rotrSH = function rotrSH(h, l, s) {\n  return h >>> s | l << 32 - s;\n};\n\nexports.rotrSH = rotrSH;\n\nvar rotrSL = function rotrSL(h, l, s) {\n  return h << 32 - s | l >>> s;\n};\n\nexports.rotrSL = rotrSL; // Right rotate for Shift in (32, 64), NOTE: 32 is special case.\n\nvar rotrBH = function rotrBH(h, l, s) {\n  return h << 64 - s | l >>> s - 32;\n};\n\nexports.rotrBH = rotrBH;\n\nvar rotrBL = function rotrBL(h, l, s) {\n  return h >>> s - 32 | l << 64 - s;\n};\n\nexports.rotrBL = rotrBL; // Right rotate for shift===32 (just swaps l&h)\n\nvar rotr32H = function rotr32H(h, l) {\n  return l;\n};\n\nexports.rotr32H = rotr32H;\n\nvar rotr32L = function rotr32L(h, l) {\n  return h;\n};\n\nexports.rotr32L = rotr32L; // Left rotate for Shift in [1, 32)\n\nvar rotlSH = function rotlSH(h, l, s) {\n  return h << s | l >>> 32 - s;\n};\n\nexports.rotlSH = rotlSH;\n\nvar rotlSL = function rotlSL(h, l, s) {\n  return l << s | h >>> 32 - s;\n};\n\nexports.rotlSL = rotlSL; // Left rotate for Shift in (32, 64), NOTE: 32 is special case.\n\nvar rotlBH = function rotlBH(h, l, s) {\n  return l << s - 32 | h >>> 64 - s;\n};\n\nexports.rotlBH = rotlBH;\n\nvar rotlBL = function rotlBL(h, l, s) {\n  return h << s - 32 | l >>> 64 - s;\n};\n\nexports.rotlBL = rotlBL; // JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n\nfunction add(Ah, Al, Bh, Bl) {\n  var l = (Al >>> 0) + (Bl >>> 0);\n  return {\n    h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,\n    l: l | 0\n  };\n}\n\nexports.add = add; // Addition with more than 2 elements\n\nvar add3L = function add3L(Al, Bl, Cl) {\n  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\n};\n\nexports.add3L = add3L;\n\nvar add3H = function add3H(low, Ah, Bh, Ch) {\n  return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;\n};\n\nexports.add3H = add3H;\n\nvar add4L = function add4L(Al, Bl, Cl, Dl) {\n  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\n};\n\nexports.add4L = add4L;\n\nvar add4H = function add4H(low, Ah, Bh, Ch, Dh) {\n  return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;\n};\n\nexports.add4H = add4H;\n\nvar add5L = function add5L(Al, Bl, Cl, Dl, El) {\n  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\n};\n\nexports.add5L = add5L;\n\nvar add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {\n  return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;\n};\n\nexports.add5H = add5H;","map":null,"metadata":{},"sourceType":"script"}