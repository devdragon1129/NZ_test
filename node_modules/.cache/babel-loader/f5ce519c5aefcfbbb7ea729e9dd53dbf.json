{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar _slicedToArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar bytes_1 = tslib_1.__importDefault(require(\"./bytes\"));\n\nvar nat_1 = tslib_1.__importDefault(require(\"./nat\"));\n\nvar elliptic_1 = tslib_1.__importDefault(require(\"elliptic\"));\n\nvar hash_1 = require(\"./hash\");\n\nvar secp256k1 = new elliptic_1.default.ec('secp256k1');\n\nexports.create = function (entropy) {\n  var innerHex = hash_1.keccak256(bytes_1.default.concat(bytes_1.default.random(32), '0x' + entropy.toString('hex') || bytes_1.default.random(32)));\n  var middleHex = bytes_1.default.concat(bytes_1.default.concat(bytes_1.default.random(32), innerHex), bytes_1.default.random(32));\n  var outerHex = hash_1.keccak256(middleHex);\n  return exports.fromPrivate(Buffer.from(outerHex.slice(2), 'hex'));\n};\n\nexports.toChecksum = function (address) {\n  var addressHash = hash_1.keccak256s(address.slice(2));\n  var checksumAddress = '0x';\n\n  for (var i = 0; i < 40; i++) {\n    checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n  }\n\n  return checksumAddress;\n};\n\nexports.fromPrivate = function (privateKey) {\n  var ecKey = secp256k1.keyFromPrivate(privateKey);\n  var publicKey = Buffer.from(ecKey.getPublic(false, 'hex'), 'hex');\n  var publicHash = hash_1.keccak256(publicKey.slice(1));\n  var address = exports.toChecksum('0x' + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey,\n    publicKey: publicKey\n  };\n};\n\nexports.encodeSignature = function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      v = _ref2[0],\n      r = _ref2[1],\n      s = _ref2[2];\n\n  return bytes_1.default.flatten([bytes_1.default.pad(32, r), bytes_1.default.pad(32, s), v]);\n};\n\nexports.decodeSignature = function (hex) {\n  return [bytes_1.default.slice(64, bytes_1.default.length(hex), hex), bytes_1.default.slice(0, 32, hex), bytes_1.default.slice(32, 64, hex)];\n};\n\nexports.makeSigner = function (addToV) {\n  return function (hash, privateKey) {\n    var signature = secp256k1.keyFromPrivate(privateKey).sign(Buffer.from(hash.slice(2), 'hex'), {\n      canonical: true\n    });\n    return exports.encodeSignature([nat_1.default.fromString(bytes_1.default.fromNumber(addToV + signature.recoveryParam)), bytes_1.default.pad(32, bytes_1.default.fromNat('0x' + signature.r.toString(16))), bytes_1.default.pad(32, bytes_1.default.fromNat('0x' + signature.s.toString(16)))]);\n  };\n};\n\nexports.sign = exports.makeSigner(27); // v=27|28 instead of 0|1...\n\nexports.recover = function (hash, signature) {\n  var vals = exports.decodeSignature(signature);\n  var vrs = {\n    v: bytes_1.default.toNumber(vals[0]),\n    r: vals[1].slice(2),\n    s: vals[2].slice(2)\n  };\n  var ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n\n  var publicKey = '0x' + ecPublicKey.encode('hex', false).slice(2);\n  var publicHash = hash_1.keccak256(publicKey);\n  var address = exports.toChecksum('0x' + publicHash.slice(-40));\n  return address;\n};\n\nexports.default = {\n  create: exports.create,\n  toChecksum: exports.toChecksum,\n  fromPrivate: exports.fromPrivate,\n  sign: exports.sign,\n  makeSigner: exports.makeSigner,\n  recover: exports.recover,\n  encodeSignature: exports.encodeSignature,\n  decodeSignature: exports.decodeSignature\n};","map":null,"metadata":{},"sourceType":"script"}