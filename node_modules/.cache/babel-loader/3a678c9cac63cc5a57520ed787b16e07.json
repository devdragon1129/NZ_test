{"ast":null,"code":"import { Engine } from \"../Engines/engine\";\n/**\r\n * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.\r\n * It will be also used in a future release to apply effects on a specific track.\r\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-sound-tracks\r\n */\n\nvar SoundTrack =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new sound track.\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-sound-tracks\r\n   * @param scene Define the scene the sound track belongs to\r\n   * @param options\r\n   */\n  function SoundTrack(scene, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    /**\r\n     * The unique identifier of the sound track in the scene.\r\n     */\n\n\n    this.id = -1;\n    this._isInitialized = false;\n    this._scene = scene;\n    this.soundCollection = new Array();\n    this._options = options;\n\n    if (!this._options.mainTrack && this._scene.soundTracks) {\n      this._scene.soundTracks.push(this);\n\n      this.id = this._scene.soundTracks.length - 1;\n    }\n  }\n\n  SoundTrack.prototype._initializeSoundTrackAudioGraph = function () {\n    if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\n      this._outputAudioNode = Engine.audioEngine.audioContext.createGain();\n\n      this._outputAudioNode.connect(Engine.audioEngine.masterGain);\n\n      if (this._options) {\n        if (this._options.volume) {\n          this._outputAudioNode.gain.value = this._options.volume;\n        }\n      }\n\n      this._isInitialized = true;\n    }\n  };\n  /**\r\n   * Release the sound track and its associated resources\r\n   */\n\n\n  SoundTrack.prototype.dispose = function () {\n    if (Engine.audioEngine && Engine.audioEngine.canUseWebAudio) {\n      if (this._connectedAnalyser) {\n        this._connectedAnalyser.stopDebugCanvas();\n      }\n\n      while (this.soundCollection.length) {\n        this.soundCollection[0].dispose();\n      }\n\n      if (this._outputAudioNode) {\n        this._outputAudioNode.disconnect();\n      }\n\n      this._outputAudioNode = null;\n    }\n  };\n  /**\r\n   * Adds a sound to this sound track\r\n   * @param sound define the cound to add\r\n   * @ignoreNaming\r\n   */\n\n\n  SoundTrack.prototype.addSound = function (sound) {\n    if (!this._isInitialized) {\n      this._initializeSoundTrackAudioGraph();\n    }\n\n    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {\n      sound.connectToSoundTrackAudioNode(this._outputAudioNode);\n    }\n\n    if (sound.soundTrackId) {\n      if (sound.soundTrackId === -1) {\n        this._scene.mainSoundTrack.removeSound(sound);\n      } else if (this._scene.soundTracks) {\n        this._scene.soundTracks[sound.soundTrackId].removeSound(sound);\n      }\n    }\n\n    this.soundCollection.push(sound);\n    sound.soundTrackId = this.id;\n  };\n  /**\r\n   * Removes a sound to this sound track\r\n   * @param sound define the cound to remove\r\n   * @ignoreNaming\r\n   */\n\n\n  SoundTrack.prototype.removeSound = function (sound) {\n    var index = this.soundCollection.indexOf(sound);\n\n    if (index !== -1) {\n      this.soundCollection.splice(index, 1);\n    }\n  };\n  /**\r\n   * Set a global volume for the full sound track.\r\n   * @param newVolume Define the new volume of the sound track\r\n   */\n\n\n  SoundTrack.prototype.setVolume = function (newVolume) {\n    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {\n      this._outputAudioNode.gain.value = newVolume;\n    }\n  };\n  /**\r\n   * Switch the panning model to HRTF:\r\n   * Renders a stereo output of higher quality than equalpower â€” it uses a convolution with measured impulse responses from human subjects.\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n   */\n\n\n  SoundTrack.prototype.switchPanningModelToHRTF = function () {\n    if (Engine.audioEngine.canUseWebAudio) {\n      for (var i = 0; i < this.soundCollection.length; i++) {\n        this.soundCollection[i].switchPanningModelToHRTF();\n      }\n    }\n  };\n  /**\r\n   * Switch the panning model to Equal Power:\r\n   * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n   */\n\n\n  SoundTrack.prototype.switchPanningModelToEqualPower = function () {\n    if (Engine.audioEngine.canUseWebAudio) {\n      for (var i = 0; i < this.soundCollection.length; i++) {\n        this.soundCollection[i].switchPanningModelToEqualPower();\n      }\n    }\n  };\n  /**\r\n   * Connect the sound track to an audio analyser allowing some amazing\r\n   * synchornization between the sounds/music and your visualization (VuMeter for instance).\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser\r\n   * @param analyser The analyser to connect to the engine\r\n   */\n\n\n  SoundTrack.prototype.connectToAnalyser = function (analyser) {\n    if (this._connectedAnalyser) {\n      this._connectedAnalyser.stopDebugCanvas();\n    }\n\n    this._connectedAnalyser = analyser;\n\n    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {\n      this._outputAudioNode.disconnect();\n\n      this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, Engine.audioEngine.masterGain);\n    }\n  };\n\n  return SoundTrack;\n}();\n\nexport { SoundTrack };","map":null,"metadata":{},"sourceType":"module"}