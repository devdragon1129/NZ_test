{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { createSelector } from 'reselect';\nimport { getCurrentProject } from 'modules/project/selectors';\nimport { ComponentType } from './types';\nimport { EMPTY_SCENE_METRICS, ShapeComponents } from './constants';\nexport var getState = function getState(state) {\n  return state.scene.present;\n};\nexport var getData = function getData(state) {\n  return getState(state).data;\n};\nexport var getCurrentScene = createSelector(getCurrentProject, getData, function (project, scenes) {\n  return project ? scenes[project.sceneId] : null;\n});\nexport var getCurrentMetrics = createSelector(getCurrentScene, function (scene) {\n  return scene ? scene.metrics : EMPTY_SCENE_METRICS;\n});\nexport var getCurrentLimits = createSelector(getCurrentScene, function (scene) {\n  return scene ? scene.limits : EMPTY_SCENE_METRICS;\n});\nexport var getComponents = createSelector(getCurrentScene, function (scene) {\n  return scene ? scene.components : {};\n});\nexport var getEntities = createSelector(getCurrentScene, function (scene) {\n  return scene ? scene.entities : {};\n});\nexport var getEntityNames = createSelector(getCurrentScene, function (scene) {\n  return scene ? Object.values(scene.entities).map(function (entity) {\n    return entity.name;\n  }) : [];\n});\nexport var getComponentsByEntityId = createSelector(getEntities, getComponents, function (entities, components) {\n  var out = {};\n\n  for (var entityId in entities) {\n    if (entityId && entities && entityId in entities) {\n      var componentReferences = entities[entityId].components;\n\n      var _iterator = _createForOfIteratorHelper(componentReferences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var componentId = _step.value;\n\n          if (!out[entityId]) {\n            out[entityId] = [];\n          }\n\n          out[entityId].push(components[componentId]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n\n  return out;\n});\nexport var getEntityComponentsByType = createSelector(getEntities, getComponents, function (entities, components) {\n  var out = {};\n\n  for (var entityId in entities) {\n    if (entities && entityId in entities) {\n      var componentReferences = entities[entityId].components;\n\n      var _iterator2 = _createForOfIteratorHelper(componentReferences),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var componentId = _step2.value;\n          var component = components[componentId];\n\n          if (!out[entityId]) {\n            out[entityId] = {};\n          }\n\n          out[entityId][component.type] = component;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }\n\n  return out;\n});\nexport var getShapesByEntityId = createSelector(getEntities, getComponents, function (entities, components) {\n  var out = {};\n\n  for (var entityId in entities) {\n    if (entityId && entities && entityId in entities) {\n      var componentReferences = entities[entityId].components;\n\n      var _iterator3 = _createForOfIteratorHelper(componentReferences),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var componentId = _step3.value;\n\n          if (components && componentId in components && ShapeComponents.includes(components[componentId].type)) {\n            out[entityId] = components[componentId];\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }\n\n  return out;\n}); // export const getScriptsByEntityId = createSelector<\n//   RootState,\n//   Scene['entities'],\n//   Scene['components'],\n//   Record<string, ComponentDefinition<ComponentType.Script>>\n// >(\n//   getEntities,\n//   getComponents,\n//   (entities, components) => {\n//     const out: Record<string, ComponentDefinition<ComponentType.Script>> = {}\n//     for (let entityId in entities) {\n//       if (entityId && entities && entityId in entities) {\n//         const componentReferences = entities[entityId].components\n//         for (const componentId of componentReferences) {\n//           if (components && componentId in components && components[componentId].type === ComponentType.Script) {\n//             out[entityId] = components[componentId] as ComponentDefinition<ComponentType.Script>\n//           }\n//         }\n//       }\n//     }\n//     return out\n//   }\n// )\n\nexport var getComponentsByType = createSelector(getCurrentScene, function (scene) {\n  var out = {};\n\n  for (var _i = 0, _Object$keys = Object.keys(ComponentType); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    out[key] = [];\n  }\n\n  if (scene) {\n    var components = scene.components;\n\n    for (var _i2 = 0, _Object$values = Object.values(components); _i2 < _Object$values.length; _i2++) {\n      var component = _Object$values[_i2];\n\n      if (!out[component.type]) {\n        out[component.type] = [];\n      }\n\n      out[component.type].push(component);\n    }\n  }\n\n  return out;\n});\nexport var getGLTFsByAssetId = createSelector(getCurrentScene, function (scene) {\n  if (!scene) return {};\n  var componentData = scene.components;\n  var res = {};\n\n  for (var key in componentData) {\n    var comp = componentData[key];\n\n    if (comp.type === ComponentType.GLTFShape) {\n      res[comp.data.assetId] = comp;\n    }\n  }\n\n  return res;\n});\nexport var getCollectiblesByURL = createSelector(getCurrentScene, function (scene) {\n  if (!scene) return {};\n  var componentData = scene.components;\n  var res = {};\n\n  for (var key in componentData) {\n    var comp = componentData[key];\n\n    if (comp.type === ComponentType.NFTShape) {\n      res[comp.data.url] = comp;\n    }\n  }\n\n  return res;\n});\nexport var hasHistory = function hasHistory(state) {\n  return state.scene.past.length > 0;\n};\nexport var numItems = createSelector(getCurrentProject, getCurrentScene, function (project, scene) {\n  if (!project || !scene) return 0;\n  var numTransforms = Object.values(scene.components).reduce(function (total, component) {\n    return component.type === ComponentType.Transform ? total + 1 : total;\n  }, 0);\n  var numGrounds = project.layout.cols * project.layout.rows;\n  return numTransforms - numGrounds;\n});","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/scene/selectors.ts"],"names":["createSelector","getCurrentProject","ComponentType","EMPTY_SCENE_METRICS","ShapeComponents","getState","state","scene","present","getData","data","getCurrentScene","project","scenes","sceneId","getCurrentMetrics","metrics","getCurrentLimits","limits","getComponents","components","getEntities","entities","getEntityNames","Object","values","map","entity","name","getComponentsByEntityId","out","entityId","componentReferences","componentId","push","getEntityComponentsByType","component","type","getShapesByEntityId","includes","getComponentsByType","keys","key","getGLTFsByAssetId","componentData","res","comp","GLTFShape","assetId","getCollectiblesByURL","NFTShape","url","hasHistory","past","length","numItems","numTransforms","reduce","total","Transform","numGrounds","layout","cols","rows"],"mappings":"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","sourcesContent":["import { createSelector } from 'reselect'\nimport { RootState } from 'modules/common/types'\nimport { SceneState } from 'modules/scene/reducer'\nimport { getCurrentProject } from 'modules/project/selectors'\nimport { Project } from 'modules/project/types'\nimport { ModelMetrics } from 'modules/models/types'\nimport { ComponentDefinition, ComponentType, Scene, AnyComponent, ShapeComponent } from './types'\nimport { EMPTY_SCENE_METRICS, ShapeComponents } from './constants'\n\nexport const getState: (state: RootState) => SceneState = state => state.scene.present\n\nexport const getData: (state: RootState) => SceneState['data'] = state => getState(state).data\n\nexport const getCurrentScene = createSelector<RootState, Project | null, SceneState['data'], Scene | null>(\n  getCurrentProject,\n  getData,\n  (project, scenes) => (project ? scenes[project.sceneId] : null)\n)\n\nexport const getCurrentMetrics = createSelector<RootState, Scene | null, ModelMetrics>(getCurrentScene, scene =>\n  scene ? scene.metrics : EMPTY_SCENE_METRICS\n)\n\nexport const getCurrentLimits = createSelector<RootState, Scene | null, ModelMetrics>(getCurrentScene, scene =>\n  scene ? scene.limits : EMPTY_SCENE_METRICS\n)\n\nexport const getComponents = createSelector<RootState, Scene | null, Scene['components']>(getCurrentScene, scene =>\n  scene ? scene.components : {}\n)\n\nexport const getEntities = createSelector<RootState, Scene | null, Scene['entities']>(getCurrentScene, scene =>\n  scene ? scene.entities : {}\n)\n\nexport const getEntityNames = createSelector<RootState, Scene | null, string[]>(getCurrentScene, scene =>\n  scene ? Object.values(scene.entities).map(entity => entity.name) : []\n)\n\nexport const getComponentsByEntityId = createSelector<RootState, Scene['entities'], Scene['components'], Record<string, AnyComponent[]>>(\n  getEntities,\n  getComponents,\n  (entities, components) => {\n    let out: Record<string, AnyComponent[]> = {}\n\n    for (let entityId in entities) {\n      if (entityId && entities && entityId in entities) {\n        const componentReferences = entities[entityId].components\n\n        for (let componentId of componentReferences) {\n          if (!out[entityId]) {\n            out[entityId] = []\n          }\n\n          out[entityId].push(components[componentId])\n        }\n      }\n    }\n\n    return out\n  }\n)\n\nexport const getEntityComponentsByType = createSelector<\n  RootState,\n  Scene['entities'],\n  Scene['components'],\n  Record<string, Record<ComponentType, AnyComponent>>\n>(getEntities, getComponents, (entities, components) => {\n  const out: Record<string, Record<ComponentType, AnyComponent>> = {}\n\n  for (let entityId in entities) {\n    if (entities && entityId in entities) {\n      const componentReferences = entities[entityId].components\n      for (const componentId of componentReferences) {\n        const component = components[componentId]\n        if (!out[entityId]) {\n          out[entityId] = {} as Record<ComponentType, AnyComponent>\n        }\n        out[entityId][component.type] = component\n      }\n    }\n  }\n\n  return out\n})\n\nexport const getShapesByEntityId = createSelector<RootState, Scene['entities'], Scene['components'], Record<string, ShapeComponent>>(\n  getEntities,\n  getComponents,\n  (entities, components) => {\n    const out: Record<string, ShapeComponent> = {}\n\n    for (let entityId in entities) {\n      if (entityId && entities && entityId in entities) {\n        const componentReferences = entities[entityId].components\n        for (const componentId of componentReferences) {\n          if (components && componentId in components && ShapeComponents.includes(components[componentId].type)) {\n            out[entityId] = components[componentId] as ShapeComponent\n          }\n        }\n      }\n    }\n\n    return out\n  }\n)\n\n// export const getScriptsByEntityId = createSelector<\n//   RootState,\n//   Scene['entities'],\n//   Scene['components'],\n//   Record<string, ComponentDefinition<ComponentType.Script>>\n// >(\n//   getEntities,\n//   getComponents,\n//   (entities, components) => {\n//     const out: Record<string, ComponentDefinition<ComponentType.Script>> = {}\n\n//     for (let entityId in entities) {\n//       if (entityId && entities && entityId in entities) {\n//         const componentReferences = entities[entityId].components\n//         for (const componentId of componentReferences) {\n//           if (components && componentId in components && components[componentId].type === ComponentType.Script) {\n//             out[entityId] = components[componentId] as ComponentDefinition<ComponentType.Script>\n//           }\n//         }\n//       }\n//     }\n\n//     return out\n//   }\n// )\n\nexport const getComponentsByType = createSelector<RootState, Scene | null, Record<ComponentType, AnyComponent[]>>(\n  getCurrentScene,\n  scene => {\n    const out: Record<ComponentType, AnyComponent[]> = {} as Record<ComponentType, AnyComponent[]>\n\n    for (const key of Object.keys(ComponentType)) {\n      out[key as ComponentType] = []\n    }\n\n    if (scene) {\n      const components = scene.components\n      for (let component of Object.values(components)) {\n        if (!out[component.type]) {\n          out[component.type] = []\n        }\n        out[component.type].push(component)\n      }\n    }\n\n    return out\n  }\n)\n\nexport const getGLTFsByAssetId = createSelector<RootState, Scene | null, Record<string, ComponentDefinition<ComponentType.GLTFShape>>>(\n  getCurrentScene,\n  scene => {\n    if (!scene) return {}\n\n    const componentData = scene.components\n    let res: Record<string, ComponentDefinition<ComponentType.GLTFShape>> = {}\n\n    for (let key in componentData) {\n      const comp = componentData[key] as ComponentDefinition<ComponentType.GLTFShape>\n      if (comp.type === ComponentType.GLTFShape) {\n        res[comp.data.assetId] = comp\n      }\n    }\n\n    return res\n  }\n)\n\nexport const getCollectiblesByURL = createSelector<RootState, Scene | null, Record<string, ComponentDefinition<ComponentType.NFTShape>>>(\n  getCurrentScene,\n  scene => {\n    if (!scene) return {}\n\n    const componentData = scene.components\n    let res: Record<string, ComponentDefinition<ComponentType.NFTShape>> = {}\n\n    for (let key in componentData) {\n      const comp = componentData[key] as ComponentDefinition<ComponentType.NFTShape>\n      if (comp.type === ComponentType.NFTShape) {\n        res[comp.data.url] = comp\n      }\n    }\n\n    return res\n  }\n)\n\nexport const hasHistory = (state: RootState) => state.scene.past.length > 0\nexport const numItems = createSelector<RootState, Project | null, Scene | null, number>(\n  getCurrentProject,\n  getCurrentScene,\n  (project, scene) => {\n    if (!project || !scene) return 0\n    const numTransforms = Object.values(scene.components).reduce<number>(\n      (total, component) => (component.type === ComponentType.Transform ? total + 1 : total),\n      0\n    )\n    const numGrounds = project.layout.cols * project.layout.rows\n    return numTransforms - numGrounds\n  }\n)\n"]},"metadata":{},"sourceType":"module"}