{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\nimport { Logger } from '../../Misc/logger';\nimport { ThinEngine } from '../thinEngine';\n\nThinEngine.prototype.restoreSingleAttachment = function () {\n  var gl = this._gl;\n  this.bindAttachments([gl.BACK]);\n};\n\nThinEngine.prototype.buildTextureLayout = function (textureStatus) {\n  var gl = this._gl;\n  var result = [];\n\n  for (var i = 0; i < textureStatus.length; i++) {\n    if (textureStatus[i]) {\n      result.push(gl[\"COLOR_ATTACHMENT\" + i]);\n    } else {\n      result.push(gl.NONE);\n    }\n  }\n\n  return result;\n};\n\nThinEngine.prototype.bindAttachments = function (attachments) {\n  var gl = this._gl;\n  gl.drawBuffers(attachments);\n};\n\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (textures, disableGenerateMipMaps, onBeforeUnbind) {\n  if (disableGenerateMipMaps === void 0) {\n    disableGenerateMipMaps = false;\n  }\n\n  this._currentRenderTarget = null; // If MSAA, we need to bitblt back to main texture\n\n  var gl = this._gl;\n  var attachments = textures[0]._attachments;\n  var count = attachments.length;\n\n  if (textures[0]._MSAAFramebuffer) {\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, textures[0]._MSAAFramebuffer);\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, textures[0]._framebuffer);\n\n    for (var i = 0; i < count; i++) {\n      var texture = textures[i];\n\n      for (var j = 0; j < count; j++) {\n        attachments[j] = gl.NONE;\n      }\n\n      attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n      gl.readBuffer(attachments[i]);\n      gl.drawBuffers(attachments);\n      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n    }\n\n    for (var i = 0; i < count; i++) {\n      attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    }\n\n    gl.drawBuffers(attachments);\n  }\n\n  for (var i = 0; i < count; i++) {\n    var texture = textures[i];\n\n    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\n\n      gl.generateMipmap(gl.TEXTURE_2D);\n\n      this._bindTextureDirectly(gl.TEXTURE_2D, null);\n    }\n  }\n\n  if (onBeforeUnbind) {\n    if (textures[0]._MSAAFramebuffer) {\n      // Bind the correct framebuffer\n      this._bindUnboundFramebuffer(textures[0]._framebuffer);\n    }\n\n    onBeforeUnbind();\n  }\n\n  this._bindUnboundFramebuffer(null);\n};\n\nThinEngine.prototype.createMultipleRenderTarget = function (size, options) {\n  var generateMipMaps = false;\n  var generateDepthBuffer = true;\n  var generateStencilBuffer = false;\n  var generateDepthTexture = false;\n  var textureCount = 1;\n  var defaultType = 0;\n  var defaultSamplingMode = 3;\n  var types = new Array();\n  var samplingModes = new Array();\n\n  if (options !== undefined) {\n    generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n    generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n    textureCount = options.textureCount || 1;\n\n    if (options.types) {\n      types = options.types;\n    }\n\n    if (options.samplingModes) {\n      samplingModes = options.samplingModes;\n    }\n  }\n\n  var gl = this._gl; // Create the framebuffer\n\n  var framebuffer = gl.createFramebuffer();\n\n  this._bindUnboundFramebuffer(framebuffer);\n\n  var width = size.width || size;\n  var height = size.height || size;\n  var textures = [];\n  var attachments = [];\n\n  var depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);\n\n  for (var i = 0; i < textureCount; i++) {\n    var samplingMode = samplingModes[i] || defaultSamplingMode;\n    var type = types[i] || defaultType;\n\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n\n    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    var attachment = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    textures.push(texture);\n    attachments.push(attachment);\n    gl.activeTexture(gl[\"TEXTURE\" + i]);\n    gl.bindTexture(gl.TEXTURE_2D, texture._webGLTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), width, height, 0, gl.RGBA, this._getWebGLTextureType(type), null);\n    gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._webGLTexture, 0);\n\n    if (generateMipMaps) {\n      this._gl.generateMipmap(this._gl.TEXTURE_2D);\n    } // Unbind\n\n\n    this._bindTextureDirectly(gl.TEXTURE_2D, null);\n\n    texture._framebuffer = framebuffer;\n    texture._depthStencilBuffer = depthStencilBuffer;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture._generateDepthBuffer = generateDepthBuffer;\n    texture._generateStencilBuffer = generateStencilBuffer;\n    texture._attachments = attachments;\n    texture._textureArray = textures;\n\n    this._internalTexturesCache.push(texture);\n  }\n\n  if (generateDepthTexture && this._caps.depthTextureExtension) {\n    // Depth texture\n    var depthTexture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, depthTexture._webGLTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, this.webGLVersion < 2 ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT16, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._webGLTexture, 0);\n    depthTexture._framebuffer = framebuffer;\n    depthTexture.baseWidth = width;\n    depthTexture.baseHeight = height;\n    depthTexture.width = width;\n    depthTexture.height = height;\n    depthTexture.isReady = true;\n    depthTexture.samples = 1;\n    depthTexture.generateMipMaps = generateMipMaps;\n    depthTexture.samplingMode = gl.NEAREST;\n    depthTexture._generateDepthBuffer = generateDepthBuffer;\n    depthTexture._generateStencilBuffer = generateStencilBuffer;\n    textures.push(depthTexture);\n\n    this._internalTexturesCache.push(depthTexture);\n  }\n\n  gl.drawBuffers(attachments);\n\n  this._bindUnboundFramebuffer(null);\n\n  this.resetTextureCache();\n  return textures;\n};\n\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (textures, samples) {\n  if (this.webGLVersion < 2 || !textures) {\n    return 1;\n  }\n\n  if (textures[0].samples === samples) {\n    return samples;\n  }\n\n  var count = textures[0]._attachments.length;\n\n  if (count === 0) {\n    return 1;\n  }\n\n  var gl = this._gl;\n  samples = Math.min(samples, this.getCaps().maxMSAASamples); // Dispose previous render buffers\n\n  if (textures[0]._depthStencilBuffer) {\n    gl.deleteRenderbuffer(textures[0]._depthStencilBuffer);\n    textures[0]._depthStencilBuffer = null;\n  }\n\n  if (textures[0]._MSAAFramebuffer) {\n    gl.deleteFramebuffer(textures[0]._MSAAFramebuffer);\n    textures[0]._MSAAFramebuffer = null;\n  }\n\n  for (var i = 0; i < count; i++) {\n    if (textures[i]._MSAARenderBuffer) {\n      gl.deleteRenderbuffer(textures[i]._MSAARenderBuffer);\n      textures[i]._MSAARenderBuffer = null;\n    }\n  }\n\n  if (samples > 1 && gl.renderbufferStorageMultisample) {\n    var framebuffer = gl.createFramebuffer();\n\n    if (!framebuffer) {\n      throw new Error(\"Unable to create multi sampled framebuffer\");\n    }\n\n    this._bindUnboundFramebuffer(framebuffer);\n\n    var depthStencilBuffer = this._setupFramebufferDepthAttachments(textures[0]._generateStencilBuffer, textures[0]._generateDepthBuffer, textures[0].width, textures[0].height, samples);\n\n    var attachments = [];\n\n    for (var i = 0; i < count; i++) {\n      var texture = textures[i];\n      var attachment = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n      var colorRenderbuffer = gl.createRenderbuffer();\n\n      if (!colorRenderbuffer) {\n        throw new Error(\"Unable to create multi sampled framebuffer\");\n      }\n\n      gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbuffer);\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, this._getRGBAMultiSampleBufferFormat(texture.type), texture.width, texture.height);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, colorRenderbuffer);\n      texture._MSAAFramebuffer = framebuffer;\n      texture._MSAARenderBuffer = colorRenderbuffer;\n      texture.samples = samples;\n      texture._depthStencilBuffer = depthStencilBuffer;\n      gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n      attachments.push(attachment);\n    }\n\n    gl.drawBuffers(attachments);\n  } else {\n    this._bindUnboundFramebuffer(textures[0]._framebuffer);\n  }\n\n  this._bindUnboundFramebuffer(null);\n\n  return samples;\n};","map":null,"metadata":{},"sourceType":"module"}