{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { Scalar } from \"../../Maths/math.scalar\";\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\nimport { ToLinearSpace } from '../../Maths/math.constants';\nimport { Color3 } from '../../Maths/math.color';\n\nvar FileFaceOrientation =\n/** @class */\nfunction () {\n  function FileFaceOrientation(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {\n    this.name = name;\n    this.worldAxisForNormal = worldAxisForNormal;\n    this.worldAxisForFileX = worldAxisForFileX;\n    this.worldAxisForFileY = worldAxisForFileY;\n  }\n\n  return FileFaceOrientation;\n}();\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\n\n\nvar CubeMapToSphericalPolynomialTools =\n/** @class */\nfunction () {\n  function CubeMapToSphericalPolynomialTools() {}\n  /**\r\n   * Converts a texture to the according Spherical Polynomial data.\r\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n   *\r\n   * @param texture The texture to extract the information from.\r\n   * @return The Spherical Polynomial data.\r\n   */\n\n\n  CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial = function (texture) {\n    if (!texture.isCube) {\n      // Only supports cube Textures currently.\n      return null;\n    }\n\n    var size = texture.getSize().width;\n    var right = texture.readPixels(0);\n    var left = texture.readPixels(1);\n    var up;\n    var down;\n\n    if (texture.isRenderTarget) {\n      up = texture.readPixels(3);\n      down = texture.readPixels(2);\n    } else {\n      up = texture.readPixels(2);\n      down = texture.readPixels(3);\n    }\n\n    var front = texture.readPixels(4);\n    var back = texture.readPixels(5);\n    var gammaSpace = texture.gammaSpace; // Always read as RGBA.\n\n    var format = 5;\n    var type = 0;\n\n    if (texture.textureType == 1 || texture.textureType == 2) {\n      type = 1;\n    }\n\n    var cubeInfo = {\n      size: size,\n      right: right,\n      left: left,\n      up: up,\n      down: down,\n      front: front,\n      back: back,\n      format: format,\n      type: type,\n      gammaSpace: gammaSpace\n    };\n    return this.ConvertCubeMapToSphericalPolynomial(cubeInfo);\n  };\n  /**\r\n   * Converts a cubemap to the according Spherical Polynomial data.\r\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n   *\r\n   * @param cubeInfo The Cube map to extract the information from.\r\n   * @return The Spherical Polynomial data.\r\n   */\n\n\n  CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial = function (cubeInfo) {\n    var sphericalHarmonics = new SphericalHarmonics();\n    var totalSolidAngle = 0.0; // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\n\n    var du = 2.0 / cubeInfo.size;\n    var dv = du; // The (u,v) of the first texel is half a texel from the corner (-1,-1).\n\n    var minUV = du * 0.5 - 1.0;\n\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var fileFace = this.FileFaces[faceIndex];\n      var dataArray = cubeInfo[fileFace.name];\n      var v = minUV; // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\n      // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\n      // Because SP is still linear, so summation is fine in that basis.\n\n      var stride = cubeInfo.format === 5 ? 4 : 3;\n\n      for (var y = 0; y < cubeInfo.size; y++) {\n        var u = minUV;\n\n        for (var x = 0; x < cubeInfo.size; x++) {\n          // World direction (not normalised)\n          var worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\n          worldDirection.normalize();\n          var deltaSolidAngle = Math.pow(1.0 + u * u + v * v, -3.0 / 2.0);\n          var r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\n          var g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\n          var b = dataArray[y * cubeInfo.size * stride + x * stride + 2]; // Prevent NaN harmonics with extreme HDRI data.\n\n          if (isNaN(r)) {\n            r = 0;\n          }\n\n          if (isNaN(g)) {\n            g = 0;\n          }\n\n          if (isNaN(b)) {\n            b = 0;\n          } // Handle Integer types.\n\n\n          if (cubeInfo.type === 0) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n          } // Handle Gamma space textures.\n\n\n          if (cubeInfo.gammaSpace) {\n            r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\n            g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\n            b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\n          } // Prevent to explode in case of really high dynamic ranges.\n          // sh 3 would not be enough to accurately represent it.\n\n\n          var max = 4096;\n          r = Scalar.Clamp(r, 0, max);\n          g = Scalar.Clamp(g, 0, max);\n          b = Scalar.Clamp(b, 0, max);\n          var color = new Color3(r, g, b);\n          sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\n          totalSolidAngle += deltaSolidAngle;\n          u += du;\n        }\n\n        v += dv;\n      }\n    } // Solid angle for entire sphere is 4*pi\n\n\n    var sphereSolidAngle = 4.0 * Math.PI; // Adjust the solid angle to allow for how many faces we processed.\n\n    var facesProcessed = 6.0;\n    var expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0; // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\n    // This is needed because the numerical integration over the cube uses a\n    // small angle approximation of solid angle for each texel (see deltaSolidAngle),\n    // and also to compensate for accumulative error due to float precision in the summation.\n\n    var correctionFactor = expectedSolidAngle / totalSolidAngle;\n    sphericalHarmonics.scaleInPlace(correctionFactor);\n    sphericalHarmonics.convertIncidentRadianceToIrradiance();\n    sphericalHarmonics.convertIrradianceToLambertianRadiance();\n    return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n  };\n\n  CubeMapToSphericalPolynomialTools.FileFaces = [new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)) // -Z bottom\n  ];\n  return CubeMapToSphericalPolynomialTools;\n}();\n\nexport { CubeMapToSphericalPolynomialTools };","map":null,"metadata":{},"sourceType":"module"}