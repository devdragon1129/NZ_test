{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { PlaneBuilder } from \"../Meshes/Builders/planeBuilder\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\n/**\r\n * Single plane drag gizmo\r\n */\n\nvar PlaneDragGizmo =\n/** @class */\nfunction (_super) {\n  __extends(PlaneDragGizmo, _super);\n  /**\r\n   * Creates a PlaneDragGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param dragPlaneNormal The axis normal to which the gizmo will be able to drag on\r\n   * @param color The color of the gizmo\r\n   */\n\n\n  function PlaneDragGizmo(dragPlaneNormal, color, gizmoLayer, parent) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    var _a;\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._pointerObserver = null;\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\n\n    _this.snapDistance = 0;\n    /**\r\n     * Event that fires each time the gizmo snaps to a new location.\r\n     * * snapDistance is the the change in distance\r\n     */\n\n    _this.onSnapObservable = new Observable();\n    _this._isEnabled = false;\n    _this._parent = null;\n    _this._dragging = false;\n    _this._parent = parent; // Create Material\n\n    _this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._coloredMaterial.diffuseColor = color;\n    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    _this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._hoverMaterial.diffuseColor = Color3.Yellow();\n    _this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._disableMaterial.diffuseColor = Color3.Gray();\n    _this._disableMaterial.alpha = 0.4; // Build plane mesh on root node\n\n    _this._gizmoMesh = PlaneDragGizmo._CreatePlane(gizmoLayer.utilityLayerScene, _this._coloredMaterial);\n\n    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(dragPlaneNormal));\n\n    _this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n\n    _this._gizmoMesh.parent = _this._rootMesh;\n    var currentSnapDragDistance = 0;\n    var tmpVector = new Vector3();\n    var tmpSnapEvent = {\n      snapDistance: 0\n    }; // Add dragPlaneNormal drag behavior to handle events when the gizmo is dragged\n\n    _this.dragBehavior = new PointerDragBehavior({\n      dragPlaneNormal: dragPlaneNormal\n    });\n    _this.dragBehavior.moveAttached = false;\n\n    _this._rootMesh.addBehavior(_this.dragBehavior);\n\n    _this.dragBehavior.onDragObservable.add(function (event) {\n      if (_this.attachedNode) {\n        // Keep world translation and use it to update world transform\n        // if the node has parent, the local transform properties (position, rotation, scale)\n        // will be recomputed in _matrixChanged function\n        // Snapping logic\n        if (_this.snapDistance == 0) {\n          _this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);\n        } else {\n          currentSnapDragDistance += event.dragDistance;\n\n          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {\n            var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);\n            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;\n            event.delta.normalizeToRef(tmpVector);\n            tmpVector.scaleInPlace(_this.snapDistance * dragSteps);\n\n            _this.attachedNode.getWorldMatrix().addTranslationFromFloats(tmpVector.x, tmpVector.y, tmpVector.z);\n\n            tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;\n\n            _this.onSnapObservable.notifyObservers(tmpSnapEvent);\n          }\n        }\n\n        _this._matrixChanged();\n      }\n    });\n\n    _this.dragBehavior.onDragStartObservable.add(function () {\n      _this._dragging = true;\n    });\n\n    _this.dragBehavior.onDragEndObservable.add(function () {\n      _this._dragging = false;\n    });\n\n    var light = gizmoLayer._getSharedGizmoLight();\n\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));\n    var cache = {\n      gizmoMeshes: _this._gizmoMesh.getChildMeshes(),\n      colliderMeshes: _this._gizmoMesh.getChildMeshes(),\n      material: _this._coloredMaterial,\n      hoverMaterial: _this._hoverMaterial,\n      disableMaterial: _this._disableMaterial,\n      active: false\n    };\n    (_a = _this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(_this._gizmoMesh, cache);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a;\n\n      if (_this._customMeshSet) {\n        return;\n      }\n\n      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) != -1);\n\n      if (!_this._parent) {\n        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;\n        cache.gizmoMeshes.forEach(function (m) {\n          m.material = material;\n        });\n      }\n    });\n    return _this;\n  }\n  /** @hidden */\n\n\n  PlaneDragGizmo._CreatePlane = function (scene, material) {\n    var plane = new TransformNode(\"plane\", scene); //make sure plane is double sided\n\n    var dragPlane = PlaneBuilder.CreatePlane(\"dragPlane\", {\n      width: .1375,\n      height: .1375,\n      sideOrientation: 2\n    }, scene);\n    dragPlane.material = material;\n    dragPlane.parent = plane;\n    return plane;\n  };\n\n  PlaneDragGizmo.prototype._attachedNodeChanged = function (value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  };\n\n  Object.defineProperty(PlaneDragGizmo.prototype, \"isEnabled\", {\n    get: function get() {\n      return this._isEnabled;\n    },\n\n    /**\r\n     * If the gizmo is enabled\r\n     */\n    set: function set(value) {\n      this._isEnabled = value;\n\n      if (!value) {\n        this.attachedNode = null;\n      } else {\n        if (this._parent) {\n          this.attachedNode = this._parent.attachedNode;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n  PlaneDragGizmo.prototype.dispose = function () {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n\n    _super.prototype.dispose.call(this);\n\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function (matl) {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n  };\n\n  return PlaneDragGizmo;\n}(Gizmo);\n\nexport { PlaneDragGizmo };","map":null,"metadata":{},"sourceType":"module"}