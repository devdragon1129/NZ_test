{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { Quaternion } from \"../../Maths/math.vector\";\nimport { Axis } from '../../Maths/math.axis';\nimport { Tools } from '../../Misc/tools';\n/**\r\n * Listen to mouse events to control the camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\n\nvar FlyCameraMouseInput =\n/** @class */\nfunction () {\n  /**\r\n   * Listen to mouse events to control the camera.\r\n   * @param touchEnabled Define if touch is enabled. (Default is true.)\r\n   * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n   */\n  function FlyCameraMouseInput(touchEnabled) {\n    if (touchEnabled === void 0) {\n      touchEnabled = true;\n    }\n    /**\r\n     * Defines the buttons associated with the input to handle camera rotation.\r\n     */\n\n\n    this.buttons = [0, 1, 2];\n    /**\r\n     * Assign buttons for Yaw control.\r\n     */\n\n    this.buttonsYaw = [-1, 0, 1];\n    /**\r\n    * Assign buttons for Pitch control.\r\n    */\n\n    this.buttonsPitch = [-1, 0, 1];\n    /**\r\n    * Assign buttons for Roll control.\r\n    */\n\n    this.buttonsRoll = [2];\n    /**\r\n     * Detect if any button is being pressed while mouse is moved.\r\n     * -1 = Mouse locked.\r\n     * 0 = Left button.\r\n     * 1 = Middle Button.\r\n     * 2 = Right Button.\r\n     */\n\n    this.activeButton = -1;\n    /**\r\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\r\n     * Higher values reduce its sensitivity.\r\n     */\n\n    this.angularSensibility = 1000.0;\n    this.previousPosition = null;\n  }\n  /**\r\n   * Attach the mouse control to the HTML DOM element.\r\n   * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\r\n   */\n\n\n  FlyCameraMouseInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this;\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.noPreventDefault = noPreventDefault;\n    this._observer = this.camera.getScene().onPointerObservable.add(function (p, s) {\n      _this._pointerInput(p, s);\n    }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE); // Correct Roll by rate, if enabled.\n\n    this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(function () {\n      if (_this.camera.rollCorrect) {\n        _this.camera.restoreRoll(_this.camera.rollCorrect);\n      }\n    });\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  FlyCameraMouseInput.prototype.detachControl = function (ignored) {\n    if (this._observer) {\n      this.camera.getScene().onPointerObservable.remove(this._observer);\n      this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\n      this._observer = null;\n      this._rollObserver = null;\n      this.previousPosition = null;\n      this.noPreventDefault = undefined;\n    }\n  };\n  /**\r\n   * Gets the class name of the current input.\r\n   * @returns the class name.\r\n   */\n\n\n  FlyCameraMouseInput.prototype.getClassName = function () {\n    return \"FlyCameraMouseInput\";\n  };\n  /**\r\n   * Get the friendly name associated with the input class.\r\n   * @returns the input's friendly name.\r\n   */\n\n\n  FlyCameraMouseInput.prototype.getSimpleName = function () {\n    return \"mouse\";\n  }; // Track mouse movement, when the pointer is not locked.\n\n\n  FlyCameraMouseInput.prototype._pointerInput = function (p, s) {\n    var e = p.event;\n    var camera = this.camera;\n    var engine = camera.getEngine();\n\n    if (engine.isInVRExclusivePointerMode) {\n      return;\n    }\n\n    if (!this.touchEnabled && e.pointerType === \"touch\") {\n      return;\n    } // Mouse is moved but an unknown mouse button is pressed.\n\n\n    if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\n      return;\n    }\n\n    var srcElement = e.srcElement || e.target; // Mouse down.\n\n    if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\n      try {\n        srcElement.setPointerCapture(e.pointerId);\n      } catch (e) {// Nothing to do with the error. Execution continues.\n      }\n\n      this.previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      this.activeButton = e.button;\n\n      if (!this.noPreventDefault) {\n        e.preventDefault();\n        this.element.focus();\n      } // This is required to move while pointer button is down\n\n\n      if (engine.isPointerLock) {\n        this._onMouseMove(p.event);\n      }\n    } else // Mouse up.\n      if (p.type === PointerEventTypes.POINTERUP && srcElement) {\n        try {\n          srcElement.releasePointerCapture(e.pointerId);\n        } catch (e) {// Nothing to do with the error. Execution continues.\n        }\n\n        this.activeButton = -1;\n        this.previousPosition = null;\n\n        if (!this.noPreventDefault) {\n          e.preventDefault();\n        }\n      } else // Mouse move.\n        if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (!this.previousPosition) {\n            if (engine.isPointerLock) {\n              this._onMouseMove(p.event);\n            }\n\n            return;\n          }\n\n          var offsetX = e.clientX - this.previousPosition.x;\n          var offsetY = e.clientY - this.previousPosition.y;\n          this.rotateCamera(offsetX, offsetY);\n          this.previousPosition = {\n            x: e.clientX,\n            y: e.clientY\n          };\n\n          if (!this.noPreventDefault) {\n            e.preventDefault();\n          }\n        }\n  }; // Track mouse movement, when pointer is locked.\n\n\n  FlyCameraMouseInput.prototype._onMouseMove = function (e) {\n    var camera = this.camera;\n    var engine = camera.getEngine();\n\n    if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\n      return;\n    }\n\n    var offsetX = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0;\n    var offsetY = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;\n    this.rotateCamera(offsetX, offsetY);\n    this.previousPosition = null;\n\n    if (!this.noPreventDefault) {\n      e.preventDefault();\n    }\n  };\n  /**\r\n   * Rotate camera by mouse offset.\r\n   */\n\n\n  FlyCameraMouseInput.prototype.rotateCamera = function (offsetX, offsetY) {\n    var _this = this;\n\n    var camera = this.camera;\n    var scene = this.camera.getScene();\n\n    if (scene.useRightHandedSystem) {\n      offsetX *= -1;\n    }\n\n    if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\n      offsetX *= -1;\n    }\n\n    var x = offsetX / this.angularSensibility;\n    var y = offsetY / this.angularSensibility; // Initialize to current rotation.\n\n    var currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\n    var rotationChange; // Pitch.\n\n    if (this.buttonsPitch.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.X, y); // Apply Pitch to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange);\n    } // Yaw.\n\n\n    if (this.buttonsYaw.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Y, x); // Apply Yaw to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange); // Add Roll, if banked turning is enabled, within Roll limit.\n\n      var limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90Â° plus manual roll.\n\n      if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\n        var bankingDelta = camera.bankedTurnMultiplier * -x; // Apply change in Radians to vector Angle.\n\n        rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta); // Apply Yaw to quaternion.\n\n        currentRotation.multiplyInPlace(rotationChange);\n      }\n    } // Roll.\n\n\n    if (this.buttonsRoll.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Z, -x); // Track Rolling.\n\n      camera._trackRoll -= x; // Apply Pitch to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange);\n    } // Apply rotationQuaternion to Euler camera.rotation.\n\n\n    currentRotation.toEulerAnglesToRef(camera.rotation);\n  };\n\n  __decorate([serialize()], FlyCameraMouseInput.prototype, \"buttons\", void 0);\n\n  __decorate([serialize()], FlyCameraMouseInput.prototype, \"angularSensibility\", void 0);\n\n  return FlyCameraMouseInput;\n}();\n\nexport { FlyCameraMouseInput };\nCameraInputTypes[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;","map":null,"metadata":{},"sourceType":"module"}