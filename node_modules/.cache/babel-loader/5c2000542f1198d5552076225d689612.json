{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar eth_crypto_1 = require(\"eth-crypto\");\n\nvar eth_1 = require(\"web3x/eth\");\n\nvar address_1 = require(\"web3x/address\");\n\nvar SignatureValidator_1 = require(\"./contracts/SignatureValidator\");\n\nvar types_1 = require(\"./types\");\n\nvar utils_1 = require(\"./helper/utils\");\n\nvar blocks_1 = __importDefault(require(\"./helper/blocks\"));\n\nexports.VALID_SIGNATURE = 'VALID_SIGNATURE';\nvar PERSONAL_SIGNATURE_LENGTH = 132;\n\nvar Authenticator = /*#__PURE__*/function () {\n  function Authenticator() {\n    _classCallCheck(this, Authenticator);\n  }\n\n  _createClass(Authenticator, null, [{\n    key: \"validateSignature\",\n\n    /** Validate that the signature belongs to the Ethereum address */\n    value: function () {\n      var _validateSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(expectedFinalAuthority, authChain, provider) {\n        var dateToValidateExpirationInMillis,\n            currentAuthority,\n            _iterator,\n            _step,\n            authLink,\n            validator,\n            _yield$validator,\n            nextAuthority,\n            ok,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                dateToValidateExpirationInMillis = _args.length > 3 && _args[3] !== undefined ? _args[3] : Date.now();\n                currentAuthority = '';\n\n                if (Authenticator.isValidAuthChain(authChain)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  ok: false,\n                  message: 'ERROR: Malformed authChain'\n                });\n\n              case 4:\n                _iterator = _createForOfIteratorHelper(authChain);\n                _context.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 23;\n                  break;\n                }\n\n                authLink = _step.value;\n                validator = getValidatorByType(authLink.type);\n                _context.prev = 10;\n                _context.next = 13;\n                return validator(currentAuthority, authLink, {\n                  provider: provider,\n                  dateToValidateExpirationInMillis: dateToValidateExpirationInMillis\n                });\n\n              case 13:\n                _yield$validator = _context.sent;\n                nextAuthority = _yield$validator.nextAuthority;\n                currentAuthority = nextAuthority ? nextAuthority : '';\n                _context.next = 21;\n                break;\n\n              case 18:\n                _context.prev = 18;\n                _context.t0 = _context[\"catch\"](10);\n                return _context.abrupt(\"return\", {\n                  ok: false,\n                  message: \"ERROR. Link type: \".concat(authLink.type, \". \").concat(_context.t0.message, \".\")\n                });\n\n              case 21:\n                _context.next = 7;\n                break;\n\n              case 23:\n                _context.next = 28;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t1 = _context[\"catch\"](5);\n\n                _iterator.e(_context.t1);\n\n              case 28:\n                _context.prev = 28;\n\n                _iterator.f();\n\n                return _context.finish(28);\n\n              case 31:\n                ok = currentAuthority === expectedFinalAuthority;\n                return _context.abrupt(\"return\", {\n                  ok: ok,\n                  message: ok ? undefined : \"ERROR: Invalid final authority. Expected: \".concat(expectedFinalAuthority, \". Current \").concat(currentAuthority, \".\")\n                });\n\n              case 33:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[5, 25, 28, 31], [10, 18]]);\n      }));\n\n      function validateSignature(_x, _x2, _x3) {\n        return _validateSignature.apply(this, arguments);\n      }\n\n      return validateSignature;\n    }()\n  }, {\n    key: \"isValidAuthChain\",\n    value: function isValidAuthChain(authChain) {\n      var _iterator2 = _createForOfIteratorHelper(authChain.entries()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              index = _step2$value[0],\n              authLink = _step2$value[1];\n\n          // SIGNER should be the first one\n          if (index === 0 && authLink.type !== types_1.AuthLinkType.SIGNER) {\n            return false;\n          } // SIGNER should be unique\n\n\n          if (authLink.type === types_1.AuthLinkType.SIGNER && index !== 0) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"createEthereumMessageHash\",\n    value: function createEthereumMessageHash(msg) {\n      var msgWithPrefix = \"\\x19Ethereum Signed Message:\\n\".concat(msg.length).concat(msg);\n      var msgHash = eth_crypto_1.hash.keccak256(msgWithPrefix);\n      return msgHash;\n    } // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md\n\n  }, {\n    key: \"createEIP1271MessageHash\",\n    value: function createEIP1271MessageHash(msg) {\n      return eth_crypto_1.hash.keccak256([{\n        type: 'string',\n        value: msg\n      }]);\n    }\n  }, {\n    key: \"createSimpleAuthChain\",\n    value: function createSimpleAuthChain(finalPayload, ownerAddress, signature) {\n      return [{\n        type: types_1.AuthLinkType.SIGNER,\n        payload: ownerAddress,\n        signature: ''\n      }, {\n        type: getSignedIdentitySignatureType(signature),\n        payload: finalPayload,\n        signature: signature\n      }];\n    }\n  }, {\n    key: \"createAuthChain\",\n    value: function createAuthChain(ownerIdentity, ephemeralIdentity, ephemeralMinutesDuration, entityId) {\n      var expiration = utils_1.moveMinutes(ephemeralMinutesDuration);\n      var ephemeralMessage = Authenticator.getEphemeralMessage(ephemeralIdentity.address, expiration);\n      var firstSignature = Authenticator.createSignature(ownerIdentity, ephemeralMessage);\n      var secondSignature = Authenticator.createSignature(ephemeralIdentity, entityId);\n      var authChain = [{\n        type: types_1.AuthLinkType.SIGNER,\n        payload: ownerIdentity.address,\n        signature: ''\n      }, {\n        type: types_1.AuthLinkType.ECDSA_PERSONAL_EPHEMERAL,\n        payload: ephemeralMessage,\n        signature: firstSignature\n      }, {\n        type: types_1.AuthLinkType.ECDSA_PERSONAL_SIGNED_ENTITY,\n        payload: entityId,\n        signature: secondSignature\n      }];\n      return authChain;\n    }\n  }, {\n    key: \"initializeAuthChain\",\n    value: function () {\n      var _initializeAuthChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ethAddress, ephemeralIdentity, ephemeralMinutesDuration, signer) {\n        var expiration, ephemeralMessage, firstSignature, authChain;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                expiration = new Date();\n                expiration.setMinutes(expiration.getMinutes() + ephemeralMinutesDuration);\n                ephemeralMessage = Authenticator.getEphemeralMessage(ephemeralIdentity.address, expiration);\n                _context2.next = 5;\n                return signer(ephemeralMessage);\n\n              case 5:\n                firstSignature = _context2.sent;\n                authChain = [{\n                  type: types_1.AuthLinkType.SIGNER,\n                  payload: ethAddress,\n                  signature: ''\n                }, {\n                  type: getEphemeralSignatureType(firstSignature),\n                  payload: ephemeralMessage,\n                  signature: firstSignature\n                }];\n                return _context2.abrupt(\"return\", {\n                  ephemeralIdentity: ephemeralIdentity,\n                  expiration: expiration,\n                  authChain: authChain\n                });\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function initializeAuthChain(_x4, _x5, _x6, _x7) {\n        return _initializeAuthChain.apply(this, arguments);\n      }\n\n      return initializeAuthChain;\n    }()\n  }, {\n    key: \"signPayload\",\n    value: function signPayload(authIdentity, entityId) {\n      var secondSignature = Authenticator.createSignature(authIdentity.ephemeralIdentity, entityId);\n      return [].concat(_toConsumableArray(authIdentity.authChain), [{\n        type: types_1.AuthLinkType.ECDSA_PERSONAL_SIGNED_ENTITY,\n        payload: entityId,\n        signature: secondSignature\n      }]);\n    }\n  }, {\n    key: \"createSignature\",\n    value: function createSignature(identity, message) {\n      return eth_crypto_1.sign(identity.privateKey, Authenticator.createEthereumMessageHash(message));\n    }\n  }, {\n    key: \"ownerAddress\",\n    value: function ownerAddress(authChain) {\n      if (authChain.length > 0) {\n        if (authChain[0].type === types_1.AuthLinkType.SIGNER) {\n          return authChain[0].payload;\n        }\n      }\n\n      return 'Invalid-Owner-Address';\n    }\n  }, {\n    key: \"getEphemeralMessage\",\n    value: function getEphemeralMessage(ephemeralAddress, expiration) {\n      return \"Decentraland Login\\nEphemeral address: \".concat(ephemeralAddress, \"\\nExpiration: \").concat(expiration.toISOString());\n    }\n  }]);\n\n  return Authenticator;\n}();\n\nexports.Authenticator = Authenticator;\n\nexports.SIGNER_VALIDATOR = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_, authLink) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", {\n              nextAuthority: authLink.payload\n            });\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x8, _x9) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.ECDSA_SIGNED_ENTITY_VALIDATOR = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(authority, authLink) {\n    var signerAddress, expectedSignedAddress, actualSignedAddress;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            signerAddress = eth_crypto_1.recover(sanitizeSignature(authLink.signature), Authenticator.createEthereumMessageHash(authLink.payload));\n            expectedSignedAddress = authority.toLocaleLowerCase();\n            actualSignedAddress = signerAddress.toLocaleLowerCase();\n\n            if (!(expectedSignedAddress === actualSignedAddress)) {\n              _context4.next = 5;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", {\n              nextAuthority: authLink.payload\n            });\n\n          case 5:\n            throw new Error(\"Invalid signer address. Expected: \".concat(expectedSignedAddress, \". Actual: \").concat(actualSignedAddress));\n\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x10, _x11) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.ECDSA_PERSONAL_EPHEMERAL_VALIDATOR = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(authority, authLink, options) {\n    var _parseEmphemeralPaylo, message, ephemeralAddress, expiration, dateToValidateExpirationInMillis, signerAddress, expectedSignedAddress, actualSignedAddress;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _parseEmphemeralPaylo = parseEmphemeralPayload(authLink.payload), message = _parseEmphemeralPaylo.message, ephemeralAddress = _parseEmphemeralPaylo.ephemeralAddress, expiration = _parseEmphemeralPaylo.expiration;\n            dateToValidateExpirationInMillis = options.dateToValidateExpirationInMillis ? options.dateToValidateExpirationInMillis : Date.now();\n\n            if (!(expiration > dateToValidateExpirationInMillis)) {\n              _context5.next = 9;\n              break;\n            }\n\n            signerAddress = eth_crypto_1.recover(sanitizeSignature(authLink.signature), Authenticator.createEthereumMessageHash(message));\n            expectedSignedAddress = authority.toLocaleLowerCase();\n            actualSignedAddress = signerAddress.toLocaleLowerCase();\n\n            if (!(expectedSignedAddress === actualSignedAddress)) {\n              _context5.next = 8;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", {\n              nextAuthority: ephemeralAddress\n            });\n\n          case 8:\n            throw new Error(\"Invalid signer address. Expected: \".concat(expectedSignedAddress, \". Actual: \").concat(actualSignedAddress));\n\n          case 9:\n            throw new Error(\"Ephemeral key expired. Expiration: \".concat(expiration, \". Test: \").concat(dateToValidateExpirationInMillis));\n\n          case 10:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function (_x12, _x13, _x14) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.ECDSA_EIP_1654_EPHEMERAL_VALIDATOR = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(authority, authLink, options) {\n    var _a, _b, _parseEmphemeralPaylo2, message, ephemeralAddress, expiration, dateToValidateExpirationInMillis;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _parseEmphemeralPaylo2 = parseEmphemeralPayload(authLink.payload), message = _parseEmphemeralPaylo2.message, ephemeralAddress = _parseEmphemeralPaylo2.ephemeralAddress, expiration = _parseEmphemeralPaylo2.expiration;\n            dateToValidateExpirationInMillis = ((_a = options) === null || _a === void 0 ? void 0 : _a.dateToValidateExpirationInMillis) ? (_b = options) === null || _b === void 0 ? void 0 : _b.dateToValidateExpirationInMillis : Date.now();\n\n            if (!(expiration > dateToValidateExpirationInMillis)) {\n              _context6.next = 7;\n              break;\n            }\n\n            _context6.next = 5;\n            return isValidEIP1654Message(options.provider, authority, message, authLink.signature, dateToValidateExpirationInMillis);\n\n          case 5:\n            if (!_context6.sent) {\n              _context6.next = 7;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", {\n              nextAuthority: ephemeralAddress\n            });\n\n          case 7:\n            throw new Error(\"Ephemeral key expired. Expiration: \".concat(expiration, \". Test: \").concat(dateToValidateExpirationInMillis));\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function (_x15, _x16, _x17) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.EIP_1654_SIGNED_ENTITY_VALIDATOR = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(authority, authLink, options) {\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return isValidEIP1654Message(options.provider, authority, authLink.payload, authLink.signature, options.dateToValidateExpirationInMillis);\n\n          case 2:\n            if (!_context7.sent) {\n              _context7.next = 4;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", {\n              nextAuthority: authLink.payload\n            });\n\n          case 4:\n            throw new Error(\"Invalid validation\");\n\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n\n  return function (_x18, _x19, _x20) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar ERROR_VALIDATOR = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(_, __) {\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", {\n              error: 'Error Validator.'\n            });\n\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n\n  return function ERROR_VALIDATOR(_x21, _x22) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nfunction getEphemeralSignatureType(signature) {\n  if (signature.length === PERSONAL_SIGNATURE_LENGTH) {\n    return types_1.AuthLinkType.ECDSA_PERSONAL_EPHEMERAL;\n  } else {\n    return types_1.AuthLinkType.ECDSA_EIP_1654_EPHEMERAL;\n  }\n}\n\nexports.getEphemeralSignatureType = getEphemeralSignatureType;\n\nfunction getSignedIdentitySignatureType(signature) {\n  if (signature.length === PERSONAL_SIGNATURE_LENGTH) {\n    return types_1.AuthLinkType.ECDSA_PERSONAL_SIGNED_ENTITY;\n  } else {\n    return types_1.AuthLinkType.ECDSA_EIP_1654_SIGNED_ENTITY;\n  }\n}\n\nexports.getSignedIdentitySignatureType = getSignedIdentitySignatureType;\n\nfunction parseEmphemeralPayload(payload) {\n  // authLink payload structure: <human-readable message >\\nEphemeral address: <ephemeral-eth - address >\\nExpiration: <timestamp>\n  // authLink payload example: Decentraland Login\\nEphemeral address: 0x123456\\nExpiration: 2020 - 01 - 20T22: 57: 11.334Z\n  var message = payload.replace(/\\r/g, '');\n  var payloadParts = message.split('\\n');\n  var ephemeralAddress = payloadParts[1].substring('Ephemeral address: '.length);\n  var expirationString = payloadParts[2].substring('Expiration: '.length);\n  var expiration = Date.parse(expirationString);\n  return {\n    message: message,\n    ephemeralAddress: ephemeralAddress,\n    expiration: expiration\n  };\n}\n\nexports.parseEmphemeralPayload = parseEmphemeralPayload;\n\nfunction sanitizeSignature(signature) {\n  var sanitizedSignature = signature;\n  var version = parseInt(signature.slice(-2), 16);\n\n  if (version === 0 || version === 1) {\n    sanitizedSignature = signature.substr(0, signature.length - 2) + (version + 27).toString(16);\n  }\n\n  return sanitizedSignature;\n}\n\nfunction isValidEIP1654Message(_x23, _x24, _x25, _x26, _x27) {\n  return _isValidEIP1654Message.apply(this, arguments);\n}\n\nfunction _isValidEIP1654Message() {\n  _isValidEIP1654Message = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(provider, contractAddress, message, signature, dateToValidateExpirationInMillis) {\n    var ERC1654_MAGIC_VALUE, eth, signatureValidator, hashedMessage, result, dater, _yield$dater$getDate, block;\n\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n            ERC1654_MAGIC_VALUE = '0x1626ba7e';\n\n            if (provider) {\n              _context9.next = 3;\n              break;\n            }\n\n            throw new Error('Missing provider');\n\n          case 3:\n            eth = new eth_1.Eth(provider);\n            signatureValidator = new SignatureValidator_1.SignatureValidator(eth, address_1.Address.fromString(contractAddress));\n            hashedMessage = Authenticator.createEIP1271MessageHash(message);\n            _context9.next = 8;\n            return signatureValidator.methods.isValidSignature(hashedMessage, signature).call();\n\n          case 8:\n            result = _context9.sent;\n\n            if (!(result === ERC1654_MAGIC_VALUE)) {\n              _context9.next = 13;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", true);\n\n          case 13:\n            // check based on the dateToValidateExpirationInMillis\n            dater = new blocks_1.default(provider);\n            _context9.prev = 14;\n            _context9.next = 17;\n            return dater.getDate(dateToValidateExpirationInMillis, false);\n\n          case 17:\n            _yield$dater$getDate = _context9.sent;\n            block = _yield$dater$getDate.block;\n            _context9.next = 21;\n            return signatureValidator.methods.isValidSignature(hashedMessage, signature).call({}, block);\n\n          case 21:\n            result = _context9.sent;\n            _context9.next = 27;\n            break;\n\n          case 24:\n            _context9.prev = 24;\n            _context9.t0 = _context9[\"catch\"](14);\n            throw new Error(\"Invalid validation. Error: \".concat(_context9.t0.message));\n\n          case 27:\n            if (!(result === ERC1654_MAGIC_VALUE)) {\n              _context9.next = 29;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", true);\n\n          case 29:\n            throw new Error(\"Invalid validation. Expected: \".concat(ERC1654_MAGIC_VALUE, \". Actual: \").concat(result));\n\n          case 30:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[14, 24]]);\n  }));\n  return _isValidEIP1654Message.apply(this, arguments);\n}\n\nfunction getValidatorByType(type) {\n  switch (type) {\n    case types_1.AuthLinkType.SIGNER:\n      return exports.SIGNER_VALIDATOR;\n\n    case types_1.AuthLinkType.ECDSA_PERSONAL_EPHEMERAL:\n      return exports.ECDSA_PERSONAL_EPHEMERAL_VALIDATOR;\n\n    case types_1.AuthLinkType.ECDSA_PERSONAL_SIGNED_ENTITY:\n      return exports.ECDSA_SIGNED_ENTITY_VALIDATOR;\n\n    case types_1.AuthLinkType.ECDSA_EIP_1654_EPHEMERAL:\n      return exports.ECDSA_EIP_1654_EPHEMERAL_VALIDATOR;\n\n    case types_1.AuthLinkType.ECDSA_EIP_1654_SIGNED_ENTITY:\n      return exports.EIP_1654_SIGNED_ENTITY_VALIDATOR;\n\n    default:\n      return ERROR_VALIDATOR;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}