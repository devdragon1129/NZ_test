{"ast":null,"code":"import { Buffer, VertexBuffer } from \"../Meshes/buffer\";\nimport \"../Engines/Extensions/engine.alpha\";\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\nimport \"../Shaders/sprites.fragment\";\nimport \"../Shaders/sprites.vertex\";\n/**\r\n * Class used to render sprites.\r\n *\r\n * It can be used either to render Sprites or ThinSriptes with ThinEngine only.\r\n */\n\nvar SpriteRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new sprite Renderer\r\n   * @param engine defines the engine the renderer works with\r\n   * @param capacity defines the maximum allowed number of sprites\r\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n   * @param scene defines the hosting scene\r\n   */\n  function SpriteRenderer(engine, capacity, epsilon, scene) {\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    if (scene === void 0) {\n      scene = null;\n    }\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static undefined properties provided in this class.\r\n     * Default value is 2\r\n     */\n\n\n    this.blendMode = 2;\n    /**\r\n     * Gets or sets a boolean indicating if alpha mode is automatically\r\n     * reset.\r\n     */\n\n    this.autoResetAlpha = true;\n    /**\r\n     * Disables writing to the depth buffer when rendering the sprites.\r\n     * It can be handy to disable depth writing when using textures without alpha channel\r\n     * and setting some specific blend modes.\r\n     */\n\n    this.disableDepthWrite = false;\n    /**\r\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\r\n     */\n\n    this.fogEnabled = true;\n    this._useVAO = false;\n    this._useInstancing = false;\n    this._vertexBuffers = {};\n    this._capacity = capacity;\n    this._epsilon = epsilon;\n    this._engine = engine;\n    this._useInstancing = engine.getCaps().instancedArrays;\n    this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\n    this._scene = scene;\n\n    if (!this._useInstancing) {\n      var indices = [];\n      var index = 0;\n\n      for (var count = 0; count < capacity; count++) {\n        indices.push(index);\n        indices.push(index + 1);\n        indices.push(index + 2);\n        indices.push(index);\n        indices.push(index + 2);\n        indices.push(index + 3);\n        index += 4;\n      }\n\n      this._indexBuffer = engine.createIndexBuffer(indices);\n    } // VBO\n    // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\n    // 16 when using instances\n\n\n    this._vertexBufferSize = this._useInstancing ? 16 : 18;\n    this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n    this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n\n    var positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\n\n    var options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\n\n    var offset = 6;\n    var offsets;\n\n    if (this._useInstancing) {\n      var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\n    } else {\n      offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\n      offset += 2;\n    }\n\n    var inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\n\n    var cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\n\n    var colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    this._vertexBuffers[\"options\"] = options;\n    this._vertexBuffers[\"offsets\"] = offsets;\n    this._vertexBuffers[\"inverts\"] = inverts;\n    this._vertexBuffers[\"cellInfo\"] = cellInfo;\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors; // Effects\n\n    this._effectBase = this._engine.createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"], [\"diffuseSampler\"], \"\");\n\n    if (this._scene) {\n      this._effectFog = this._scene.getEngine().createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"], [\"diffuseSampler\"], \"#define FOG\");\n    }\n  }\n\n  Object.defineProperty(SpriteRenderer.prototype, \"capacity\", {\n    /**\r\n     * Gets the capacity of the manager\r\n     */\n    get: function get() {\n      return this._capacity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Render all child sprites\r\n   * @param sprites defines the list of sprites to render\r\n   * @param deltaTime defines the time since last frame\r\n   * @param viewMatrix defines the viewMatrix to use to render the sprites\r\n   * @param projectionMatrix defines the projectionMatrix to use to render the sprites\r\n   * @param customSpriteUpdate defines a custom function to update the sprites data before they render\r\n   */\n\n  SpriteRenderer.prototype.render = function (sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate) {\n    if (customSpriteUpdate === void 0) {\n      customSpriteUpdate = null;\n    }\n\n    if (!this.texture || !this.texture.isReady() || !sprites.length) {\n      return;\n    }\n\n    var effect = this._effectBase;\n    var shouldRenderFog = false;\n\n    if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\n      effect = this._effectFog;\n      shouldRenderFog = true;\n    } // Check\n\n\n    if (!effect.isReady()) {\n      return;\n    }\n\n    var engine = this._engine;\n    var useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\n    var baseSize = this.texture.getBaseSize(); // Sprites\n\n    var max = Math.min(this._capacity, sprites.length);\n    var offset = 0;\n    var noSprite = true;\n\n    for (var index = 0; index < max; index++) {\n      var sprite = sprites[index];\n\n      if (!sprite || !sprite.isVisible) {\n        continue;\n      }\n\n      noSprite = false;\n\n      sprite._animate(deltaTime);\n\n      this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n      if (!this._useInstancing) {\n        this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n        this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n        this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n      }\n    }\n\n    if (noSprite) {\n      return;\n    }\n\n    this._buffer.update(this._vertexData);\n\n    var culling = engine.depthCullingState.cull || true;\n    var zOffset = engine.depthCullingState.zOffset; // Handle Right Handed\n\n    if (useRightHandedSystem) {\n      this._scene.getEngine().setState(culling, zOffset, false, false);\n    } // Render\n\n\n    engine.enableEffect(effect);\n    effect.setTexture(\"diffuseSampler\", this.texture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", projectionMatrix); // Scene Info\n\n    if (shouldRenderFog) {\n      var scene = this._scene; // Fog\n\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n      effect.setColor3(\"vFogColor\", scene.fogColor);\n    }\n\n    if (this._useVAO) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n\n      engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    } // Draw order\n\n\n    engine.depthCullingState.depthFunc = 515;\n\n    if (!this.disableDepthWrite) {\n      effect.setBool(\"alphaTest\", true);\n      engine.setColorWrite(false);\n\n      if (this._useInstancing) {\n        engine.drawArraysType(8, 0, 4, offset);\n      } else {\n        engine.drawElementsType(0, 0, offset / 4 * 6);\n      }\n\n      engine.setColorWrite(true);\n      effect.setBool(\"alphaTest\", false);\n    }\n\n    engine.setAlphaMode(this.blendMode);\n\n    if (this._useInstancing) {\n      engine.drawArraysType(8, 0, 4, offset);\n    } else {\n      engine.drawElementsType(0, 0, offset / 4 * 6);\n    }\n\n    if (this.autoResetAlpha) {\n      engine.setAlphaMode(0);\n    } // Restore Right Handed\n\n\n    if (useRightHandedSystem) {\n      this._scene.getEngine().setState(culling, zOffset, false, true);\n    }\n\n    engine.unbindInstanceAttributes();\n  };\n\n  SpriteRenderer.prototype._appendSpriteVertex = function (index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate) {\n    var arrayOffset = index * this._vertexBufferSize;\n\n    if (offsetX === 0) {\n      offsetX = this._epsilon;\n    } else if (offsetX === 1) {\n      offsetX = 1 - this._epsilon;\n    }\n\n    if (offsetY === 0) {\n      offsetY = this._epsilon;\n    } else if (offsetY === 1) {\n      offsetY = 1 - this._epsilon;\n    }\n\n    if (customSpriteUpdate) {\n      customSpriteUpdate(sprite, baseSize);\n    } else {\n      if (!sprite.cellIndex) {\n        sprite.cellIndex = 0;\n      }\n\n      var rowSize = baseSize.width / this.cellWidth;\n      var offset = sprite.cellIndex / rowSize >> 0;\n      sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;\n      sprite._yOffset = offset * this.cellHeight / baseSize.height;\n      sprite._xSize = this.cellWidth;\n      sprite._ySize = this.cellHeight;\n    } // Positions\n\n\n    this._vertexData[arrayOffset] = sprite.position.x;\n    this._vertexData[arrayOffset + 1] = sprite.position.y;\n    this._vertexData[arrayOffset + 2] = sprite.position.z;\n    this._vertexData[arrayOffset + 3] = sprite.angle; // Options\n\n    this._vertexData[arrayOffset + 4] = sprite.width;\n    this._vertexData[arrayOffset + 5] = sprite.height;\n\n    if (!this._useInstancing) {\n      this._vertexData[arrayOffset + 6] = offsetX;\n      this._vertexData[arrayOffset + 7] = offsetY;\n    } else {\n      arrayOffset -= 2;\n    } // Inverts according to Right Handed\n\n\n    if (useRightHandedSystem) {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\n    } else {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\n    }\n\n    this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\n    this._vertexData[arrayOffset + 10] = sprite._xOffset;\n    this._vertexData[arrayOffset + 11] = sprite._yOffset;\n    this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\n    this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height; // Color\n\n    this._vertexData[arrayOffset + 14] = sprite.color.r;\n    this._vertexData[arrayOffset + 15] = sprite.color.g;\n    this._vertexData[arrayOffset + 16] = sprite.color.b;\n    this._vertexData[arrayOffset + 17] = sprite.color.a;\n  };\n  /**\r\n   * Release associated resources\r\n   */\n\n\n  SpriteRenderer.prototype.dispose = function () {\n    if (this._buffer) {\n      this._buffer.dispose();\n\n      this._buffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    }\n  };\n\n  return SpriteRenderer;\n}();\n\nexport { SpriteRenderer };","map":null,"metadata":{},"sourceType":"module"}