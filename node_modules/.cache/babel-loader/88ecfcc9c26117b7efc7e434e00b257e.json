{"ast":null,"code":"import { Vector2, Vector4 } from \"../../Maths/math.vector\";\nimport { Color4 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\nimport { EngineStore } from '../../Engines/engineStore';\n\nVertexData.CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {\n  var faceUV = fUV || new Array(3);\n  var faceColors = fColors;\n  var colors = [];\n  var wrap = wrp || false; // default face colors and UV if undefined\n\n  for (var f = 0; f < 3; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  var positions = polygon.getVerticesData(VertexBuffer.PositionKind);\n  var normals = polygon.getVerticesData(VertexBuffer.NormalKind);\n  var uvs = polygon.getVerticesData(VertexBuffer.UVKind);\n  var indices = polygon.getIndices();\n  var startIndex = positions.length / 9;\n  var disp = 0;\n  var distX = 0;\n  var distZ = 0;\n  var dist = 0;\n  var totalLen = 0;\n  var cumulate = [0];\n\n  if (wrap) {\n    for (var idx = startIndex; idx < positions.length / 3; idx += 4) {\n      distX = positions[3 * (idx + 2)] - positions[3 * idx];\n      distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\n      dist = Math.sqrt(distX * distX + distZ * distZ);\n      totalLen += dist;\n      cumulate.push(totalLen);\n    }\n  } // set face colours and textures\n\n\n  var idx = 0;\n  var face = 0;\n\n  for (var index = 0; index < normals.length; index += 3) {\n    //Edge Face  no. 1\n    if (Math.abs(normals[index + 1]) < 0.001) {\n      face = 1;\n    } //Top Face  no. 0\n\n\n    if (Math.abs(normals[index + 1] - 1) < 0.001) {\n      face = 0;\n    } //Bottom Face  no. 2\n\n\n    if (Math.abs(normals[index + 1] + 1) < 0.001) {\n      face = 2;\n    }\n\n    idx = index / 3;\n\n    if (face === 1) {\n      disp = idx - startIndex;\n\n      if (disp % 4 < 1.5) {\n        if (wrap) {\n          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;\n        } else {\n          uvs[2 * idx] = faceUV[face].x;\n        }\n      } else {\n        if (wrap) {\n          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;\n        } else {\n          uvs[2 * idx] = faceUV[face].z;\n        }\n      }\n\n      if (disp % 2 === 0) {\n        uvs[2 * idx + 1] = faceUV[face].w;\n      } else {\n        uvs[2 * idx + 1] = faceUV[face].y;\n      }\n    } else {\n      uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\n      uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\n    }\n\n    if (faceColors) {\n      colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\n    }\n  } // sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n\n  return vertexData;\n};\n\nMesh.CreatePolygon = function (name, shape, scene, holes, updatable, sideOrientation, earcutInjection) {\n  if (earcutInjection === void 0) {\n    earcutInjection = earcut;\n  }\n\n  var options = {\n    shape: shape,\n    holes: holes,\n    updatable: updatable,\n    sideOrientation: sideOrientation\n  };\n  return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\n};\n\nMesh.ExtrudePolygon = function (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {\n  if (earcutInjection === void 0) {\n    earcutInjection = earcut;\n  }\n\n  var options = {\n    shape: shape,\n    holes: holes,\n    depth: depth,\n    updatable: updatable,\n    sideOrientation: sideOrientation\n  };\n  return PolygonBuilder.ExtrudePolygon(name, options, scene, earcutInjection);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar PolygonBuilder =\n/** @class */\nfunction () {\n  function PolygonBuilder() {}\n  /**\r\n   * Creates a polygon mesh\r\n   * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n   * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n   * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n   * * Remember you can only change the shape positions, not their number when updating a polygon\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @param earcutInjection can be used to inject your own earcut reference\r\n   * @returns the polygon mesh\r\n   */\n\n\n  PolygonBuilder.CreatePolygon = function (name, options, scene, earcutInjection) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (earcutInjection === void 0) {\n      earcutInjection = earcut;\n    }\n\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    var shape = options.shape;\n    var holes = options.holes || [];\n    var depth = options.depth || 0;\n    var contours = [];\n    var hole = [];\n\n    for (var i = 0; i < shape.length; i++) {\n      contours[i] = new Vector2(shape[i].x, shape[i].z);\n    }\n\n    var epsilon = 0.00000001;\n\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\n      contours.pop();\n    }\n\n    var polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene, earcutInjection);\n\n    for (var hNb = 0; hNb < holes.length; hNb++) {\n      hole = [];\n\n      for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\n        hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\n      }\n\n      polygonTriangulation.addHole(hole);\n    }\n\n    var polygon = polygonTriangulation.build(options.updatable, depth);\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreatePolygon(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\n    vertexData.applyToMesh(polygon, options.updatable);\n    return polygon;\n  };\n  /**\r\n   * Creates an extruded polygon mesh, with depth in the Y direction.\r\n   * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n   * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @param earcutInjection can be used to inject your own earcut reference\r\n   * @returns the polygon mesh\r\n   */\n\n\n  PolygonBuilder.ExtrudePolygon = function (name, options, scene, earcutInjection) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (earcutInjection === void 0) {\n      earcutInjection = earcut;\n    }\n\n    return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\n  };\n\n  return PolygonBuilder;\n}();\n\nexport { PolygonBuilder };","map":null,"metadata":{},"sourceType":"module"}