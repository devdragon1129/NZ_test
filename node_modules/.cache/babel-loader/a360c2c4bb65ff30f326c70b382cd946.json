{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { VertexBuffer } from '../Meshes/buffer';\nimport { Viewport } from '../Maths/math.viewport';\nimport { Observable } from '../Misc/observable';\nimport { Effect } from './effect'; // Prevents ES6 Crash if not imported.\n\nimport \"../Shaders/postprocess.vertex\";\n/**\r\n * Helper class to render one or more effects.\r\n * You can access the previous rendering in your shader by declaring a sampler named textureSampler\r\n */\n\nvar EffectRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an effect renderer\r\n   * @param engine the engine to use for rendering\r\n   * @param options defines the options of the effect renderer\r\n   */\n  function EffectRenderer(engine, options) {\n    var _a;\n\n    if (options === void 0) {\n      options = EffectRenderer._DefaultOptions;\n    }\n\n    this.engine = engine;\n    this._fullscreenViewport = new Viewport(0, 0, 1, 1);\n    options = __assign(__assign({}, EffectRenderer._DefaultOptions), options);\n    this._vertexBuffers = (_a = {}, _a[VertexBuffer.PositionKind] = new VertexBuffer(engine, options.positions, VertexBuffer.PositionKind, false, false, 2), _a);\n    this._indexBuffer = engine.createIndexBuffer(options.indices);\n  }\n  /**\r\n   * Sets the current viewport in normalized coordinates 0-1\r\n   * @param viewport Defines the viewport to set (defaults to 0 0 1 1)\r\n   */\n\n\n  EffectRenderer.prototype.setViewport = function (viewport) {\n    if (viewport === void 0) {\n      viewport = this._fullscreenViewport;\n    }\n\n    this.engine.setViewport(viewport);\n  };\n  /**\r\n   * Binds the embedded attributes buffer to the effect.\r\n   * @param effect Defines the effect to bind the attributes for\r\n   */\n\n\n  EffectRenderer.prototype.bindBuffers = function (effect) {\n    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n  };\n  /**\r\n   * Sets the current effect wrapper to use during draw.\r\n   * The effect needs to be ready before calling this api.\r\n   * This also sets the default full screen position attribute.\r\n   * @param effectWrapper Defines the effect to draw with\r\n   */\n\n\n  EffectRenderer.prototype.applyEffectWrapper = function (effectWrapper) {\n    this.engine.depthCullingState.depthTest = false;\n    this.engine.stencilState.stencilTest = false;\n    this.engine.enableEffect(effectWrapper.effect);\n    this.bindBuffers(effectWrapper.effect);\n    effectWrapper.onApplyObservable.notifyObservers({});\n  };\n  /**\r\n   * Restores engine states\r\n   */\n\n\n  EffectRenderer.prototype.restoreStates = function () {\n    this.engine.depthCullingState.depthTest = true;\n    this.engine.stencilState.stencilTest = true;\n  };\n  /**\r\n   * Draws a full screen quad.\r\n   */\n\n\n  EffectRenderer.prototype.draw = function () {\n    this.engine.drawElementsType(0, 0, 6);\n  };\n\n  EffectRenderer.prototype.isRenderTargetTexture = function (texture) {\n    return texture.renderList !== undefined;\n  };\n  /**\r\n   * renders one or more effects to a specified texture\r\n   * @param effectWrapper the effect to renderer\r\n   * @param outputTexture texture to draw to, if null it will render to the screen.\r\n   */\n\n\n  EffectRenderer.prototype.render = function (effectWrapper, outputTexture) {\n    if (outputTexture === void 0) {\n      outputTexture = null;\n    } // Ensure effect is ready\n\n\n    if (!effectWrapper.effect.isReady()) {\n      return;\n    } // Reset state\n\n\n    this.setViewport();\n    var out = outputTexture === null ? null : this.isRenderTargetTexture(outputTexture) ? outputTexture.getInternalTexture() : outputTexture;\n\n    if (out) {\n      this.engine.bindFramebuffer(out);\n    }\n\n    this.applyEffectWrapper(effectWrapper);\n    this.draw();\n\n    if (out) {\n      this.engine.unBindFramebuffer(out);\n    }\n\n    this.restoreStates();\n  };\n  /**\r\n   * Disposes of the effect renderer\r\n   */\n\n\n  EffectRenderer.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      delete this._vertexBuffers[VertexBuffer.PositionKind];\n    }\n\n    if (this._indexBuffer) {\n      this.engine._releaseBuffer(this._indexBuffer);\n    }\n  }; // Fullscreen quad buffers by default.\n\n\n  EffectRenderer._DefaultOptions = {\n    positions: [1, 1, -1, 1, -1, -1, 1, -1],\n    indices: [0, 1, 2, 0, 2, 3]\n  };\n  return EffectRenderer;\n}();\n\nexport { EffectRenderer };\n/**\r\n * Wraps an effect to be used for rendering\r\n */\n\nvar EffectWrapper =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an effect to be renderer\r\n   * @param creationOptions options to create the effect\r\n   */\n  function EffectWrapper(creationOptions) {\n    var _this = this;\n    /**\r\n     * Event that is fired right before the effect is drawn (should be used to update uniforms)\r\n     */\n\n\n    this.onApplyObservable = new Observable();\n    var effectCreationOptions;\n    var uniformNames = creationOptions.uniformNames || [];\n\n    if (creationOptions.vertexShader) {\n      effectCreationOptions = {\n        fragmentSource: creationOptions.fragmentShader,\n        vertexSource: creationOptions.vertexShader,\n        spectorName: creationOptions.name || \"effectWrapper\"\n      };\n    } else {\n      // Default scale to use in post process vertex shader.\n      uniformNames.push(\"scale\");\n      effectCreationOptions = {\n        fragmentSource: creationOptions.fragmentShader,\n        vertex: \"postprocess\",\n        spectorName: creationOptions.name || \"effectWrapper\"\n      }; // Sets the default scale to identity for the post process vertex shader.\n\n      this.onApplyObservable.add(function () {\n        _this.effect.setFloat2(\"scale\", 1, 1);\n      });\n    }\n\n    var defines = creationOptions.defines ? creationOptions.defines.join(\"\\n\") : \"\";\n\n    if (creationOptions.useShaderStore) {\n      effectCreationOptions.fragment = effectCreationOptions.fragmentSource;\n\n      if (!effectCreationOptions.vertex) {\n        effectCreationOptions.vertex = effectCreationOptions.vertexSource;\n      }\n\n      delete effectCreationOptions.fragmentSource;\n      delete effectCreationOptions.vertexSource;\n      this.effect = creationOptions.engine.createEffect(effectCreationOptions.spectorName, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, defines, undefined, creationOptions.onCompiled);\n    } else {\n      this.effect = new Effect(effectCreationOptions, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, undefined, creationOptions.onCompiled);\n    }\n  }\n  /**\r\n  * Disposes of the effect wrapper\r\n  */\n\n\n  EffectWrapper.prototype.dispose = function () {\n    this.effect.dispose();\n  };\n\n  return EffectWrapper;\n}();\n\nexport { EffectWrapper };","map":null,"metadata":{},"sourceType":"module"}