{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { EngineStore } from \"../../../Engines/engineStore\";\nimport { ProceduralTexture } from \"./proceduralTexture\";\nimport { _TypeStore } from '../../../Misc/typeStore';\nimport \"../../../Shaders/noise.fragment\";\n/**\r\n * Class used to generate noise procedural textures\r\n */\n\nvar NoiseProceduralTexture =\n/** @class */\nfunction (_super) {\n  __extends(NoiseProceduralTexture, _super);\n  /**\r\n   * Creates a new NoiseProceduralTexture\r\n   * @param name defines the name fo the texture\r\n   * @param size defines the size of the texture (default is 256)\r\n   * @param scene defines the hosting scene\r\n   * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\r\n   * @param generateMipMaps defines if mipmaps must be generated (true by default)\r\n   */\n\n\n  function NoiseProceduralTexture(name, size, scene, fallbackTexture, generateMipMaps) {\n    if (size === void 0) {\n      size = 256;\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    var _this = _super.call(this, name, size, \"noise\", scene, fallbackTexture, generateMipMaps) || this;\n    /** Gets or sets the start time (default is 0) */\n\n\n    _this.time = 0.0;\n    /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\n\n    _this.brightness = 0.2;\n    /** Defines the number of octaves to process */\n\n    _this.octaves = 3;\n    /** Defines the level of persistence (0.8 by default) */\n\n    _this.persistence = 0.8;\n    /** Gets or sets animation speed factor (default is 1) */\n\n    _this.animationSpeedFactor = 1;\n    _this.autoClear = false;\n\n    _this._updateShaderUniforms();\n\n    return _this;\n  }\n\n  NoiseProceduralTexture.prototype._updateShaderUniforms = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\n    this.setFloat(\"brightness\", this.brightness);\n    this.setFloat(\"persistence\", this.persistence);\n    this.setFloat(\"timeScale\", this.time);\n  };\n\n  NoiseProceduralTexture.prototype._getDefines = function () {\n    return \"#define OCTAVES \" + (this.octaves | 0);\n  };\n  /** Generate the current state of the procedural texture */\n\n\n  NoiseProceduralTexture.prototype.render = function (useCameraPostProcess) {\n    this._updateShaderUniforms();\n\n    _super.prototype.render.call(this, useCameraPostProcess);\n  };\n  /**\r\n   * Serializes this noise procedural texture\r\n   * @returns a serialized noise procedural texture object\r\n   */\n\n\n  NoiseProceduralTexture.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\n    serializationObject.brightness = this.brightness;\n    serializationObject.octaves = this.octaves;\n    serializationObject.persistence = this.persistence;\n    serializationObject.animationSpeedFactor = this.animationSpeedFactor;\n    serializationObject.size = this.getSize().width;\n    serializationObject.generateMipMaps = this._generateMipMaps;\n    serializationObject.time = this.time;\n    return serializationObject;\n  };\n  /**\r\n   * Clone the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  NoiseProceduralTexture.prototype.clone = function () {\n    var textureSize = this.getSize();\n    var newTexture = new NoiseProceduralTexture(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : undefined, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // RenderTarget Texture\n\n    newTexture.coordinatesMode = this.coordinatesMode; // Noise Specifics\n\n    newTexture.brightness = this.brightness;\n    newTexture.octaves = this.octaves;\n    newTexture.persistence = this.persistence;\n    newTexture.animationSpeedFactor = this.animationSpeedFactor;\n    newTexture.time = this.time;\n    return newTexture;\n  };\n  /**\r\n   * Creates a NoiseProceduralTexture from parsed noise procedural texture data\r\n   * @param parsedTexture defines parsed texture data\r\n   * @param scene defines the current scene\r\n   * @param rootUrl defines the root URL containing noise procedural texture information\r\n   * @returns a parsed NoiseProceduralTexture\r\n   */\n\n\n  NoiseProceduralTexture.Parse = function (parsedTexture, scene) {\n    var _a;\n\n    var texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\n    texture.brightness = parsedTexture.brightness;\n    texture.octaves = parsedTexture.octaves;\n    texture.persistence = parsedTexture.persistence;\n    texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\n    texture.time = (_a = parsedTexture.time) !== null && _a !== void 0 ? _a : 0;\n    return texture;\n  };\n\n  return NoiseProceduralTexture;\n}(ProceduralTexture);\n\nexport { NoiseProceduralTexture };\n_TypeStore.RegisteredTypes[\"BABYLON.NoiseProceduralTexture\"] = NoiseProceduralTexture;","map":null,"metadata":{},"sourceType":"module"}