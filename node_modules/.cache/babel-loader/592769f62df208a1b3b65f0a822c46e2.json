{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\nimport { WebXRCamera } from \"./webXRCamera\";\nimport { WebXRState } from \"./webXRTypes\";\nimport { WebXRFeaturesManager } from \"./webXRFeaturesManager\";\nimport { Logger } from \"../Misc/logger\";\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/how_to/webxr_experience_helpers\r\n */\n\nvar WebXRExperienceHelper =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a WebXRExperienceHelper\r\n   * @param scene The scene the helper should be created in\r\n   */\n  function WebXRExperienceHelper(scene) {\n    var _this = this;\n\n    this.scene = scene;\n    this._nonVRCamera = null;\n    this._originalSceneAutoClear = true;\n    this._supported = false;\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\n\n    this.onInitialXRPoseSetObservable = new Observable();\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\n\n    this.onStateChangedObservable = new Observable();\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\n\n    this.state = WebXRState.NOT_IN_XR;\n    this.sessionManager = new WebXRSessionManager(scene);\n    this.camera = new WebXRCamera(\"\", scene, this.sessionManager);\n    this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\n    scene.onDisposeObservable.add(function () {\n      _this.exitXRAsync();\n    });\n  }\n  /**\r\n   * Creates the experience helper\r\n   * @param scene the scene to attach the experience helper to\r\n   * @returns a promise for the experience helper\r\n   */\n\n\n  WebXRExperienceHelper.CreateAsync = function (scene) {\n    var helper = new WebXRExperienceHelper(scene);\n    return helper.sessionManager.initializeAsync().then(function () {\n      helper._supported = true;\n      return helper;\n    }).catch(function (e) {\n      helper._setState(WebXRState.NOT_IN_XR);\n\n      helper.dispose();\n      throw e;\n    });\n  };\n  /**\r\n   * Disposes of the experience helper\r\n   */\n\n\n  WebXRExperienceHelper.prototype.dispose = function () {\n    this.camera.dispose();\n    this.onStateChangedObservable.clear();\n    this.onInitialXRPoseSetObservable.clear();\n    this.sessionManager.dispose();\n\n    if (this._nonVRCamera) {\n      this.scene.activeCamera = this._nonVRCamera;\n    }\n  };\n  /**\r\n   * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n   * @param sessionMode options for the XR session\r\n   * @param referenceSpaceType frame of reference of the XR session\r\n   * @param renderTarget the output canvas that will be used to enter XR mode\r\n   * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n   * @returns promise that resolves after xr mode has entered\r\n   */\n\n\n  WebXRExperienceHelper.prototype.enterXRAsync = function (sessionMode, referenceSpaceType, renderTarget, sessionCreationOptions) {\n    var _this = this;\n\n    if (renderTarget === void 0) {\n      renderTarget = this.sessionManager.getWebXRRenderTarget();\n    }\n\n    if (sessionCreationOptions === void 0) {\n      sessionCreationOptions = {};\n    }\n\n    if (!this._supported) {\n      throw \"WebXR not supported in this browser or environment\";\n    }\n\n    this._setState(WebXRState.ENTERING_XR);\n\n    if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\n      sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\n      sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\n    }\n\n    this.featuresManager.extendXRSessionInitObject(sessionCreationOptions); // we currently recommend \"unbounded\" space in AR (#7959)\n\n    if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\n      Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\n    } // make sure that the session mode is supported\n\n\n    return this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions).then(function () {\n      return _this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\n    }).then(function () {\n      return renderTarget.initializeXRLayerAsync(_this.sessionManager.session);\n    }).then(function () {\n      return _this.sessionManager.updateRenderStateAsync({\n        depthFar: _this.camera.maxZ,\n        depthNear: _this.camera.minZ,\n        baseLayer: renderTarget.xrLayer\n      });\n    }).then(function () {\n      // run the render loop\n      _this.sessionManager.runXRRenderLoop(); // Cache pre xr scene settings\n\n\n      _this._originalSceneAutoClear = _this.scene.autoClear;\n      _this._nonVRCamera = _this.scene.activeCamera;\n      _this.scene.activeCamera = _this.camera; // do not compensate when AR session is used\n\n      if (sessionMode !== \"immersive-ar\") {\n        _this._nonXRToXRCamera();\n      } else {\n        // Kept here, TODO - check if needed\n        _this.scene.autoClear = false;\n        _this.camera.compensateOnFirstFrame = false;\n      }\n\n      _this.sessionManager.onXRSessionEnded.addOnce(function () {\n        // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\n        _this.camera.rigCameras.forEach(function (c) {\n          c.outputRenderTarget = null;\n        }); // Restore scene settings\n\n\n        _this.scene.autoClear = _this._originalSceneAutoClear;\n        _this.scene.activeCamera = _this._nonVRCamera;\n\n        if (sessionMode !== \"immersive-ar\" && _this.camera.compensateOnFirstFrame) {\n          if (_this._nonVRCamera.setPosition) {\n            _this._nonVRCamera.setPosition(_this.camera.position);\n          } else {\n            _this._nonVRCamera.position.copyFrom(_this.camera.position);\n          }\n        }\n\n        _this._setState(WebXRState.NOT_IN_XR);\n      }); // Wait until the first frame arrives before setting state to in xr\n\n\n      _this.sessionManager.onXRFrameObservable.addOnce(function () {\n        _this._setState(WebXRState.IN_XR);\n      });\n\n      return _this.sessionManager;\n    }).catch(function (e) {\n      console.log(e);\n      console.log(e.message);\n\n      _this._setState(WebXRState.NOT_IN_XR);\n\n      throw e;\n    });\n  };\n  /**\r\n   * Exits XR mode and returns the scene to its original state\r\n   * @returns promise that resolves after xr mode has exited\r\n   */\n\n\n  WebXRExperienceHelper.prototype.exitXRAsync = function () {\n    // only exit if state is IN_XR\n    if (this.state !== WebXRState.IN_XR) {\n      return Promise.resolve();\n    }\n\n    this._setState(WebXRState.EXITING_XR);\n\n    return this.sessionManager.exitXRAsync();\n  };\n\n  WebXRExperienceHelper.prototype._nonXRToXRCamera = function () {\n    this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);\n    this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\n  };\n\n  WebXRExperienceHelper.prototype._setState = function (val) {\n    if (this.state === val) {\n      return;\n    }\n\n    this.state = val;\n    this.onStateChangedObservable.notifyObservers(this.state);\n  };\n\n  return WebXRExperienceHelper;\n}();\n\nexport { WebXRExperienceHelper };","map":null,"metadata":{},"sourceType":"module"}