{"ast":null,"code":"import { Scalar } from \"@babylonjs/core/Maths/math.scalar\";\nimport { SphericalHarmonics, SphericalPolynomial } from \"@babylonjs/core/Maths/sphericalPolynomial\";\nimport { Quaternion, Matrix } from \"@babylonjs/core/Maths/math.vector\";\nimport { RawCubeTexture } from \"@babylonjs/core/Materials/Textures/rawCubeTexture\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nvar NAME = \"EXT_lights_image_based\";\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\r\n */\n\nvar EXT_lights_image_based =\n/** @class */\nfunction () {\n  /** @hidden */\n  function EXT_lights_image_based(loader) {\n    /**\r\n     * The name of this extension.\r\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  EXT_lights_image_based.prototype.dispose = function () {\n    this._loader = null;\n    delete this._lights;\n  };\n  /** @hidden */\n\n\n  EXT_lights_image_based.prototype.onLoading = function () {\n    var extensions = this._loader.gltf.extensions;\n\n    if (extensions && extensions[this.name]) {\n      var extension = extensions[this.name];\n      this._lights = extension.lights;\n    }\n  };\n  /** @hidden */\n\n\n  EXT_lights_image_based.prototype.loadSceneAsync = function (context, scene) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, scene, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      promises.push(_this._loader.loadSceneAsync(context, scene));\n\n      _this._loader.logOpen(\"\" + extensionContext);\n\n      var light = ArrayItem.Get(extensionContext + \"/light\", _this._lights, extension.light);\n      promises.push(_this._loadLightAsync(\"/extensions/\" + _this.name + \"/lights/\" + extension.light, light).then(function (texture) {\n        _this._loader.babylonScene.environmentTexture = texture;\n      }));\n\n      _this._loader.logClose();\n\n      return Promise.all(promises).then(function () {});\n    });\n  };\n\n  EXT_lights_image_based.prototype._loadLightAsync = function (context, light) {\n    var _this = this;\n\n    if (!light._loaded) {\n      var promises = new Array();\n\n      this._loader.logOpen(\"\" + context);\n\n      var imageData_1 = new Array(light.specularImages.length);\n\n      var _loop_1 = function _loop_1(mipmap) {\n        var faces = light.specularImages[mipmap];\n        imageData_1[mipmap] = new Array(faces.length);\n\n        var _loop_2 = function _loop_2(face) {\n          var specularImageContext = context + \"/specularImages/\" + mipmap + \"/\" + face;\n\n          this_1._loader.logOpen(\"\" + specularImageContext);\n\n          var index = faces[face];\n          var image = ArrayItem.Get(specularImageContext, this_1._loader.gltf.images, index);\n          promises.push(this_1._loader.loadImageAsync(\"/images/\" + index, image).then(function (data) {\n            imageData_1[mipmap][face] = data;\n          }));\n\n          this_1._loader.logClose();\n        };\n\n        for (var face = 0; face < faces.length; face++) {\n          _loop_2(face);\n        }\n      };\n\n      var this_1 = this;\n\n      for (var mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\n        _loop_1(mipmap);\n      }\n\n      this._loader.logClose();\n\n      light._loaded = Promise.all(promises).then(function () {\n        var babylonTexture = new RawCubeTexture(_this._loader.babylonScene, null, light.specularImageSize);\n        babylonTexture.name = light.name || \"environment\";\n        light._babylonTexture = babylonTexture;\n\n        if (light.intensity != undefined) {\n          babylonTexture.level = light.intensity;\n        }\n\n        if (light.rotation) {\n          var rotation = Quaternion.FromArray(light.rotation); // Invert the rotation so that positive rotation is counter-clockwise.\n\n          if (!_this._loader.babylonScene.useRightHandedSystem) {\n            rotation = Quaternion.Inverse(rotation);\n          }\n\n          Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\n        }\n\n        var sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\n        sphericalHarmonics.scaleInPlace(light.intensity);\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\n        var sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics); // Compute the lod generation scale to fit exactly to the number of levels available.\n\n        var lodGenerationScale = (imageData_1.length - 1) / Scalar.Log2(light.specularImageSize);\n        return babylonTexture.updateRGBDAsync(imageData_1, sphericalPolynomial, lodGenerationScale);\n      });\n    }\n\n    return light._loaded.then(function () {\n      return light._babylonTexture;\n    });\n  };\n\n  return EXT_lights_image_based;\n}();\n\nexport { EXT_lights_image_based };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new EXT_lights_image_based(loader);\n});","map":null,"metadata":{},"sourceType":"module"}