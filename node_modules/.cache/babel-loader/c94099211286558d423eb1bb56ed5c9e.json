{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatLimitDefinition = void 0;\n\nvar ajv_1 = require(\"ajv\");\n\nvar codegen_1 = require(\"ajv/dist/compile/codegen\");\n\nvar ops = codegen_1.operators;\nvar KWDs = {\n  formatMaximum: {\n    okStr: \"<=\",\n    ok: ops.LTE,\n    fail: ops.GT\n  },\n  formatMinimum: {\n    okStr: \">=\",\n    ok: ops.GTE,\n    fail: ops.LT\n  },\n  formatExclusiveMaximum: {\n    okStr: \"<\",\n    ok: ops.LT,\n    fail: ops.GTE\n  },\n  formatExclusiveMinimum: {\n    okStr: \">\",\n    ok: ops.GT,\n    fail: ops.LTE\n  }\n};\nvar error = {\n  message: function message(_ref) {\n    var keyword = _ref.keyword,\n        schemaCode = _ref.schemaCode;\n    return codegen_1.str(_templateObject || (_templateObject = _taggedTemplateLiteral([\"should be \", \" \", \"\"])), KWDs[keyword].okStr, schemaCode);\n  },\n  params: function params(_ref2) {\n    var keyword = _ref2.keyword,\n        schemaCode = _ref2.schemaCode;\n    return codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{comparison: \", \", limit: \", \"}\"])), KWDs[keyword].okStr, schemaCode);\n  }\n};\nexports.formatLimitDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        schemaCode = cxt.schemaCode,\n        keyword = cxt.keyword,\n        it = cxt.it;\n    var opts = it.opts,\n        self = it.self;\n    if (!opts.validateFormats) return;\n    var fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n    if (fCxt.$data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      var fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      var fmt = gen.const(\"fmt\", codegen_1._(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), fmts, fCxt.schemaCode));\n      cxt.fail$data(codegen_1.or(codegen_1._(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"typeof \", \" != \\\"object\\\"\"])), fmt), codegen_1._(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" instanceof RegExp\"])), fmt), codegen_1._(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"typeof \", \".compare != \\\"function\\\"\"])), fmt), compareCode(fmt)));\n    }\n\n    function validateFormat() {\n      var format = fCxt.schema;\n      var fmtDef = self.formats[format];\n      if (!fmtDef || fmtDef === true) return;\n\n      if (typeof fmtDef != \"object\" || fmtDef instanceof RegExp || typeof fmtDef.compare != \"function\") {\n        throw new Error(\"\\\"\".concat(keyword, \"\\\": format \\\"\").concat(format, \"\\\" does not define \\\"compare\\\" function\"));\n      }\n\n      var fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? codegen_1._(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \"\", \"\"])), opts.code.formats, codegen_1.getProperty(format)) : undefined\n      });\n      cxt.fail$data(compareCode(fmt));\n    }\n\n    function compareCode(fmt) {\n      return codegen_1._(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".compare(\", \", \", \") \", \" 0\"])), fmt, data, schemaCode, KWDs[keyword].fail);\n    }\n  },\n  dependencies: [\"format\"]\n};\n\nvar formatLimitPlugin = function formatLimitPlugin(ajv) {\n  ajv.addKeyword(exports.formatLimitDefinition);\n  return ajv;\n};\n\nexports.default = formatLimitPlugin;","map":null,"metadata":{},"sourceType":"script"}