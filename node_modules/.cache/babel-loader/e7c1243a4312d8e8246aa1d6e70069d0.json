{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\nimport { Matrix } from '../../Maths/math.vector';\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\nimport \"../../Engines/Extensions/engine.videoTexture\";\n/**\r\n * This represents the smallest workload to use an already existing element (Canvas or Video) as a texture.\r\n * To be as efficient as possible depending on your constraints nothing aside the first upload\r\n * is automatically managed.\r\n * It is a cheap VideoTexture or DynamicTexture if you prefer to keep full control of the elements\r\n * in your application.\r\n *\r\n * As the update is not automatic, you need to call them manually.\r\n */\n\nvar HtmlElementTexture =\n/** @class */\nfunction (_super) {\n  __extends(HtmlElementTexture, _super);\n  /**\r\n   * Instantiates a HtmlElementTexture from the following parameters.\r\n   *\r\n   * @param name Defines the name of the texture\r\n   * @param element Defines the video or canvas the texture is filled with\r\n   * @param options Defines the other none mandatory texture creation options\r\n   */\n\n\n  function HtmlElementTexture(name, element, options) {\n    var _this = _super.call(this, options.scene || options.engine) || this;\n\n    if (!element || !options.engine && !options.scene) {\n      return _this;\n    }\n\n    options = __assign(__assign({}, HtmlElementTexture.DefaultOptions), options);\n    _this._generateMipMaps = options.generateMipMaps;\n    _this._samplingMode = options.samplingMode;\n    _this._textureMatrix = Matrix.Identity();\n    _this.name = name;\n    _this.element = element;\n    _this._isVideo = element instanceof HTMLVideoElement;\n    _this.anisotropicFilteringLevel = 1;\n\n    _this._createInternalTexture();\n\n    return _this;\n  }\n\n  HtmlElementTexture.prototype._createInternalTexture = function () {\n    var width = 0;\n    var height = 0;\n\n    if (this._isVideo) {\n      width = this.element.videoWidth;\n      height = this.element.videoHeight;\n    } else {\n      width = this.element.width;\n      height = this.element.height;\n    }\n\n    var engine = this._getEngine();\n\n    if (engine) {\n      this._texture = engine.createDynamicTexture(width, height, this._generateMipMaps, this._samplingMode);\n    }\n\n    this.update();\n  };\n  /**\r\n   * Returns the texture matrix used in most of the material.\r\n   */\n\n\n  HtmlElementTexture.prototype.getTextureMatrix = function () {\n    return this._textureMatrix;\n  };\n  /**\r\n   * Updates the content of the texture.\r\n   * @param invertY Defines wether the texture should be inverted on Y (false by default on video and true on canvas)\r\n   */\n\n\n  HtmlElementTexture.prototype.update = function (invertY) {\n    if (invertY === void 0) {\n      invertY = null;\n    }\n\n    var engine = this._getEngine();\n\n    if (this._texture == null || engine == null) {\n      return;\n    }\n\n    if (this._isVideo) {\n      var videoElement = this.element;\n\n      if (videoElement.readyState < videoElement.HAVE_CURRENT_DATA) {\n        return;\n      }\n\n      engine.updateVideoTexture(this._texture, videoElement, invertY === null ? true : invertY);\n    } else {\n      var canvasElement = this.element;\n      engine.updateDynamicTexture(this._texture, canvasElement, invertY === null ? true : invertY, false);\n    }\n  };\n\n  HtmlElementTexture.DefaultOptions = {\n    generateMipMaps: false,\n    samplingMode: 2,\n    engine: null,\n    scene: null\n  };\n  return HtmlElementTexture;\n}(BaseTexture);\n\nexport { HtmlElementTexture };","map":null,"metadata":{},"sourceType":"module"}