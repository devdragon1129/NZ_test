{"ast":null,"code":"import { Engine } from \"../../../Engines/engine\";\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\nimport { Texture } from \"../texture\";\nimport { DynamicTexture } from \"../dynamicTexture\";\nimport { Vector2 } from \"../../../Maths/math.vector\";\nimport { Color3, Color4 } from \"../../../Maths/math.color\";\nimport { TexturePackerFrame } from \"./frame\";\nimport { Logger } from \"../../../Misc/logger\";\nimport { Tools } from '../../../Misc/tools';\n/**\r\n* This is a support class that generates a series of packed texture sets.\r\n* @see https://doc.babylonjs.com/babylon101/materials\r\n*/\n\nvar TexturePacker =\n/** @class */\nfunction () {\n  /**\r\n  * Initializes a texture package series from an array of meshes or a single mesh.\r\n  * @param name The name of the package\r\n  * @param meshes The target meshes to compose the package from\r\n  * @param options The arguments that texture packer should follow while building.\r\n  * @param scene The scene which the textures are scoped to.\r\n  * @returns TexturePacker\r\n  */\n  function TexturePacker(name, meshes, options, scene) {\n    var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    this.name = name;\n    this.meshes = meshes;\n    this.scene = scene;\n    /**\r\n     * Run through the options and set what ever defaults are needed that where not declared.\r\n     */\n\n    this.options = options;\n    this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : ['ambientTexture', 'bumpTexture', 'diffuseTexture', 'emissiveTexture', 'lightmapTexture', 'opacityTexture', 'reflectionTexture', 'refractionTexture', 'specularTexture'];\n    this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;\n    this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;\n    this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker.LAYOUT_STRIP;\n\n    if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\n      this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;\n    }\n\n    this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;\n    this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;\n    this._expecting = 0;\n    this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;\n\n    if (this.options.fillBlanks === true) {\n      this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : 'black';\n    }\n\n    this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;\n    this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;\n    this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio); //Make it an even padding Number.\n\n    if (this._paddingValue % 2 !== 0) {\n      this._paddingValue++;\n    }\n\n    this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker.SUBUV_WRAP;\n\n    if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\n      this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1.0);\n    }\n\n    this.sets = {};\n    this.frames = [];\n    return this;\n  }\n  /**\r\n  * Starts the package process\r\n  * @param resolve The promises resolution function\r\n  * @returns TexturePacker\r\n  */\n\n\n  TexturePacker.prototype._createFrames = function (resolve) {\n    var _this = this;\n\n    var dtSize = this._calculateSize();\n\n    var dtUnits = new Vector2(1, 1).divide(dtSize);\n    var doneCount = 0;\n    var expecting = this._expecting;\n    var meshLength = this.meshes.length;\n    var sKeys = Object.keys(this.sets);\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var setName = sKeys[i];\n      var dt = new DynamicTexture(this.name + '.TexturePack.' + setName + 'Set', {\n        width: dtSize.x,\n        height: dtSize.y\n      }, this.scene, true, //Generate Mips\n      Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);\n      var dtx = dt.getContext();\n      dtx.fillStyle = 'rgba(0,0,0,0)';\n      dtx.fillRect(0, 0, dtSize.x, dtSize.y);\n      dt.update(false);\n      this.sets[setName] = dt;\n    }\n\n    var baseSize = this.options.frameSize || 256;\n    var padding = this._paddingValue;\n    var tcs = baseSize + 2 * padding;\n\n    var done = function done() {\n      _this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, _this.options.updateInputMeshes || false);\n    }; //Update the Textures\n\n\n    for (var i = 0; i < meshLength; i++) {\n      var m = this.meshes[i];\n      var mat = m.material;\n\n      var _loop_1 = function _loop_1(j) {\n        var tempTexture = new DynamicTexture('temp', tcs, this_1.scene, true);\n        var tcx = tempTexture.getContext();\n\n        var offset = this_1._getFrameOffset(i);\n\n        var updateDt = function updateDt() {\n          doneCount++;\n          tempTexture.update(false);\n          var iDat = tcx.getImageData(0, 0, tcs, tcs); //Update Set\n\n          var dt = _this.sets[setName];\n          var dtx = dt.getContext();\n          dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\n          tempTexture.dispose();\n          dt.update(false);\n\n          if (doneCount == expecting) {\n            done();\n            resolve();\n            return;\n          }\n        };\n\n        var setName = sKeys[j] || '_blank';\n\n        if (!mat || mat[setName] === null) {\n          tcx.fillStyle = 'rgba(0,0,0,0)';\n\n          if (this_1.options.fillBlanks) {\n            tcx.fillStyle = this_1.options.customFillColor;\n          }\n\n          tcx.fillRect(0, 0, tcs, tcs);\n          updateDt();\n        } else {\n          var setTexture = mat[setName];\n          var img_1 = new Image();\n\n          if (setTexture instanceof DynamicTexture) {\n            img_1.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\n          } else {\n            img_1.src = setTexture.url;\n          }\n\n          Tools.SetCorsBehavior(img_1.src, img_1);\n\n          img_1.onload = function () {\n            tcx.fillStyle = 'rgba(0,0,0,0)';\n            tcx.fillRect(0, 0, tcs, tcs);\n            tempTexture.update(false);\n            tcx.setTransform(1, 0, 0, -1, 0, 0);\n            var cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\n\n            switch (_this.options.paddingMode) {\n              //Wrap Mode\n              case 0:\n                for (var i_1 = 0; i_1 < 9; i_1++) {\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[i_1], padding + baseSize * cellOffsets[i_1 + 1] - tcs, baseSize, baseSize);\n                }\n\n                break;\n              //Extend Mode\n\n              case 1:\n                for (var i_2 = 0; i_2 < padding; i_2++) {\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, i_2 + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding * 2 - i_2, padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, i_2 - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, padding * 2 - i_2 - tcs, baseSize, baseSize);\n                }\n\n                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n              //Color Mode\n\n              case 2:\n                tcx.fillStyle = (_this.options.paddingColor || Color3.Black()).toHexString();\n                tcx.fillRect(0, 0, tcs, -tcs);\n                tcx.clearRect(padding, padding, baseSize, baseSize);\n                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n            }\n\n            tcx.setTransform(1, 0, 0, 1, 0, 0);\n            updateDt();\n          };\n        }\n      };\n\n      var this_1 = this; //Check if the material has the texture\n      //Create a temporary canvas the same size as 1 frame\n      //Then apply the texture to the center and the 8 offsets\n      //Copy the Context and place in the correct frame on the DT\n\n      for (var j = 0; j < sKeys.length; j++) {\n        _loop_1(j);\n      }\n    }\n  };\n  /**\r\n  * Calculates the Size of the Channel Sets\r\n  * @returns Vector2\r\n  */\n\n\n  TexturePacker.prototype._calculateSize = function () {\n    var meshLength = this.meshes.length || 0;\n    var baseSize = this.options.frameSize || 0;\n    var padding = this._paddingValue || 0;\n\n    switch (this.options.layout) {\n      case 0:\n        //STRIP_LAYOUT\n        return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\n        break;\n\n      case 1:\n        //POWER2\n        var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n        var size = baseSize * sqrtCount + 2 * padding * sqrtCount;\n        return new Vector2(size, size);\n        break;\n\n      case 2:\n        //COLNUM\n        var cols = this.options.colnum || 1;\n        var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n        return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\n        break;\n    }\n\n    return Vector2.Zero();\n  };\n  /**\r\n  * Calculates the UV data for the frames.\r\n  * @param baseSize the base frameSize\r\n  * @param padding the base frame padding\r\n  * @param dtSize size of the Dynamic Texture for that channel\r\n  * @param dtUnits is 1/dtSize\r\n  * @param update flag to update the input meshes\r\n  */\n\n\n  TexturePacker.prototype._calculateMeshUVFrames = function (baseSize, padding, dtSize, dtUnits, update) {\n    var meshLength = this.meshes.length;\n\n    for (var i = 0; i < meshLength; i++) {\n      var m = this.meshes[i];\n      var scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\n      var pOffset = dtUnits.clone().scale(padding);\n\n      var frameOffset = this._getFrameOffset(i);\n\n      var offset = frameOffset.add(pOffset);\n      var frame = new TexturePackerFrame(i, scale, offset);\n      this.frames.push(frame); //Update Output UVs\n\n      if (update) {\n        this._updateMeshUV(m, i);\n\n        this._updateTextureReferences(m);\n      }\n    }\n  };\n  /**\r\n  * Calculates the frames Offset.\r\n  * @param index of the frame\r\n  * @returns Vector2\r\n  */\n\n\n  TexturePacker.prototype._getFrameOffset = function (index) {\n    var meshLength = this.meshes.length;\n    var uvStep, yStep, xStep;\n\n    switch (this.options.layout) {\n      case 0:\n        //STRIP_LAYOUT\n        uvStep = 1 / meshLength;\n        return new Vector2(index * uvStep, 0);\n        break;\n\n      case 1:\n        //POWER2\n        var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n        yStep = Math.floor(index / sqrtCount);\n        xStep = index - yStep * sqrtCount;\n        uvStep = 1 / sqrtCount;\n        return new Vector2(xStep * uvStep, yStep * uvStep);\n        break;\n\n      case 2:\n        //COLNUM\n        var cols = this.options.colnum || 1;\n        var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n        xStep = Math.floor(index / rowCnt);\n        yStep = index - xStep * rowCnt;\n        uvStep = new Vector2(1 / cols, 1 / rowCnt);\n        return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\n        break;\n    }\n\n    return Vector2.Zero();\n  };\n  /**\r\n  * Updates a Mesh to the frame data\r\n  * @param mesh that is the target\r\n  * @param frameID or the frame index\r\n  */\n\n\n  TexturePacker.prototype._updateMeshUV = function (mesh, frameID) {\n    var frame = this.frames[frameID];\n    var uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\n    var uvOut = [];\n    var toCount = 0;\n\n    if (uvIn.length) {\n      toCount = uvIn.length || 0;\n    }\n\n    for (var i = 0; i < toCount; i += 2) {\n      uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);\n    }\n\n    mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\n  };\n  /**\r\n  * Updates a Meshes materials to use the texture packer channels\r\n  * @param m is the mesh to target\r\n  * @param force all channels on the packer to be set.\r\n  */\n\n\n  TexturePacker.prototype._updateTextureReferences = function (m, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    var mat = m.material;\n    var sKeys = Object.keys(this.sets);\n\n    var _dispose = function _dispose(_t) {\n      if (_t.dispose) {\n        _t.dispose();\n      }\n    };\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var setName = sKeys[i];\n\n      if (!force) {\n        if (!mat) {\n          return;\n        }\n\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n\n          mat[setName] = this.sets[setName];\n        }\n      } else {\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n        }\n\n        mat[setName] = this.sets[setName];\n      }\n    }\n  };\n  /**\r\n  * Public method to set a Mesh to a frame\r\n  * @param m that is the target\r\n  * @param frameID or the frame index\r\n  * @param updateMaterial trigger for if the Meshes attached Material be updated?\r\n  */\n\n\n  TexturePacker.prototype.setMeshToFrame = function (m, frameID, updateMaterial) {\n    if (updateMaterial === void 0) {\n      updateMaterial = false;\n    }\n\n    this._updateMeshUV(m, frameID);\n\n    if (updateMaterial) {\n      this._updateTextureReferences(m, true);\n    }\n  };\n  /**\r\n  * Starts the async promise to compile the texture packer.\r\n  * @returns Promise<void>\r\n  */\n\n\n  TexturePacker.prototype.processAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.meshes.length === 0) {\n          //Must be a JSON load!\n          resolve();\n          return;\n        }\n\n        var done_1 = 0;\n\n        var doneCheck_1 = function doneCheck_1(mat) {\n          done_1++; //Check Status of all Textures on all meshes, till they are ready.\n\n          if (_this.options.map) {\n            for (var j = 0; j < _this.options.map.length; j++) {\n              var index = _this.options.map[j];\n              var t = mat[index];\n\n              if (t !== null) {\n                if (!_this.sets[_this.options.map[j]]) {\n                  _this.sets[_this.options.map[j]] = true;\n                }\n\n                _this._expecting++;\n              }\n            }\n\n            if (done_1 === _this.meshes.length) {\n              _this._createFrames(resolve);\n            }\n          }\n        };\n\n        var _loop_2 = function _loop_2(i) {\n          var mesh = _this.meshes[i];\n          var material = mesh.material;\n\n          if (!material) {\n            done_1++;\n\n            if (done_1 === _this.meshes.length) {\n              return {\n                value: _this._createFrames(resolve)\n              };\n            }\n\n            return \"continue\";\n          }\n\n          material.forceCompilationAsync(mesh).then(function () {\n            doneCheck_1(material);\n          });\n        };\n\n        for (var i = 0; i < _this.meshes.length; i++) {\n          var state_1 = _loop_2(i);\n\n          if (typeof state_1 === \"object\") return state_1.value;\n        }\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n  /**\r\n  * Disposes all textures associated with this packer\r\n  */\n\n\n  TexturePacker.prototype.dispose = function () {\n    var sKeys = Object.keys(this.sets);\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var channel = sKeys[i];\n      this.sets[channel].dispose();\n    }\n  };\n  /**\r\n  * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\r\n  * @param imageType is the image type to use.\r\n  * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\r\n  */\n\n\n  TexturePacker.prototype.download = function (imageType, quality) {\n    var _this = this;\n\n    if (imageType === void 0) {\n      imageType = 'png';\n    }\n\n    if (quality === void 0) {\n      quality = 1;\n    }\n\n    setTimeout(function () {\n      var pack = {\n        name: _this.name,\n        sets: {},\n        options: {},\n        frames: []\n      };\n      var sKeys = Object.keys(_this.sets);\n      var oKeys = Object.keys(_this.options);\n\n      try {\n        for (var i = 0; i < sKeys.length; i++) {\n          var channel = sKeys[i];\n          var dt = _this.sets[channel];\n          pack.sets[channel] = dt.getContext().canvas.toDataURL('image/' + imageType, quality);\n        }\n\n        for (var i = 0; i < oKeys.length; i++) {\n          var opt = oKeys[i];\n          pack.options[opt] = _this.options[opt];\n        }\n\n        for (var i = 0; i < _this.frames.length; i++) {\n          var _f = _this.frames[i];\n          pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\n        }\n      } catch (err) {\n        Logger.Warn(\"Unable to download: \" + err);\n        return;\n      }\n\n      var data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\n\n      var _a = document.createElement('a');\n\n      _a.setAttribute(\"href\", data);\n\n      _a.setAttribute(\"download\", _this.name + \"_texurePackage.json\");\n\n      document.body.appendChild(_a);\n\n      _a.click();\n\n      _a.remove();\n    }, 0);\n  };\n  /**\r\n  * Public method to load a texturePacker JSON file.\r\n  * @param data of the JSON file in string format.\r\n  */\n\n\n  TexturePacker.prototype.updateFromJSON = function (data) {\n    try {\n      var parsedData = JSON.parse(data);\n      this.name = parsedData.name;\n\n      var _options = Object.keys(parsedData.options);\n\n      for (var i = 0; i < _options.length; i++) {\n        this.options[_options[i]] = parsedData.options[_options[i]];\n      }\n\n      for (var i = 0; i < parsedData.frames.length; i += 4) {\n        var frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));\n        this.frames.push(frame);\n      }\n\n      var channels = Object.keys(parsedData.sets);\n\n      for (var i = 0; i < channels.length; i++) {\n        var _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\n\n        this.sets[channels[i]] = _t;\n      }\n    } catch (err) {\n      Logger.Warn(\"Unable to update from JSON: \" + err);\n    }\n  };\n  /** Packer Layout Constant 0 */\n\n\n  TexturePacker.LAYOUT_STRIP = 0;\n  /** Packer Layout Constant 1 */\n\n  TexturePacker.LAYOUT_POWER2 = 1;\n  /** Packer Layout Constant 2 */\n\n  TexturePacker.LAYOUT_COLNUM = 2;\n  /** Packer Layout Constant 0 */\n\n  TexturePacker.SUBUV_WRAP = 0;\n  /** Packer Layout Constant 1 */\n\n  TexturePacker.SUBUV_EXTEND = 1;\n  /** Packer Layout Constant 2 */\n\n  TexturePacker.SUBUV_COLOR = 2;\n  return TexturePacker;\n}();\n\nexport { TexturePacker };","map":null,"metadata":{},"sourceType":"module"}