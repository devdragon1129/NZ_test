{"ast":null,"code":"import { VertexBuffer } from \"./buffer\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { extractMinAndMaxIndexed } from '../Maths/math.functions';\n/**\r\n * Defines a subdivision inside a mesh\r\n */\n\nvar SubMesh =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new submesh\r\n   * @param materialIndex defines the material index to use\r\n   * @param verticesStart defines vertex index start\r\n   * @param verticesCount defines vertices count\r\n   * @param indexStart defines index start\r\n   * @param indexCount defines indices count\r\n   * @param mesh defines the parent mesh\r\n   * @param renderingMesh defines an optional rendering mesh\r\n   * @param createBoundingBox defines if bounding box should be created for this submesh\r\n   * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n   */\n  function SubMesh(\n  /** the material index to use */\n  materialIndex,\n  /** vertex index start */\n  verticesStart,\n  /** vertices count */\n  verticesCount,\n  /** index start */\n  indexStart,\n  /** indices count */\n  indexCount, mesh, renderingMesh, createBoundingBox, addToMesh) {\n    if (createBoundingBox === void 0) {\n      createBoundingBox = true;\n    }\n\n    if (addToMesh === void 0) {\n      addToMesh = true;\n    }\n\n    this.materialIndex = materialIndex;\n    this.verticesStart = verticesStart;\n    this.verticesCount = verticesCount;\n    this.indexStart = indexStart;\n    this.indexCount = indexCount;\n    /** @hidden */\n\n    this._materialDefines = null;\n    /** @hidden */\n\n    this._materialEffect = null;\n    /** @hidden */\n\n    this._effectOverride = null;\n    /** @hidden */\n\n    this._linesIndexCount = 0;\n    this._linesIndexBuffer = null;\n    /** @hidden */\n\n    this._lastColliderWorldVertices = null;\n    /** @hidden */\n\n    this._lastColliderTransformMatrix = null;\n    /** @hidden */\n\n    this._renderId = 0;\n    /** @hidden */\n\n    this._alphaIndex = 0;\n    /** @hidden */\n\n    this._distanceToCamera = 0;\n    this._currentMaterial = null;\n    this._mesh = mesh;\n    this._renderingMesh = renderingMesh || mesh;\n\n    if (addToMesh) {\n      mesh.subMeshes.push(this);\n    }\n\n    this._trianglePlanes = [];\n    this._id = mesh.subMeshes.length - 1;\n\n    if (createBoundingBox) {\n      this.refreshBoundingInfo();\n      mesh.computeWorldMatrix(true);\n    }\n  }\n\n  Object.defineProperty(SubMesh.prototype, \"materialDefines\", {\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\n    get: function get() {\n      return this._materialDefines;\n    },\n\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\n    set: function set(defines) {\n      this._materialDefines = defines;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SubMesh.prototype, \"effect\", {\n    /**\r\n     * Gets associated effect\r\n     */\n    get: function get() {\n      var _a;\n\n      return (_a = this._effectOverride) !== null && _a !== void 0 ? _a : this._materialEffect;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets associated effect (effect used to render this submesh)\r\n   * @param effect defines the effect to associate with\r\n   * @param defines defines the set of defines used to compile this effect\r\n   */\n\n  SubMesh.prototype.setEffect = function (effect, defines) {\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (this._materialEffect === effect) {\n      if (!effect) {\n        this._materialDefines = null;\n      }\n\n      return;\n    }\n\n    this._materialDefines = defines;\n    this._materialEffect = effect;\n  };\n  /**\r\n   * Add a new submesh to a mesh\r\n   * @param materialIndex defines the material index to use\r\n   * @param verticesStart defines vertex index start\r\n   * @param verticesCount defines vertices count\r\n   * @param indexStart defines index start\r\n   * @param indexCount defines indices count\r\n   * @param mesh defines the parent mesh\r\n   * @param renderingMesh defines an optional rendering mesh\r\n   * @param createBoundingBox defines if bounding box should be created for this submesh\r\n   * @returns the new submesh\r\n   */\n\n\n  SubMesh.AddToMesh = function (materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {\n    if (createBoundingBox === void 0) {\n      createBoundingBox = true;\n    }\n\n    return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\n  };\n\n  Object.defineProperty(SubMesh.prototype, \"IsGlobal\", {\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\n    get: function get() {\n      return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the submesh BoudingInfo object\r\n   * @returns current bounding info (or mesh's one if the submesh is global)\r\n   */\n\n  SubMesh.prototype.getBoundingInfo = function () {\n    if (this.IsGlobal) {\n      return this._mesh.getBoundingInfo();\n    }\n\n    return this._boundingInfo;\n  };\n  /**\r\n   * Sets the submesh BoundingInfo\r\n   * @param boundingInfo defines the new bounding info to use\r\n   * @returns the SubMesh\r\n   */\n\n\n  SubMesh.prototype.setBoundingInfo = function (boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  };\n  /**\r\n   * Returns the mesh of the current submesh\r\n   * @return the parent mesh\r\n   */\n\n\n  SubMesh.prototype.getMesh = function () {\n    return this._mesh;\n  };\n  /**\r\n   * Returns the rendering mesh of the submesh\r\n   * @returns the rendering mesh (could be different from parent mesh)\r\n   */\n\n\n  SubMesh.prototype.getRenderingMesh = function () {\n    return this._renderingMesh;\n  };\n  /**\r\n   * Returns the replacement mesh of the submesh\r\n   * @returns the replacement mesh (could be different from parent mesh)\r\n   */\n\n\n  SubMesh.prototype.getReplacementMesh = function () {\n    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n  };\n  /**\r\n   * Returns the effective mesh of the submesh\r\n   * @returns the effective mesh (could be different from parent mesh)\r\n   */\n\n\n  SubMesh.prototype.getEffectiveMesh = function () {\n    var replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n    return replacementMesh ? replacementMesh : this._renderingMesh;\n  };\n  /**\r\n   * Returns the submesh material\r\n   * @returns null or the current material\r\n   */\n\n\n  SubMesh.prototype.getMaterial = function () {\n    var rootMaterial = this._renderingMesh.material;\n\n    if (rootMaterial === null || rootMaterial === undefined) {\n      return this._mesh.getScene().defaultMaterial;\n    } else if (this._IsMultiMaterial(rootMaterial)) {\n      var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\n\n      if (this._currentMaterial !== effectiveMaterial) {\n        this._currentMaterial = effectiveMaterial;\n        this._materialDefines = null;\n      }\n\n      return effectiveMaterial;\n    }\n\n    return rootMaterial;\n  };\n\n  SubMesh.prototype._IsMultiMaterial = function (material) {\n    return material.getSubMaterial !== undefined;\n  }; // Methods\n\n  /**\r\n   * Sets a new updated BoundingInfo object to the submesh\r\n   * @param data defines an optional position array to use to determine the bounding info\r\n   * @returns the SubMesh\r\n   */\n\n\n  SubMesh.prototype.refreshBoundingInfo = function (data) {\n    if (data === void 0) {\n      data = null;\n    }\n\n    this._lastColliderWorldVertices = null;\n\n    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\n      return this;\n    }\n\n    if (!data) {\n      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\n    }\n\n    if (!data) {\n      this._boundingInfo = this._mesh.getBoundingInfo();\n      return this;\n    }\n\n    var indices = this._renderingMesh.getIndices();\n\n    var extend; //is this the only submesh?\n\n    if (this.indexStart === 0 && this.indexCount === indices.length) {\n      var boundingInfo = this._renderingMesh.getBoundingInfo(); //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n\n\n      extend = {\n        minimum: boundingInfo.minimum.clone(),\n        maximum: boundingInfo.maximum.clone()\n      };\n    } else {\n      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n    }\n\n    if (this._boundingInfo) {\n      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n    } else {\n      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._checkCollision = function (collider) {\n    var boundingInfo = this.getBoundingInfo();\n    return boundingInfo._checkCollision(collider);\n  };\n  /**\r\n   * Updates the submesh BoundingInfo\r\n   * @param world defines the world matrix to use to update the bounding info\r\n   * @returns the submesh\r\n   */\n\n\n  SubMesh.prototype.updateBoundingInfo = function (world) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      this.refreshBoundingInfo();\n      boundingInfo = this.getBoundingInfo();\n    }\n\n    if (boundingInfo) {\n      boundingInfo.update(world);\n    }\n\n    return this;\n  };\n  /**\r\n   * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n   * @param frustumPlanes defines the frustum planes\r\n   * @returns true if the submesh is intersecting with the frustum\r\n   */\n\n\n  SubMesh.prototype.isInFrustum = function (frustumPlanes) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\n  };\n  /**\r\n   * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n   * @param frustumPlanes defines the frustum planes\r\n   * @returns true if the submesh is inside the frustum\r\n   */\n\n\n  SubMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  };\n  /**\r\n   * Renders the submesh\r\n   * @param enableAlphaMode defines if alpha needs to be used\r\n   * @returns the submesh\r\n   */\n\n\n  SubMesh.prototype.render = function (enableAlphaMode) {\n    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\n\n    return this;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  SubMesh.prototype._getLinesIndexBuffer = function (indices, engine) {\n    if (!this._linesIndexBuffer) {\n      var linesIndices = [];\n\n      for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n      }\n\n      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n      this._linesIndexCount = linesIndices.length;\n    }\n\n    return this._linesIndexBuffer;\n  };\n  /**\r\n   * Checks if the submesh intersects with a ray\r\n   * @param ray defines the ray to test\r\n   * @returns true is the passed ray intersects the submesh bounding box\r\n   */\n\n\n  SubMesh.prototype.canIntersects = function (ray) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return ray.intersectsBox(boundingInfo.boundingBox);\n  };\n  /**\r\n   * Intersects current submesh with a ray\r\n   * @param ray defines the ray to test\r\n   * @param positions defines mesh's positions array\r\n   * @param indices defines mesh's indices array\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns intersection info or null if no intersection\r\n   */\n\n\n  SubMesh.prototype.intersects = function (ray, positions, indices, fastCheck, trianglePredicate) {\n    var material = this.getMaterial();\n\n    if (!material) {\n      return null;\n    }\n\n    var step = 3;\n    var checkStopper = false;\n\n    switch (material.fillMode) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 8:\n        return null;\n\n      case 7:\n        step = 1;\n        checkStopper = true;\n        break;\n\n      default:\n        break;\n    } // LineMesh first as it's also a Mesh...\n\n\n    if (this._mesh.getClassName() === \"InstancedLinesMesh\" || this._mesh.getClassName() === \"LinesMesh\") {\n      // Check if mesh is unindexed\n      if (!indices.length) {\n        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n      }\n\n      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n    } else {\n      // Check if mesh is unindexed\n      if (!indices.length && this._mesh._unIndexed) {\n        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\n      }\n\n      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\n    }\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._intersectLines = function (ray, positions, indices, intersectionThreshold, fastCheck) {\n    var intersectInfo = null; // Line test\n\n    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n      var p0 = positions[indices[index]];\n      var p1 = positions[indices[index + 1]];\n      var length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n\n      if (length < 0) {\n        continue;\n      }\n\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._intersectUnIndexedLines = function (ray, positions, indices, intersectionThreshold, fastCheck) {\n    var intersectInfo = null; // Line test\n\n    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\n      var p0 = positions[index];\n      var p1 = positions[index + 1];\n      var length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n\n      if (length < 0) {\n        continue;\n      }\n\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._intersectTriangles = function (ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {\n    var intersectInfo = null; // Triangles test\n\n    var faceID = -1;\n\n    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += step) {\n      faceID++;\n      var indexA = indices[index];\n      var indexB = indices[index + 1];\n      var indexC = indices[index + 2];\n\n      if (checkStopper && indexC === 0xFFFFFFFF) {\n        index += 2;\n        continue;\n      }\n\n      var p0 = positions[indexA];\n      var p1 = positions[indexB];\n      var p2 = positions[indexC];\n\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = faceID;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._intersectUnIndexedTriangles = function (ray, positions, indices, fastCheck, trianglePredicate) {\n    var intersectInfo = null; // Triangles test\n\n    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n      var p0 = positions[index];\n      var p1 = positions[index + 1];\n      var p2 = positions[index + 2];\n\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = index / 3;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._rebuild = function () {\n    if (this._linesIndexBuffer) {\n      this._linesIndexBuffer = null;\n    }\n  }; // Clone\n\n  /**\r\n   * Creates a new submesh from the passed mesh\r\n   * @param newMesh defines the new hosting mesh\r\n   * @param newRenderingMesh defines an optional rendering mesh\r\n   * @returns the new submesh\r\n   */\n\n\n  SubMesh.prototype.clone = function (newMesh, newRenderingMesh) {\n    var result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n\n    if (!this.IsGlobal) {\n      var boundingInfo = this.getBoundingInfo();\n\n      if (!boundingInfo) {\n        return result;\n      }\n\n      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n    }\n\n    return result;\n  }; // Dispose\n\n  /**\r\n   * Release associated resources\r\n   */\n\n\n  SubMesh.prototype.dispose = function () {\n    if (this._linesIndexBuffer) {\n      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n\n      this._linesIndexBuffer = null;\n    } // Remove from mesh\n\n\n    var index = this._mesh.subMeshes.indexOf(this);\n\n    this._mesh.subMeshes.splice(index, 1);\n  };\n  /**\r\n   * Gets the class name\r\n   * @returns the string \"SubMesh\".\r\n   */\n\n\n  SubMesh.prototype.getClassName = function () {\n    return \"SubMesh\";\n  }; // Statics\n\n  /**\r\n   * Creates a new submesh from indices data\r\n   * @param materialIndex the index of the main mesh material\r\n   * @param startIndex the index where to start the copy in the mesh indices array\r\n   * @param indexCount the number of indices to copy then from the startIndex\r\n   * @param mesh the main mesh to create the submesh from\r\n   * @param renderingMesh the optional rendering mesh\r\n   * @returns a new submesh\r\n   */\n\n\n  SubMesh.CreateFromIndices = function (materialIndex, startIndex, indexCount, mesh, renderingMesh) {\n    var minVertexIndex = Number.MAX_VALUE;\n    var maxVertexIndex = -Number.MAX_VALUE;\n    var whatWillRender = renderingMesh || mesh;\n    var indices = whatWillRender.getIndices();\n\n    for (var index = startIndex; index < startIndex + indexCount; index++) {\n      var vertexIndex = indices[index];\n\n      if (vertexIndex < minVertexIndex) {\n        minVertexIndex = vertexIndex;\n      }\n\n      if (vertexIndex > maxVertexIndex) {\n        maxVertexIndex = vertexIndex;\n      }\n    }\n\n    return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh);\n  };\n\n  return SubMesh;\n}();\n\nexport { SubMesh };","map":null,"metadata":{},"sourceType":"module"}