{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { ThinEngine } from \"../../Engines/thinEngine\";\nimport { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\nimport { Logger } from '../../Misc/logger';\nimport { FileTools } from '../../Misc/fileTools';\n\nThinEngine.prototype._createDepthStencilCubeTexture = function (size, options) {\n  var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown);\n  internalTexture.isCube = true;\n\n  if (this.webGLVersion === 1) {\n    Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\n    return internalTexture;\n  }\n\n  var internalOptions = __assign({\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false\n  }, options);\n\n  var gl = this._gl;\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\n\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction); // Create the depth/stencil buffer\n\n\n  for (var face = 0; face < 6; face++) {\n    if (internalOptions.generateStencil) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\n    } else {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\n    }\n  }\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n\n  return internalTexture;\n};\n\nThinEngine.prototype._partialLoadFile = function (url, index, loadedFiles, onfinish, onErrorCallBack) {\n  if (onErrorCallBack === void 0) {\n    onErrorCallBack = null;\n  }\n\n  var onload = function onload(data) {\n    loadedFiles[index] = data;\n    loadedFiles._internalCount++;\n\n    if (loadedFiles._internalCount === 6) {\n      onfinish(loadedFiles);\n    }\n  };\n\n  var onerror = function onerror(request, exception) {\n    if (onErrorCallBack && request) {\n      onErrorCallBack(request.status + \" \" + request.statusText, exception);\n    }\n  };\n\n  this._loadFile(url, onload, undefined, undefined, true, onerror);\n};\n\nThinEngine.prototype._cascadeLoadFiles = function (scene, onfinish, files, onError) {\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  var loadedFiles = [];\n  loadedFiles._internalCount = 0;\n\n  for (var index = 0; index < 6; index++) {\n    this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\n  }\n};\n\nThinEngine.prototype._cascadeLoadImgs = function (scene, onfinish, files, onError, mimeType) {\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  var loadedImages = [];\n  loadedImages._internalCount = 0;\n\n  for (var index = 0; index < 6; index++) {\n    this._partialLoadImg(files[index], index, loadedImages, scene, onfinish, onError, mimeType);\n  }\n};\n\nThinEngine.prototype._partialLoadImg = function (url, index, loadedImages, scene, onfinish, onErrorCallBack, mimeType) {\n  if (onErrorCallBack === void 0) {\n    onErrorCallBack = null;\n  }\n\n  var img;\n\n  var onload = function onload() {\n    if (img) {\n      loadedImages[index] = img;\n      loadedImages._internalCount++;\n\n      if (scene) {\n        scene._removePendingData(img);\n      }\n    }\n\n    if (loadedImages._internalCount === 6) {\n      onfinish(loadedImages);\n    }\n  };\n\n  var onerror = function onerror(message, exception) {\n    if (scene) {\n      scene._removePendingData(img);\n    }\n\n    if (onErrorCallBack) {\n      onErrorCallBack(message, exception);\n    }\n  };\n\n  img = FileTools.LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\n\n  if (scene && img) {\n    scene._addPendingData(img);\n  }\n};\n\nThinEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap) {\n  var gl = this._gl;\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  texture.samplingMode = loadMipmap ? 3 : 2;\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n};\n\nThinEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, loaderOptions) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (forcedExtension === void 0) {\n    forcedExtension = null;\n  }\n\n  if (createPolynomials === void 0) {\n    createPolynomials = false;\n  }\n\n  if (lodScale === void 0) {\n    lodScale = 0;\n  }\n\n  if (lodOffset === void 0) {\n    lodOffset = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = null;\n  }\n\n  var gl = this._gl;\n  var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n  texture.isCube = true;\n  texture.url = rootUrl;\n  texture.generateMipMaps = !noMipmap;\n  texture._lodGenerationScale = lodScale;\n  texture._lodGenerationOffset = lodOffset;\n\n  if (!this._doNotHandleContextLost) {\n    texture._extension = forcedExtension;\n    texture._files = files;\n  }\n\n  var originalRootUrl = rootUrl;\n\n  if (this._transformTextureUrl && !fallback) {\n    rootUrl = this._transformTextureUrl(rootUrl);\n  }\n\n  var lastDot = rootUrl.lastIndexOf('.');\n  var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\n  var loader = null;\n\n  for (var _i = 0, _a = ThinEngine._TextureLoaders; _i < _a.length; _i++) {\n    var availableLoader = _a[_i];\n\n    if (availableLoader.canLoad(extension)) {\n      loader = availableLoader;\n      break;\n    }\n  }\n\n  var onInternalError = function onInternalError(request, exception) {\n    if (rootUrl === originalRootUrl) {\n      if (onError && request) {\n        onError(request.status + \" \" + request.statusText, exception);\n      }\n    } else {\n      // fall back to the original url if the transformed url fails to load\n      Logger.Warn(\"Failed to load \" + rootUrl + \", falling back to the \" + originalRootUrl);\n\n      _this.createCubeTexture(originalRootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, loaderOptions);\n    }\n  };\n\n  if (loader) {\n    var onloaddata_1 = function onloaddata_1(data) {\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n      loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);\n    };\n\n    if (files && files.length === 6) {\n      if (loader.supportCascades) {\n        this._cascadeLoadFiles(scene, function (images) {\n          return onloaddata_1(images.map(function (image) {\n            return new Uint8Array(image);\n          }));\n        }, files, onError);\n      } else {\n        if (onError) {\n          onError(\"Textures type does not support cascades.\");\n        } else {\n          Logger.Warn(\"Texture loader does not support cascades.\");\n        }\n      }\n    } else {\n      this._loadFile(rootUrl, function (data) {\n        return onloaddata_1(new Uint8Array(data));\n      }, undefined, undefined, true, onInternalError);\n    }\n  } else {\n    if (!files) {\n      throw new Error(\"Cannot load cubemap because files were not defined\");\n    }\n\n    this._cascadeLoadImgs(scene, function (imgs) {\n      var width = _this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, _this._caps.maxCubemapTextureSize) : imgs[0].width;\n      var height = width;\n      var faces = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n      _this._unpackFlipY(false);\n\n      var internalFormat = format ? _this._getInternalFormat(format) : _this._gl.RGBA;\n\n      for (var index = 0; index < faces.length; index++) {\n        if (imgs[index].width !== width || imgs[index].height !== height) {\n          _this._prepareWorkingCanvas();\n\n          if (!_this._workingCanvas || !_this._workingContext) {\n            Logger.Warn(\"Cannot create canvas to resize texture.\");\n            return;\n          }\n\n          _this._workingCanvas.width = width;\n          _this._workingCanvas.height = height;\n\n          _this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\n\n          gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);\n        } else {\n          gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, imgs[index]);\n        }\n      }\n\n      if (!noMipmap) {\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n      }\n\n      _this._setCubeMapTextureParams(texture, !noMipmap);\n\n      texture.width = width;\n      texture.height = height;\n      texture.isReady = true;\n\n      if (format) {\n        texture.format = format;\n      }\n\n      texture.onLoadedObservable.notifyObservers(texture);\n      texture.onLoadedObservable.clear();\n\n      if (onLoad) {\n        onLoad();\n      }\n    }, files, onError);\n  }\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};","map":null,"metadata":{},"sourceType":"module"}