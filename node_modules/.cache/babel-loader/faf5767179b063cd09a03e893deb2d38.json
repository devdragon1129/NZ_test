{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Logger } from \"../../Misc/logger\";\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../../Meshes/mesh\";\n/**\r\n * An Abstract Motion controller\r\n * This class receives an xrInput and a profile layout and uses those to initialize the components\r\n * Each component has an observable to check for changes in value and state\r\n */\n\nvar WebXRAbstractMotionController =\n/** @class */\nfunction () {\n  /**\r\n   * constructs a new abstract motion controller\r\n   * @param scene the scene to which the model of the controller will be added\r\n   * @param layout The profile layout to load\r\n   * @param gamepadObject The gamepad object correlating to this controller\r\n   * @param handedness handedness (left/right/none) of this controller\r\n   * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading\r\n   */\n  function WebXRAbstractMotionController(scene, layout,\n  /**\r\n   * The gamepad object correlating to this controller\r\n   */\n  gamepadObject,\n  /**\r\n   * handedness (left/right/none) of this controller\r\n   */\n  handedness, _doNotLoadControllerMesh) {\n    var _this = this;\n\n    if (_doNotLoadControllerMesh === void 0) {\n      _doNotLoadControllerMesh = false;\n    }\n\n    this.scene = scene;\n    this.layout = layout;\n    this.gamepadObject = gamepadObject;\n    this.handedness = handedness;\n\n    this._initComponent = function (id) {\n      if (!id) {\n        return;\n      }\n\n      var componentDef = _this.layout.components[id];\n      var type = componentDef.type;\n      var buttonIndex = componentDef.gamepadIndices.button; // search for axes\n\n      var axes = [];\n\n      if (componentDef.gamepadIndices.xAxis !== undefined && componentDef.gamepadIndices.yAxis !== undefined) {\n        axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);\n      }\n\n      _this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);\n    };\n\n    this._modelReady = false;\n    /**\r\n     * A map of components (WebXRControllerComponent) in this motion controller\r\n     * Components have a ComponentType and can also have both button and axis definitions\r\n     */\n\n    this.components = {};\n    /**\r\n     * Disable the model's animation. Can be set at any time.\r\n     */\n\n    this.disableAnimation = false;\n    /**\r\n     * Observers registered here will be triggered when the model of this controller is done loading\r\n     */\n\n    this.onModelLoadedObservable = new Observable(); // initialize the components\n\n    if (layout.components) {\n      Object.keys(layout.components).forEach(this._initComponent);\n    } // Model is loaded in WebXRInput\n\n  }\n  /**\r\n   * Dispose this controller, the model mesh and all its components\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.dispose = function () {\n    var _this = this;\n\n    this.getComponentIds().forEach(function (id) {\n      return _this.getComponent(id).dispose();\n    });\n\n    if (this.rootMesh) {\n      this.rootMesh.dispose();\n    }\n  };\n  /**\r\n   * Returns all components of specific type\r\n   * @param type the type to search for\r\n   * @return an array of components with this type\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.getAllComponentsOfType = function (type) {\n    var _this = this;\n\n    return this.getComponentIds().map(function (id) {\n      return _this.components[id];\n    }).filter(function (component) {\n      return component.type === type;\n    });\n  };\n  /**\r\n   * get a component based an its component id as defined in layout.components\r\n   * @param id the id of the component\r\n   * @returns the component correlates to the id or undefined if not found\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.getComponent = function (id) {\n    return this.components[id];\n  };\n  /**\r\n   * Get the list of components available in this motion controller\r\n   * @returns an array of strings correlating to available components\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.getComponentIds = function () {\n    return Object.keys(this.components);\n  };\n  /**\r\n   * Get the first component of specific type\r\n   * @param type type of component to find\r\n   * @return a controller component or null if not found\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.getComponentOfType = function (type) {\n    return this.getAllComponentsOfType(type)[0] || null;\n  };\n  /**\r\n   * Get the main (Select) component of this controller as defined in the layout\r\n   * @returns the main component of this controller\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.getMainComponent = function () {\n    return this.getComponent(this.layout.selectComponentId);\n  };\n  /**\r\n   * Loads the model correlating to this controller\r\n   * When the mesh is loaded, the onModelLoadedObservable will be triggered\r\n   * @returns A promise fulfilled with the result of the model loading\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.loadModel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var useGeneric, loadingParams;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        useGeneric = !this._getModelLoadingConstraints();\n        loadingParams = this._getGenericFilenameAndPath(); // Checking if GLB loader is present\n\n        if (useGeneric) {\n          Logger.Warn(\"Falling back to generic models\");\n        } else {\n          loadingParams = this._getFilenameAndPath();\n        }\n\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          SceneLoader.ImportMesh(\"\", loadingParams.path, loadingParams.filename, _this.scene, function (meshes) {\n            if (useGeneric) {\n              _this._getGenericParentMesh(meshes);\n            } else {\n              _this._setRootMesh(meshes);\n            }\n\n            _this._processLoadedModel(meshes);\n\n            _this._modelReady = true;\n\n            _this.onModelLoadedObservable.notifyObservers(_this);\n\n            resolve(true);\n          }, null, function (_scene, message) {\n            Logger.Log(message);\n            Logger.Warn(\"Failed to retrieve controller model of type \" + _this.profileId + \" from the remote server: \" + loadingParams.path + loadingParams.filename);\n            reject(message);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Update this model using the current XRFrame\r\n   * @param xrFrame the current xr frame to use and update the model\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.updateFromXRFrame = function (xrFrame) {\n    var _this = this;\n\n    this.getComponentIds().forEach(function (id) {\n      return _this.getComponent(id).update(_this.gamepadObject);\n    });\n    this.updateModel(xrFrame);\n  };\n\n  Object.defineProperty(WebXRAbstractMotionController.prototype, \"handness\", {\n    /**\r\n     * Backwards compatibility due to a deeply-integrated typo\r\n     */\n    get: function get() {\n      return this.handedness;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Pulse (vibrate) this controller\r\n   * If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called\r\n   * Consecutive calls to this function will cancel the last pulse call\r\n   *\r\n   * @param value the strength of the pulse in 0.0...1.0 range\r\n   * @param duration Duration of the pulse in milliseconds\r\n   * @param hapticActuatorIndex optional index of actuator (will usually be 0)\r\n   * @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued\r\n   */\n\n  WebXRAbstractMotionController.prototype.pulse = function (value, duration, hapticActuatorIndex) {\n    if (hapticActuatorIndex === void 0) {\n      hapticActuatorIndex = 0;\n    }\n\n    if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {\n      return this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);\n    } else {\n      return Promise.resolve(false);\n    }\n  }; // Look through all children recursively. This will return null if no mesh exists with the given name.\n\n\n  WebXRAbstractMotionController.prototype._getChildByName = function (node, name) {\n    return node.getChildren(function (n) {\n      return n.name === name;\n    }, false)[0];\n  }; // Look through only immediate children. This will return null if no mesh exists with the given name.\n\n\n  WebXRAbstractMotionController.prototype._getImmediateChildByName = function (node, name) {\n    return node.getChildren(function (n) {\n      return n.name == name;\n    }, true)[0];\n  };\n  /**\r\n   * Moves the axis on the controller mesh based on its current state\r\n   * @param axis the index of the axis\r\n   * @param axisValue the value of the axis which determines the meshes new position\r\n   * @hidden\r\n   */\n\n\n  WebXRAbstractMotionController.prototype._lerpTransform = function (axisMap, axisValue, fixValueCoordinates) {\n    if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {\n      return;\n    }\n\n    if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {\n      return;\n    } // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\n\n\n    var lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;\n    Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);\n    Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);\n  };\n  /**\r\n   * Update the model itself with the current frame data\r\n   * @param xrFrame the frame to use for updating the model mesh\r\n   */\n\n\n  WebXRAbstractMotionController.prototype.updateModel = function (xrFrame) {\n    if (!this._modelReady) {\n      return;\n    }\n\n    this._updateModel(xrFrame);\n  };\n\n  WebXRAbstractMotionController.prototype._getGenericFilenameAndPath = function () {\n    return {\n      filename: \"generic.babylon\",\n      path: \"https://controllers.babylonjs.com/generic/\"\n    };\n  };\n\n  WebXRAbstractMotionController.prototype._getGenericParentMesh = function (meshes) {\n    var _this = this;\n\n    this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\n    meshes.forEach(function (mesh) {\n      if (!mesh.parent) {\n        mesh.isPickable = false;\n        mesh.setParent(_this.rootMesh);\n      }\n    });\n    this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\n  };\n\n  return WebXRAbstractMotionController;\n}();\n\nexport { WebXRAbstractMotionController };","map":null,"metadata":{},"sourceType":"module"}