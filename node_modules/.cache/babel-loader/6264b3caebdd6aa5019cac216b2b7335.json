{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethers_1 = require(\"ethers\");\n\nvar solidityKeccak256 = ethers_1.utils.solidityKeccak256;\n\nfunction bufferToHex(buf) {\n  return '0x' + buf.toString('hex');\n}\n\nvar MerkleTree = /*#__PURE__*/function () {\n  function MerkleTree(elements) {\n    _classCallCheck(this, MerkleTree);\n\n    this.elements = _toConsumableArray(elements); // Sort elements\n\n    this.elements.sort(Buffer.compare); // Deduplicate elements\n\n    this.elements = MerkleTree.bufDedup(this.elements);\n    this.bufferElementPositionIndex = this.elements.reduce(function (memo, el, index) {\n      memo[bufferToHex(el)] = index;\n      return memo;\n    }, {}); // Create layers\n\n    this.layers = this.getLayers(this.elements);\n  }\n\n  _createClass(MerkleTree, [{\n    key: \"getLayers\",\n    value: function getLayers(elements) {\n      if (elements.length === 0) {\n        throw new Error('empty tree');\n      }\n\n      var layers = [];\n      layers.push(elements); // Get next layer until we reach the root\n\n      while (layers[layers.length - 1].length > 1) {\n        layers.push(this.getNextLayer(layers[layers.length - 1]));\n      }\n\n      return layers;\n    }\n  }, {\n    key: \"getNextLayer\",\n    value: function getNextLayer(elements) {\n      return elements.reduce(function (layer, el, idx, arr) {\n        if (idx % 2 === 0) {\n          // Hash the current element with its pair element\n          layer.push(MerkleTree.combinedHash(el, arr[idx + 1]));\n        }\n\n        return layer;\n      }, []);\n    }\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      return this.layers[this.layers.length - 1][0];\n    }\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return bufferToHex(this.getRoot());\n    }\n  }, {\n    key: \"getProof\",\n    value: function getProof(el) {\n      var idx = this.bufferElementPositionIndex[bufferToHex(el)];\n\n      if (typeof idx !== 'number') {\n        throw new Error('Element does not exist in Merkle tree');\n      }\n\n      return this.layers.reduce(function (proof, layer) {\n        var pairElement = MerkleTree.getPairElement(idx, layer);\n\n        if (pairElement) {\n          proof.push(pairElement);\n        }\n\n        idx = Math.floor(idx / 2);\n        return proof;\n      }, []);\n    }\n  }, {\n    key: \"getHexProof\",\n    value: function getHexProof(el) {\n      var proof = this.getProof(el);\n      return MerkleTree.bufArrToHexArr(proof);\n    }\n  }], [{\n    key: \"combinedHash\",\n    value: function combinedHash(first, second) {\n      if (!first) {\n        return second;\n      }\n\n      if (!second) {\n        return first;\n      }\n\n      return Buffer.from(solidityKeccak256(['bytes'], [bufferToHex(MerkleTree.sortAndConcat(first, second))]).substr(2), 'hex');\n    }\n  }, {\n    key: \"getPairElement\",\n    value: function getPairElement(idx, layer) {\n      var pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n\n      if (pairIdx < layer.length) {\n        return layer[pairIdx];\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"bufDedup\",\n    value: function bufDedup(elements) {\n      return elements.filter(function (el, idx) {\n        return idx === 0 || !elements[idx - 1].equals(el);\n      });\n    }\n  }, {\n    key: \"bufArrToHexArr\",\n    value: function bufArrToHexArr(arr) {\n      if (arr.some(function (el) {\n        return !Buffer.isBuffer(el);\n      })) {\n        throw new Error('Array is not an array of buffers');\n      }\n\n      return arr.map(function (el) {\n        return '0x' + el.toString('hex');\n      });\n    }\n  }, {\n    key: \"sortAndConcat\",\n    value: function sortAndConcat() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return Buffer.concat([].concat(args).sort(Buffer.compare));\n    }\n  }]);\n\n  return MerkleTree;\n}();\n\nexports.default = MerkleTree;","map":null,"metadata":{},"sourceType":"script"}