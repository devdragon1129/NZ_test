{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Hashing = void 0;\n\nvar hashing = __importStar(require(\"@dcl/hashing\"));\n\nvar Hashing;\n\n(function (Hashing) {\n  /**\n   * Given a set of files, return a map with their hash\n   * @deprecated use calculateIPFSHashes instead. This function only exists for compatibility reasons\n   */\n  function calculateHashes(_x) {\n    return _calculateHashes.apply(this, arguments);\n  }\n\n  function _calculateHashes() {\n    _calculateHashes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(files) {\n      var entries;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              entries = Array.from(files).map( /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(file) {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return calculateBufferHash(file);\n\n                        case 2:\n                          _context.t0 = _context.sent;\n                          _context.t1 = file;\n                          return _context.abrupt(\"return\", {\n                            hash: _context.t0,\n                            file: _context.t1\n                          });\n\n                        case 5:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x5) {\n                  return _ref.apply(this, arguments);\n                };\n              }());\n              return _context2.abrupt(\"return\", Promise.all(entries));\n\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _calculateHashes.apply(this, arguments);\n  }\n\n  Hashing.calculateHashes = calculateHashes;\n  /**\n   * Return the given buffer's hash\n   * @deprecated use calculateIPFSHash instead. This function only exists for compatibility reasons\n   */\n\n  function calculateBufferHash(_x2) {\n    return _calculateBufferHash.apply(this, arguments);\n  }\n\n  function _calculateBufferHash() {\n    _calculateBufferHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(buffer) {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", hashing.hashV0(buffer));\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return _calculateBufferHash.apply(this, arguments);\n  }\n\n  Hashing.calculateBufferHash = calculateBufferHash;\n  /**\n   * @deprecated use `import {hashV1} from '@dcl/hashing'` instead\n   */\n\n  function calculateIPFSHash(_x3) {\n    return _calculateIPFSHash.apply(this, arguments);\n  }\n\n  function _calculateIPFSHash() {\n    _calculateIPFSHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(buffer) {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", hashing.hashV1(buffer));\n\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _calculateIPFSHash.apply(this, arguments);\n  }\n\n  Hashing.calculateIPFSHash = calculateIPFSHash;\n\n  function calculateIPFSHashes(_x4) {\n    return _calculateIPFSHashes.apply(this, arguments);\n  }\n\n  function _calculateIPFSHashes() {\n    _calculateIPFSHashes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(files) {\n      var entries;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              entries = Array.from(files).map( /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(file) {\n                  return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _context5.next = 2;\n                          return hashing.hashV1(file);\n\n                        case 2:\n                          _context5.t0 = _context5.sent;\n                          _context5.t1 = file;\n                          return _context5.abrupt(\"return\", {\n                            hash: _context5.t0,\n                            file: _context5.t1\n                          });\n\n                        case 5:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }));\n\n                return function (_x6) {\n                  return _ref2.apply(this, arguments);\n                };\n              }());\n              return _context6.abrupt(\"return\", Promise.all(entries));\n\n            case 2:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n    return _calculateIPFSHashes.apply(this, arguments);\n  }\n\n  Hashing.calculateIPFSHashes = calculateIPFSHashes;\n  /**\n   * Calculates the content hash of multiple files to be used consistently by the builder\n   * and other content-based applications when hashes need to be stored on-chain.\n   *\n   * Returns the CIDv1 of the data prepared to sign\n   *\n   * @deprecated use `import {calculateMultipleHashesADR32} from '@dcl/hashing'` instead\n   */\n\n  Hashing.calculateMultipleHashesADR32 = hashing.calculateMultipleHashesADR32;\n  /**\n   * Calculates the content hash of multiple files to be used consistently by the builder\n   * and other content-based applications when hashes need to be stored on-chain.\n   * @deprecated this is maintained only for compatibility reasons with calculateBufferHash (Qm prefix)\n   */\n\n  Hashing.calculateMultipleHashesADR32LegacyQmHash = hashing.calculateMultipleHashesADR32LegacyQmHash;\n})(Hashing = exports.Hashing || (exports.Hashing = {}));","map":null,"metadata":{},"sourceType":"script"}