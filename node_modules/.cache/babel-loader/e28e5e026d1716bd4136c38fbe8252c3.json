{"ast":null,"code":"import { SceneLoader } from \"../Loading/sceneLoader\";\nimport { Logger } from \"../Misc/logger\";\nimport { FilesInputStore } from \"./filesInputStore\";\n/**\r\n * Class used to help managing file picking and drag'n'drop\r\n */\n\nvar FilesInput =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new FilesInput\r\n   * @param engine defines the rendering engine\r\n   * @param scene defines the hosting scene\r\n   * @param sceneLoadedCallback callback called when scene is loaded\r\n   * @param progressCallback callback called to track progress\r\n   * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\r\n   * @param textureLoadingCallback callback called when a texture is loading\r\n   * @param startingProcessingFilesCallback callback called when the system is about to process all files\r\n   * @param onReloadCallback callback called when a reload is requested\r\n   * @param errorCallback callback call if an error occurs\r\n   */\n  function FilesInput(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback) {\n    /**\r\n     * Callback called when a file is processed\r\n     */\n    this.onProcessFileCallback = function () {\n      return true;\n    };\n\n    this._engine = engine;\n    this._currentScene = scene;\n    this._sceneLoadedCallback = sceneLoadedCallback;\n    this._progressCallback = progressCallback;\n    this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\n    this._textureLoadingCallback = textureLoadingCallback;\n    this._startingProcessingFilesCallback = startingProcessingFilesCallback;\n    this._onReloadCallback = onReloadCallback;\n    this._errorCallback = errorCallback;\n  }\n\n  Object.defineProperty(FilesInput, \"FilesToLoad\", {\n    /**\r\n     * List of files ready to be loaded\r\n     */\n    get: function get() {\n      return FilesInputStore.FilesToLoad;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Calls this function to listen to drag'n'drop events on a specific DOM element\r\n   * @param elementToMonitor defines the DOM element to track\r\n   */\n\n  FilesInput.prototype.monitorElementForDragNDrop = function (elementToMonitor) {\n    var _this = this;\n\n    if (elementToMonitor) {\n      this._elementToMonitor = elementToMonitor;\n\n      this._dragEnterHandler = function (e) {\n        _this.drag(e);\n      };\n\n      this._dragOverHandler = function (e) {\n        _this.drag(e);\n      };\n\n      this._dropHandler = function (e) {\n        _this.drop(e);\n      };\n\n      this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\n\n      this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\n\n      this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\n    }\n  };\n\n  Object.defineProperty(FilesInput.prototype, \"filesToLoad\", {\n    /** Gets the current list of files to load */\n    get: function get() {\n      return this._filesToLoad;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Release all associated resources\r\n   */\n\n  FilesInput.prototype.dispose = function () {\n    if (!this._elementToMonitor) {\n      return;\n    }\n\n    this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\n\n    this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\n\n    this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\n  };\n\n  FilesInput.prototype.renderFunction = function () {\n    if (this._additionalRenderLoopLogicCallback) {\n      this._additionalRenderLoopLogicCallback();\n    }\n\n    if (this._currentScene) {\n      if (this._textureLoadingCallback) {\n        var remaining = this._currentScene.getWaitingItemsCount();\n\n        if (remaining > 0) {\n          this._textureLoadingCallback(remaining);\n        }\n      }\n\n      this._currentScene.render();\n    }\n  };\n\n  FilesInput.prototype.drag = function (e) {\n    e.stopPropagation();\n    e.preventDefault();\n  };\n\n  FilesInput.prototype.drop = function (eventDrop) {\n    eventDrop.stopPropagation();\n    eventDrop.preventDefault();\n    this.loadFiles(eventDrop);\n  };\n\n  FilesInput.prototype._traverseFolder = function (folder, files, remaining, callback) {\n    var _this = this;\n\n    var reader = folder.createReader();\n    var relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\n    reader.readEntries(function (entries) {\n      remaining.count += entries.length;\n\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var entry = entries_1[_i];\n\n        if (entry.isFile) {\n          entry.file(function (file) {\n            file.correctName = relativePath + file.name;\n            files.push(file);\n\n            if (--remaining.count === 0) {\n              callback();\n            }\n          });\n        } else if (entry.isDirectory) {\n          _this._traverseFolder(entry, files, remaining, callback);\n        }\n      }\n\n      if (--remaining.count === 0) {\n        callback();\n      }\n    });\n  };\n\n  FilesInput.prototype._processFiles = function (files) {\n    for (var i = 0; i < files.length; i++) {\n      var name = files[i].correctName.toLowerCase();\n      var extension = name.split('.').pop();\n\n      if (!this.onProcessFileCallback(files[i], name, extension)) {\n        continue;\n      }\n\n      if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\n        this._sceneFileToLoad = files[i];\n      }\n\n      FilesInput.FilesToLoad[name] = files[i];\n    }\n  };\n  /**\r\n   * Load files from a drop event\r\n   * @param event defines the drop event to use as source\r\n   */\n\n\n  FilesInput.prototype.loadFiles = function (event) {\n    var _this = this; // Handling data transfer via drag'n'drop\n\n\n    if (event && event.dataTransfer && event.dataTransfer.files) {\n      this._filesToLoad = event.dataTransfer.files;\n    } // Handling files from input files\n\n\n    if (event && event.target && event.target.files) {\n      this._filesToLoad = event.target.files;\n    }\n\n    if (!this._filesToLoad || this._filesToLoad.length === 0) {\n      return;\n    }\n\n    if (this._startingProcessingFilesCallback) {\n      this._startingProcessingFilesCallback(this._filesToLoad);\n    }\n\n    if (this._filesToLoad && this._filesToLoad.length > 0) {\n      var files_1 = new Array();\n      var folders = [];\n      var items = event.dataTransfer ? event.dataTransfer.items : null;\n\n      for (var i = 0; i < this._filesToLoad.length; i++) {\n        var fileToLoad = this._filesToLoad[i];\n        var name_1 = fileToLoad.name.toLowerCase();\n        var entry = void 0;\n        fileToLoad.correctName = name_1;\n\n        if (items) {\n          var item = items[i];\n\n          if (item.getAsEntry) {\n            entry = item.getAsEntry();\n          } else if (item.webkitGetAsEntry) {\n            entry = item.webkitGetAsEntry();\n          }\n        }\n\n        if (!entry) {\n          files_1.push(fileToLoad);\n        } else {\n          if (entry.isDirectory) {\n            folders.push(entry);\n          } else {\n            files_1.push(fileToLoad);\n          }\n        }\n      }\n\n      if (folders.length === 0) {\n        this._processFiles(files_1);\n\n        this._processReload();\n      } else {\n        var remaining = {\n          count: folders.length\n        };\n\n        for (var _i = 0, folders_1 = folders; _i < folders_1.length; _i++) {\n          var folder = folders_1[_i];\n\n          this._traverseFolder(folder, files_1, remaining, function () {\n            _this._processFiles(files_1);\n\n            if (remaining.count === 0) {\n              _this._processReload();\n            }\n          });\n        }\n      }\n    }\n  };\n\n  FilesInput.prototype._processReload = function () {\n    if (this._onReloadCallback) {\n      this._onReloadCallback(this._sceneFileToLoad);\n    } else {\n      this.reload();\n    }\n  };\n  /**\r\n   * Reload the current scene from the loaded files\r\n   */\n\n\n  FilesInput.prototype.reload = function () {\n    var _this = this; // If a scene file has been provided\n\n\n    if (this._sceneFileToLoad) {\n      if (this._currentScene) {\n        if (Logger.errorsCount > 0) {\n          Logger.ClearLogCache();\n        }\n\n        this._engine.stopRenderLoop();\n      }\n\n      SceneLoader.ShowLoadingScreen = false;\n\n      this._engine.displayLoadingUI();\n\n      SceneLoader.LoadAsync(\"file:\", this._sceneFileToLoad, this._engine, function (progress) {\n        if (_this._progressCallback) {\n          _this._progressCallback(progress);\n        }\n      }).then(function (scene) {\n        if (_this._currentScene) {\n          _this._currentScene.dispose();\n        }\n\n        _this._currentScene = scene;\n\n        if (_this._sceneLoadedCallback) {\n          _this._sceneLoadedCallback(_this._sceneFileToLoad, _this._currentScene);\n        } // Wait for textures and shaders to be ready\n\n\n        _this._currentScene.executeWhenReady(function () {\n          _this._engine.hideLoadingUI();\n\n          _this._engine.runRenderLoop(function () {\n            _this.renderFunction();\n          });\n        });\n      }).catch(function (error) {\n        _this._engine.hideLoadingUI();\n\n        if (_this._errorCallback) {\n          _this._errorCallback(_this._sceneFileToLoad, _this._currentScene, error.message);\n        }\n      });\n    } else {\n      Logger.Error(\"Please provide a valid .babylon file.\");\n    }\n  };\n\n  return FilesInput;\n}();\n\nexport { FilesInput };","map":null,"metadata":{},"sourceType":"module"}