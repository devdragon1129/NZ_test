{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess\";\nimport { Logger } from \"./logger\";\nimport { Tools } from \"./tools\";\n/**\r\n * Class containing a set of static utilities functions for screenshots\r\n */\n\nvar ScreenshotTools =\n/** @class */\nfunction () {\n  function ScreenshotTools() {}\n  /**\r\n   * Captures a screenshot of the current rendering\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine defines the rendering engine\r\n   * @param camera defines the source camera\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param successCallback defines the callback receives a single parameter which contains the\r\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n   * src parameter of an <img> to display it\r\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   */\n\n\n  ScreenshotTools.CreateScreenshot = function (engine, camera, size, successCallback, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    var _a = ScreenshotTools._getScreenshotSize(engine, camera, size),\n        height = _a.height,\n        width = _a.width;\n\n    if (!(height && width)) {\n      Logger.Error(\"Invalid 'size' parameter !\");\n      return;\n    }\n\n    if (!Tools._ScreenshotCanvas) {\n      Tools._ScreenshotCanvas = document.createElement('canvas');\n    }\n\n    Tools._ScreenshotCanvas.width = width;\n    Tools._ScreenshotCanvas.height = height;\n\n    var renderContext = Tools._ScreenshotCanvas.getContext(\"2d\");\n\n    var ratio = engine.getRenderWidth() / engine.getRenderHeight();\n    var newWidth = width;\n    var newHeight = newWidth / ratio;\n\n    if (newHeight > height) {\n      newHeight = height;\n      newWidth = newHeight * ratio;\n    }\n\n    var offsetX = Math.max(0, width - newWidth) / 2;\n    var offsetY = Math.max(0, height - newHeight) / 2;\n    var renderingCanvas = engine.getRenderingCanvas();\n\n    if (renderContext && renderingCanvas) {\n      renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\n    }\n\n    Tools.EncodeScreenshotCanvasData(successCallback, mimeType);\n  };\n  /**\r\n   * Captures a screenshot of the current rendering\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine defines the rendering engine\r\n   * @param camera defines the source camera\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n   * to the src parameter of an <img> to display it\r\n   */\n\n\n  ScreenshotTools.CreateScreenshotAsync = function (engine, camera, size, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      ScreenshotTools.CreateScreenshot(engine, camera, size, function (data) {\n        if (typeof data !== \"undefined\") {\n          resolve(data);\n        } else {\n          reject(new Error(\"Data is undefined\"));\n        }\n      }, mimeType);\n    });\n  };\n  /**\r\n   * Generates an image screenshot from the specified camera.\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine The engine to use for rendering\r\n   * @param camera The camera to use for rendering\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param successCallback The callback receives a single parameter which contains the\r\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n   * src parameter of an <img> to display it\r\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @param samples Texture samples (default: 1)\r\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n   * @param fileName A name for for the downloaded file.\r\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n   */\n\n\n  ScreenshotTools.CreateScreenshotUsingRenderTarget = function (engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    if (samples === void 0) {\n      samples = 1;\n    }\n\n    if (antialiasing === void 0) {\n      antialiasing = false;\n    }\n\n    if (renderSprites === void 0) {\n      renderSprites = false;\n    }\n\n    if (enableStencilBuffer === void 0) {\n      enableStencilBuffer = false;\n    }\n\n    var _a = ScreenshotTools._getScreenshotSize(engine, camera, size),\n        height = _a.height,\n        width = _a.width;\n\n    var targetTextureSize = {\n      width: width,\n      height: height\n    };\n\n    if (!(height && width)) {\n      Logger.Error(\"Invalid 'size' parameter !\");\n      return;\n    }\n\n    var renderCanvas = engine.getRenderingCanvas();\n\n    if (!renderCanvas) {\n      Logger.Error(\"No rendering canvas found !\");\n      return;\n    }\n\n    var originalSize = {\n      width: renderCanvas.width,\n      height: renderCanvas.height\n    };\n    engine.setSize(width, height);\n    var scene = camera.getScene();\n    var previousCamera = null;\n    var previousCameras = scene.activeCameras;\n\n    if (scene.activeCamera !== camera || scene.activeCameras && scene.activeCameras.length) {\n      previousCamera = scene.activeCamera;\n      scene.activeCamera = camera;\n    }\n\n    scene.render(); // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\n\n    var texture = new RenderTargetTexture(\"screenShot\", targetTextureSize, scene, false, false, 0, false, Texture.NEAREST_SAMPLINGMODE, undefined, enableStencilBuffer);\n    texture.renderList = null;\n    texture.samples = samples;\n    texture.renderSprites = renderSprites;\n    texture.onAfterRenderObservable.add(function () {\n      Tools.DumpFramebuffer(width, height, engine, successCallback, mimeType, fileName);\n    });\n\n    var renderToTexture = function renderToTexture() {\n      scene.incrementRenderId();\n      scene.resetCachedMaterial();\n      texture.render(true);\n      texture.dispose();\n\n      if (previousCamera) {\n        scene.activeCamera = previousCamera;\n      }\n\n      scene.activeCameras = previousCameras;\n      engine.setSize(originalSize.width, originalSize.height);\n      camera.getProjectionMatrix(true); // Force cache refresh;\n    };\n\n    if (antialiasing) {\n      var fxaaPostProcess = new FxaaPostProcess('antialiasing', 1.0, scene.activeCamera);\n      texture.addPostProcess(fxaaPostProcess); // Async Shader Compilation can lead to none ready effects in synchronous code\n\n      if (!fxaaPostProcess.getEffect().isReady()) {\n        fxaaPostProcess.getEffect().onCompiled = function () {\n          renderToTexture();\n        };\n      } // The effect is ready we can render\n      else {\n        renderToTexture();\n      }\n    } else {\n      // No need to wait for extra resources to be ready\n      renderToTexture();\n    }\n  };\n  /**\r\n   * Generates an image screenshot from the specified camera.\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine The engine to use for rendering\r\n   * @param camera The camera to use for rendering\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @param samples Texture samples (default: 1)\r\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n   * @param fileName A name for for the downloaded file.\r\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n   * to the src parameter of an <img> to display it\r\n   */\n\n\n  ScreenshotTools.CreateScreenshotUsingRenderTargetAsync = function (engine, camera, size, mimeType, samples, antialiasing, fileName, renderSprites) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    if (samples === void 0) {\n      samples = 1;\n    }\n\n    if (antialiasing === void 0) {\n      antialiasing = false;\n    }\n\n    if (renderSprites === void 0) {\n      renderSprites = false;\n    }\n\n    return new Promise(function (resolve, reject) {\n      ScreenshotTools.CreateScreenshotUsingRenderTarget(engine, camera, size, function (data) {\n        if (typeof data !== \"undefined\") {\n          resolve(data);\n        } else {\n          reject(new Error(\"Data is undefined\"));\n        }\n      }, mimeType, samples, antialiasing, fileName, renderSprites);\n    });\n  };\n  /**\r\n   * Gets height and width for screenshot size\r\n   * @private\r\n   */\n\n\n  ScreenshotTools._getScreenshotSize = function (engine, camera, size) {\n    var height = 0;\n    var width = 0; //If a size value defined as object\n\n    if (typeof size === 'object') {\n      var precision = size.precision ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\n      : 1; //If a width and height values is specified\n\n      if (size.width && size.height) {\n        height = size.height * precision;\n        width = size.width * precision;\n      } //If passing only width, computing height to keep display canvas ratio.\n      else if (size.width && !size.height) {\n        width = size.width * precision;\n        height = Math.round(width / engine.getAspectRatio(camera));\n      } //If passing only height, computing width to keep display canvas ratio.\n      else if (size.height && !size.width) {\n        height = size.height * precision;\n        width = Math.round(height * engine.getAspectRatio(camera));\n      } else {\n        width = Math.round(engine.getRenderWidth() * precision);\n        height = Math.round(width / engine.getAspectRatio(camera));\n      }\n    } //Assuming here that \"size\" parameter is a number\n    else if (!isNaN(size)) {\n      height = size;\n      width = size;\n    } // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\n    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\n    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\n    // to resolve this, we truncate the floats here to ensure the same size\n\n\n    if (width) {\n      width = Math.floor(width);\n    }\n\n    if (height) {\n      height = Math.floor(height);\n    }\n\n    return {\n      height: height | 0,\n      width: width | 0\n    };\n  };\n\n  return ScreenshotTools;\n}();\n\nexport { ScreenshotTools };\nTools.CreateScreenshot = ScreenshotTools.CreateScreenshot;\nTools.CreateScreenshotAsync = ScreenshotTools.CreateScreenshotAsync;\nTools.CreateScreenshotUsingRenderTarget = ScreenshotTools.CreateScreenshotUsingRenderTarget;\nTools.CreateScreenshotUsingRenderTargetAsync = ScreenshotTools.CreateScreenshotUsingRenderTargetAsync;","map":null,"metadata":{},"sourceType":"module"}