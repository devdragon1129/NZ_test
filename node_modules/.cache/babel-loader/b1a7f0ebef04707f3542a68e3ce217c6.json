{"ast":null,"code":"import _objectSpread from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { ComponentType } from 'modules/scene/types';\nimport { getGLTFShapeName, getUniqueName } from 'modules/scene/utils';\nexport function addScale(scene) {\n  if (scene) {\n    for (var _i = 0, _Object$values = Object.values(scene.components); _i < _Object$values.length; _i++) {\n      var component = _Object$values[_i];\n\n      if (component.type === ComponentType.Transform) {\n        var transform = component;\n\n        if (!transform.data.scale) {\n          transform.data.scale = {\n            x: 1,\n            y: 1,\n            z: 1\n          };\n        }\n      }\n    }\n  }\n}\nexport function toProjectCloudSchema(project) {\n  var newProject = _objectSpread({}, project, {\n    userId: null,\n    createdAt: new Date(project.createdAt).toISOString(),\n    updatedAt: new Date().toISOString()\n  });\n\n  delete newProject.ownerEmail;\n  delete newProject.parcels;\n  return newProject;\n}\nexport function runMigrations(input, migrations) {\n  var out = input;\n  var version = out.version || 1;\n  var latestVersion = parseInt(Object.keys(migrations).slice(-1)[0], 10);\n\n  while (version < latestVersion) {\n    version++;\n\n    if (version in migrations) {\n      out = migrations[version](out);\n      out.version = version;\n    }\n  }\n\n  return out;\n}\nexport function getUniqueNameLegacy(components, takenNames) {\n  var attempts = 1;\n  var rawName = 'entity';\n\n  var _iterator = _createForOfIteratorHelper(components),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var component = _step.value;\n\n      try {\n        if (component.type === ComponentType.GLTFShape) {\n          rawName = getGLTFShapeName(component);\n        } else if (component.type === ComponentType.NFTShape) {\n          rawName = 'nft';\n        }\n      } catch (e) {// swallow\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var name = rawName;\n\n  while (takenNames.has(name)) {\n    name = \"\".concat(rawName).concat(++attempts);\n  }\n\n  return name;\n}\nexport function addEntityName(scene) {\n  var takenNames = new Set();\n\n  for (var entityId in scene.entities) {\n    var entity = scene.entities[entityId];\n    var components = entity.components.map(function (id) {\n      return scene.components[id];\n    });\n    var name = getUniqueNameLegacy(components, takenNames);\n    takenNames.add(name);\n    entity.name = name;\n  }\n}\nexport function addAssets(scene) {\n  if (!scene.assets) {\n    scene.assets = {};\n  }\n}\nexport function removeScriptSrc(scene) {\n  var scripts = Object.values(scene.components).filter(function (component) {\n    return component.type === ComponentType.Script;\n  });\n\n  var _iterator2 = _createForOfIteratorHelper(scripts),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var script = _step2.value;\n      delete script.data.src;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\nexport function sanitizeEntityName(scene) {\n  var takenNames = new Set();\n\n  for (var entityId in scene.entities) {\n    var entity = scene.entities[entityId];\n\n    if (entity.name.match(/^\\d/)) {\n      var components = entity.components.map(function (id) {\n        return scene.components[id];\n      });\n      var name = getUniqueName(components, takenNames, scene.assets);\n      takenNames.add(name);\n      entity.name = name;\n    }\n  }\n}\nexport function sanitizeEntityName2(scene) {\n  var takenNames = new Set();\n\n  for (var entityId in scene.entities) {\n    var entity = scene.entities[entityId]; // If the name is not a letter followed by more letters and numbers, then we need to update it\n\n    if (entity.name.match(/^[A-Za-z][A-Za-z\\d]+$/g) === null) {\n      var components = entity.components.map(function (id) {\n        return scene.components[id];\n      });\n      var name = getUniqueName(components, takenNames, scene.assets);\n      takenNames.add(name);\n      entity.name = name;\n    }\n  }\n}\nexport function dedupeEntityName(scene) {\n  var takenNames = new Set();\n\n  for (var entityId in scene.entities) {\n    var entity = scene.entities[entityId];\n    var components = entity.components.map(function (id) {\n      return scene.components[id];\n    });\n    var name = getUniqueName(components, takenNames, scene.assets);\n    takenNames.add(name);\n    entity.name = name;\n  }\n}\nexport function replaceUserIdWithEthAddress(project) {\n  delete project.userId; // tslint:disable-next-line\n\n  if (typeof project.ethAddress === 'undefined') {\n    project.ethAddress = null;\n  }\n}","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/migrations/utils.ts"],"names":["ComponentType","getGLTFShapeName","getUniqueName","addScale","scene","Object","values","components","component","type","Transform","transform","data","scale","x","y","z","toProjectCloudSchema","project","newProject","userId","createdAt","Date","toISOString","updatedAt","ownerEmail","parcels","runMigrations","input","migrations","out","version","latestVersion","parseInt","keys","slice","getUniqueNameLegacy","takenNames","attempts","rawName","GLTFShape","NFTShape","e","name","has","addEntityName","Set","entityId","entities","entity","map","id","add","addAssets","assets","removeScriptSrc","scripts","filter","Script","script","src","sanitizeEntityName","match","sanitizeEntityName2","dedupeEntityName","replaceUserIdWithEthAddress","ethAddress"],"mappings":"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","sourcesContent":["import { Project } from 'modules/project/types'\nimport { Migration, Versionable } from './types'\nimport { Scene, ComponentType, ComponentDefinition, AnyComponent } from 'modules/scene/types'\nimport { getGLTFShapeName, getUniqueName } from 'modules/scene/utils'\n\nexport function addScale(scene: Scene) {\n  if (scene) {\n    for (const component of Object.values(scene.components)) {\n      if (component.type === ComponentType.Transform) {\n        const transform = component as ComponentDefinition<ComponentType.Transform>\n        if (!transform.data.scale) {\n          transform.data.scale = { x: 1, y: 1, z: 1 }\n        }\n      }\n    }\n  }\n}\n\nexport function toProjectCloudSchema(project: Project): Project {\n  const newProject = {\n    ...project,\n    userId: null,\n    createdAt: new Date(project.createdAt).toISOString(),\n    updatedAt: new Date().toISOString()\n  }\n  delete (newProject as any).ownerEmail\n  delete (newProject as any).parcels\n  return newProject\n}\n\nexport function runMigrations<T extends Versionable>(input: T, migrations: Migration<T>) {\n  let out: T = input\n  let version = out.version || 1\n  const latestVersion = parseInt(Object.keys(migrations).slice(-1)[0], 10)\n\n  while (version < latestVersion) {\n    version++\n    if (version in migrations) {\n      out = migrations[version](out)\n      out.version = version\n    }\n  }\n\n  return out\n}\n\nexport function getUniqueNameLegacy(components: AnyComponent[], takenNames: Readonly<Set<string>>) {\n  let attempts = 1\n  let rawName = 'entity'\n\n  for (let component of components) {\n    try {\n      if (component.type === ComponentType.GLTFShape) {\n        rawName = getGLTFShapeName(component as ComponentDefinition<ComponentType.GLTFShape>)\n      } else if (component.type === ComponentType.NFTShape) {\n        rawName = 'nft'\n      }\n    } catch (e) {\n      // swallow\n    }\n  }\n\n  let name = rawName\n  while (takenNames.has(name)) {\n    name = `${rawName}${++attempts}`\n  }\n\n  return name\n}\n\nexport function addEntityName(scene: Scene) {\n  const takenNames = new Set<string>()\n\n  for (let entityId in scene.entities) {\n    const entity = scene.entities[entityId]\n    const components = entity.components.map(id => scene.components[id])\n    const name = getUniqueNameLegacy(components, takenNames)\n    takenNames.add(name)\n    entity.name = name\n  }\n}\n\nexport function addAssets(scene: Scene) {\n  if (!scene.assets) {\n    scene.assets = {}\n  }\n}\n\nexport function removeScriptSrc(scene: Scene) {\n  const scripts = Object.values(scene.components).filter(component => component.type === ComponentType.Script)\n  for (const script of scripts) {\n    delete (script.data as any).src\n  }\n}\n\nexport function sanitizeEntityName(scene: Scene) {\n  const takenNames = new Set<string>()\n\n  for (let entityId in scene.entities) {\n    const entity = scene.entities[entityId]\n    if (entity.name.match(/^\\d/)) {\n      const components = entity.components.map(id => scene.components[id])\n      const name = getUniqueName(components, takenNames, scene.assets)\n      takenNames.add(name)\n      entity.name = name\n    }\n  }\n}\n\nexport function sanitizeEntityName2(scene: Scene) {\n  const takenNames = new Set<string>()\n\n  for (let entityId in scene.entities) {\n    const entity = scene.entities[entityId]\n    // If the name is not a letter followed by more letters and numbers, then we need to update it\n    if (entity.name.match(/^[A-Za-z][A-Za-z\\d]+$/g) === null) {\n      const components = entity.components.map(id => scene.components[id])\n      const name = getUniqueName(components, takenNames, scene.assets)\n      takenNames.add(name)\n      entity.name = name\n    }\n  }\n}\n\nexport function dedupeEntityName(scene: Scene) {\n  const takenNames = new Set<string>()\n  for (let entityId in scene.entities) {\n    const entity = scene.entities[entityId]\n    const components = entity.components.map(id => scene.components[id])\n    const name = getUniqueName(components, takenNames, scene.assets)\n    takenNames.add(name)\n    entity.name = name\n  }\n}\n\nexport function replaceUserIdWithEthAddress(project: Project) {\n  delete (project as any).userId\n  // tslint:disable-next-line\n  if (typeof project.ethAddress === 'undefined') {\n    project.ethAddress = null\n  }\n}\n"]},"metadata":{},"sourceType":"module"}