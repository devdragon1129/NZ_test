{"ast":null,"code":"import { Color4 } from \"../Maths/math.color\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport \"../Shaders/depth.fragment\";\nimport \"../Shaders/depth.vertex\";\nimport { _DevTools } from '../Misc/devTools';\n/**\r\n * This represents a depth renderer in Babylon.\r\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\r\n */\n\nvar DepthRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a depth renderer\r\n   * @param scene The scene the renderer belongs to\r\n   * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\r\n   * @param camera The camera to be used to render the depth map (default: scene's active camera)\r\n   * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n   */\n  function DepthRenderer(scene, type, camera, storeNonLinearDepth) {\n    var _this = this;\n\n    if (type === void 0) {\n      type = 1;\n    }\n\n    if (camera === void 0) {\n      camera = null;\n    }\n\n    if (storeNonLinearDepth === void 0) {\n      storeNonLinearDepth = false;\n    }\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n\n\n    this.enabled = true;\n    /**\r\n     * Specifiess that the depth renderer will only be used within\r\n     * the camera it is created for.\r\n     * This can help forcing its rendering during the camera processing.\r\n     */\n\n    this.useOnlyInActiveCamera = false;\n    this._scene = scene;\n    this._storeNonLinearDepth = storeNonLinearDepth;\n    this.isPacked = type === 0;\n\n    if (this.isPacked) {\n      this._clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\n    }\n\n    DepthRenderer._SceneComponentInitialization(this._scene);\n\n    this._camera = camera;\n    var engine = scene.getEngine(); // Render target\n\n    var format = this.isPacked || engine.webGLVersion === 1 ? 5 : 6;\n    this._depthMap = new RenderTargetTexture(\"depthMap\", {\n      width: engine.getRenderWidth(),\n      height: engine.getRenderHeight()\n    }, this._scene, false, true, type, false, undefined, undefined, undefined, undefined, format);\n    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.refreshRate = 1;\n    this._depthMap.renderParticles = false;\n    this._depthMap.renderList = null; // Camera to get depth map from to support multiple concurrent cameras\n\n    this._depthMap.activeCamera = this._camera;\n    this._depthMap.ignoreCameraViewport = true;\n    this._depthMap.useCameraPostProcesses = false; // set default depth value to 1.0 (far away)\n\n    this._depthMap.onClearObservable.add(function (engine) {\n      engine.clear(_this._clearColor, true, true, true);\n    }); // Custom render function\n\n\n    var renderSubMesh = function renderSubMesh(subMesh) {\n      var renderingMesh = subMesh.getRenderingMesh();\n      var effectiveMesh = subMesh.getEffectiveMesh();\n      var scene = _this._scene;\n      var engine = scene.getEngine();\n      var material = subMesh.getMaterial();\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n\n      if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n        return;\n      } // Culling and reverse (right handed system)\n\n\n      engine.setState(material.backFaceCulling, 0, false, scene.useRightHandedSystem); // Managing instances\n\n      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n      if (batch.mustReturn) {\n        return;\n      }\n\n      var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n      var camera = _this._camera || scene.activeCamera;\n\n      if (_this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n        subMesh._renderId = scene.getRenderId();\n        engine.enableEffect(_this._effect);\n\n        renderingMesh._bind(subMesh, _this._effect, material.fillMode);\n\n        _this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n        _this._effect.setFloat2(\"depthValues\", camera.minZ, camera.minZ + camera.maxZ); // Alpha test\n\n\n        if (material && material.needAlphaTesting()) {\n          var alphaTexture = material.getAlphaTestTexture();\n\n          if (alphaTexture) {\n            _this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n\n            _this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n          }\n        } // Bones\n\n\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          _this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n        } // Morph targets\n\n\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, _this._effect); // Draw\n\n        renderingMesh._processRendering(effectiveMesh, subMesh, _this._effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n          return _this._effect.setMatrix(\"world\", world);\n        });\n      }\n    };\n\n    this._depthMap.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      var index;\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n    };\n  }\n  /**\r\n   * Creates the depth rendering effect and checks if the effect is ready.\r\n   * @param subMesh The submesh to be used to render the depth map of\r\n   * @param useInstances If multiple world instances should be used\r\n   * @returns if the depth renderer is ready to render the depth map\r\n   */\n\n\n  DepthRenderer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n\n    if (material.disableDepthWrite) {\n      return false;\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind];\n    var mesh = subMesh.getMesh(); // Alpha test\n\n    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n      defines.push(\"#define ALPHATEST\");\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var morphTargetManager = mesh.morphTargetManager;\n    var numMorphInfluencers = 0;\n\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // None linear depth\n\n\n    if (this._storeNonLinearDepth) {\n      defines.push(\"#define NONLINEARDEPTH\");\n    } // Float Mode\n\n\n    if (this.isPacked) {\n      defines.push(\"#define PACKED\");\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effect = this._scene.getEngine().createEffect(\"depth\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"depthValues\", \"morphTargetInfluences\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      });\n    }\n\n    return this._effect.isReady();\n  };\n  /**\r\n   * Gets the texture which the depth map will be written to.\r\n   * @returns The depth map texture\r\n   */\n\n\n  DepthRenderer.prototype.getDepthMap = function () {\n    return this._depthMap;\n  };\n  /**\r\n   * Disposes of the depth renderer.\r\n   */\n\n\n  DepthRenderer.prototype.dispose = function () {\n    this._depthMap.dispose();\n  };\n  /** @hidden */\n\n\n  DepthRenderer._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"DepthRendererSceneComponent\");\n  };\n\n  return DepthRenderer;\n}();\n\nexport { DepthRenderer };","map":null,"metadata":{},"sourceType":"module"}