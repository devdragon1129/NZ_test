{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators\";\nimport { Tools } from \"../Misc/tools\";\nimport { TargetCamera } from \"./targetCamera\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { FollowCameraInputsManager } from './followCameraInputsManager';\nNode.AddNodeConstructor(\"FollowCamera\", function (name, scene) {\n  return function () {\n    return new FollowCamera(name, Vector3.Zero(), scene);\n  };\n});\nNode.AddNodeConstructor(\"ArcFollowCamera\", function (name, scene) {\n  return function () {\n    return new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\n  };\n});\n/**\r\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\r\n * an arc rotate version arcFollowCamera are available.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\n\nvar FollowCamera =\n/** @class */\nfunction (_super) {\n  __extends(FollowCamera, _super);\n  /**\r\n   * Instantiates the follow camera.\r\n   * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n   * @param name Define the name of the camera in the scene\r\n   * @param position Define the position of the camera\r\n   * @param scene Define the scene the camera belong to\r\n   * @param lockedTarget Define the target of the camera\r\n   */\n\n\n  function FollowCamera(name, position, scene, lockedTarget) {\n    if (lockedTarget === void 0) {\n      lockedTarget = null;\n    }\n\n    var _this = _super.call(this, name, position, scene) || this;\n    /**\r\n     * Distance the follow camera should follow an object at\r\n     */\n\n\n    _this.radius = 12;\n    /**\r\n     * Minimum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerRadiusLimit = null;\n    /**\r\n     * Maximum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperRadiusLimit = null;\n    /**\r\n     * Define a rotation offset between the camera and the object it follows\r\n     */\n\n    _this.rotationOffset = 0;\n    /**\r\n     * Minimum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerRotationOffsetLimit = null;\n    /**\r\n     * Maximum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperRotationOffsetLimit = null;\n    /**\r\n     * Define a height offset between the camera and the object it follows.\r\n     * It can help following an object from the top (like a car chaing a plane)\r\n     */\n\n    _this.heightOffset = 4;\n    /**\r\n     * Minimum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerHeightOffsetLimit = null;\n    /**\r\n     * Maximum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperHeightOffsetLimit = null;\n    /**\r\n     * Define how fast the camera can accelerate to follow it s target.\r\n     */\n\n    _this.cameraAcceleration = 0.05;\n    /**\r\n     * Define the speed limit of the camera following an object.\r\n     */\n\n    _this.maxCameraSpeed = 20;\n    _this.lockedTarget = lockedTarget;\n    _this.inputs = new FollowCameraInputsManager(_this);\n\n    _this.inputs.addKeyboard().addMouseWheel().addPointers();\n\n    return _this; // Uncomment the following line when the relevant handlers have been implemented.\n    // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\n  }\n\n  FollowCamera.prototype._follow = function (cameraTarget) {\n    if (!cameraTarget) {\n      return;\n    }\n\n    var yRotation;\n\n    if (cameraTarget.rotationQuaternion) {\n      var rotMatrix = new Matrix();\n      cameraTarget.rotationQuaternion.toRotationMatrix(rotMatrix);\n      yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\n    } else {\n      yRotation = cameraTarget.rotation.y;\n    }\n\n    var radians = Tools.ToRadians(this.rotationOffset) + yRotation;\n    var targetPosition = cameraTarget.getAbsolutePosition();\n    var targetX = targetPosition.x + Math.sin(radians) * this.radius;\n    var targetZ = targetPosition.z + Math.cos(radians) * this.radius;\n    var dx = targetX - this.position.x;\n    var dy = targetPosition.y + this.heightOffset - this.position.y;\n    var dz = targetZ - this.position.z;\n    var vx = dx * this.cameraAcceleration * 2; //this is set to .05\n\n    var vy = dy * this.cameraAcceleration;\n    var vz = dz * this.cameraAcceleration * 2;\n\n    if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\n      vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\n      vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\n      vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\n    this.setTarget(targetPosition);\n  };\n  /**\r\n   * Attached controls to the current camera.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n\n  FollowCamera.prototype.attachControl = function (ignored, noPreventDefault) {\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n\n    this._reset = function () {};\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  FollowCamera.prototype.detachControl = function (ignored) {\n    this.inputs.detachElement();\n\n    if (this._reset) {\n      this._reset();\n    }\n  };\n  /** @hidden */\n\n\n  FollowCamera.prototype._checkInputs = function () {\n    this.inputs.checkInputs();\n\n    this._checkLimits();\n\n    _super.prototype._checkInputs.call(this);\n\n    if (this.lockedTarget) {\n      this._follow(this.lockedTarget);\n    }\n  };\n\n  FollowCamera.prototype._checkLimits = function () {\n    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\n      this.radius = this.lowerRadiusLimit;\n    }\n\n    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\n      this.radius = this.upperRadiusLimit;\n    }\n\n    if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\n      this.heightOffset = this.lowerHeightOffsetLimit;\n    }\n\n    if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\n      this.heightOffset = this.upperHeightOffsetLimit;\n    }\n\n    if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\n      this.rotationOffset = this.lowerRotationOffsetLimit;\n    }\n\n    if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\n      this.rotationOffset = this.upperRotationOffsetLimit;\n    }\n  };\n  /**\r\n   * Gets the camera class name.\r\n   * @returns the class name\r\n   */\n\n\n  FollowCamera.prototype.getClassName = function () {\n    return \"FollowCamera\";\n  };\n\n  __decorate([serialize()], FollowCamera.prototype, \"radius\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerRadiusLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperRadiusLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"rotationOffset\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerRotationOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperRotationOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"heightOffset\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerHeightOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperHeightOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"cameraAcceleration\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"maxCameraSpeed\", void 0);\n\n  __decorate([serializeAsMeshReference(\"lockedTargetId\")], FollowCamera.prototype, \"lockedTarget\", void 0);\n\n  return FollowCamera;\n}(TargetCamera);\n\nexport { FollowCamera };\n/**\r\n * Arc Rotate version of the follow camera.\r\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\n\nvar ArcFollowCamera =\n/** @class */\nfunction (_super) {\n  __extends(ArcFollowCamera, _super);\n  /**\r\n   * Instantiates a new ArcFollowCamera\r\n   * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n   * @param name Define the name of the camera\r\n   * @param alpha Define the rotation angle of the camera around the logitudinal axis\r\n   * @param beta Define the rotation angle of the camera around the elevation axis\r\n   * @param radius Define the radius of the camera from its target point\r\n   * @param target Define the target of the camera\r\n   * @param scene Define the scene the camera belongs to\r\n   */\n\n\n  function ArcFollowCamera(name,\n  /** The longitudinal angle of the camera */\n  alpha,\n  /** The latitudinal angle of the camera */\n  beta,\n  /** The radius of the camera from its target */\n  radius,\n  /** Define the camera target (the mesh it should follow) */\n  target, scene) {\n    var _this = _super.call(this, name, Vector3.Zero(), scene) || this;\n\n    _this.alpha = alpha;\n    _this.beta = beta;\n    _this.radius = radius;\n    _this._cartesianCoordinates = Vector3.Zero();\n    _this._meshTarget = target;\n\n    _this._follow();\n\n    return _this;\n  }\n\n  ArcFollowCamera.prototype._follow = function () {\n    if (!this._meshTarget) {\n      return;\n    }\n\n    this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\n    this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\n    this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\n\n    var targetPosition = this._meshTarget.getAbsolutePosition();\n\n    this.position = targetPosition.add(this._cartesianCoordinates);\n    this.setTarget(targetPosition);\n  };\n  /** @hidden */\n\n\n  ArcFollowCamera.prototype._checkInputs = function () {\n    _super.prototype._checkInputs.call(this);\n\n    this._follow();\n  };\n  /**\r\n   * Returns the class name of the object.\r\n   * It is mostly used internally for serialization purposes.\r\n   */\n\n\n  ArcFollowCamera.prototype.getClassName = function () {\n    return \"ArcFollowCamera\";\n  };\n\n  return ArcFollowCamera;\n}(TargetCamera);\n\nexport { ArcFollowCamera };","map":null,"metadata":{},"sourceType":"module"}