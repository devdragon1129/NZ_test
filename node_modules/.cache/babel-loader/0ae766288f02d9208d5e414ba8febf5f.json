{"ast":null,"code":"import { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\nimport { PhysicsJoint } from \"../../Physics/physicsJoint\";\nimport { PhysicsEngine } from \"../../Physics/physicsEngine\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\nimport { Logger } from \"../../Misc/logger\";\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\n/** @hidden */\n\nvar OimoJSPlugin =\n/** @class */\nfunction () {\n  function OimoJSPlugin(_useDeltaForWorldStep, iterations, oimoInjection) {\n    if (_useDeltaForWorldStep === void 0) {\n      _useDeltaForWorldStep = true;\n    }\n\n    if (oimoInjection === void 0) {\n      oimoInjection = OIMO;\n    }\n\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"OimoJSPlugin\";\n    this._fixedTimeStep = 1 / 60;\n    this._tmpImpostorsArray = [];\n    this._tmpPositionVector = Vector3.Zero();\n    this.BJSOIMO = oimoInjection;\n    this.world = new this.BJSOIMO.World({\n      iterations: iterations\n    });\n    this.world.clear();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n\n  OimoJSPlugin.prototype.setGravity = function (gravity) {\n    this.world.gravity.set(gravity.x, gravity.y, gravity.z);\n  };\n\n  OimoJSPlugin.prototype.setTimeStep = function (timeStep) {\n    this.world.timeStep = timeStep;\n  };\n\n  OimoJSPlugin.prototype.getTimeStep = function () {\n    return this.world.timeStep;\n  };\n\n  OimoJSPlugin.prototype.executeStep = function (delta, impostors) {\n    var _this = this;\n\n    impostors.forEach(function (impostor) {\n      impostor.beforeStep();\n    });\n    this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\n    this.world.step();\n    impostors.forEach(function (impostor) {\n      impostor.afterStep(); //update the ordered impostors array\n\n      _this._tmpImpostorsArray[impostor.uniqueId] = impostor;\n    }); //check for collisions\n\n    var contact = this.world.contacts;\n\n    while (contact !== null) {\n      if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\n        contact = contact.next;\n        continue;\n      } //is this body colliding with any other? get the impostor\n\n\n      var mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\n      var collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\n\n      if (!mainImpostor || !collidingImpostor) {\n        contact = contact.next;\n        continue;\n      }\n\n      mainImpostor.onCollide({\n        body: collidingImpostor.physicsBody,\n        point: null\n      });\n      collidingImpostor.onCollide({\n        body: mainImpostor.physicsBody,\n        point: null\n      });\n      contact = contact.next;\n    }\n  };\n\n  OimoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n    var mass = impostor.physicsBody.mass;\n    impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\n  };\n\n  OimoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n    Logger.Warn(\"Oimo doesn't support applying force. Using impule instead.\");\n    this.applyImpulse(impostor, force, contactPoint);\n  };\n\n  OimoJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n    var _this = this; //parent-child relationship. Does this impostor has a parent impostor?\n\n\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor); //TODO is that needed?\n\n        impostor.forceUpdate();\n      }\n\n      return;\n    }\n\n    if (impostor.isBodyInitRequired()) {\n      var bodyConfig = {\n        name: impostor.uniqueId,\n        //Oimo must have mass, also for static objects.\n        config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\n        size: [],\n        type: [],\n        pos: [],\n        posShape: [],\n        rot: [],\n        rotShape: [],\n        move: impostor.getParam(\"mass\") !== 0,\n        density: impostor.getParam(\"mass\"),\n        friction: impostor.getParam(\"friction\"),\n        restitution: impostor.getParam(\"restitution\"),\n        //Supporting older versions of Oimo\n        world: this.world\n      };\n      var impostors = [impostor];\n\n      var addToArray = function addToArray(parent) {\n        if (!parent.getChildMeshes) {\n          return;\n        }\n\n        parent.getChildMeshes().forEach(function (m) {\n          if (m.physicsImpostor) {\n            impostors.push(m.physicsImpostor); //m.physicsImpostor._init();\n          }\n        });\n      };\n\n      addToArray(impostor.object);\n\n      var checkWithEpsilon_1 = function checkWithEpsilon_1(value) {\n        return Math.max(value, PhysicsEngine.Epsilon);\n      };\n\n      var globalQuaternion_1 = new Quaternion();\n      impostors.forEach(function (i) {\n        if (!i.object.rotationQuaternion) {\n          return;\n        } //get the correct bounding box\n\n\n        var oldQuaternion = i.object.rotationQuaternion;\n        globalQuaternion_1.copyFrom(oldQuaternion);\n        i.object.rotationQuaternion.set(0, 0, 0, 1);\n        i.object.computeWorldMatrix(true);\n        var rot = globalQuaternion_1.toEulerAngles();\n        var extendSize = i.getObjectExtendSize();\n        var radToDeg = 57.295779513082320876;\n\n        if (i === impostor) {\n          var center = impostor.getObjectCenter();\n          impostor.object.getAbsolutePivotPoint().subtractToRef(center, _this._tmpPositionVector);\n\n          _this._tmpPositionVector.divideInPlace(impostor.object.scaling); //Can also use Array.prototype.push.apply\n\n\n          bodyConfig.pos.push(center.x);\n          bodyConfig.pos.push(center.y);\n          bodyConfig.pos.push(center.z);\n          bodyConfig.posShape.push(0, 0, 0);\n          bodyConfig.rotShape.push(0, 0, 0);\n        } else {\n          var localPosition = i.object.position.clone();\n          bodyConfig.posShape.push(localPosition.x);\n          bodyConfig.posShape.push(localPosition.y);\n          bodyConfig.posShape.push(localPosition.z); // bodyConfig.pos.push(0, 0, 0);\n\n          bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\n        }\n\n        i.object.rotationQuaternion.copyFrom(globalQuaternion_1); // register mesh\n\n        switch (i.type) {\n          case PhysicsImpostor.ParticleImpostor:\n            Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\n\n          case PhysicsImpostor.SphereImpostor:\n            var radiusX = extendSize.x;\n            var radiusY = extendSize.y;\n            var radiusZ = extendSize.z;\n            var size = Math.max(checkWithEpsilon_1(radiusX), checkWithEpsilon_1(radiusY), checkWithEpsilon_1(radiusZ)) / 2;\n            bodyConfig.type.push(\"sphere\"); //due to the way oimo works with compounds, add 3 times\n\n            bodyConfig.size.push(size);\n            bodyConfig.size.push(size);\n            bodyConfig.size.push(size);\n            break;\n\n          case PhysicsImpostor.CylinderImpostor:\n            var sizeX = checkWithEpsilon_1(extendSize.x) / 2;\n            var sizeY = checkWithEpsilon_1(extendSize.y);\n            bodyConfig.type.push(\"cylinder\");\n            bodyConfig.size.push(sizeX);\n            bodyConfig.size.push(sizeY); //due to the way oimo works with compounds, add one more value.\n\n            bodyConfig.size.push(sizeY);\n            break;\n\n          case PhysicsImpostor.PlaneImpostor:\n          case PhysicsImpostor.BoxImpostor:\n          default:\n            var sizeX = checkWithEpsilon_1(extendSize.x);\n            var sizeY = checkWithEpsilon_1(extendSize.y);\n            var sizeZ = checkWithEpsilon_1(extendSize.z);\n            bodyConfig.type.push(\"box\"); //if (i === impostor) {\n\n            bodyConfig.size.push(sizeX);\n            bodyConfig.size.push(sizeY);\n            bodyConfig.size.push(sizeZ); //} else {\n            //    bodyConfig.size.push(0,0,0);\n            //}\n\n            break;\n        } //actually not needed, but hey...\n\n\n        i.object.rotationQuaternion = oldQuaternion;\n      });\n      impostor.physicsBody = this.world.add(bodyConfig); // set the quaternion, ignoring the previously defined (euler) rotation\n\n      impostor.physicsBody.resetQuaternion(globalQuaternion_1); // update with delta 0, so the body will receive the new rotation.\n\n      impostor.physicsBody.updatePosition(0);\n    } else {\n      this._tmpPositionVector.copyFromFloats(0, 0, 0);\n    }\n\n    impostor.setDeltaPosition(this._tmpPositionVector); //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\n    //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\n  };\n\n  OimoJSPlugin.prototype.removePhysicsBody = function (impostor) {\n    //impostor.physicsBody.dispose();\n    //Same as : (older oimo versions)\n    this.world.removeRigidBody(impostor.physicsBody);\n  };\n\n  OimoJSPlugin.prototype.generateJoint = function (impostorJoint) {\n    var mainBody = impostorJoint.mainImpostor.physicsBody;\n    var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n\n    var jointData = impostorJoint.joint.jointData;\n    var options = jointData.nativeParams || {};\n    var type;\n    var nativeJointData = {\n      body1: mainBody,\n      body2: connectedBody,\n      axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\n      axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\n      pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\n      pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\n      min: options.min,\n      max: options.max,\n      collision: options.collision || jointData.collision,\n      spring: options.spring,\n      //supporting older version of Oimo\n      world: this.world\n    };\n\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.BallAndSocketJoint:\n        type = \"jointBall\";\n        break;\n\n      case PhysicsJoint.SpringJoint:\n        Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\n        var springData = jointData;\n        nativeJointData.min = springData.length || nativeJointData.min; //Max should also be set, just make sure it is at least min\n\n        nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\n\n      case PhysicsJoint.DistanceJoint:\n        type = \"jointDistance\";\n        nativeJointData.max = jointData.maxDistance;\n        break;\n\n      case PhysicsJoint.PrismaticJoint:\n        type = \"jointPrisme\";\n        break;\n\n      case PhysicsJoint.SliderJoint:\n        type = \"jointSlide\";\n        break;\n\n      case PhysicsJoint.WheelJoint:\n        type = \"jointWheel\";\n        break;\n\n      case PhysicsJoint.HingeJoint:\n      default:\n        type = \"jointHinge\";\n        break;\n    }\n\n    nativeJointData.type = type;\n    impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\n  };\n\n  OimoJSPlugin.prototype.removeJoint = function (impostorJoint) {\n    //Bug in Oimo prevents us from disposing a joint in the playground\n    //joint.joint.physicsJoint.dispose();\n    //So we will bruteforce it!\n    try {\n      this.world.removeJoint(impostorJoint.joint.physicsJoint);\n    } catch (e) {\n      Logger.Warn(e);\n    }\n  };\n\n  OimoJSPlugin.prototype.isSupported = function () {\n    return this.BJSOIMO !== undefined;\n  };\n\n  OimoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n    if (!impostor.physicsBody.sleeping) {\n      if (impostor.physicsBody.shapes.next) {\n        var parent_1 = impostor.physicsBody.shapes;\n\n        while (parent_1.next) {\n          parent_1 = parent_1.next;\n        }\n\n        impostor.object.position.set(parent_1.position.x, parent_1.position.y, parent_1.position.z);\n      } else {\n        var pos = impostor.physicsBody.getPosition();\n        impostor.object.position.set(pos.x, pos.y, pos.z);\n      } //}\n\n\n      if (impostor.object.rotationQuaternion) {\n        var quat = impostor.physicsBody.getQuaternion();\n        impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\n      }\n    }\n  };\n\n  OimoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n    var body = impostor.physicsBody; // disable bidirectional for compound meshes\n\n    if (impostor.physicsBody.shapes.next) {\n      return;\n    }\n\n    body.position.set(newPosition.x, newPosition.y, newPosition.z);\n    body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n    body.syncShapes();\n    body.awake();\n  };\n  /*private _getLastShape(body: any): any {\r\n      var lastShape = body.shapes;\r\n      while (lastShape.next) {\r\n          lastShape = lastShape.next;\r\n      }\r\n      return lastShape;\r\n  }*/\n\n\n  OimoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n    impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  OimoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  OimoJSPlugin.prototype.getLinearVelocity = function (impostor) {\n    var v = impostor.physicsBody.linearVelocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  OimoJSPlugin.prototype.getAngularVelocity = function (impostor) {\n    var v = impostor.physicsBody.angularVelocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  OimoJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n    var staticBody = mass === 0; //this will actually set the body's density and not its mass.\n    //But this is how oimo treats the mass variable.\n\n    impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\n    impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\n  };\n\n  OimoJSPlugin.prototype.getBodyMass = function (impostor) {\n    return impostor.physicsBody.shapes.density;\n  };\n\n  OimoJSPlugin.prototype.getBodyFriction = function (impostor) {\n    return impostor.physicsBody.shapes.friction;\n  };\n\n  OimoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n    impostor.physicsBody.shapes.friction = friction;\n  };\n\n  OimoJSPlugin.prototype.getBodyRestitution = function (impostor) {\n    return impostor.physicsBody.shapes.restitution;\n  };\n\n  OimoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n    impostor.physicsBody.shapes.restitution = restitution;\n  };\n\n  OimoJSPlugin.prototype.sleepBody = function (impostor) {\n    impostor.physicsBody.sleep();\n  };\n\n  OimoJSPlugin.prototype.wakeUpBody = function (impostor) {\n    impostor.physicsBody.awake();\n  };\n\n  OimoJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {\n    joint.physicsJoint.limitMotor.upperLimit = maxDistance;\n\n    if (minDistance !== void 0) {\n      joint.physicsJoint.limitMotor.lowerLimit = minDistance;\n    }\n  };\n\n  OimoJSPlugin.prototype.setMotor = function (joint, speed, force, motorIndex) {\n    if (force !== undefined) {\n      Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\n    } else {\n      force = 1e6;\n    }\n\n    speed *= -1; //TODO separate rotational and transational motors.\n\n    var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n\n    if (motor) {\n      motor.setMotor(speed, force);\n    }\n  };\n\n  OimoJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit, motorIndex) {\n    //TODO separate rotational and transational motors.\n    var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n\n    if (motor) {\n      motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\n    }\n  };\n\n  OimoJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n    var body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.orientation.x;\n      mesh.rotationQuaternion.y = body.orientation.y;\n      mesh.rotationQuaternion.z = body.orientation.z;\n      mesh.rotationQuaternion.w = body.orientation.s;\n    }\n  };\n\n  OimoJSPlugin.prototype.getRadius = function (impostor) {\n    return impostor.physicsBody.shapes.radius;\n  };\n\n  OimoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n    var shape = impostor.physicsBody.shapes;\n    result.x = shape.halfWidth * 2;\n    result.y = shape.halfHeight * 2;\n    result.z = shape.halfDepth * 2;\n  };\n\n  OimoJSPlugin.prototype.dispose = function () {\n    this.world.clear();\n  };\n  /**\r\n   * Does a raycast in the physics world\r\n   * @param from when should the ray start?\r\n   * @param to when should the ray end?\r\n   * @returns PhysicsRaycastResult\r\n   */\n\n\n  OimoJSPlugin.prototype.raycast = function (from, to) {\n    Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\n\n    this._raycastResult.reset(from, to);\n\n    return this._raycastResult;\n  };\n\n  return OimoJSPlugin;\n}();\n\nexport { OimoJSPlugin };","map":null,"metadata":{},"sourceType":"module"}