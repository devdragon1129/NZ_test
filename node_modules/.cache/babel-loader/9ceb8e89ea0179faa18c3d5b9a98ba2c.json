{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { SmartArray } from \"../Misc/smartArray\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport \"../Shaders/postprocess.vertex\";\nimport { Engine } from '../Engines/engine';\nimport \"../Engines/Extensions/engine.renderTarget\";\nimport { serialize, serializeAsColor4, SerializationHelper } from '../Misc/decorators';\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * PostProcess can be used to apply a shader to a texture after it has been rendered\r\n * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses\r\n */\n\nvar PostProcess =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance PostProcess\r\n   * @param name The name of the PostProcess.\r\n   * @param fragmentUrl The url of the fragment shader to be used.\r\n   * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\r\n   * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   * @param defines String of defines that will be set when running the fragment shader. (default: null)\r\n   * @param textureType Type of textures used when performing the post process. (default: 0)\r\n   * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\r\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n   * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\r\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n   */\n  function PostProcess(name, fragmentUrl, parameters, samplers, options, camera, samplingMode, engine, reusable, defines, textureType, vertexUrl, indexParameters, blockCompilation, textureFormat) {\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (vertexUrl === void 0) {\n      vertexUrl = \"postprocess\";\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n    /**\r\n    * Width of the texture to apply the post process on\r\n    */\n\n\n    this.width = -1;\n    /**\r\n    * Height of the texture to apply the post process on\r\n    */\n\n    this.height = -1;\n    /**\r\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\r\n     */\n\n    this.nodeMaterialSource = null;\n    /**\r\n    * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\r\n    * @hidden\r\n    */\n\n    this._outputTexture = null;\n    /**\r\n    * If the buffer needs to be cleared before applying the post process. (default: true)\r\n    * Should be set to false if shader will overwrite all previous pixels.\r\n    */\n\n    this.autoClear = true;\n    /**\r\n    * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\r\n    */\n\n    this.alphaMode = 0;\n    /**\r\n    * Animations to be used for the post processing\r\n    */\n\n    this.animations = new Array();\n    /**\r\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\r\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\r\n     */\n\n    this.enablePixelPerfectMode = false;\n    /**\r\n     * Force the postprocess to be applied without taking in account viewport\r\n     */\n\n    this.forceFullscreenViewport = true;\n    /**\r\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\r\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\r\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\r\n     *\r\n     */\n\n    this.scaleMode = 1;\n    /**\r\n    * Force textures to be a power of two (default: false)\r\n    */\n\n    this.alwaysForcePOT = false;\n    this._samples = 1;\n    /**\r\n    * Modify the scale of the post process to be the same as the viewport (default: false)\r\n    */\n\n    this.adaptScaleToCurrentViewport = false;\n    this._reusable = false;\n    /**\r\n    * Smart array of input and output textures for the post process.\r\n    * @hidden\r\n    */\n\n    this._textures = new SmartArray(2);\n    /**\r\n    * The index in _textures that corresponds to the output texture.\r\n    * @hidden\r\n    */\n\n    this._currentRenderTextureInd = 0;\n    this._scaleRatio = new Vector2(1, 1);\n    this._texelSize = Vector2.Zero(); // Events\n\n    /**\r\n    * An event triggered when the postprocess is activated.\r\n    */\n\n    this.onActivateObservable = new Observable();\n    /**\r\n    * An event triggered when the postprocess changes its size.\r\n    */\n\n    this.onSizeChangedObservable = new Observable();\n    /**\r\n    * An event triggered when the postprocess applies its effect.\r\n    */\n\n    this.onApplyObservable = new Observable();\n    /**\r\n    * An event triggered before rendering the postprocess\r\n    */\n\n    this.onBeforeRenderObservable = new Observable();\n    /**\r\n    * An event triggered after rendering the postprocess\r\n    */\n\n    this.onAfterRenderObservable = new Observable();\n    this.name = name;\n\n    if (camera != null) {\n      this._camera = camera;\n      this._scene = camera.getScene();\n      camera.attachPostProcess(this);\n      this._engine = this._scene.getEngine();\n\n      this._scene.postProcesses.push(this);\n\n      this.uniqueId = this._scene.getUniqueId();\n    } else if (engine) {\n      this._engine = engine;\n\n      this._engine.postProcesses.push(this);\n    }\n\n    this._options = options;\n    this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;\n    this._reusable = reusable || false;\n    this._textureType = textureType;\n    this._textureFormat = textureFormat;\n    this._samplers = samplers || [];\n\n    this._samplers.push(\"textureSampler\");\n\n    this._fragmentUrl = fragmentUrl;\n    this._vertexUrl = vertexUrl;\n    this._parameters = parameters || [];\n\n    this._parameters.push(\"scale\");\n\n    this._indexParameters = indexParameters;\n\n    if (!blockCompilation) {\n      this.updateEffect(defines);\n    }\n  }\n\n  Object.defineProperty(PostProcess.prototype, \"samples\", {\n    /**\r\n    * Number of sample textures (default: 1)\r\n    */\n    get: function get() {\n      return this._samples;\n    },\n    set: function set(n) {\n      var _this = this;\n\n      this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\n\n      this._textures.forEach(function (texture) {\n        if (texture.samples !== _this._samples) {\n          _this._engine.updateRenderTargetTextureSampleCount(texture, _this._samples);\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the fragment url or shader name used in the post process.\r\n   * @returns the fragment url or name in the shader store.\r\n   */\n\n  PostProcess.prototype.getEffectName = function () {\n    return this._fragmentUrl;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"onActivate\", {\n    /**\r\n    * A function that is added to the onActivateObservable\r\n    */\n    set: function set(callback) {\n      if (this._onActivateObserver) {\n        this.onActivateObservable.remove(this._onActivateObserver);\n      }\n\n      if (callback) {\n        this._onActivateObserver = this.onActivateObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onSizeChanged\", {\n    /**\r\n    * A function that is added to the onSizeChangedObservable\r\n    */\n    set: function set(callback) {\n      if (this._onSizeChangedObserver) {\n        this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\n      }\n\n      this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onApply\", {\n    /**\r\n    * A function that is added to the onApplyObservable\r\n    */\n    set: function set(callback) {\n      if (this._onApplyObserver) {\n        this.onApplyObservable.remove(this._onApplyObserver);\n      }\n\n      this._onApplyObserver = this.onApplyObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onBeforeRender\", {\n    /**\r\n    * A function that is added to the onBeforeRenderObservable\r\n    */\n    set: function set(callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onAfterRender\", {\n    /**\r\n    * A function that is added to the onAfterRenderObservable\r\n    */\n    set: function set(callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"inputTexture\", {\n    /**\r\n    * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\r\n    * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\r\n    */\n    get: function get() {\n      return this._textures.data[this._currentRenderTextureInd];\n    },\n    set: function set(value) {\n      this._forcedOutputTexture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n  * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\r\n  * the only way to unset it is to use this function to restore its internal state\r\n  */\n\n  PostProcess.prototype.restoreDefaultInputTexture = function () {\n    this._forcedOutputTexture = null;\n  };\n  /**\r\n  * Gets the camera which post process is applied to.\r\n  * @returns The camera the post process is applied to.\r\n  */\n\n\n  PostProcess.prototype.getCamera = function () {\n    return this._camera;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"texelSize\", {\n    /**\r\n    * Gets the texel size of the postprocess.\r\n    * See https://en.wikipedia.org/wiki/Texel_(graphics)\r\n    */\n    get: function get() {\n      if (this._shareOutputWithPostProcess) {\n        return this._shareOutputWithPostProcess.texelSize;\n      }\n\n      if (this._forcedOutputTexture) {\n        this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\n      }\n\n      return this._texelSize;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"PostProcess\" string\r\n   */\n\n  PostProcess.prototype.getClassName = function () {\n    return \"PostProcess\";\n  };\n  /**\r\n   * Gets the engine which this post process belongs to.\r\n   * @returns The engine the post process was enabled with.\r\n   */\n\n\n  PostProcess.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * The effect that is created when initializing the post process.\r\n   * @returns The created effect corresponding the the postprocess.\r\n   */\n\n\n  PostProcess.prototype.getEffect = function () {\n    return this._effect;\n  };\n  /**\r\n   * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\r\n   * @param postProcess The post process to share the output with.\r\n   * @returns This post process.\r\n   */\n\n\n  PostProcess.prototype.shareOutputWith = function (postProcess) {\n    this._disposeTextures();\n\n    this._shareOutputWithPostProcess = postProcess;\n    return this;\n  };\n  /**\r\n   * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\r\n   * This should be called if the post process that shares output with this post process is disabled/disposed.\r\n   */\n\n\n  PostProcess.prototype.useOwnOutput = function () {\n    if (this._textures.length == 0) {\n      this._textures = new SmartArray(2);\n    }\n\n    this._shareOutputWithPostProcess = null;\n  };\n  /**\r\n   * Updates the effect with the current post process compile time values and recompiles the shader.\r\n   * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n   * @param onCompiled Called when the shader has been compiled.\r\n   * @param onError Called if there is an error when compiling a shader.\r\n   * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\r\n   * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\r\n   */\n\n\n  PostProcess.prototype.updateEffect = function (defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (uniforms === void 0) {\n      uniforms = null;\n    }\n\n    if (samplers === void 0) {\n      samplers = null;\n    }\n\n    this._effect = this._engine.createEffect({\n      vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl,\n      fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl\n    }, [\"position\"], uniforms || this._parameters, samplers || this._samplers, defines !== null ? defines : \"\", undefined, onCompiled, onError, indexParameters || this._indexParameters);\n  };\n  /**\r\n   * The post process is reusable if it can be used multiple times within one frame.\r\n   * @returns If the post process is reusable\r\n   */\n\n\n  PostProcess.prototype.isReusable = function () {\n    return this._reusable;\n  };\n  /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\n\n\n  PostProcess.prototype.markTextureDirty = function () {\n    this.width = -1;\n  };\n  /**\r\n   * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\r\n   * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\r\n   * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\r\n   * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\r\n   * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\r\n   * @returns The target texture that was bound to be written to.\r\n   */\n\n\n  PostProcess.prototype.activate = function (camera, sourceTexture, forceDepthStencil) {\n    var _this = this;\n\n    if (sourceTexture === void 0) {\n      sourceTexture = null;\n    }\n\n    camera = camera || this._camera;\n    var scene = camera.getScene();\n    var engine = scene.getEngine();\n    var maxSize = engine.getCaps().maxTextureSize;\n    var requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;\n    var requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0; // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\n\n    var webVRCamera = camera.parent;\n\n    if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\n      requiredWidth /= 2;\n    }\n\n    var desiredWidth = this._options.width || requiredWidth;\n    var desiredHeight = this._options.height || requiredHeight;\n    var needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;\n\n    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\n      if (this.adaptScaleToCurrentViewport) {\n        var currentViewport = engine.currentViewport;\n\n        if (currentViewport) {\n          desiredWidth *= currentViewport.width;\n          desiredHeight *= currentViewport.height;\n        }\n      }\n\n      if (needMipMaps || this.alwaysForcePOT) {\n        if (!this._options.width) {\n          desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\n        }\n\n        if (!this._options.height) {\n          desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\n        }\n      }\n\n      if (this.width !== desiredWidth || this.height !== desiredHeight) {\n        if (this._textures.length > 0) {\n          for (var i = 0; i < this._textures.length; i++) {\n            this._engine._releaseTexture(this._textures.data[i]);\n          }\n\n          this._textures.reset();\n        }\n\n        this.width = desiredWidth;\n        this.height = desiredHeight;\n        var textureSize = {\n          width: this.width,\n          height: this.height\n        };\n        var textureOptions = {\n          generateMipMaps: needMipMaps,\n          generateDepthBuffer: forceDepthStencil || camera._postProcesses.indexOf(this) === 0,\n          generateStencilBuffer: (forceDepthStencil || camera._postProcesses.indexOf(this) === 0) && this._engine.isStencilEnable,\n          samplingMode: this.renderTargetSamplingMode,\n          type: this._textureType,\n          format: this._textureFormat\n        };\n\n        this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\n\n        if (this._reusable) {\n          this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\n        }\n\n        this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\n\n        this.onSizeChangedObservable.notifyObservers(this);\n      }\n\n      this._textures.forEach(function (texture) {\n        if (texture.samples !== _this.samples) {\n          _this._engine.updateRenderTargetTextureSampleCount(texture, _this.samples);\n        }\n      });\n    }\n\n    var target;\n\n    if (this._shareOutputWithPostProcess) {\n      target = this._shareOutputWithPostProcess.inputTexture;\n    } else if (this._forcedOutputTexture) {\n      target = this._forcedOutputTexture;\n      this.width = this._forcedOutputTexture.width;\n      this.height = this._forcedOutputTexture.height;\n    } else {\n      target = this.inputTexture;\n    } // Bind the input of this post process to be used as the output of the previous post process.\n\n\n    if (this.enablePixelPerfectMode) {\n      this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\n\n      this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\n    } else {\n      this._scaleRatio.copyFromFloats(1, 1);\n\n      this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\n    }\n\n    this.onActivateObservable.notifyObservers(camera); // Clear\n\n    if (this.autoClear && this.alphaMode === 0) {\n      this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\n    }\n\n    if (this._reusable) {\n      this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\n    }\n\n    return target;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"isSupported\", {\n    /**\r\n     * If the post process is supported.\r\n     */\n    get: function get() {\n      return this._effect.isSupported;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"aspectRatio\", {\n    /**\r\n     * The aspect ratio of the output texture.\r\n     */\n    get: function get() {\n      if (this._shareOutputWithPostProcess) {\n        return this._shareOutputWithPostProcess.aspectRatio;\n      }\n\n      if (this._forcedOutputTexture) {\n        return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\n      }\n\n      return this.width / this.height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get a value indicating if the post-process is ready to be used\r\n   * @returns true if the post-process is ready (shader is compiled)\r\n   */\n\n  PostProcess.prototype.isReady = function () {\n    return this._effect && this._effect.isReady();\n  };\n  /**\r\n   * Binds all textures and uniforms to the shader, this will be run on every pass.\r\n   * @returns the effect corresponding to this post process. Null if not compiled or not ready.\r\n   */\n\n\n  PostProcess.prototype.apply = function () {\n    // Check\n    if (!this._effect || !this._effect.isReady()) {\n      return null;\n    } // States\n\n\n    this._engine.enableEffect(this._effect);\n\n    this._engine.setState(false);\n\n    this._engine.setDepthBuffer(false);\n\n    this._engine.setDepthWrite(false); // Alpha\n\n\n    this._engine.setAlphaMode(this.alphaMode);\n\n    if (this.alphaConstants) {\n      this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\n    } // Bind the output texture of the preivous post process as the input to this post process.\n\n\n    var source;\n\n    if (this._shareOutputWithPostProcess) {\n      source = this._shareOutputWithPostProcess.inputTexture;\n    } else if (this._forcedOutputTexture) {\n      source = this._forcedOutputTexture;\n    } else {\n      source = this.inputTexture;\n    }\n\n    this._effect._bindTexture(\"textureSampler\", source); // Parameters\n\n\n    this._effect.setVector2(\"scale\", this._scaleRatio);\n\n    this.onApplyObservable.notifyObservers(this._effect);\n    return this._effect;\n  };\n\n  PostProcess.prototype._disposeTextures = function () {\n    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\n      return;\n    }\n\n    if (this._textures.length > 0) {\n      for (var i = 0; i < this._textures.length; i++) {\n        this._engine._releaseTexture(this._textures.data[i]);\n      }\n    }\n\n    this._textures.dispose();\n  };\n  /**\r\n   * Sets the required values to the prepass renderer.\r\n   * @param prePassRenderer defines the prepass renderer to setup.\r\n   * @returns true if the pre pass is needed.\r\n   */\n\n\n  PostProcess.prototype.setPrePassRenderer = function (prePassRenderer) {\n    if (this._prePassEffectConfiguration) {\n      this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\n      this._prePassEffectConfiguration.enabled = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Disposes the post process.\r\n   * @param camera The camera to dispose the post process on.\r\n   */\n\n\n  PostProcess.prototype.dispose = function (camera) {\n    camera = camera || this._camera;\n\n    this._disposeTextures();\n\n    var index;\n\n    if (this._scene) {\n      index = this._scene.postProcesses.indexOf(this);\n\n      if (index !== -1) {\n        this._scene.postProcesses.splice(index, 1);\n      }\n    }\n\n    index = this._engine.postProcesses.indexOf(this);\n\n    if (index !== -1) {\n      this._engine.postProcesses.splice(index, 1);\n    }\n\n    if (!camera) {\n      return;\n    }\n\n    camera.detachPostProcess(this);\n    index = camera._postProcesses.indexOf(this);\n\n    if (index === 0 && camera._postProcesses.length > 0) {\n      var firstPostProcess = this._camera._getFirstPostProcess();\n\n      if (firstPostProcess) {\n        firstPostProcess.markTextureDirty();\n      }\n    }\n\n    this.onActivateObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onApplyObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onSizeChangedObservable.clear();\n  };\n  /**\r\n   * Serializes the particle system to a JSON object\r\n   * @returns the JSON object\r\n   */\n\n\n  PostProcess.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.cameraId = this.getCamera().id;\n    serializationObject.reusable = this._reusable;\n    serializationObject.options = this._options;\n    serializationObject.textureType = this._textureType;\n    return serializationObject;\n  };\n  /**\r\n   * Creates a material from parsed material data\r\n   * @param parsedPostProcess defines parsed post process data\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures\r\n   * @returns a new post process\r\n   */\n\n\n  PostProcess.Parse = function (parsedPostProcess, scene, rootUrl) {\n    var postProcessType = _TypeStore.GetClass(parsedPostProcess.customType);\n\n    if (!postProcessType || !postProcessType._Parse) {\n      return null;\n    }\n\n    var camera = scene.getCameraByID(parsedPostProcess.cameraId);\n\n    if (!camera) {\n      return null;\n    }\n\n    return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\n  };\n\n  __decorate([serialize()], PostProcess.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"name\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"width\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"height\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"renderTargetSamplingMode\", void 0);\n\n  __decorate([serializeAsColor4()], PostProcess.prototype, \"clearColor\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"autoClear\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alphaMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alphaConstants\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"enablePixelPerfectMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"forceFullscreenViewport\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"scaleMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alwaysForcePOT\", void 0);\n\n  __decorate([serialize(\"samples\")], PostProcess.prototype, \"_samples\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"adaptScaleToCurrentViewport\", void 0);\n\n  return PostProcess;\n}();\n\nexport { PostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.PostProcess\"] = PostProcess;","map":null,"metadata":{},"sourceType":"module"}