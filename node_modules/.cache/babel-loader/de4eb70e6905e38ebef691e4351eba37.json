{"ast":null,"code":"import { Scene } from \"../scene\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Matrix } from \"../Maths/math.vector\";\nimport { SmartArray } from \"../Misc/smartArray\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { Material } from \"../Materials/material\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\nimport \"../Meshes/Builders/boxBuilder\";\nimport \"../Shaders/color.fragment\";\nimport \"../Shaders/color.vertex\";\nimport { Color3 } from '../Maths/math.color';\nimport { Observable } from '../Misc/observable';\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\n  get: function get() {\n    return this._forceShowBoundingBoxes || false;\n  },\n  set: function set(value) {\n    this._forceShowBoundingBoxes = value; // Lazyly creates a BB renderer if needed.\n\n    if (value) {\n      this.getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nScene.prototype.getBoundingBoxRenderer = function () {\n  if (!this._boundingBoxRenderer) {\n    this._boundingBoxRenderer = new BoundingBoxRenderer(this);\n  }\n\n  return this._boundingBoxRenderer;\n};\n\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\n  get: function get() {\n    return this._showBoundingBox || false;\n  },\n  set: function set(value) {\n    this._showBoundingBox = value; // Lazyly creates a BB renderer if needed.\n\n    if (value) {\n      this.getScene().getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\r\n * Component responsible of rendering the bounding box of the meshes in a scene.\r\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\r\n */\n\nvar BoundingBoxRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new bounding box renderer in a scene.\r\n   * @param scene the scene the  renderer renders in\r\n   */\n  function BoundingBoxRenderer(scene) {\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\n    /**\r\n     * Color of the bounding box lines placed in front of an object\r\n     */\n\n    this.frontColor = new Color3(1, 1, 1);\n    /**\r\n     * Color of the bounding box lines placed behind an object\r\n     */\n\n    this.backColor = new Color3(0.1, 0.1, 0.1);\n    /**\r\n     * Defines if the renderer should show the back lines or not\r\n     */\n\n    this.showBackLines = true;\n    /**\r\n     * Observable raised before rendering a bounding box\r\n     */\n\n    this.onBeforeBoxRenderingObservable = new Observable();\n    /**\r\n     * Observable raised after rendering a bounding box\r\n     */\n\n    this.onAfterBoxRenderingObservable = new Observable();\n    /**\r\n     * Observable raised after resources are created\r\n     */\n\n    this.onResourcesReadyObservable = new Observable();\n    /**\r\n     * When false, no bounding boxes will be rendered\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * @hidden\r\n     */\n\n    this.renderList = new SmartArray(32);\n    this._vertexBuffers = {};\n    this._fillIndexBuffer = null;\n    this._fillIndexData = null;\n    this.scene = scene;\n\n    scene._addComponent(this);\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  BoundingBoxRenderer.prototype.register = function () {\n    this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\n\n    this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\n\n    this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\n\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\n  };\n\n  BoundingBoxRenderer.prototype._evaluateSubMesh = function (mesh, subMesh) {\n    if (mesh.showSubMeshesBoundingBox) {\n      var boundingInfo = subMesh.getBoundingInfo();\n\n      if (boundingInfo !== null && boundingInfo !== undefined) {\n        boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n        this.renderList.push(boundingInfo.boundingBox);\n      }\n    }\n  };\n\n  BoundingBoxRenderer.prototype._preActiveMesh = function (mesh) {\n    if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\n      var boundingInfo = mesh.getBoundingInfo();\n      boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n      this.renderList.push(boundingInfo.boundingBox);\n    }\n  };\n\n  BoundingBoxRenderer.prototype._prepareResources = function () {\n    if (this._colorShader) {\n      return;\n    }\n\n    this._colorShader = new ShaderMaterial(\"colorShader\", this.scene, \"color\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"color\"]\n    });\n    this._colorShader.reservedDataStore = {\n      hidden: true\n    };\n    var engine = this.scene.getEngine();\n    var boxdata = VertexData.CreateBox({\n      size: 1.0\n    });\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);\n\n    this._createIndexBuffer();\n\n    this._fillIndexData = boxdata.indices;\n    this.onResourcesReadyObservable.notifyObservers(this);\n  };\n\n  BoundingBoxRenderer.prototype._createIndexBuffer = function () {\n    var engine = this.scene.getEngine();\n    this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  BoundingBoxRenderer.prototype.rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._createIndexBuffer();\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  BoundingBoxRenderer.prototype.reset = function () {\n    this.renderList.reset();\n  };\n  /**\r\n   * Render the bounding boxes of a specific rendering group\r\n   * @param renderingGroupId defines the rendering group to render\r\n   */\n\n\n  BoundingBoxRenderer.prototype.render = function (renderingGroupId) {\n    if (this.renderList.length === 0 || !this.enabled) {\n      return;\n    }\n\n    this._prepareResources();\n\n    if (!this._colorShader.isReady()) {\n      return;\n    }\n\n    var engine = this.scene.getEngine();\n    engine.setDepthWrite(false);\n\n    this._colorShader._preBind();\n\n    for (var boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\n      var boundingBox = this.renderList.data[boundingBoxIndex];\n\n      if (boundingBox._tag !== renderingGroupId) {\n        continue;\n      }\n\n      this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\n      var min = boundingBox.minimum;\n      var max = boundingBox.maximum;\n      var diff = max.subtract(min);\n      var median = min.add(diff.scale(0.5));\n      var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix()); // VBOs\n\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n\n      if (this.showBackLines) {\n        // Back\n        engine.setDepthFunctionToGreaterOrEqual();\n        this.scene.resetCachedMaterial();\n\n        this._colorShader.setColor4(\"color\", this.backColor.toColor4());\n\n        this._colorShader.bind(worldMatrix); // Draw order\n\n\n        engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      } // Front\n\n\n      engine.setDepthFunctionToLess();\n      this.scene.resetCachedMaterial();\n\n      this._colorShader.setColor4(\"color\", this.frontColor.toColor4());\n\n      this._colorShader.bind(worldMatrix); // Draw order\n\n\n      engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\n    }\n\n    this._colorShader.unbind();\n\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n  };\n  /**\r\n   * In case of occlusion queries, we can render the occlusion bounding box through this method\r\n   * @param mesh Define the mesh to render the occlusion bounding box for\r\n   */\n\n\n  BoundingBoxRenderer.prototype.renderOcclusionBoundingBox = function (mesh) {\n    this._prepareResources();\n\n    if (!this._colorShader.isReady() || !mesh._boundingInfo) {\n      return;\n    }\n\n    var engine = this.scene.getEngine();\n\n    if (!this._fillIndexBuffer) {\n      this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);\n    }\n\n    engine.setDepthWrite(false);\n    engine.setColorWrite(false);\n\n    this._colorShader._preBind();\n\n    var boundingBox = mesh._boundingInfo.boundingBox;\n    var min = boundingBox.minimum;\n    var max = boundingBox.maximum;\n    var diff = max.subtract(min);\n    var median = min.add(diff.scale(0.5));\n    var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n    engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, this._colorShader.getEffect());\n    engine.setDepthFunctionToLess();\n    this.scene.resetCachedMaterial();\n\n    this._colorShader.bind(worldMatrix);\n\n    engine.drawElementsType(Material.TriangleFillMode, 0, 36);\n\n    this._colorShader.unbind();\n\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n    engine.setColorWrite(true);\n  };\n  /**\r\n   * Dispose and release the resources attached to this renderer.\r\n   */\n\n\n  BoundingBoxRenderer.prototype.dispose = function () {\n    if (!this._colorShader) {\n      return;\n    }\n\n    this.onBeforeBoxRenderingObservable.clear();\n    this.onAfterBoxRenderingObservable.clear();\n    this.onResourcesReadyObservable.clear();\n    this.renderList.dispose();\n\n    this._colorShader.dispose();\n\n    var buffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (buffer) {\n      buffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    this.scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n    if (this._fillIndexBuffer) {\n      this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\n\n      this._fillIndexBuffer = null;\n    }\n  };\n\n  return BoundingBoxRenderer;\n}();\n\nexport { BoundingBoxRenderer };","map":null,"metadata":{},"sourceType":"module"}