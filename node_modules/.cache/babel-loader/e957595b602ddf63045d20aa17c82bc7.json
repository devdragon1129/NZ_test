{"ast":null,"code":"import { Observable } from \"@babylonjs/core/Misc/observable\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nvar NAME = \"MSFT_lod\";\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_lod)\r\n */\n\nvar MSFT_lod =\n/** @class */\nfunction () {\n  /** @hidden */\n  function MSFT_lod(loader) {\n    /**\r\n     * The name of this extension.\r\n     */\n    this.name = NAME;\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\n\n    this.order = 100;\n    /**\r\n     * Maximum number of LODs to load, starting from the lowest LOD.\r\n     */\n\n    this.maxLODsToLoad = 10;\n    /**\r\n     * Observable raised when all node LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\n\n    this.onNodeLODsLoadedObservable = new Observable();\n    /**\r\n     * Observable raised when all material LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\n\n    this.onMaterialLODsLoadedObservable = new Observable();\n    this._bufferLODs = new Array();\n    this._nodeIndexLOD = null;\n    this._nodeSignalLODs = new Array();\n    this._nodePromiseLODs = new Array();\n    this._nodeBufferLODs = new Array();\n    this._materialIndexLOD = null;\n    this._materialSignalLODs = new Array();\n    this._materialPromiseLODs = new Array();\n    this._materialBufferLODs = new Array();\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  MSFT_lod.prototype.dispose = function () {\n    this._loader = null;\n    this._nodeIndexLOD = null;\n    this._nodeSignalLODs.length = 0;\n    this._nodePromiseLODs.length = 0;\n    this._nodeBufferLODs.length = 0;\n    this._materialIndexLOD = null;\n    this._materialSignalLODs.length = 0;\n    this._materialPromiseLODs.length = 0;\n    this._materialBufferLODs.length = 0;\n    this.onMaterialLODsLoadedObservable.clear();\n    this.onNodeLODsLoadedObservable.clear();\n  };\n  /** @hidden */\n\n\n  MSFT_lod.prototype.onReady = function () {\n    var _this = this;\n\n    var _loop_1 = function _loop_1(indexLOD) {\n      var promise = Promise.all(this_1._nodePromiseLODs[indexLOD]).then(function () {\n        if (indexLOD !== 0) {\n          _this._loader.endPerformanceCounter(\"Node LOD \" + indexLOD);\n\n          _this._loader.log(\"Loaded node LOD \" + indexLOD);\n        }\n\n        _this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n\n        if (indexLOD !== _this._nodePromiseLODs.length - 1) {\n          _this._loader.startPerformanceCounter(\"Node LOD \" + (indexLOD + 1));\n\n          _this._loadBufferLOD(_this._nodeBufferLODs, indexLOD + 1);\n\n          if (_this._nodeSignalLODs[indexLOD]) {\n            _this._nodeSignalLODs[indexLOD].resolve();\n          }\n        }\n      });\n\n      this_1._loader._completePromises.push(promise);\n    };\n\n    var this_1 = this;\n\n    for (var indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n      _loop_1(indexLOD);\n    }\n\n    var _loop_2 = function _loop_2(indexLOD) {\n      var promise = Promise.all(this_2._materialPromiseLODs[indexLOD]).then(function () {\n        if (indexLOD !== 0) {\n          _this._loader.endPerformanceCounter(\"Material LOD \" + indexLOD);\n\n          _this._loader.log(\"Loaded material LOD \" + indexLOD);\n        }\n\n        _this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n\n        if (indexLOD !== _this._materialPromiseLODs.length - 1) {\n          _this._loader.startPerformanceCounter(\"Material LOD \" + (indexLOD + 1));\n\n          _this._loadBufferLOD(_this._materialBufferLODs, indexLOD + 1);\n\n          if (_this._materialSignalLODs[indexLOD]) {\n            _this._materialSignalLODs[indexLOD].resolve();\n          }\n        }\n      });\n\n      this_2._loader._completePromises.push(promise);\n    };\n\n    var this_2 = this;\n\n    for (var indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n      _loop_2(indexLOD);\n    }\n  };\n  /** @hidden */\n\n\n  MSFT_lod.prototype.loadSceneAsync = function (context, scene) {\n    var promise = this._loader.loadSceneAsync(context, scene);\n\n    this._loadBufferLOD(this._bufferLODs, 0);\n\n    return promise;\n  };\n  /** @hidden */\n\n\n  MSFT_lod.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n      var firstPromise;\n\n      var nodeLODs = _this._getLODs(extensionContext, node, _this._loader.gltf.nodes, extension.ids);\n\n      _this._loader.logOpen(\"\" + extensionContext);\n\n      var _loop_3 = function _loop_3(indexLOD) {\n        var nodeLOD = nodeLODs[indexLOD];\n\n        if (indexLOD !== 0) {\n          _this._nodeIndexLOD = indexLOD;\n          _this._nodeSignalLODs[indexLOD] = _this._nodeSignalLODs[indexLOD] || new Deferred();\n        }\n\n        var assign_1 = function assign_1(babylonTransformNode) {\n          babylonTransformNode.setEnabled(false);\n        };\n\n        var promise = _this._loader.loadNodeAsync(\"/nodes/\" + nodeLOD.index, nodeLOD, assign_1).then(function (babylonMesh) {\n          if (indexLOD !== 0) {\n            // TODO: should not rely on _babylonTransformNode\n            var previousNodeLOD = nodeLODs[indexLOD - 1];\n\n            if (previousNodeLOD._babylonTransformNode) {\n              _this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\n\n              delete previousNodeLOD._babylonTransformNode;\n            }\n          }\n\n          babylonMesh.setEnabled(true);\n          return babylonMesh;\n        });\n\n        _this._nodePromiseLODs[indexLOD] = _this._nodePromiseLODs[indexLOD] || [];\n\n        if (indexLOD === 0) {\n          firstPromise = promise;\n        } else {\n          _this._nodeIndexLOD = null;\n\n          _this._nodePromiseLODs[indexLOD].push(promise);\n        }\n      };\n\n      for (var indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n        _loop_3(indexLOD);\n      }\n\n      _this._loader.logClose();\n\n      return firstPromise;\n    });\n  };\n  /** @hidden */\n\n\n  MSFT_lod.prototype._loadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {\n    var _this = this; // Don't load material LODs if already loading a node LOD.\n\n\n    if (this._nodeIndexLOD) {\n      return null;\n    }\n\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) {\n      var firstPromise;\n\n      var materialLODs = _this._getLODs(extensionContext, material, _this._loader.gltf.materials, extension.ids);\n\n      _this._loader.logOpen(\"\" + extensionContext);\n\n      var _loop_4 = function _loop_4(indexLOD) {\n        var materialLOD = materialLODs[indexLOD];\n\n        if (indexLOD !== 0) {\n          _this._materialIndexLOD = indexLOD;\n        }\n\n        var promise = _this._loader._loadMaterialAsync(\"/materials/\" + materialLOD.index, materialLOD, babylonMesh, babylonDrawMode, function (babylonMaterial) {\n          if (indexLOD === 0) {\n            assign(babylonMaterial);\n          }\n        }).then(function (babylonMaterial) {\n          if (indexLOD !== 0) {\n            assign(babylonMaterial); // TODO: should not rely on _data\n\n            var previousDataLOD = materialLODs[indexLOD - 1]._data;\n\n            if (previousDataLOD[babylonDrawMode]) {\n              _this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\n\n              delete previousDataLOD[babylonDrawMode];\n            }\n          }\n\n          return babylonMaterial;\n        });\n\n        _this._materialPromiseLODs[indexLOD] = _this._materialPromiseLODs[indexLOD] || [];\n\n        if (indexLOD === 0) {\n          firstPromise = promise;\n        } else {\n          _this._materialIndexLOD = null;\n\n          _this._materialPromiseLODs[indexLOD].push(promise);\n        }\n      };\n\n      for (var indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n        _loop_4(indexLOD);\n      }\n\n      _this._loader.logClose();\n\n      return firstPromise;\n    });\n  };\n  /** @hidden */\n\n\n  MSFT_lod.prototype._loadUriAsync = function (context, property, uri) {\n    var _this = this; // Defer the loading of uris if loading a node or material LOD.\n\n\n    if (this._nodeIndexLOD !== null) {\n      this._loader.log(\"deferred\");\n\n      var previousIndexLOD = this._nodeIndexLOD - 1;\n      this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();\n      return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function () {\n        return _this._loader.loadUriAsync(context, property, uri);\n      });\n    } else if (this._materialIndexLOD !== null) {\n      this._loader.log(\"deferred\");\n\n      var previousIndexLOD = this._materialIndexLOD - 1;\n      this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();\n      return this._materialSignalLODs[previousIndexLOD].promise.then(function () {\n        return _this._loader.loadUriAsync(context, property, uri);\n      });\n    }\n\n    return null;\n  };\n  /** @hidden */\n\n\n  MSFT_lod.prototype.loadBufferAsync = function (context, buffer, byteOffset, byteLength) {\n    if (this._loader.parent.useRangeRequests && !buffer.uri) {\n      if (!this._loader.bin) {\n        throw new Error(context + \": Uri is missing or the binary glTF is missing its binary chunk\");\n      }\n\n      var loadAsync = function loadAsync(bufferLODs, indexLOD) {\n        var start = byteOffset;\n        var end = start + byteLength - 1;\n        var bufferLOD = bufferLODs[indexLOD];\n\n        if (bufferLOD) {\n          bufferLOD.start = Math.min(bufferLOD.start, start);\n          bufferLOD.end = Math.max(bufferLOD.end, end);\n        } else {\n          bufferLOD = {\n            start: start,\n            end: end,\n            loaded: new Deferred()\n          };\n          bufferLODs[indexLOD] = bufferLOD;\n        }\n\n        return bufferLOD.loaded.promise.then(function (data) {\n          return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\n        });\n      };\n\n      this._loader.log(\"deferred\");\n\n      if (this._nodeIndexLOD !== null) {\n        return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\n      } else if (this._materialIndexLOD !== null) {\n        return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\n      } else {\n        return loadAsync(this._bufferLODs, 0);\n      }\n    }\n\n    return null;\n  };\n\n  MSFT_lod.prototype._loadBufferLOD = function (bufferLODs, indexLOD) {\n    var bufferLOD = bufferLODs[indexLOD];\n\n    if (bufferLOD) {\n      this._loader.log(\"Loading buffer range [\" + bufferLOD.start + \"-\" + bufferLOD.end + \"]\");\n\n      this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(function (data) {\n        bufferLOD.loaded.resolve(data);\n      }, function (error) {\n        bufferLOD.loaded.reject(error);\n      });\n    }\n  };\n  /**\r\n   * Gets an array of LOD properties from lowest to highest.\r\n   */\n\n\n  MSFT_lod.prototype._getLODs = function (context, property, array, ids) {\n    if (this.maxLODsToLoad <= 0) {\n      throw new Error(\"maxLODsToLoad must be greater than zero\");\n    }\n\n    var properties = new Array();\n\n    for (var i = ids.length - 1; i >= 0; i--) {\n      properties.push(ArrayItem.Get(context + \"/ids/\" + ids[i], array, ids[i]));\n\n      if (properties.length === this.maxLODsToLoad) {\n        return properties;\n      }\n    }\n\n    properties.push(property);\n    return properties;\n  };\n\n  MSFT_lod.prototype._disposeTransformNode = function (babylonTransformNode) {\n    var _this = this;\n\n    var babylonMaterials = new Array();\n    var babylonMaterial = babylonTransformNode.material;\n\n    if (babylonMaterial) {\n      babylonMaterials.push(babylonMaterial);\n    }\n\n    for (var _i = 0, _a = babylonTransformNode.getChildMeshes(); _i < _a.length; _i++) {\n      var babylonMesh = _a[_i];\n\n      if (babylonMesh.material) {\n        babylonMaterials.push(babylonMesh.material);\n      }\n    }\n\n    babylonTransformNode.dispose();\n    var babylonMaterialsToDispose = babylonMaterials.filter(function (babylonMaterial) {\n      return _this._loader.babylonScene.meshes.every(function (mesh) {\n        return mesh.material != babylonMaterial;\n      });\n    });\n\n    this._disposeMaterials(babylonMaterialsToDispose);\n  };\n\n  MSFT_lod.prototype._disposeMaterials = function (babylonMaterials) {\n    var babylonTextures = {};\n\n    for (var _i = 0, babylonMaterials_1 = babylonMaterials; _i < babylonMaterials_1.length; _i++) {\n      var babylonMaterial = babylonMaterials_1[_i];\n\n      for (var _a = 0, _b = babylonMaterial.getActiveTextures(); _a < _b.length; _a++) {\n        var babylonTexture = _b[_a];\n        babylonTextures[babylonTexture.uniqueId] = babylonTexture;\n      }\n\n      babylonMaterial.dispose();\n    }\n\n    for (var uniqueId in babylonTextures) {\n      for (var _c = 0, _d = this._loader.babylonScene.materials; _c < _d.length; _c++) {\n        var babylonMaterial = _d[_c];\n\n        if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\n          delete babylonTextures[uniqueId];\n        }\n      }\n    }\n\n    for (var uniqueId in babylonTextures) {\n      babylonTextures[uniqueId].dispose();\n    }\n  };\n\n  return MSFT_lod;\n}();\n\nexport { MSFT_lod };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new MSFT_lod(loader);\n});","map":null,"metadata":{},"sourceType":"module"}