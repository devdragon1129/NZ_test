{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport \"../Meshes/Builders/linesBuilder\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\n/**\r\n * Single plane rotation gizmo\r\n */\n\nvar PlaneRotationGizmo =\n/** @class */\nfunction (_super) {\n  __extends(PlaneRotationGizmo, _super);\n  /**\r\n   * Creates a PlaneRotationGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\r\n   * @param color The color of the gizmo\r\n   * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n   * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n   * @param thickness display gizmo axis thickness\r\n   */\n\n\n  function PlaneRotationGizmo(planeNormal, color, gizmoLayer, tessellation, parent, useEulerRotation, thickness) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (tessellation === void 0) {\n      tessellation = 32;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (useEulerRotation === void 0) {\n      useEulerRotation = false;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _a;\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._pointerObserver = null;\n    /**\r\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\r\n     */\n\n    _this.snapDistance = 0;\n    /**\r\n     * Event that fires each time the gizmo snaps to a new location.\r\n     * * snapDistance is the the change in distance\r\n     */\n\n    _this.onSnapObservable = new Observable();\n    _this._isEnabled = true;\n    _this._parent = null;\n    _this._dragging = false;\n    _this._parent = parent; // Create Material\n\n    _this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._coloredMaterial.diffuseColor = color;\n    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    _this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._hoverMaterial.diffuseColor = Color3.Yellow();\n    _this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._disableMaterial.diffuseColor = Color3.Gray();\n    _this._disableMaterial.alpha = 0.4; // Build mesh on root node\n\n    _this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n\n    var _b = _this._createGizmoMesh(_this._gizmoMesh, thickness, tessellation),\n        rotationMesh = _b.rotationMesh,\n        collider = _b.collider; // Setup Rotation Circle\n\n\n    var rotationCirclePaths = [];\n    _this._rotationCircle = _this.setupRotationCircle(rotationCirclePaths, _this._gizmoMesh);\n\n    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(planeNormal));\n\n    _this._rootMesh.addChild(_this._gizmoMesh);\n\n    _this._gizmoMesh.scaling.scaleInPlace(1 / 3); // Add drag behavior to handle events when the gizmo is dragged\n\n\n    _this.dragBehavior = new PointerDragBehavior({\n      dragPlaneNormal: planeNormal\n    });\n    _this.dragBehavior.moveAttached = false;\n    _this.dragBehavior.maxDragAngle = Math.PI * 9 / 20;\n    _this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\n\n    _this._rootMesh.addBehavior(_this.dragBehavior); // Closures for drag logic\n\n\n    var dragDistance = 0;\n    var lastDragPosition = new Vector3();\n    var dragPlanePoint = new Vector3();\n    var rotationMatrix = new Matrix();\n    var planeNormalTowardsCamera = new Vector3();\n    var localPlaneNormalTowardsCamera = new Vector3();\n\n    _this.dragBehavior.onDragStartObservable.add(function (e) {\n      if (_this.attachedNode) {\n        lastDragPosition.copyFrom(e.dragPlanePoint); // This is for instantiation location of rotation circle\n\n        var forward = new Vector3(0, 0, 1);\n\n        var direction = _this._rotationCircle.getDirection(forward);\n\n        direction.normalize(); // Remove Rotation Circle from parent mesh before drag interaction\n\n        _this._gizmoMesh.removeChild(_this._rotationCircle);\n\n        lastDragPosition.copyFrom(e.dragPlanePoint);\n        dragPlanePoint = e.dragPlanePoint;\n\n        var origin_1 = _this._rotationCircle.getAbsolutePosition().clone();\n\n        var originalRotationPoint = _this._rotationCircle.getAbsolutePosition().clone().addInPlace(direction);\n\n        var dragStartPoint = e.dragPlanePoint;\n        var angle = Vector3.GetAngleBetweenVectors(originalRotationPoint.subtract(origin_1), dragStartPoint.subtract(origin_1), _this._rotationCircle.up);\n\n        _this._rotationCircle.addRotation(0, angle, 0);\n\n        _this._dragging = true;\n      }\n    });\n\n    _this.dragBehavior.onDragEndObservable.add(function () {\n      dragDistance = 0;\n\n      _this.updateRotationCircle(_this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint);\n\n      _this._gizmoMesh.addChild(_this._rotationCircle); // Add rotation circle back to parent mesh after drag behavior\n\n\n      _this._dragging = false;\n    });\n\n    var tmpSnapEvent = {\n      snapDistance: 0\n    };\n    var currentSnapDragDistance = 0;\n    var tmpMatrix = new Matrix();\n    var amountToRotate = new Quaternion();\n\n    _this.dragBehavior.onDragObservable.add(function (event) {\n      if (_this.attachedNode) {\n        // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\n        var nodeScale = new Vector3(1, 1, 1);\n        var nodeQuaternion = new Quaternion(0, 0, 0, 1);\n        var nodeTranslation = new Vector3(0, 0, 0);\n\n        _this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\n\n        var newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();\n        var originalVector = lastDragPosition.subtract(nodeTranslation).normalize();\n        var cross = Vector3.Cross(newVector, originalVector);\n        var dot = Vector3.Dot(newVector, originalVector);\n        var angle = Math.atan2(cross.length(), dot);\n        planeNormalTowardsCamera.copyFrom(planeNormal);\n        localPlaneNormalTowardsCamera.copyFrom(planeNormal);\n\n        if (_this.updateGizmoRotationToMatchAttachedMesh) {\n          nodeQuaternion.toRotationMatrix(rotationMatrix);\n          localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\n        } // Flip up vector depending on which side the camera is on\n\n\n        var cameraFlipped = false;\n\n        if (gizmoLayer.utilityLayerScene.activeCamera) {\n          var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation);\n\n          if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\n            planeNormalTowardsCamera.scaleInPlace(-1);\n            localPlaneNormalTowardsCamera.scaleInPlace(-1);\n            cameraFlipped = true;\n          }\n        }\n\n        var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\n\n        if (halfCircleSide) {\n          angle = -angle;\n        } // Snapping logic\n\n\n        var snapped = false;\n\n        if (_this.snapDistance != 0) {\n          currentSnapDragDistance += angle;\n\n          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {\n            var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);\n\n            if (currentSnapDragDistance < 0) {\n              dragSteps *= -1;\n            }\n\n            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;\n            angle = _this.snapDistance * dragSteps;\n            snapped = true;\n          } else {\n            angle = 0;\n          }\n        }\n\n        dragDistance += cameraFlipped ? -angle : angle;\n\n        _this.updateRotationCircle(_this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint); // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\n\n\n        var quaternionCoefficient = Math.sin(angle / 2);\n        amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2)); // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\n\n        if (tmpMatrix.determinant() > 0) {\n          var tmpVector = new Vector3();\n          amountToRotate.toEulerAnglesToRef(tmpVector);\n          Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\n        }\n\n        if (_this.updateGizmoRotationToMatchAttachedMesh) {\n          // Rotate selected mesh quaternion over fixed axis\n          nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\n        } else {\n          // Rotate selected mesh quaternion over rotated axis\n          amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);\n        } // recompose matrix\n\n\n        _this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));\n\n        lastDragPosition.copyFrom(event.dragPlanePoint);\n\n        if (snapped) {\n          tmpSnapEvent.snapDistance = angle;\n\n          _this.onSnapObservable.notifyObservers(tmpSnapEvent);\n        }\n\n        _this._matrixChanged();\n      }\n    });\n\n    var light = gizmoLayer._getSharedGizmoLight();\n\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));\n    var cache = {\n      colliderMeshes: [collider],\n      gizmoMeshes: [rotationMesh],\n      material: _this._coloredMaterial,\n      hoverMaterial: _this._hoverMaterial,\n      disableMaterial: _this._disableMaterial,\n      active: false\n    };\n    (_a = _this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(_this._gizmoMesh, cache);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a;\n\n      if (_this._customMeshSet) {\n        return;\n      }\n\n      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) != -1);\n\n      if (!_this._parent) {\n        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;\n        cache.gizmoMeshes.forEach(function (m) {\n          m.material = material;\n\n          if (m.color) {\n            m.color = material.diffuseColor;\n          }\n        });\n      }\n    });\n    return _this;\n  }\n  /** Create Geometry for Gizmo */\n\n\n  PlaneRotationGizmo.prototype._createGizmoMesh = function (parentMesh, thickness, tessellation) {\n    var collider = Mesh.CreateTorus(\"ignore\", 0.6, 0.03 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);\n    collider.visibility = 0;\n    var rotationMesh = Mesh.CreateTorus(\"\", 0.6, 0.005 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);\n    rotationMesh.material = this._coloredMaterial; // Position arrow pointing in its drag axis\n\n    rotationMesh.rotation.x = Math.PI / 2;\n    collider.rotation.x = Math.PI / 2;\n    parentMesh.addChild(rotationMesh);\n    parentMesh.addChild(collider);\n    return {\n      rotationMesh: rotationMesh,\n      collider: collider\n    };\n  };\n\n  PlaneRotationGizmo.prototype._attachedNodeChanged = function (value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  };\n\n  PlaneRotationGizmo.prototype.setupRotationCircle = function (paths, parentMesh) {\n    var fillRadians = 0;\n    var step = PlaneRotationGizmo._CircleConstants.pi2 / PlaneRotationGizmo._CircleConstants.tessellation;\n\n    for (var p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {\n      var path = [];\n\n      for (var i = 0; i < PlaneRotationGizmo._CircleConstants.pi2 * PlaneRotationGizmo._CircleConstants.rotationCircleRange + 0.01; i += step) {\n        if (i < fillRadians) {\n          var x = PlaneRotationGizmo._CircleConstants.radius * Math.sin(i) * Math.cos(p);\n          var z = PlaneRotationGizmo._CircleConstants.radius * Math.cos(i) * Math.cos(p);\n          var y = 0;\n          path.push(new Vector3(x, y, z));\n        } else {\n          path.push(new Vector3(0, 0, 0));\n        }\n      }\n\n      paths.push(path);\n    }\n\n    var mat = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n    mat.diffuseColor = Color3.Yellow();\n    mat.backFaceCulling = false;\n    var mesh = Mesh.CreateRibbon(\"rotationCircle\", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, true);\n    mesh.material = mat;\n    mesh.material.alpha = .25;\n    mesh.rotation.x = Math.PI / 2;\n    parentMesh.addChild(mesh);\n    return mesh;\n  };\n\n  PlaneRotationGizmo.prototype.updateRotationPath = function (pathArr, newFill) {\n    // To update the Ribbon, you have to mutate the pathArray in-place\n    var step = PlaneRotationGizmo._CircleConstants.pi2 / PlaneRotationGizmo._CircleConstants.tessellation;\n    var tessellationCounter = 0;\n\n    for (var p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {\n      var path = pathArr[tessellationCounter];\n\n      if (path) {\n        var radianCounter = 0;\n\n        for (var i = 0; i < PlaneRotationGizmo._CircleConstants.pi2 * PlaneRotationGizmo._CircleConstants.rotationCircleRange + 0.01; i += step) {\n          if (path[radianCounter]) {\n            if (i < Math.abs(newFill)) {\n              var absI = newFill > 0 ? i : i * -1;\n              var absP = newFill > 0 ? p : p * -1;\n              path[radianCounter].set(PlaneRotationGizmo._CircleConstants.radius * Math.sin(absI) * Math.cos(absP), 0, PlaneRotationGizmo._CircleConstants.radius * Math.cos(absI) * Math.cos(absP));\n            } else {\n              path[radianCounter].set(0, 0, 0);\n            }\n          }\n\n          radianCounter++;\n        }\n      }\n\n      tessellationCounter++;\n    }\n  };\n\n  PlaneRotationGizmo.prototype.updateRotationCircle = function (mesh, paths, newFill, dragPlanePoint) {\n    this.updateRotationPath(paths, newFill);\n    Mesh.CreateRibbon(\"rotationCircle\", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, undefined, undefined, mesh.geometry ? mesh : undefined);\n  };\n\n  Object.defineProperty(PlaneRotationGizmo.prototype, \"isEnabled\", {\n    get: function get() {\n      return this._isEnabled;\n    },\n\n    /**\r\n         * If the gizmo is enabled\r\n         */\n    set: function set(value) {\n      this._isEnabled = value;\n\n      if (!value) {\n        this.attachedMesh = null;\n      } else {\n        if (this._parent) {\n          this.attachedMesh = this._parent.attachedMesh;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n  PlaneRotationGizmo.prototype.dispose = function () {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n\n    if (this._rotationCircle) {\n      this._rotationCircle.dispose();\n    }\n\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function (matl) {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n\n    _super.prototype.dispose.call(this);\n  };\n\n  PlaneRotationGizmo._CircleConstants = {\n    radius: 0.3,\n    pi2: Math.PI * 2,\n    tessellation: 70,\n    rotationCircleRange: 4\n  };\n  return PlaneRotationGizmo;\n}(Gizmo);\n\nexport { PlaneRotationGizmo };","map":null,"metadata":{},"sourceType":"module"}