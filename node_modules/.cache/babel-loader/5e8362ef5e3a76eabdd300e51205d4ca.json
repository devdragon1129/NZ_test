{"ast":null,"code":"import { Vector3 } from \"../../../Maths/math\";\nimport { Scalar } from \"../../../Maths/math.scalar\";\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\nimport \"../../../Shaders/hdrFiltering.vertex\";\nimport \"../../../Shaders/hdrFiltering.fragment\";\nimport { Logger } from '../../../Misc/logger';\n/**\r\n * Filters HDR maps to get correct renderings of PBR reflections\r\n */\n\nvar HDRFiltering =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates HDR filter for reflection maps\r\n   *\r\n   * @param engine Thin engine\r\n   * @param options Options\r\n   */\n  function HDRFiltering(engine, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._lodGenerationOffset = 0;\n    this._lodGenerationScale = 0.8;\n    /**\r\n     * Quality switch for prefiltering. Should be set to `4096` unless\r\n     * you care about baking speed.\r\n     */\n\n    this.quality = 4096;\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\n\n    this.hdrScale = 1; // pass\n\n    this._engine = engine;\n    this.hdrScale = options.hdrScale || this.hdrScale;\n    this.quality = options.hdrScale || this.quality;\n  }\n\n  HDRFiltering.prototype._createRenderTarget = function (size) {\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else if (this._engine.getCaps().textureFloatRender) {\n      textureType = 1;\n    }\n\n    var texture = this._engine.createRenderTargetCubeTexture(size, {\n      format: 5,\n      type: textureType,\n      generateMipMaps: false,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false,\n      samplingMode: 1\n    });\n\n    this._engine.updateTextureWrappingMode(texture, 0, 0, 0);\n\n    this._engine.updateTextureSamplingMode(3, texture, true);\n\n    return texture;\n  };\n\n  HDRFiltering.prototype._prefilterInternal = function (texture) {\n    var width = texture.getSize().width;\n    var mipmapsCount = Math.round(Scalar.Log2(width)) + 1;\n    var effect = this._effectWrapper.effect;\n\n    var outputTexture = this._createRenderTarget(width);\n\n    this._effectRenderer.setViewport();\n\n    var intTexture = texture.getInternalTexture();\n\n    if (intTexture) {\n      // Just in case generate fresh clean mips.\n      this._engine.updateTextureSamplingMode(3, intTexture, true);\n    }\n\n    this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n\n    var directions = [[new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)]];\n    effect.setFloat(\"hdrScale\", this.hdrScale);\n    effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\n    effect.setTexture(\"inputTexture\", texture);\n\n    for (var face = 0; face < 6; face++) {\n      effect.setVector3(\"up\", directions[face][0]);\n      effect.setVector3(\"right\", directions[face][1]);\n      effect.setVector3(\"front\", directions[face][2]);\n\n      for (var lod = 0; lod < mipmapsCount; lod++) {\n        this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\n\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n\n        var alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\n\n        if (lod === 0) {\n          alpha = 0;\n        }\n\n        effect.setFloat(\"alphaG\", alpha);\n\n        this._effectRenderer.draw();\n      }\n    } // Cleanup\n\n\n    this._effectRenderer.restoreStates();\n\n    this._engine.restoreDefaultFramebuffer();\n\n    this._engine._releaseFramebufferObjects(outputTexture);\n\n    this._engine._releaseTexture(texture._texture); // Internal Swap\n\n\n    outputTexture._swapAndDie(texture._texture);\n\n    texture._prefiltered = true;\n    return texture;\n  };\n\n  HDRFiltering.prototype._createEffect = function (texture, onCompiled) {\n    var defines = [];\n\n    if (texture.gammaSpace) {\n      defines.push(\"#define GAMMA_INPUT\");\n    }\n\n    defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\n\n    var effectWrapper = new EffectWrapper({\n      engine: this._engine,\n      name: \"hdrFiltering\",\n      vertexShader: \"hdrFiltering\",\n      fragmentShader: \"hdrFiltering\",\n      samplerNames: [\"inputTexture\"],\n      uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\n      useShaderStore: true,\n      defines: defines,\n      onCompiled: onCompiled\n    });\n    return effectWrapper;\n  };\n  /**\r\n   * Get a value indicating if the filter is ready to be used\r\n   * @param texture Texture to filter\r\n   * @returns true if the filter is ready\r\n   */\n\n\n  HDRFiltering.prototype.isReady = function (texture) {\n    return texture.isReady() && this._effectWrapper.effect.isReady();\n  };\n  /**\r\n    * Prefilters a cube texture to have mipmap levels representing roughness values.\r\n    * Prefiltering will be invoked at the end of next rendering pass.\r\n    * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\r\n    * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\r\n    * @param texture Texture to filter\r\n    * @param onFinished Callback when filtering is done\r\n    * @return Promise called when prefiltering is done\r\n    */\n\n\n  HDRFiltering.prototype.prefilter = function (texture, onFinished) {\n    var _this = this;\n\n    if (onFinished === void 0) {\n      onFinished = null;\n    }\n\n    if (this._engine.webGLVersion === 1) {\n      Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n      return;\n    }\n\n    return new Promise(function (resolve) {\n      _this._effectRenderer = new EffectRenderer(_this._engine);\n      _this._effectWrapper = _this._createEffect(texture);\n\n      _this._effectWrapper.effect.executeWhenCompiled(function () {\n        _this._prefilterInternal(texture);\n\n        _this._effectRenderer.dispose();\n\n        _this._effectWrapper.dispose();\n\n        resolve();\n\n        if (onFinished) {\n          onFinished();\n        }\n      });\n    });\n  };\n\n  return HDRFiltering;\n}();\n\nexport { HDRFiltering };","map":null,"metadata":{},"sourceType":"module"}