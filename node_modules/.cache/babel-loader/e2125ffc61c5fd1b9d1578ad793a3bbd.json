{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { DomManagement } from \"../Misc/domManagement\";\nimport { EngineStore } from \"./engineStore\";\nimport { _DevTools } from '../Misc/devTools';\nimport { ThinEngine } from './thinEngine';\nimport { PerformanceMonitor } from '../Misc/performanceMonitor';\nimport { PerfCounter } from '../Misc/perfCounter';\nimport { WebGLDataBuffer } from '../Meshes/WebGL/webGLDataBuffer';\nimport { Logger } from '../Misc/logger';\nimport \"./Extensions/engine.alpha\";\nimport \"./Extensions/engine.readTexture\";\nimport \"./Extensions/engine.dynamicBuffer\";\n/**\r\n * The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio\r\n */\n\nvar Engine =\n/** @class */\nfunction (_super) {\n  __extends(Engine, _super);\n  /**\r\n   * Creates a new engine\r\n   * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which alreay used the WebGL context\r\n   * @param antialias defines enable antialiasing (default: false)\r\n   * @param options defines further options to be sent to the getContext() function\r\n   * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)\r\n   */\n\n\n  function Engine(canvasOrContext, antialias, options, adaptToDeviceRatio) {\n    if (adaptToDeviceRatio === void 0) {\n      adaptToDeviceRatio = false;\n    }\n\n    var _this = _super.call(this, canvasOrContext, antialias, options, adaptToDeviceRatio) || this; // Members\n\n    /**\r\n     * Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest\r\n     **/\n\n\n    _this.enableOfflineSupport = false;\n    /**\r\n     * Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (js will always consider the database is up to date)\r\n     **/\n\n    _this.disableManifestCheck = false;\n    /**\r\n     * Gets the list of created scenes\r\n     */\n\n    _this.scenes = new Array();\n    /**\r\n     * Event raised when a new scene is created\r\n     */\n\n    _this.onNewSceneAddedObservable = new Observable();\n    /**\r\n     * Gets the list of created postprocesses\r\n     */\n\n    _this.postProcesses = new Array();\n    /**\r\n     * Gets a boolean indicating if the pointer is currently locked\r\n     */\n\n    _this.isPointerLock = false; // Observables\n\n    /**\r\n     * Observable event triggered each time the rendering canvas is resized\r\n     */\n\n    _this.onResizeObservable = new Observable();\n    /**\r\n     * Observable event triggered each time the canvas loses focus\r\n     */\n\n    _this.onCanvasBlurObservable = new Observable();\n    /**\r\n     * Observable event triggered each time the canvas gains focus\r\n     */\n\n    _this.onCanvasFocusObservable = new Observable();\n    /**\r\n     * Observable event triggered each time the canvas receives pointerout event\r\n     */\n\n    _this.onCanvasPointerOutObservable = new Observable();\n    /**\r\n     * Observable raised when the engine begins a new frame\r\n     */\n\n    _this.onBeginFrameObservable = new Observable();\n    /**\r\n     * If set, will be used to request the next animation frame for the render loop\r\n     */\n\n    _this.customAnimationFrameRequester = null;\n    /**\r\n     * Observable raised when the engine ends the current frame\r\n     */\n\n    _this.onEndFrameObservable = new Observable();\n    /**\r\n     * Observable raised when the engine is about to compile a shader\r\n     */\n\n    _this.onBeforeShaderCompilationObservable = new Observable();\n    /**\r\n     * Observable raised when the engine has jsut compiled a shader\r\n     */\n\n    _this.onAfterShaderCompilationObservable = new Observable(); // Deterministic lockstepMaxSteps\n\n    _this._deterministicLockstep = false;\n    _this._lockstepMaxSteps = 4;\n    _this._timeStep = 1 / 60; // FPS\n\n    _this._fps = 60;\n    _this._deltaTime = 0;\n    /** @hidden */\n\n    _this._drawCalls = new PerfCounter();\n    /** Gets or sets the tab index to set to the rendering canvas. 1 is the minimum value to set to be able to capture keyboard events */\n\n    _this.canvasTabIndex = 1;\n    /**\r\n     * Turn this value on if you want to pause FPS computation when in background\r\n     */\n\n    _this.disablePerformanceMonitorInBackground = false;\n    _this._performanceMonitor = new PerformanceMonitor();\n    Engine.Instances.push(_this);\n\n    if (!canvasOrContext) {\n      return _this;\n    }\n\n    options = _this._creationOptions;\n\n    if (canvasOrContext.getContext) {\n      var canvas_1 = canvasOrContext;\n\n      _this._onCanvasFocus = function () {\n        _this.onCanvasFocusObservable.notifyObservers(_this);\n      };\n\n      _this._onCanvasBlur = function () {\n        _this.onCanvasBlurObservable.notifyObservers(_this);\n      };\n\n      canvas_1.addEventListener(\"focus\", _this._onCanvasFocus);\n      canvas_1.addEventListener(\"blur\", _this._onCanvasBlur);\n\n      _this._onBlur = function () {\n        if (_this.disablePerformanceMonitorInBackground) {\n          _this._performanceMonitor.disable();\n        }\n\n        _this._windowIsBackground = true;\n      };\n\n      _this._onFocus = function () {\n        if (_this.disablePerformanceMonitorInBackground) {\n          _this._performanceMonitor.enable();\n        }\n\n        _this._windowIsBackground = false;\n      };\n\n      _this._onCanvasPointerOut = function (ev) {\n        _this.onCanvasPointerOutObservable.notifyObservers(ev);\n      };\n\n      canvas_1.addEventListener(\"pointerout\", _this._onCanvasPointerOut);\n\n      if (DomManagement.IsWindowObjectExist()) {\n        var hostWindow = _this.getHostWindow();\n\n        hostWindow.addEventListener(\"blur\", _this._onBlur);\n        hostWindow.addEventListener(\"focus\", _this._onFocus);\n        var anyDoc_1 = document; // Fullscreen\n\n        _this._onFullscreenChange = function () {\n          if (anyDoc_1.fullscreen !== undefined) {\n            _this.isFullscreen = anyDoc_1.fullscreen;\n          } else if (anyDoc_1.mozFullScreen !== undefined) {\n            _this.isFullscreen = anyDoc_1.mozFullScreen;\n          } else if (anyDoc_1.webkitIsFullScreen !== undefined) {\n            _this.isFullscreen = anyDoc_1.webkitIsFullScreen;\n          } else if (anyDoc_1.msIsFullScreen !== undefined) {\n            _this.isFullscreen = anyDoc_1.msIsFullScreen;\n          } // Pointer lock\n\n\n          if (_this.isFullscreen && _this._pointerLockRequested && canvas_1) {\n            Engine._RequestPointerlock(canvas_1);\n          }\n        };\n\n        document.addEventListener(\"fullscreenchange\", _this._onFullscreenChange, false);\n        document.addEventListener(\"mozfullscreenchange\", _this._onFullscreenChange, false);\n        document.addEventListener(\"webkitfullscreenchange\", _this._onFullscreenChange, false);\n        document.addEventListener(\"msfullscreenchange\", _this._onFullscreenChange, false); // Pointer lock\n\n        _this._onPointerLockChange = function () {\n          _this.isPointerLock = anyDoc_1.mozPointerLockElement === canvas_1 || anyDoc_1.webkitPointerLockElement === canvas_1 || anyDoc_1.msPointerLockElement === canvas_1 || anyDoc_1.pointerLockElement === canvas_1;\n        };\n\n        document.addEventListener(\"pointerlockchange\", _this._onPointerLockChange, false);\n        document.addEventListener(\"mspointerlockchange\", _this._onPointerLockChange, false);\n        document.addEventListener(\"mozpointerlockchange\", _this._onPointerLockChange, false);\n        document.addEventListener(\"webkitpointerlockchange\", _this._onPointerLockChange, false); // Create Audio Engine if needed.\n\n        if (!Engine.audioEngine && options.audioEngine && Engine.AudioEngineFactory) {\n          Engine.audioEngine = Engine.AudioEngineFactory(_this.getRenderingCanvas());\n        }\n      }\n\n      _this._connectVREvents();\n\n      _this.enableOfflineSupport = Engine.OfflineProviderFactory !== undefined;\n\n      if (!options.doNotHandleTouchAction) {\n        _this._disableTouchAction();\n      }\n\n      _this._deterministicLockstep = !!options.deterministicLockstep;\n      _this._lockstepMaxSteps = options.lockstepMaxSteps || 0;\n      _this._timeStep = options.timeStep || 1 / 60;\n    } // Load WebVR Devices\n\n\n    _this._prepareVRComponent();\n\n    if (options.autoEnableWebVR) {\n      _this.initWebVR();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(Engine, \"NpmPackage\", {\n    /**\r\n     * Returns the current npm package of the sdk\r\n     */\n    // Not mixed with Version for tooling purpose.\n    get: function get() {\n      return ThinEngine.NpmPackage;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Engine, \"Version\", {\n    /**\r\n     * Returns the current version of the framework\r\n     */\n    get: function get() {\n      return ThinEngine.Version;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Engine, \"Instances\", {\n    /** Gets the list of created engines */\n    get: function get() {\n      return EngineStore.Instances;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Engine, \"LastCreatedEngine\", {\n    /**\r\n     * Gets the latest created engine\r\n     */\n    get: function get() {\n      return EngineStore.LastCreatedEngine;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Engine, \"LastCreatedScene\", {\n    /**\r\n     * Gets the latest created scene\r\n     */\n    get: function get() {\n      return EngineStore.LastCreatedScene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation\r\n   * @param flag defines which part of the materials must be marked as dirty\r\n   * @param predicate defines a predicate used to filter which materials should be affected\r\n   */\n\n  Engine.MarkAllMaterialsAsDirty = function (flag, predicate) {\n    for (var engineIndex = 0; engineIndex < Engine.Instances.length; engineIndex++) {\n      var engine = Engine.Instances[engineIndex];\n\n      for (var sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {\n        engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);\n      }\n    }\n  };\n  /**\r\n   * Method called to create the default loading screen.\r\n   * This can be overriden in your own app.\r\n   * @param canvas The rendering canvas element\r\n   * @returns The loading screen\r\n   */\n\n\n  Engine.DefaultLoadingScreenFactory = function (canvas) {\n    throw _DevTools.WarnImport(\"LoadingScreen\");\n  };\n\n  Object.defineProperty(Engine.prototype, \"_supportsHardwareTextureRescaling\", {\n    get: function get() {\n      return !!Engine._RescalePostProcessFactory;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Engine.prototype, \"performanceMonitor\", {\n    /**\r\n     * Gets the performance monitor attached to this engine\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation\r\n     */\n    get: function get() {\n      return this._performanceMonitor;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Events\n\n  /**\r\n   * Gets the HTML element used to attach event listeners\r\n   * @returns a HTML element\r\n   */\n\n  Engine.prototype.getInputElement = function () {\n    return this._renderingCanvas;\n  };\n  /**\r\n   * Gets current aspect ratio\r\n   * @param viewportOwner defines the camera to use to get the aspect ratio\r\n   * @param useScreen defines if screen size must be used (or the current render target if any)\r\n   * @returns a number defining the aspect ratio\r\n   */\n\n\n  Engine.prototype.getAspectRatio = function (viewportOwner, useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    var viewport = viewportOwner.viewport;\n    return this.getRenderWidth(useScreen) * viewport.width / (this.getRenderHeight(useScreen) * viewport.height);\n  };\n  /**\r\n   * Gets current screen aspect ratio\r\n   * @returns a number defining the aspect ratio\r\n   */\n\n\n  Engine.prototype.getScreenAspectRatio = function () {\n    return this.getRenderWidth(true) / this.getRenderHeight(true);\n  };\n  /**\r\n   * Gets the client rect of the HTML canvas attached with the current webGL context\r\n   * @returns a client rectanglee\r\n   */\n\n\n  Engine.prototype.getRenderingCanvasClientRect = function () {\n    if (!this._renderingCanvas) {\n      return null;\n    }\n\n    return this._renderingCanvas.getBoundingClientRect();\n  };\n  /**\r\n   * Gets the client rect of the HTML element used for events\r\n   * @returns a client rectanglee\r\n   */\n\n\n  Engine.prototype.getInputElementClientRect = function () {\n    if (!this._renderingCanvas) {\n      return null;\n    }\n\n    return this.getInputElement().getBoundingClientRect();\n  };\n  /**\r\n   * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns true if engine is in deterministic lock step mode\r\n   */\n\n\n  Engine.prototype.isDeterministicLockStep = function () {\n    return this._deterministicLockstep;\n  };\n  /**\r\n   * Gets the max steps when engine is running in deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns the max steps\r\n   */\n\n\n  Engine.prototype.getLockstepMaxSteps = function () {\n    return this._lockstepMaxSteps;\n  };\n  /**\r\n   * Returns the time in ms between steps when using deterministic lock step.\r\n   * @returns time step in (ms)\r\n   */\n\n\n  Engine.prototype.getTimeStep = function () {\n    return this._timeStep * 1000;\n  };\n  /**\r\n   * Force the mipmap generation for the given render target texture\r\n   * @param texture defines the render target texture to use\r\n   * @param unbind defines whether or not to unbind the texture after generation. Defaults to true.\r\n   */\n\n\n  Engine.prototype.generateMipMapsForCubemap = function (texture, unbind) {\n    if (unbind === void 0) {\n      unbind = true;\n    }\n\n    if (texture.generateMipMaps) {\n      var gl = this._gl;\n\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n\n      if (unbind) {\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n      }\n    }\n  };\n  /** States */\n\n  /**\r\n   * Set various states to the webGL context\r\n   * @param culling defines backface culling state\r\n   * @param zOffset defines the value to apply to zOffset (0 by default)\r\n   * @param force defines if states must be applied even if cache is up to date\r\n   * @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)\r\n   */\n\n\n  Engine.prototype.setState = function (culling, zOffset, force, reverseSide) {\n    if (zOffset === void 0) {\n      zOffset = 0;\n    }\n\n    if (reverseSide === void 0) {\n      reverseSide = false;\n    } // Culling\n\n\n    if (this._depthCullingState.cull !== culling || force) {\n      this._depthCullingState.cull = culling;\n    } // Cull face\n\n\n    var cullFace = this.cullBackFaces ? this._gl.BACK : this._gl.FRONT;\n\n    if (this._depthCullingState.cullFace !== cullFace || force) {\n      this._depthCullingState.cullFace = cullFace;\n    } // Z offset\n\n\n    this.setZOffset(zOffset); // Front face\n\n    var frontFace = reverseSide ? this._gl.CW : this._gl.CCW;\n\n    if (this._depthCullingState.frontFace !== frontFace || force) {\n      this._depthCullingState.frontFace = frontFace;\n    }\n  };\n  /**\r\n   * Set the z offset to apply to current rendering\r\n   * @param value defines the offset to apply\r\n   */\n\n\n  Engine.prototype.setZOffset = function (value) {\n    this._depthCullingState.zOffset = value;\n  };\n  /**\r\n   * Gets the current value of the zOffset\r\n   * @returns the current zOffset state\r\n   */\n\n\n  Engine.prototype.getZOffset = function () {\n    return this._depthCullingState.zOffset;\n  };\n  /**\r\n   * Enable or disable depth buffering\r\n   * @param enable defines the state to set\r\n   */\n\n\n  Engine.prototype.setDepthBuffer = function (enable) {\n    this._depthCullingState.depthTest = enable;\n  };\n  /**\r\n   * Gets a boolean indicating if depth writing is enabled\r\n   * @returns the current depth writing state\r\n   */\n\n\n  Engine.prototype.getDepthWrite = function () {\n    return this._depthCullingState.depthMask;\n  };\n  /**\r\n   * Enable or disable depth writing\r\n   * @param enable defines the state to set\r\n   */\n\n\n  Engine.prototype.setDepthWrite = function (enable) {\n    this._depthCullingState.depthMask = enable;\n  };\n  /**\r\n   * Gets a boolean indicating if stencil buffer is enabled\r\n   * @returns the current stencil buffer state\r\n   */\n\n\n  Engine.prototype.getStencilBuffer = function () {\n    return this._stencilState.stencilTest;\n  };\n  /**\r\n   * Enable or disable the stencil buffer\r\n   * @param enable defines if the stencil buffer must be enabled or disabled\r\n   */\n\n\n  Engine.prototype.setStencilBuffer = function (enable) {\n    this._stencilState.stencilTest = enable;\n  };\n  /**\r\n   * Gets the current stencil mask\r\n   * @returns a number defining the new stencil mask to use\r\n   */\n\n\n  Engine.prototype.getStencilMask = function () {\n    return this._stencilState.stencilMask;\n  };\n  /**\r\n   * Sets the current stencil mask\r\n   * @param mask defines the new stencil mask to use\r\n   */\n\n\n  Engine.prototype.setStencilMask = function (mask) {\n    this._stencilState.stencilMask = mask;\n  };\n  /**\r\n   * Gets the current stencil function\r\n   * @returns a number defining the stencil function to use\r\n   */\n\n\n  Engine.prototype.getStencilFunction = function () {\n    return this._stencilState.stencilFunc;\n  };\n  /**\r\n   * Gets the current stencil reference value\r\n   * @returns a number defining the stencil reference value to use\r\n   */\n\n\n  Engine.prototype.getStencilFunctionReference = function () {\n    return this._stencilState.stencilFuncRef;\n  };\n  /**\r\n   * Gets the current stencil mask\r\n   * @returns a number defining the stencil mask to use\r\n   */\n\n\n  Engine.prototype.getStencilFunctionMask = function () {\n    return this._stencilState.stencilFuncMask;\n  };\n  /**\r\n   * Sets the current stencil function\r\n   * @param stencilFunc defines the new stencil function to use\r\n   */\n\n\n  Engine.prototype.setStencilFunction = function (stencilFunc) {\n    this._stencilState.stencilFunc = stencilFunc;\n  };\n  /**\r\n   * Sets the current stencil reference\r\n   * @param reference defines the new stencil reference to use\r\n   */\n\n\n  Engine.prototype.setStencilFunctionReference = function (reference) {\n    this._stencilState.stencilFuncRef = reference;\n  };\n  /**\r\n   * Sets the current stencil mask\r\n   * @param mask defines the new stencil mask to use\r\n   */\n\n\n  Engine.prototype.setStencilFunctionMask = function (mask) {\n    this._stencilState.stencilFuncMask = mask;\n  };\n  /**\r\n   * Gets the current stencil operation when stencil fails\r\n   * @returns a number defining stencil operation to use when stencil fails\r\n   */\n\n\n  Engine.prototype.getStencilOperationFail = function () {\n    return this._stencilState.stencilOpStencilFail;\n  };\n  /**\r\n   * Gets the current stencil operation when depth fails\r\n   * @returns a number defining stencil operation to use when depth fails\r\n   */\n\n\n  Engine.prototype.getStencilOperationDepthFail = function () {\n    return this._stencilState.stencilOpDepthFail;\n  };\n  /**\r\n   * Gets the current stencil operation when stencil passes\r\n   * @returns a number defining stencil operation to use when stencil passes\r\n   */\n\n\n  Engine.prototype.getStencilOperationPass = function () {\n    return this._stencilState.stencilOpStencilDepthPass;\n  };\n  /**\r\n   * Sets the stencil operation to use when stencil fails\r\n   * @param operation defines the stencil operation to use when stencil fails\r\n   */\n\n\n  Engine.prototype.setStencilOperationFail = function (operation) {\n    this._stencilState.stencilOpStencilFail = operation;\n  };\n  /**\r\n   * Sets the stencil operation to use when depth fails\r\n   * @param operation defines the stencil operation to use when depth fails\r\n   */\n\n\n  Engine.prototype.setStencilOperationDepthFail = function (operation) {\n    this._stencilState.stencilOpDepthFail = operation;\n  };\n  /**\r\n   * Sets the stencil operation to use when stencil passes\r\n   * @param operation defines the stencil operation to use when stencil passes\r\n   */\n\n\n  Engine.prototype.setStencilOperationPass = function (operation) {\n    this._stencilState.stencilOpStencilDepthPass = operation;\n  };\n  /**\r\n   * Sets a boolean indicating if the dithering state is enabled or disabled\r\n   * @param value defines the dithering state\r\n   */\n\n\n  Engine.prototype.setDitheringState = function (value) {\n    if (value) {\n      this._gl.enable(this._gl.DITHER);\n    } else {\n      this._gl.disable(this._gl.DITHER);\n    }\n  };\n  /**\r\n   * Sets a boolean indicating if the rasterizer state is enabled or disabled\r\n   * @param value defines the rasterizer state\r\n   */\n\n\n  Engine.prototype.setRasterizerState = function (value) {\n    if (value) {\n      this._gl.disable(this._gl.RASTERIZER_DISCARD);\n    } else {\n      this._gl.enable(this._gl.RASTERIZER_DISCARD);\n    }\n  };\n  /**\r\n   * Gets the current depth function\r\n   * @returns a number defining the depth function\r\n   */\n\n\n  Engine.prototype.getDepthFunction = function () {\n    return this._depthCullingState.depthFunc;\n  };\n  /**\r\n   * Sets the current depth function\r\n   * @param depthFunc defines the function to use\r\n   */\n\n\n  Engine.prototype.setDepthFunction = function (depthFunc) {\n    this._depthCullingState.depthFunc = depthFunc;\n  };\n  /**\r\n   * Sets the current depth function to GREATER\r\n   */\n\n\n  Engine.prototype.setDepthFunctionToGreater = function () {\n    this._depthCullingState.depthFunc = this._gl.GREATER;\n  };\n  /**\r\n   * Sets the current depth function to GEQUAL\r\n   */\n\n\n  Engine.prototype.setDepthFunctionToGreaterOrEqual = function () {\n    this._depthCullingState.depthFunc = this._gl.GEQUAL;\n  };\n  /**\r\n   * Sets the current depth function to LESS\r\n   */\n\n\n  Engine.prototype.setDepthFunctionToLess = function () {\n    this._depthCullingState.depthFunc = this._gl.LESS;\n  };\n  /**\r\n   * Sets the current depth function to LEQUAL\r\n   */\n\n\n  Engine.prototype.setDepthFunctionToLessOrEqual = function () {\n    this._depthCullingState.depthFunc = this._gl.LEQUAL;\n  };\n  /**\r\n   * Caches the the state of the stencil buffer\r\n   */\n\n\n  Engine.prototype.cacheStencilState = function () {\n    this._cachedStencilBuffer = this.getStencilBuffer();\n    this._cachedStencilFunction = this.getStencilFunction();\n    this._cachedStencilMask = this.getStencilMask();\n    this._cachedStencilOperationPass = this.getStencilOperationPass();\n    this._cachedStencilOperationFail = this.getStencilOperationFail();\n    this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();\n    this._cachedStencilReference = this.getStencilFunctionReference();\n  };\n  /**\r\n   * Restores the state of the stencil buffer\r\n   */\n\n\n  Engine.prototype.restoreStencilState = function () {\n    this.setStencilFunction(this._cachedStencilFunction);\n    this.setStencilMask(this._cachedStencilMask);\n    this.setStencilBuffer(this._cachedStencilBuffer);\n    this.setStencilOperationPass(this._cachedStencilOperationPass);\n    this.setStencilOperationFail(this._cachedStencilOperationFail);\n    this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);\n    this.setStencilFunctionReference(this._cachedStencilReference);\n  };\n  /**\r\n   * Directly set the WebGL Viewport\r\n   * @param x defines the x coordinate of the viewport (in screen space)\r\n   * @param y defines the y coordinate of the viewport (in screen space)\r\n   * @param width defines the width of the viewport (in screen space)\r\n   * @param height defines the height of the viewport (in screen space)\r\n   * @return the current viewport Object (if any) that is being replaced by this call. You can restore this viewport later on to go back to the original state\r\n   */\n\n\n  Engine.prototype.setDirectViewport = function (x, y, width, height) {\n    var currentViewport = this._cachedViewport;\n    this._cachedViewport = null;\n\n    this._viewport(x, y, width, height);\n\n    return currentViewport;\n  };\n  /**\r\n   * Executes a scissor clear (ie. a clear on a specific portion of the screen)\r\n   * @param x defines the x-coordinate of the top left corner of the clear rectangle\r\n   * @param y defines the y-coordinate of the corner of the clear rectangle\r\n   * @param width defines the width of the clear rectangle\r\n   * @param height defines the height of the clear rectangle\r\n   * @param clearColor defines the clear color\r\n   */\n\n\n  Engine.prototype.scissorClear = function (x, y, width, height, clearColor) {\n    this.enableScissor(x, y, width, height);\n    this.clear(clearColor, true, true, true);\n    this.disableScissor();\n  };\n  /**\r\n   * Enable scissor test on a specific rectangle (ie. render will only be executed on a specific portion of the screen)\r\n   * @param x defines the x-coordinate of the top left corner of the clear rectangle\r\n   * @param y defines the y-coordinate of the corner of the clear rectangle\r\n   * @param width defines the width of the clear rectangle\r\n   * @param height defines the height of the clear rectangle\r\n   */\n\n\n  Engine.prototype.enableScissor = function (x, y, width, height) {\n    var gl = this._gl; // Change state\n\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(x, y, width, height);\n  };\n  /**\r\n   * Disable previously set scissor test rectangle\r\n   */\n\n\n  Engine.prototype.disableScissor = function () {\n    var gl = this._gl;\n    gl.disable(gl.SCISSOR_TEST);\n  };\n\n  Engine.prototype._reportDrawCall = function () {\n    this._drawCalls.addCount(1, false);\n  };\n  /**\r\n   * Initializes a webVR display and starts listening to display change events\r\n   * The onVRDisplayChangedObservable will be notified upon these changes\r\n   * @returns The onVRDisplayChangedObservable\r\n   */\n\n\n  Engine.prototype.initWebVR = function () {\n    throw _DevTools.WarnImport(\"WebVRCamera\");\n  };\n  /** @hidden */\n\n\n  Engine.prototype._prepareVRComponent = function () {// Do nothing as the engine side effect will overload it\n  };\n  /** @hidden */\n\n\n  Engine.prototype._connectVREvents = function (canvas, document) {// Do nothing as the engine side effect will overload it\n  };\n  /** @hidden */\n\n\n  Engine.prototype._submitVRFrame = function () {// Do nothing as the engine side effect will overload it\n  };\n  /**\r\n   * Call this function to leave webVR mode\r\n   * Will do nothing if webVR is not supported or if there is no webVR device\r\n   * @see https://doc.babylonjs.com/how_to/webvr_camera\r\n   */\n\n\n  Engine.prototype.disableVR = function () {// Do nothing as the engine side effect will overload it\n  };\n  /**\r\n   * Gets a boolean indicating that the system is in VR mode and is presenting\r\n   * @returns true if VR mode is engaged\r\n   */\n\n\n  Engine.prototype.isVRPresenting = function () {\n    return false;\n  };\n  /** @hidden */\n\n\n  Engine.prototype._requestVRFrame = function () {// Do nothing as the engine side effect will overload it\n  };\n  /** @hidden */\n\n\n  Engine.prototype._loadFileAsync = function (url, offlineProvider, useArrayBuffer) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._loadFile(url, function (data) {\n        resolve(data);\n      }, undefined, offlineProvider, useArrayBuffer, function (request, exception) {\n        reject(exception);\n      });\n    });\n  };\n  /**\r\n  * Gets the source code of the vertex shader associated with a specific webGL program\r\n  * @param program defines the program to use\r\n  * @returns a string containing the source code of the vertex shader associated with the program\r\n  */\n\n\n  Engine.prototype.getVertexShaderSource = function (program) {\n    var shaders = this._gl.getAttachedShaders(program);\n\n    if (!shaders) {\n      return null;\n    }\n\n    return this._gl.getShaderSource(shaders[0]);\n  };\n  /**\r\n   * Gets the source code of the fragment shader associated with a specific webGL program\r\n   * @param program defines the program to use\r\n   * @returns a string containing the source code of the fragment shader associated with the program\r\n   */\n\n\n  Engine.prototype.getFragmentShaderSource = function (program) {\n    var shaders = this._gl.getAttachedShaders(program);\n\n    if (!shaders) {\n      return null;\n    }\n\n    return this._gl.getShaderSource(shaders[1]);\n  };\n  /**\r\n   * Sets a depth stencil texture from a render target to the according uniform.\r\n   * @param channel The texture channel\r\n   * @param uniform The uniform to set\r\n   * @param texture The render target texture containing the depth stencil texture to apply\r\n   */\n\n\n  Engine.prototype.setDepthStencilTexture = function (channel, uniform, texture) {\n    if (channel === undefined) {\n      return;\n    }\n\n    if (uniform) {\n      this._boundUniforms[channel] = uniform;\n    }\n\n    if (!texture || !texture.depthStencilTexture) {\n      this._setTexture(channel, null);\n    } else {\n      this._setTexture(channel, texture, false, true);\n    }\n  };\n  /**\r\n   * Sets a texture to the webGL context from a postprocess\r\n   * @param channel defines the channel to use\r\n   * @param postProcess defines the source postprocess\r\n   */\n\n\n  Engine.prototype.setTextureFromPostProcess = function (channel, postProcess) {\n    this._bindTexture(channel, postProcess ? postProcess._textures.data[postProcess._currentRenderTextureInd] : null);\n  };\n  /**\r\n   * Binds the output of the passed in post process to the texture channel specified\r\n   * @param channel The channel the texture should be bound to\r\n   * @param postProcess The post process which's output should be bound\r\n   */\n\n\n  Engine.prototype.setTextureFromPostProcessOutput = function (channel, postProcess) {\n    this._bindTexture(channel, postProcess ? postProcess._outputTexture : null);\n  };\n\n  Engine.prototype._rebuildBuffers = function () {\n    // Index / Vertex\n    for (var _i = 0, _a = this.scenes; _i < _a.length; _i++) {\n      var scene = _a[_i];\n      scene.resetCachedMaterial();\n\n      scene._rebuildGeometries();\n\n      scene._rebuildTextures();\n    }\n\n    _super.prototype._rebuildBuffers.call(this);\n  };\n  /** @hidden */\n\n\n  Engine.prototype._renderFrame = function () {\n    for (var index = 0; index < this._activeRenderLoops.length; index++) {\n      var renderFunction = this._activeRenderLoops[index];\n      renderFunction();\n    }\n  };\n\n  Engine.prototype._renderLoop = function () {\n    if (!this._contextWasLost) {\n      var shouldRender = true;\n\n      if (!this.renderEvenInBackground && this._windowIsBackground) {\n        shouldRender = false;\n      }\n\n      if (shouldRender) {\n        // Start new frame\n        this.beginFrame(); // Child canvases\n\n        if (!this._renderViews()) {\n          // Main frame\n          this._renderFrame();\n        } // Present\n\n\n        this.endFrame();\n      }\n    }\n\n    if (this._activeRenderLoops.length > 0) {\n      // Register new frame\n      if (this.customAnimationFrameRequester) {\n        this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);\n        this._frameHandler = this.customAnimationFrameRequester.requestID;\n      } else if (this.isVRPresenting()) {\n        this._requestVRFrame();\n      } else {\n        this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\n      }\n    } else {\n      this._renderingQueueLaunched = false;\n    }\n  };\n  /** @hidden */\n\n\n  Engine.prototype._renderViews = function () {\n    return false;\n  };\n  /**\r\n   * Toggle full screen mode\r\n   * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n   */\n\n\n  Engine.prototype.switchFullscreen = function (requestPointerLock) {\n    if (this.isFullscreen) {\n      this.exitFullscreen();\n    } else {\n      this.enterFullscreen(requestPointerLock);\n    }\n  };\n  /**\r\n   * Enters full screen mode\r\n   * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n   */\n\n\n  Engine.prototype.enterFullscreen = function (requestPointerLock) {\n    if (!this.isFullscreen) {\n      this._pointerLockRequested = requestPointerLock;\n\n      if (this._renderingCanvas) {\n        Engine._RequestFullscreen(this._renderingCanvas);\n      }\n    }\n  };\n  /**\r\n   * Exits full screen mode\r\n   */\n\n\n  Engine.prototype.exitFullscreen = function () {\n    if (this.isFullscreen) {\n      Engine._ExitFullscreen();\n    }\n  };\n  /**\r\n   * Enters Pointerlock mode\r\n   */\n\n\n  Engine.prototype.enterPointerlock = function () {\n    if (this._renderingCanvas) {\n      Engine._RequestPointerlock(this._renderingCanvas);\n    }\n  };\n  /**\r\n   * Exits Pointerlock mode\r\n   */\n\n\n  Engine.prototype.exitPointerlock = function () {\n    Engine._ExitPointerlock();\n  };\n  /**\r\n   * Begin a new frame\r\n   */\n\n\n  Engine.prototype.beginFrame = function () {\n    this._measureFps();\n\n    this.onBeginFrameObservable.notifyObservers(this);\n\n    _super.prototype.beginFrame.call(this);\n  };\n  /**\r\n   * Enf the current frame\r\n   */\n\n\n  Engine.prototype.endFrame = function () {\n    _super.prototype.endFrame.call(this);\n\n    this._submitVRFrame();\n\n    this.onEndFrameObservable.notifyObservers(this);\n  };\n\n  Engine.prototype.resize = function () {\n    // We're not resizing the size of the canvas while in VR mode & presenting\n    if (this.isVRPresenting()) {\n      return;\n    }\n\n    _super.prototype.resize.call(this);\n  };\n  /**\r\n   * Force a specific size of the canvas\r\n   * @param width defines the new canvas' width\r\n   * @param height defines the new canvas' height\r\n   * @returns true if the size was changed\r\n   */\n\n\n  Engine.prototype.setSize = function (width, height) {\n    if (!this._renderingCanvas) {\n      return false;\n    }\n\n    if (!_super.prototype.setSize.call(this, width, height)) {\n      return false;\n    }\n\n    if (this.scenes) {\n      for (var index = 0; index < this.scenes.length; index++) {\n        var scene = this.scenes[index];\n\n        for (var camIndex = 0; camIndex < scene.cameras.length; camIndex++) {\n          var cam = scene.cameras[camIndex];\n          cam._currentRenderId = 0;\n        }\n      }\n\n      if (this.onResizeObservable.hasObservers()) {\n        this.onResizeObservable.notifyObservers(this);\n      }\n    }\n\n    return true;\n  };\n\n  Engine.prototype._deletePipelineContext = function (pipelineContext) {\n    var webGLPipelineContext = pipelineContext;\n\n    if (webGLPipelineContext && webGLPipelineContext.program) {\n      if (webGLPipelineContext.transformFeedback) {\n        this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);\n        webGLPipelineContext.transformFeedback = null;\n      }\n    }\n\n    _super.prototype._deletePipelineContext.call(this, pipelineContext);\n  };\n\n  Engine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {\n    if (transformFeedbackVaryings === void 0) {\n      transformFeedbackVaryings = null;\n    }\n\n    context = context || this._gl;\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n\n    var program = _super.prototype.createShaderProgram.call(this, pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);\n\n    this.onAfterShaderCompilationObservable.notifyObservers(this);\n    return program;\n  };\n\n  Engine.prototype._createShaderProgram = function (pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {\n    if (transformFeedbackVaryings === void 0) {\n      transformFeedbackVaryings = null;\n    }\n\n    var shaderProgram = context.createProgram();\n    pipelineContext.program = shaderProgram;\n\n    if (!shaderProgram) {\n      throw new Error(\"Unable to create program\");\n    }\n\n    context.attachShader(shaderProgram, vertexShader);\n    context.attachShader(shaderProgram, fragmentShader);\n\n    if (this.webGLVersion > 1 && transformFeedbackVaryings) {\n      var transformFeedback = this.createTransformFeedback();\n      this.bindTransformFeedback(transformFeedback);\n      this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);\n      pipelineContext.transformFeedback = transformFeedback;\n    }\n\n    context.linkProgram(shaderProgram);\n\n    if (this.webGLVersion > 1 && transformFeedbackVaryings) {\n      this.bindTransformFeedback(null);\n    }\n\n    pipelineContext.context = context;\n    pipelineContext.vertexShader = vertexShader;\n    pipelineContext.fragmentShader = fragmentShader;\n\n    if (!pipelineContext.isParallelCompiled) {\n      this._finalizePipelineContext(pipelineContext);\n    }\n\n    return shaderProgram;\n  };\n\n  Engine.prototype._releaseTexture = function (texture) {\n    _super.prototype._releaseTexture.call(this, texture); // Set output texture of post process to null if the texture has been released/disposed\n\n\n    this.scenes.forEach(function (scene) {\n      scene.postProcesses.forEach(function (postProcess) {\n        if (postProcess._outputTexture == texture) {\n          postProcess._outputTexture = null;\n        }\n      });\n      scene.cameras.forEach(function (camera) {\n        camera._postProcesses.forEach(function (postProcess) {\n          if (postProcess) {\n            if (postProcess._outputTexture == texture) {\n              postProcess._outputTexture = null;\n            }\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Rescales a texture\r\n   * @param source input texutre\r\n   * @param destination destination texture\r\n   * @param scene scene to use to render the resize\r\n   * @param internalFormat format to use when resizing\r\n   * @param onComplete callback to be called when resize has completed\r\n   */\n\n\n  Engine.prototype._rescaleTexture = function (source, destination, scene, internalFormat, onComplete) {\n    var _this = this;\n\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);\n\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);\n\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n\n    var rtt = this.createRenderTargetTexture({\n      width: destination.width,\n      height: destination.height\n    }, {\n      generateMipMaps: false,\n      type: 0,\n      samplingMode: 2,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false\n    });\n\n    if (!this._rescalePostProcess && Engine._RescalePostProcessFactory) {\n      this._rescalePostProcess = Engine._RescalePostProcessFactory(this);\n    }\n\n    this._rescalePostProcess.getEffect().executeWhenCompiled(function () {\n      _this._rescalePostProcess.onApply = function (effect) {\n        effect._bindTexture(\"textureSampler\", source);\n      };\n\n      var hostingScene = scene;\n\n      if (!hostingScene) {\n        hostingScene = _this.scenes[_this.scenes.length - 1];\n      }\n\n      hostingScene.postProcessManager.directRender([_this._rescalePostProcess], rtt, true);\n\n      _this._bindTextureDirectly(_this._gl.TEXTURE_2D, destination, true);\n\n      _this._gl.copyTexImage2D(_this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);\n\n      _this.unBindFramebuffer(rtt);\n\n      _this._releaseTexture(rtt);\n\n      if (onComplete) {\n        onComplete();\n      }\n    });\n  }; // FPS\n\n  /**\r\n   * Gets the current framerate\r\n   * @returns a number representing the framerate\r\n   */\n\n\n  Engine.prototype.getFps = function () {\n    return this._fps;\n  };\n  /**\r\n   * Gets the time spent between current and previous frame\r\n   * @returns a number representing the delta time in ms\r\n   */\n\n\n  Engine.prototype.getDeltaTime = function () {\n    return this._deltaTime;\n  };\n\n  Engine.prototype._measureFps = function () {\n    this._performanceMonitor.sampleFrame();\n\n    this._fps = this._performanceMonitor.averageFPS;\n    this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;\n  };\n  /** @hidden */\n\n\n  Engine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    var gl = this._gl;\n\n    var textureType = this._getWebGLTextureType(texture.type);\n\n    var format = this._getInternalFormat(texture.format);\n\n    var internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);\n\n    var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\n\n    this._bindTextureDirectly(bindTarget, texture, true);\n\n    this._unpackFlipY(texture.invertY);\n\n    var target = gl.TEXTURE_2D;\n\n    if (texture.isCube) {\n      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\n    }\n\n    gl.texImage2D(target, lod, internalFormat, format, textureType, image);\n\n    this._bindTextureDirectly(bindTarget, null, true);\n  };\n  /**\r\n   * Updates the sample count of a render target texture\r\n   * @see https://doc.babylonjs.com/features/webgl2#multisample-render-targets\r\n   * @param texture defines the texture to update\r\n   * @param samples defines the sample count to set\r\n   * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n   */\n\n\n  Engine.prototype.updateRenderTargetTextureSampleCount = function (texture, samples) {\n    if (this.webGLVersion < 2 || !texture) {\n      return 1;\n    }\n\n    if (texture.samples === samples) {\n      return samples;\n    }\n\n    var gl = this._gl;\n    samples = Math.min(samples, this.getCaps().maxMSAASamples); // Dispose previous render buffers\n\n    if (texture._depthStencilBuffer) {\n      gl.deleteRenderbuffer(texture._depthStencilBuffer);\n      texture._depthStencilBuffer = null;\n    }\n\n    if (texture._MSAAFramebuffer) {\n      gl.deleteFramebuffer(texture._MSAAFramebuffer);\n      texture._MSAAFramebuffer = null;\n    }\n\n    if (texture._MSAARenderBuffer) {\n      gl.deleteRenderbuffer(texture._MSAARenderBuffer);\n      texture._MSAARenderBuffer = null;\n    }\n\n    if (samples > 1 && gl.renderbufferStorageMultisample) {\n      var framebuffer = gl.createFramebuffer();\n\n      if (!framebuffer) {\n        throw new Error(\"Unable to create multi sampled framebuffer\");\n      }\n\n      texture._MSAAFramebuffer = framebuffer;\n\n      this._bindUnboundFramebuffer(texture._MSAAFramebuffer);\n\n      var colorRenderbuffer = gl.createRenderbuffer();\n\n      if (!colorRenderbuffer) {\n        throw new Error(\"Unable to create multi sampled framebuffer\");\n      }\n\n      gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbuffer);\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, this._getRGBAMultiSampleBufferFormat(texture.type), texture.width, texture.height);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, colorRenderbuffer);\n      texture._MSAARenderBuffer = colorRenderbuffer;\n    } else {\n      this._bindUnboundFramebuffer(texture._framebuffer);\n    }\n\n    texture.samples = samples;\n    texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(texture._generateStencilBuffer, texture._generateDepthBuffer, texture.width, texture.height, samples);\n\n    this._bindUnboundFramebuffer(null);\n\n    return samples;\n  };\n  /**\r\n   * Updates a depth texture Comparison Mode and Function.\r\n   * If the comparison Function is equal to 0, the mode will be set to none.\r\n   * Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.\r\n   * @param texture The texture to set the comparison function for\r\n   * @param comparisonFunction The comparison function to set, 0 if no comparison required\r\n   */\n\n\n  Engine.prototype.updateTextureComparisonFunction = function (texture, comparisonFunction) {\n    if (this.webGLVersion === 1) {\n      Logger.Error(\"WebGL 1 does not support texture comparison.\");\n      return;\n    }\n\n    var gl = this._gl;\n\n    if (texture.isCube) {\n      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\n\n      if (comparisonFunction === 0) {\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);\n      } else {\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n      }\n\n      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n    } else {\n      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n\n      if (comparisonFunction === 0) {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);\n      } else {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n      }\n\n      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n    }\n\n    texture._comparisonFunction = comparisonFunction;\n  };\n  /**\r\n   * Creates a webGL buffer to use with instanciation\r\n   * @param capacity defines the size of the buffer\r\n   * @returns the webGL buffer\r\n   */\n\n\n  Engine.prototype.createInstancesBuffer = function (capacity) {\n    var buffer = this._gl.createBuffer();\n\n    if (!buffer) {\n      throw new Error(\"Unable to create instance buffer\");\n    }\n\n    var result = new WebGLDataBuffer(buffer);\n    result.capacity = capacity;\n    this.bindArrayBuffer(result);\n\n    this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);\n\n    return result;\n  };\n  /**\r\n   * Delete a webGL buffer used with instanciation\r\n   * @param buffer defines the webGL buffer to delete\r\n   */\n\n\n  Engine.prototype.deleteInstancesBuffer = function (buffer) {\n    this._gl.deleteBuffer(buffer);\n  };\n\n  Engine.prototype._clientWaitAsync = function (sync, flags, interval_ms) {\n    if (flags === void 0) {\n      flags = 0;\n    }\n\n    if (interval_ms === void 0) {\n      interval_ms = 10;\n    }\n\n    var gl = this._gl;\n    return new Promise(function (resolve, reject) {\n      var check = function check() {\n        var res = gl.clientWaitSync(sync, flags, 0);\n\n        if (res == gl.WAIT_FAILED) {\n          reject();\n          return;\n        }\n\n        if (res == gl.TIMEOUT_EXPIRED) {\n          setTimeout(check, interval_ms);\n          return;\n        }\n\n        resolve();\n      };\n\n      check();\n    });\n  };\n  /** @hidden */\n\n\n  Engine.prototype._readPixelsAsync = function (x, y, w, h, format, type, outputBuffer) {\n    if (this._webGLVersion < 2) {\n      throw new Error(\"_readPixelsAsync only work on WebGL2+\");\n    }\n\n    var gl = this._gl;\n    var buf = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);\n    gl.readPixels(x, y, w, h, format, type, 0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n\n    if (!sync) {\n      return null;\n    }\n\n    gl.flush();\n    return this._clientWaitAsync(sync, 0, 10).then(function () {\n      gl.deleteSync(sync);\n      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);\n      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n      gl.deleteBuffer(buf);\n      return outputBuffer;\n    });\n  };\n\n  Engine.prototype.dispose = function () {\n    this.hideLoadingUI();\n    this.onNewSceneAddedObservable.clear(); // Release postProcesses\n\n    while (this.postProcesses.length) {\n      this.postProcesses[0].dispose();\n    } // Rescale PP\n\n\n    if (this._rescalePostProcess) {\n      this._rescalePostProcess.dispose();\n    } // Release scenes\n\n\n    while (this.scenes.length) {\n      this.scenes[0].dispose();\n    } // Release audio engine\n\n\n    if (Engine.Instances.length === 1 && Engine.audioEngine) {\n      Engine.audioEngine.dispose();\n    } //WebVR\n\n\n    this.disableVR(); // Events\n\n    if (DomManagement.IsWindowObjectExist()) {\n      window.removeEventListener(\"blur\", this._onBlur);\n      window.removeEventListener(\"focus\", this._onFocus);\n\n      if (this._renderingCanvas) {\n        this._renderingCanvas.removeEventListener(\"focus\", this._onCanvasFocus);\n\n        this._renderingCanvas.removeEventListener(\"blur\", this._onCanvasBlur);\n\n        this._renderingCanvas.removeEventListener(\"pointerout\", this._onCanvasPointerOut);\n      }\n\n      if (DomManagement.IsDocumentAvailable()) {\n        document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\n        document.removeEventListener(\"mozfullscreenchange\", this._onFullscreenChange);\n        document.removeEventListener(\"webkitfullscreenchange\", this._onFullscreenChange);\n        document.removeEventListener(\"msfullscreenchange\", this._onFullscreenChange);\n        document.removeEventListener(\"pointerlockchange\", this._onPointerLockChange);\n        document.removeEventListener(\"mspointerlockchange\", this._onPointerLockChange);\n        document.removeEventListener(\"mozpointerlockchange\", this._onPointerLockChange);\n        document.removeEventListener(\"webkitpointerlockchange\", this._onPointerLockChange);\n      }\n    }\n\n    _super.prototype.dispose.call(this); // Remove from Instances\n\n\n    var index = Engine.Instances.indexOf(this);\n\n    if (index >= 0) {\n      Engine.Instances.splice(index, 1);\n    } // Observables\n\n\n    this.onResizeObservable.clear();\n    this.onCanvasBlurObservable.clear();\n    this.onCanvasFocusObservable.clear();\n    this.onCanvasPointerOutObservable.clear();\n    this.onBeginFrameObservable.clear();\n    this.onEndFrameObservable.clear();\n  };\n\n  Engine.prototype._disableTouchAction = function () {\n    if (!this._renderingCanvas || !this._renderingCanvas.setAttribute) {\n      return;\n    }\n\n    this._renderingCanvas.setAttribute(\"touch-action\", \"none\");\n\n    this._renderingCanvas.style.touchAction = \"none\";\n    this._renderingCanvas.style.msTouchAction = \"none\";\n  }; // Loading screen\n\n  /**\r\n   * Display the loading screen\r\n   * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen\r\n   */\n\n\n  Engine.prototype.displayLoadingUI = function () {\n    if (!DomManagement.IsWindowObjectExist()) {\n      return;\n    }\n\n    var loadingScreen = this.loadingScreen;\n\n    if (loadingScreen) {\n      loadingScreen.displayLoadingUI();\n    }\n  };\n  /**\r\n   * Hide the loading screen\r\n   * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen\r\n   */\n\n\n  Engine.prototype.hideLoadingUI = function () {\n    if (!DomManagement.IsWindowObjectExist()) {\n      return;\n    }\n\n    var loadingScreen = this._loadingScreen;\n\n    if (loadingScreen) {\n      loadingScreen.hideLoadingUI();\n    }\n  };\n\n  Object.defineProperty(Engine.prototype, \"loadingScreen\", {\n    /**\r\n     * Gets the current loading screen object\r\n     * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen\r\n     */\n    get: function get() {\n      if (!this._loadingScreen && this._renderingCanvas) {\n        this._loadingScreen = Engine.DefaultLoadingScreenFactory(this._renderingCanvas);\n      }\n\n      return this._loadingScreen;\n    },\n\n    /**\r\n     * Sets the current loading screen object\r\n     * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen\r\n     */\n    set: function set(loadingScreen) {\n      this._loadingScreen = loadingScreen;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Engine.prototype, \"loadingUIText\", {\n    /**\r\n     * Sets the current loading screen text\r\n     * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen\r\n     */\n    set: function set(text) {\n      this.loadingScreen.loadingUIText = text;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Engine.prototype, \"loadingUIBackgroundColor\", {\n    /**\r\n     * Sets the current loading screen background color\r\n     * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen\r\n     */\n    set: function set(color) {\n      this.loadingScreen.loadingUIBackgroundColor = color;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Pointerlock and fullscreen */\n\n  /**\r\n   * Ask the browser to promote the current element to pointerlock mode\r\n   * @param element defines the DOM element to promote\r\n   */\n\n  Engine._RequestPointerlock = function (element) {\n    element.requestPointerLock = element.requestPointerLock || element.msRequestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;\n\n    if (element.requestPointerLock) {\n      element.requestPointerLock();\n    }\n  };\n  /**\r\n   * Asks the browser to exit pointerlock mode\r\n   */\n\n\n  Engine._ExitPointerlock = function () {\n    var anyDoc = document;\n    document.exitPointerLock = document.exitPointerLock || anyDoc.msExitPointerLock || anyDoc.mozExitPointerLock || anyDoc.webkitExitPointerLock;\n\n    if (document.exitPointerLock) {\n      document.exitPointerLock();\n    }\n  };\n  /**\r\n   * Ask the browser to promote the current element to fullscreen rendering mode\r\n   * @param element defines the DOM element to promote\r\n   */\n\n\n  Engine._RequestFullscreen = function (element) {\n    var requestFunction = element.requestFullscreen || element.msRequestFullscreen || element.webkitRequestFullscreen || element.mozRequestFullScreen;\n\n    if (!requestFunction) {\n      return;\n    }\n\n    requestFunction.call(element);\n  };\n  /**\r\n   * Asks the browser to exit fullscreen mode\r\n   */\n\n\n  Engine._ExitFullscreen = function () {\n    var anyDoc = document;\n\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    } else if (anyDoc.mozCancelFullScreen) {\n      anyDoc.mozCancelFullScreen();\n    } else if (anyDoc.webkitCancelFullScreen) {\n      anyDoc.webkitCancelFullScreen();\n    } else if (anyDoc.msCancelFullScreen) {\n      anyDoc.msCancelFullScreen();\n    }\n  }; // Const statics\n\n  /** Defines that alpha blending is disabled */\n\n\n  Engine.ALPHA_DISABLE = 0;\n  /** Defines that alpha blending to SRC ALPHA * SRC + DEST */\n\n  Engine.ALPHA_ADD = 1;\n  /** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */\n\n  Engine.ALPHA_COMBINE = 2;\n  /** Defines that alpha blending to DEST - SRC * DEST */\n\n  Engine.ALPHA_SUBTRACT = 3;\n  /** Defines that alpha blending to SRC * DEST */\n\n  Engine.ALPHA_MULTIPLY = 4;\n  /** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST */\n\n  Engine.ALPHA_MAXIMIZED = 5;\n  /** Defines that alpha blending to SRC + DEST */\n\n  Engine.ALPHA_ONEONE = 6;\n  /** Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST */\n\n  Engine.ALPHA_PREMULTIPLIED = 7;\n  /**\r\n   * Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST\r\n   * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA\r\n   */\n\n  Engine.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;\n  /** Defines that alpha blending to CST * SRC + (1 - CST) * DEST */\n\n  Engine.ALPHA_INTERPOLATE = 9;\n  /**\r\n   * Defines that alpha blending to SRC + (1 - SRC) * DEST\r\n   * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA\r\n   */\n\n  Engine.ALPHA_SCREENMODE = 10;\n  /** Defines that the ressource is not delayed*/\n\n  Engine.DELAYLOADSTATE_NONE = 0;\n  /** Defines that the ressource was successfully delay loaded */\n\n  Engine.DELAYLOADSTATE_LOADED = 1;\n  /** Defines that the ressource is currently delay loading */\n\n  Engine.DELAYLOADSTATE_LOADING = 2;\n  /** Defines that the ressource is delayed and has not started loading */\n\n  Engine.DELAYLOADSTATE_NOTLOADED = 4; // Depht or Stencil test Constants.\n\n  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */\n\n  Engine.NEVER = 512;\n  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */\n\n  Engine.ALWAYS = 519;\n  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */\n\n  Engine.LESS = 513;\n  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */\n\n  Engine.EQUAL = 514;\n  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */\n\n  Engine.LEQUAL = 515;\n  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */\n\n  Engine.GREATER = 516;\n  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */\n\n  Engine.GEQUAL = 518;\n  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */\n\n  Engine.NOTEQUAL = 517; // Stencil Actions Constants.\n\n  /** Passed to stencilOperation to specify that stencil value must be kept */\n\n  Engine.KEEP = 7680;\n  /** Passed to stencilOperation to specify that stencil value must be replaced */\n\n  Engine.REPLACE = 7681;\n  /** Passed to stencilOperation to specify that stencil value must be incremented */\n\n  Engine.INCR = 7682;\n  /** Passed to stencilOperation to specify that stencil value must be decremented */\n\n  Engine.DECR = 7683;\n  /** Passed to stencilOperation to specify that stencil value must be inverted */\n\n  Engine.INVERT = 5386;\n  /** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */\n\n  Engine.INCR_WRAP = 34055;\n  /** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */\n\n  Engine.DECR_WRAP = 34056;\n  /** Texture is not repeating outside of 0..1 UVs */\n\n  Engine.TEXTURE_CLAMP_ADDRESSMODE = 0;\n  /** Texture is repeating outside of 0..1 UVs */\n\n  Engine.TEXTURE_WRAP_ADDRESSMODE = 1;\n  /** Texture is repeating and mirrored */\n\n  Engine.TEXTURE_MIRROR_ADDRESSMODE = 2;\n  /** ALPHA */\n\n  Engine.TEXTUREFORMAT_ALPHA = 0;\n  /** LUMINANCE */\n\n  Engine.TEXTUREFORMAT_LUMINANCE = 1;\n  /** LUMINANCE_ALPHA */\n\n  Engine.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;\n  /** RGB */\n\n  Engine.TEXTUREFORMAT_RGB = 4;\n  /** RGBA */\n\n  Engine.TEXTUREFORMAT_RGBA = 5;\n  /** RED */\n\n  Engine.TEXTUREFORMAT_RED = 6;\n  /** RED (2nd reference) */\n\n  Engine.TEXTUREFORMAT_R = 6;\n  /** RG */\n\n  Engine.TEXTUREFORMAT_RG = 7;\n  /** RED_INTEGER */\n\n  Engine.TEXTUREFORMAT_RED_INTEGER = 8;\n  /** RED_INTEGER (2nd reference) */\n\n  Engine.TEXTUREFORMAT_R_INTEGER = 8;\n  /** RG_INTEGER */\n\n  Engine.TEXTUREFORMAT_RG_INTEGER = 9;\n  /** RGB_INTEGER */\n\n  Engine.TEXTUREFORMAT_RGB_INTEGER = 10;\n  /** RGBA_INTEGER */\n\n  Engine.TEXTUREFORMAT_RGBA_INTEGER = 11;\n  /** UNSIGNED_BYTE */\n\n  Engine.TEXTURETYPE_UNSIGNED_BYTE = 0;\n  /** UNSIGNED_BYTE (2nd reference) */\n\n  Engine.TEXTURETYPE_UNSIGNED_INT = 0;\n  /** FLOAT */\n\n  Engine.TEXTURETYPE_FLOAT = 1;\n  /** HALF_FLOAT */\n\n  Engine.TEXTURETYPE_HALF_FLOAT = 2;\n  /** BYTE */\n\n  Engine.TEXTURETYPE_BYTE = 3;\n  /** SHORT */\n\n  Engine.TEXTURETYPE_SHORT = 4;\n  /** UNSIGNED_SHORT */\n\n  Engine.TEXTURETYPE_UNSIGNED_SHORT = 5;\n  /** INT */\n\n  Engine.TEXTURETYPE_INT = 6;\n  /** UNSIGNED_INT */\n\n  Engine.TEXTURETYPE_UNSIGNED_INTEGER = 7;\n  /** UNSIGNED_SHORT_4_4_4_4 */\n\n  Engine.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;\n  /** UNSIGNED_SHORT_5_5_5_1 */\n\n  Engine.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;\n  /** UNSIGNED_SHORT_5_6_5 */\n\n  Engine.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;\n  /** UNSIGNED_INT_2_10_10_10_REV */\n\n  Engine.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;\n  /** UNSIGNED_INT_24_8 */\n\n  Engine.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;\n  /** UNSIGNED_INT_10F_11F_11F_REV */\n\n  Engine.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;\n  /** UNSIGNED_INT_5_9_9_9_REV */\n\n  Engine.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;\n  /** FLOAT_32_UNSIGNED_INT_24_8_REV */\n\n  Engine.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;\n  /** nearest is mag = nearest and min = nearest and mip = linear */\n\n  Engine.TEXTURE_NEAREST_SAMPLINGMODE = 1;\n  /** Bilinear is mag = linear and min = linear and mip = nearest */\n\n  Engine.TEXTURE_BILINEAR_SAMPLINGMODE = 2;\n  /** Trilinear is mag = linear and min = linear and mip = linear */\n\n  Engine.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;\n  /** nearest is mag = nearest and min = nearest and mip = linear */\n\n  Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;\n  /** Bilinear is mag = linear and min = linear and mip = nearest */\n\n  Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;\n  /** Trilinear is mag = linear and min = linear and mip = linear */\n\n  Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;\n  /** mag = nearest and min = nearest and mip = nearest */\n\n  Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;\n  /** mag = nearest and min = linear and mip = nearest */\n\n  Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;\n  /** mag = nearest and min = linear and mip = linear */\n\n  Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;\n  /** mag = nearest and min = linear and mip = none */\n\n  Engine.TEXTURE_NEAREST_LINEAR = 7;\n  /** mag = nearest and min = nearest and mip = none */\n\n  Engine.TEXTURE_NEAREST_NEAREST = 1;\n  /** mag = linear and min = nearest and mip = nearest */\n\n  Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;\n  /** mag = linear and min = nearest and mip = linear */\n\n  Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;\n  /** mag = linear and min = linear and mip = none */\n\n  Engine.TEXTURE_LINEAR_LINEAR = 2;\n  /** mag = linear and min = nearest and mip = none */\n\n  Engine.TEXTURE_LINEAR_NEAREST = 12;\n  /** Explicit coordinates mode */\n\n  Engine.TEXTURE_EXPLICIT_MODE = 0;\n  /** Spherical coordinates mode */\n\n  Engine.TEXTURE_SPHERICAL_MODE = 1;\n  /** Planar coordinates mode */\n\n  Engine.TEXTURE_PLANAR_MODE = 2;\n  /** Cubic coordinates mode */\n\n  Engine.TEXTURE_CUBIC_MODE = 3;\n  /** Projection coordinates mode */\n\n  Engine.TEXTURE_PROJECTION_MODE = 4;\n  /** Skybox coordinates mode */\n\n  Engine.TEXTURE_SKYBOX_MODE = 5;\n  /** Inverse Cubic coordinates mode */\n\n  Engine.TEXTURE_INVCUBIC_MODE = 6;\n  /** Equirectangular coordinates mode */\n\n  Engine.TEXTURE_EQUIRECTANGULAR_MODE = 7;\n  /** Equirectangular Fixed coordinates mode */\n\n  Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;\n  /** Equirectangular Fixed Mirrored coordinates mode */\n\n  Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9; // Texture rescaling mode\n\n  /** Defines that texture rescaling will use a floor to find the closer power of 2 size */\n\n  Engine.SCALEMODE_FLOOR = 1;\n  /** Defines that texture rescaling will look for the nearest power of 2 size */\n\n  Engine.SCALEMODE_NEAREST = 2;\n  /** Defines that texture rescaling will use a ceil to find the closer power of 2 size */\n\n  Engine.SCALEMODE_CEILING = 3;\n  /**\r\n   * Method called to create the default rescale post process on each engine.\r\n   */\n\n  Engine._RescalePostProcessFactory = null;\n  return Engine;\n}(ThinEngine);\n\nexport { Engine };","map":null,"metadata":{},"sourceType":"module"}