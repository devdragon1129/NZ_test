{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { TargetCamera } from \"./targetCamera\";\nimport { FlyCameraInputsManager } from \"./flyCameraInputsManager\";\nimport { Tools } from '../Misc/tools';\n/**\r\n * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n * such as in a 3D Space Shooter or a Flight Simulator.\r\n */\n\nvar FlyCamera =\n/** @class */\nfunction (_super) {\n  __extends(FlyCamera, _super);\n  /**\r\n   * Instantiates a FlyCamera.\r\n   * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n   * such as in a 3D Space Shooter or a Flight Simulator.\r\n   * @param name Define the name of the camera in the scene.\r\n   * @param position Define the starting position of the camera in the scene.\r\n   * @param scene Define the scene the camera belongs to.\r\n   * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active, if no other camera has been defined as active.\r\n  */\n\n\n  function FlyCamera(name, position, scene, setActiveOnSceneIfNoneActive) {\n    if (setActiveOnSceneIfNoneActive === void 0) {\n      setActiveOnSceneIfNoneActive = true;\n    }\n\n    var _this = _super.call(this, name, position, scene, setActiveOnSceneIfNoneActive) || this;\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful for simulating a camera body, like a player's body.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n     */\n\n\n    _this.ellipsoid = new Vector3(1, 1, 1);\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful if the camera is attached away from the player's body center,\r\n     * such as at its head.\r\n     */\n\n    _this.ellipsoidOffset = new Vector3(0, 0, 0);\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\n\n    _this.checkCollisions = false;\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\n\n    _this.applyGravity = false;\n    /**\r\n     * Define the current direction the camera is moving to.\r\n     */\n\n    _this.cameraDirection = Vector3.Zero();\n    /**\r\n     * Track Roll to maintain the wanted Rolling when looking around.\r\n     */\n\n    _this._trackRoll = 0;\n    /**\r\n    * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.\r\n    */\n\n    _this.rollCorrect = 100;\n    /**\r\n     * Mimic a banked turn, Rolling the camera when Yawing.\r\n     * It's recommended to use rollCorrect = 10 for faster banking correction.\r\n     */\n\n    _this.bankedTurn = false;\n    /**\r\n     * Limit in radians for how much Roll banking will add. (Default: 90Â°)\r\n     */\n\n    _this.bankedTurnLimit = Math.PI / 2;\n    /**\r\n     * Value of 0 disables the banked Roll.\r\n     * Value of 1 is equal to the Yaw angle in radians.\r\n     */\n\n    _this.bankedTurnMultiplier = 1;\n    _this._needMoveForGravity = false;\n    _this._oldPosition = Vector3.Zero();\n    _this._diffPosition = Vector3.Zero();\n    _this._newPosition = Vector3.Zero(); // Collisions.\n\n    _this._collisionMask = -1;\n    /** @hidden */\n\n    _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n      if (collidedMesh === void 0) {\n        collidedMesh = null;\n      }\n\n      var updatePosition = function updatePosition(newPos) {\n        _this._newPosition.copyFrom(newPos);\n\n        _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition);\n\n        if (_this._diffPosition.length() > Engine.CollisionsEpsilon) {\n          _this.position.addInPlace(_this._diffPosition);\n\n          if (_this.onCollide && collidedMesh) {\n            _this.onCollide(collidedMesh);\n          }\n        }\n      };\n\n      updatePosition(newPosition);\n    };\n\n    _this.inputs = new FlyCameraInputsManager(_this);\n\n    _this.inputs.addKeyboard().addMouse();\n\n    return _this;\n  }\n\n  Object.defineProperty(FlyCamera.prototype, \"angularSensibility\", {\n    /**\r\n     * Gets the input sensibility for mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\n    get: function get() {\n      var mouse = this.inputs.attached[\"mouse\"];\n\n      if (mouse) {\n        return mouse.angularSensibility;\n      }\n\n      return 0;\n    },\n\n    /**\r\n     * Sets the input sensibility for a mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\n    set: function set(value) {\n      var mouse = this.inputs.attached[\"mouse\"];\n\n      if (mouse) {\n        mouse.angularSensibility = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysForward\", {\n    /**\r\n     * Get the keys for camera movement forward.\r\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysForward;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement forward.\r\n    */\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysForward = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysBackward\", {\n    /**\r\n     * Get the keys for camera movement backward.\r\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysBackward;\n      }\n\n      return [];\n    },\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysBackward = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysUp\", {\n    /**\r\n     * Get the keys for camera movement up.\r\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysUp;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement up.\r\n    */\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysUp = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysDown\", {\n    /**\r\n     * Get the keys for camera movement down.\r\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysDown;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement down.\r\n    */\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysDown = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysLeft\", {\n    /**\r\n     * Get the keys for camera movement left.\r\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysLeft;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement left.\r\n    */\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysLeft = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysRight\", {\n    /**\r\n     * Set the keys for camera movement right.\r\n     */\n    get: function get() {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysRight;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement right.\r\n    */\n    set: function set(value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysRight = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Attached controls to the current camera.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n  FlyCamera.prototype.attachControl = function (ignored, noPreventDefault) {\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n  };\n  /**\r\n   * Detach a control from the HTML DOM element.\r\n   * The camera will stop reacting to that input.\r\n   */\n\n\n  FlyCamera.prototype.detachControl = function () {\n    this.inputs.detachElement();\n    this.cameraDirection = new Vector3(0, 0, 0);\n  };\n\n  Object.defineProperty(FlyCamera.prototype, \"collisionMask\", {\n    /**\r\n     * Get the mask that the camera ignores in collision events.\r\n     */\n    get: function get() {\n      return this._collisionMask;\n    },\n\n    /**\r\n    * Set the mask that the camera ignores in collision events.\r\n    */\n    set: function set(mask) {\n      this._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  FlyCamera.prototype._collideWithWorld = function (displacement) {\n    var globalPosition;\n\n    if (this.parent) {\n      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n    } else {\n      globalPosition = this.position;\n    }\n\n    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n\n    this._oldPosition.addInPlace(this.ellipsoidOffset);\n\n    var coordinator = this.getScene().collisionCoordinator;\n\n    if (!this._collider) {\n      this._collider = coordinator.createCollider();\n    }\n\n    this._collider._radius = this.ellipsoid;\n    this._collider.collisionMask = this._collisionMask; // No need for clone, as long as gravity is not on.\n\n    var actualDisplacement = displacement; // Add gravity to direction to prevent dual-collision checking.\n\n    if (this.applyGravity) {\n      // This prevents mending with cameraDirection, a global variable of the fly camera class.\n      actualDisplacement = displacement.add(this.getScene().gravity);\n    }\n\n    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n  };\n  /** @hidden */\n\n\n  FlyCamera.prototype._checkInputs = function () {\n    if (!this._localDirection) {\n      this._localDirection = Vector3.Zero();\n      this._transformedDirection = Vector3.Zero();\n    }\n\n    this.inputs.checkInputs();\n\n    _super.prototype._checkInputs.call(this);\n  };\n  /** @hidden */\n\n\n  FlyCamera.prototype._decideIfNeedsToMove = function () {\n    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  };\n  /** @hidden */\n\n\n  FlyCamera.prototype._updatePosition = function () {\n    if (this.checkCollisions && this.getScene().collisionsEnabled) {\n      this._collideWithWorld(this.cameraDirection);\n    } else {\n      _super.prototype._updatePosition.call(this);\n    }\n  };\n  /**\r\n   * Restore the Roll to its target value at the rate specified.\r\n   * @param rate - Higher means slower restoring.\r\n   * @hidden\r\n   */\n\n\n  FlyCamera.prototype.restoreRoll = function (rate) {\n    var limit = this._trackRoll; // Target Roll.\n\n    var z = this.rotation.z; // Current Roll.\n\n    var delta = limit - z; // Difference in Roll.\n\n    var minRad = 0.001; // Tenth of a radian is a barely noticable difference.\n    // If the difference is noticable, restore the Roll.\n\n    if (Math.abs(delta) >= minRad) {\n      // Change Z rotation towards the target Roll.\n      this.rotation.z += delta / rate; // Match when near enough.\n\n      if (Math.abs(limit - this.rotation.z) <= minRad) {\n        this.rotation.z = limit;\n      }\n    }\n  };\n  /**\r\n   * Destroy the camera and release the current resources held by it.\r\n   */\n\n\n  FlyCamera.prototype.dispose = function () {\n    this.inputs.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Get the current object class name.\r\n   * @returns the class name.\r\n   */\n\n\n  FlyCamera.prototype.getClassName = function () {\n    return \"FlyCamera\";\n  };\n\n  __decorate([serializeAsVector3()], FlyCamera.prototype, \"ellipsoid\", void 0);\n\n  __decorate([serializeAsVector3()], FlyCamera.prototype, \"ellipsoidOffset\", void 0);\n\n  __decorate([serialize()], FlyCamera.prototype, \"checkCollisions\", void 0);\n\n  __decorate([serialize()], FlyCamera.prototype, \"applyGravity\", void 0);\n\n  return FlyCamera;\n}(TargetCamera);\n\nexport { FlyCamera };","map":null,"metadata":{},"sourceType":"module"}