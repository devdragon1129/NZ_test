{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _taggedTemplateLiteral = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar error = {\n  message: function message(_ref) {\n    var schemaCode = _ref.schemaCode;\n    return codegen_1.str(_templateObject || (_templateObject = _taggedTemplateLiteral([\"should match format \\\"\", \"\\\"\"])), schemaCode);\n  },\n  params: function params(_ref2) {\n    var schemaCode = _ref2.schemaCode;\n    return codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{format: \", \"}\"])), schemaCode);\n  }\n};\nvar def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error: error,\n  code: function code(cxt, ruleType) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        $data = cxt.$data,\n        schema = cxt.schema,\n        schemaCode = cxt.schemaCode,\n        it = cxt.it;\n    var opts = it.opts,\n        errSchemaPath = it.errSchemaPath,\n        schemaEnv = it.schemaEnv,\n        self = it.self;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      var fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      var fDef = gen.const(\"fDef\", codegen_1._(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), fmts, schemaCode));\n      var fType = gen.let(\"fType\");\n      var format = gen.let(\"format\"); // TODO simplify\n\n      gen.if(codegen_1._(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"typeof \", \" == \\\"object\\\" && !(\", \" instanceof RegExp)\"])), fDef, fDef), function () {\n        return gen.assign(fType, codegen_1._(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".type || \\\"string\\\"\"])), fDef)).assign(format, codegen_1._(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \".validate\"])), fDef));\n      }, function () {\n        return gen.assign(fType, codegen_1._(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\\\"string\\\"\"])))).assign(format, fDef);\n      });\n      cxt.fail$data(codegen_1.or(unknownFmt(), invalidFmt()));\n\n      function unknownFmt() {\n        if (opts.strict === false) return codegen_1.nil;\n        return codegen_1._(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" && !\", \"\"])), schemaCode, format);\n      }\n\n      function invalidFmt() {\n        var callFormat = schemaEnv.$async ? codegen_1._(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"(\", \".async ? await \", \"(\", \") : \", \"(\", \"))\"])), fDef, format, data, format, data) : codegen_1._(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), format, data);\n\n        var validData = codegen_1._(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"(typeof \", \" == \\\"function\\\" ? \", \" : \", \".test(\", \"))\"])), format, callFormat, format, data);\n\n        return codegen_1._(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" && \", \" !== true && \", \" === \", \" && !\", \"\"])), format, format, fType, ruleType, validData);\n      }\n    }\n\n    function validateFormat() {\n      var formatDef = self.formats[schema];\n\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n\n      if (formatDef === true) return;\n\n      var _getFormat = getFormat(formatDef),\n          _getFormat2 = _slicedToArray(_getFormat, 3),\n          fmtType = _getFormat2[0],\n          format = _getFormat2[1],\n          fmtRef = _getFormat2[2];\n\n      if (fmtType === ruleType) cxt.pass(validCondition());\n\n      function unknownFormat() {\n        if (opts.strict === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n\n        throw new Error(unknownMsg());\n\n        function unknownMsg() {\n          return \"unknown format \\\"\".concat(schema, \"\\\" ignored in schema at path \\\"\").concat(errSchemaPath, \"\\\"\");\n        }\n      }\n\n      function getFormat(fmtDef) {\n        var fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code: opts.code.formats ? codegen_1._(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \"\", \"\"])), opts.code.formats, codegen_1.getProperty(schema)) : undefined\n        });\n\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, codegen_1._(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \".validate\"])), fmt)];\n        }\n\n        return [\"string\", fmtDef, fmt];\n      }\n\n      function validCondition() {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return codegen_1._(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"await \", \"(\", \")\"])), fmtRef, data);\n        }\n\n        return typeof format == \"function\" ? codegen_1._(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), fmtRef, data) : codegen_1._(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), fmtRef, data);\n      }\n    }\n  }\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}