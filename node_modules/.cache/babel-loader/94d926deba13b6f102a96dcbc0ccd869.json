{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../../../Misc/decorators\";\nimport { Observable } from \"../../../Misc/observable\";\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\nimport { Material } from \"../../../Materials/material\";\nimport { Texture } from \"../../../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\nimport \"../../../Engines/Extensions/engine.renderTarget\";\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\nimport \"../../../Shaders/procedural.vertex\";\nimport { _TypeStore } from '../../../Misc/typeStore';\nimport { EngineStore } from '../../../Engines/engineStore';\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n */\n\nvar ProceduralTexture =\n/** @class */\nfunction (_super) {\n  __extends(ProceduralTexture, _super);\n  /**\r\n   * Instantiates a new procedural texture.\r\n   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n   * This is the base class of any Procedural texture and contains most of the shareable code.\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n   * @param name  Define the name of the texture\r\n   * @param size Define the size of the texture to create\r\n   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\r\n   * @param scene Define the scene the texture belongs to\r\n   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n   * @param generateMipMaps Define if the texture should creates mip maps or not\r\n   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n   * @param textureType The FBO internal texture type\r\n   */\n\n\n  function ProceduralTexture(name, size, fragment, scene, fallbackTexture, generateMipMaps, isCube, textureType) {\n    if (fallbackTexture === void 0) {\n      fallbackTexture = null;\n    }\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (isCube === void 0) {\n      isCube = false;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps) || this;\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\n\n\n    _this.isEnabled = true;\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\n\n    _this.autoClear = true;\n    /**\r\n     * Event raised when the texture is generated\r\n     */\n\n    _this.onGeneratedObservable = new Observable();\n    /**\r\n     * Event raised before the texture is generated\r\n     */\n\n    _this.onBeforeGenerationObservable = new Observable();\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\n\n    _this.nodeMaterialSource = null;\n    /** @hidden */\n\n    _this._textures = {};\n    _this._currentRefreshId = -1;\n    _this._frameId = -1;\n    _this._refreshRate = 1;\n    _this._vertexBuffers = {};\n    _this._uniforms = new Array();\n    _this._samplers = new Array();\n    _this._floats = {};\n    _this._ints = {};\n    _this._floatsArrays = {};\n    _this._colors3 = {};\n    _this._colors4 = {};\n    _this._vectors2 = {};\n    _this._vectors3 = {};\n    _this._matrices = {};\n    _this._fallbackTextureUsed = false;\n    _this._cachedDefines = \"\";\n    _this._contentUpdateId = -1;\n    scene = _this.getScene() || EngineStore.LastCreatedScene;\n\n    var component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n\n    if (!component) {\n      component = new ProceduralTextureSceneComponent(scene);\n\n      scene._addComponent(component);\n    }\n\n    scene.proceduralTextures.push(_this);\n    _this._fullEngine = scene.getEngine();\n    _this.name = name;\n    _this.isRenderTarget = true;\n    _this._size = size;\n    _this._generateMipMaps = generateMipMaps;\n\n    _this.setFragment(fragment);\n\n    _this._fallbackTexture = fallbackTexture;\n\n    if (isCube) {\n      _this._texture = _this._fullEngine.createRenderTargetCubeTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n\n      _this.setFloat(\"face\", 0);\n    } else {\n      _this._texture = _this._fullEngine.createRenderTargetTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n    } // VBO\n\n\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    _this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(_this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\n\n    _this._createIndexBuffer();\n\n    return _this;\n  }\n  /**\r\n   * The effect that is created when initializing the post process.\r\n   * @returns The created effect corresponding the the postprocess.\r\n   */\n\n\n  ProceduralTexture.prototype.getEffect = function () {\n    return this._effect;\n  };\n  /**\r\n   * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n   * @returns an ArrayBufferView (Uint8Array or Float32Array)\r\n   */\n\n\n  ProceduralTexture.prototype.getContent = function () {\n    if (this._contentData && this._frameId === this._contentUpdateId) {\n      return this._contentData;\n    }\n\n    this._contentData = this.readPixels(0, 0, this._contentData);\n    this._contentUpdateId = this._frameId;\n    return this._contentData;\n  };\n\n  ProceduralTexture.prototype._createIndexBuffer = function () {\n    var engine = this._fullEngine; // Indices\n\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  };\n  /** @hidden */\n\n\n  ProceduralTexture.prototype._rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._createIndexBuffer();\n\n    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    }\n  };\n  /**\r\n   * Resets the texture in order to recreate its associated resources.\r\n   * This can be called in case of context loss\r\n   */\n\n\n  ProceduralTexture.prototype.reset = function () {\n    if (this._effect === undefined) {\n      return;\n    }\n\n    this._effect.dispose();\n  };\n\n  ProceduralTexture.prototype._getDefines = function () {\n    return \"\";\n  };\n  /**\r\n   * Is the texture ready to be used ? (rendered at least once)\r\n   * @returns true if ready, otherwise, false.\r\n   */\n\n\n  ProceduralTexture.prototype.isReady = function () {\n    var _this = this;\n\n    var engine = this._fullEngine;\n    var shaders;\n\n    if (this.nodeMaterialSource) {\n      return this._effect.isReady();\n    }\n\n    if (!this._fragment) {\n      return false;\n    }\n\n    if (this._fallbackTextureUsed) {\n      return true;\n    }\n\n    var defines = this._getDefines();\n\n    if (this._effect && defines === this._cachedDefines && this._effect.isReady()) {\n      return true;\n    }\n\n    if (this._fragment.fragmentElement !== undefined) {\n      shaders = {\n        vertex: \"procedural\",\n        fragmentElement: this._fragment.fragmentElement\n      };\n    } else {\n      shaders = {\n        vertex: \"procedural\",\n        fragment: this._fragment\n      };\n    }\n\n    this._cachedDefines = defines;\n    this._effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, function () {\n      _this.releaseInternalTexture();\n\n      if (_this._fallbackTexture) {\n        _this._texture = _this._fallbackTexture._texture;\n\n        if (_this._texture) {\n          _this._texture.incrementReferences();\n        }\n      }\n\n      _this._fallbackTextureUsed = true;\n    });\n    return this._effect.isReady();\n  };\n  /**\r\n   * Resets the refresh counter of the texture and start bak from scratch.\r\n   * Could be useful to regenerate the texture if it is setup to render only once.\r\n   */\n\n\n  ProceduralTexture.prototype.resetRefreshCounter = function () {\n    this._currentRefreshId = -1;\n  };\n  /**\r\n   * Set the fragment shader to use in order to render the texture.\r\n   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n   */\n\n\n  ProceduralTexture.prototype.setFragment = function (fragment) {\n    this._fragment = fragment;\n  };\n\n  Object.defineProperty(ProceduralTexture.prototype, \"refreshRate\", {\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\n    get: function get() {\n      return this._refreshRate;\n    },\n    set: function set(value) {\n      this._refreshRate = value;\n      this.resetRefreshCounter();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  ProceduralTexture.prototype._shouldRender = function () {\n    if (!this.isEnabled || !this.isReady() || !this._texture) {\n      if (this._texture) {\n        this._texture.isReady = false;\n      }\n\n      return false;\n    }\n\n    if (this._fallbackTextureUsed) {\n      return false;\n    }\n\n    if (this._currentRefreshId === -1) {\n      // At least render once\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n\n    if (this.refreshRate === this._currentRefreshId) {\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n\n    this._currentRefreshId++;\n    return false;\n  };\n  /**\r\n   * Get the size the texture is rendering at.\r\n   * @returns the size (on cube texture it is always squared)\r\n   */\n\n\n  ProceduralTexture.prototype.getRenderSize = function () {\n    return this._size;\n  };\n  /**\r\n   * Resize the texture to new value.\r\n   * @param size Define the new size the texture should have\r\n   * @param generateMipMaps Define whether the new texture should create mip maps\r\n   */\n\n\n  ProceduralTexture.prototype.resize = function (size, generateMipMaps) {\n    if (this._fallbackTextureUsed) {\n      return;\n    }\n\n    this.releaseInternalTexture();\n    this._texture = this._fullEngine.createRenderTargetTexture(size, generateMipMaps); // Update properties\n\n    this._size = size;\n    this._generateMipMaps = generateMipMaps;\n  };\n\n  ProceduralTexture.prototype._checkUniform = function (uniformName) {\n    if (this._uniforms.indexOf(uniformName) === -1) {\n      this._uniforms.push(uniformName);\n    }\n  };\n  /**\r\n   * Set a texture in the shader program used to render.\r\n   * @param name Define the name of the uniform samplers as defined in the shader\r\n   * @param texture Define the texture to bind to this sampler\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setTexture = function (name, texture) {\n    if (this._samplers.indexOf(name) === -1) {\n      this._samplers.push(name);\n    }\n\n    this._textures[name] = texture;\n    return this;\n  };\n  /**\r\n   * Set a float in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setFloat = function (name, value) {\n    this._checkUniform(name);\n\n    this._floats[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a int in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setInt = function (name, value) {\n    this._checkUniform(name);\n\n    this._ints[name] = value;\n    return this;\n  };\n  /**\r\n   * Set an array of floats in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setFloats = function (name, value) {\n    this._checkUniform(name);\n\n    this._floatsArrays[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 in the shader from a Color3.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setColor3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec4 in the shader from a Color4.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setColor4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors4[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec2 in the shader from a Vector2.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setVector2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors2[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 in the shader from a Vector3.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setVector3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a mat4 in the shader from a MAtrix.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setMatrix = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices[name] = value;\n    return this;\n  };\n  /**\r\n   * Render the texture to its associated render target.\r\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n   */\n\n\n  ProceduralTexture.prototype.render = function (useCameraPostProcess) {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = this._fullEngine; // Render\n\n    engine.enableEffect(this._effect);\n    this.onBeforeGenerationObservable.notifyObservers(this);\n    engine.setState(false);\n\n    if (!this.nodeMaterialSource) {\n      // Texture\n      for (var name in this._textures) {\n        this._effect.setTexture(name, this._textures[name]);\n      } // Float\n\n\n      for (name in this._ints) {\n        this._effect.setInt(name, this._ints[name]);\n      } // Float\n\n\n      for (name in this._floats) {\n        this._effect.setFloat(name, this._floats[name]);\n      } // Floats\n\n\n      for (name in this._floatsArrays) {\n        this._effect.setArray(name, this._floatsArrays[name]);\n      } // Color3\n\n\n      for (name in this._colors3) {\n        this._effect.setColor3(name, this._colors3[name]);\n      } // Color4\n\n\n      for (name in this._colors4) {\n        var color = this._colors4[name];\n\n        this._effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      } // Vector2\n\n\n      for (name in this._vectors2) {\n        this._effect.setVector2(name, this._vectors2[name]);\n      } // Vector3\n\n\n      for (name in this._vectors3) {\n        this._effect.setVector3(name, this._vectors3[name]);\n      } // Matrix\n\n\n      for (name in this._matrices) {\n        this._effect.setMatrix(name, this._matrices[name]);\n      }\n    }\n\n    if (!this._texture) {\n      return;\n    }\n\n    if (this.isCube) {\n      for (var face = 0; face < 6; face++) {\n        engine.bindFramebuffer(this._texture, face, undefined, undefined, true); // VBOs\n\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\n\n        this._effect.setFloat(\"face\", face); // Clear\n\n\n        if (this.autoClear) {\n          engine.clear(scene.clearColor, true, false, false);\n        } // Draw order\n\n\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6); // Mipmaps\n\n        if (face === 5) {\n          engine.generateMipMapsForCubemap(this._texture);\n        }\n      }\n    } else {\n      engine.bindFramebuffer(this._texture, 0, undefined, undefined, true); // VBOs\n\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect); // Clear\n\n      if (this.autoClear) {\n        engine.clear(scene.clearColor, true, false, false);\n      } // Draw order\n\n\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    } // Unbind\n\n\n    engine.unBindFramebuffer(this._texture, this.isCube);\n\n    if (this.onGenerated) {\n      this.onGenerated();\n    }\n\n    this.onGeneratedObservable.notifyObservers(this);\n  };\n  /**\r\n   * Clone the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  ProceduralTexture.prototype.clone = function () {\n    var textureSize = this.getSize();\n    var newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // RenderTarget Texture\n\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  };\n  /**\r\n   * Dispose the texture and release its asoociated resources.\r\n   */\n\n\n  ProceduralTexture.prototype.dispose = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var index = scene.proceduralTextures.indexOf(this);\n\n    if (index >= 0) {\n      scene.proceduralTextures.splice(index, 1);\n    }\n\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\n      this._indexBuffer = null;\n    }\n\n    this.onGeneratedObservable.clear();\n    this.onBeforeGenerationObservable.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"isEnabled\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"autoClear\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"_generateMipMaps\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"_size\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"refreshRate\", null);\n\n  return ProceduralTexture;\n}(Texture);\n\nexport { ProceduralTexture };\n_TypeStore.RegisteredTypes[\"BABYLON.ProceduralTexture\"] = ProceduralTexture;","map":null,"metadata":{},"sourceType":"module"}