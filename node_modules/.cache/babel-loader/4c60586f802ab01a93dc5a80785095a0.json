{"ast":null,"code":"import { Matrix } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport { Color4 } from '../Maths/math.color';\nimport { StandardMaterial } from '../Materials/standardMaterial';\nimport { PBRMaterial } from '../Materials/PBR/pbrMaterial';\nimport { _DevTools } from '../Misc/devTools';\nimport { Material } from '../Materials/material';\nimport \"../Shaders/geometry.fragment\";\nimport \"../Shaders/geometry.vertex\";\n/**\r\n * This renderer is helpfull to fill one of the render target with a geometry buffer.\r\n */\n\nvar GeometryBufferRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new G Buffer for the scene\r\n   * @param scene The scene the buffer belongs to\r\n   * @param ratio How big is the buffer related to the main canvas.\r\n   */\n  function GeometryBufferRenderer(scene, ratio) {\n    if (ratio === void 0) {\n      ratio = 1;\n    }\n    /**\r\n     * Dictionary used to store the previous transformation matrices of each rendered mesh\r\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\r\n     * @hidden\r\n     */\n\n\n    this._previousTransformationMatrices = {};\n    /**\r\n     * Dictionary used to store the previous bones transformation matrices of each rendered mesh\r\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\r\n     * @hidden\r\n     */\n\n    this._previousBonesTransformationMatrices = {};\n    /**\r\n     * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).\r\n     * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).\r\n     */\n\n    this.excludedSkinnedMeshesFromVelocity = [];\n    /** Gets or sets a boolean indicating if transparent meshes should be rendered */\n\n    this.renderTransparentMeshes = true;\n    this._resizeObserver = null;\n    this._enablePosition = false;\n    this._enableVelocity = false;\n    this._enableReflectivity = false;\n    this._positionIndex = -1;\n    this._velocityIndex = -1;\n    this._reflectivityIndex = -1;\n    this._depthNormalIndex = -1;\n    this._linkedWithPrePass = false;\n    this._scene = scene;\n    this._ratio = ratio;\n\n    GeometryBufferRenderer._SceneComponentInitialization(this._scene); // Render target\n\n\n    this._createRenderTargets();\n  }\n  /**\r\n   * @hidden\r\n   * Sets up internal structures to share outputs with PrePassRenderer\r\n   * This method should only be called by the PrePassRenderer itself\r\n   */\n\n\n  GeometryBufferRenderer.prototype._linkPrePassRenderer = function (prePassRenderer) {\n    this._linkedWithPrePass = true;\n    this._prePassRenderer = prePassRenderer;\n\n    if (this._multiRenderTarget) {\n      // prevents clearing of the RT since it's done by prepass\n      this._multiRenderTarget.onClearObservable.clear();\n\n      this._multiRenderTarget.onClearObservable.add(function (engine) {// pass\n      });\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.\r\n   * This method should only be called by the PrePassRenderer itself\r\n   */\n\n\n  GeometryBufferRenderer.prototype._unlinkPrePassRenderer = function () {\n    this._linkedWithPrePass = false;\n\n    this._createRenderTargets();\n  };\n  /**\r\n   * @hidden\r\n   * Resets the geometry buffer layout\r\n   */\n\n\n  GeometryBufferRenderer.prototype._resetLayout = function () {\n    this._enablePosition = false;\n    this._enableReflectivity = false;\n    this._enableVelocity = false;\n    this._attachments = [];\n  };\n  /**\r\n   * @hidden\r\n   * Replaces a texture in the geometry buffer renderer\r\n   * Useful when linking textures of the prepass renderer\r\n   */\n\n\n  GeometryBufferRenderer.prototype._forceTextureType = function (geometryBufferType, index) {\n    if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {\n      this._positionIndex = index;\n      this._enablePosition = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {\n      this._velocityIndex = index;\n      this._enableVelocity = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {\n      this._reflectivityIndex = index;\n      this._enableReflectivity = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE) {\n      this._depthNormalIndex = index;\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Sets texture attachments\r\n   * Useful when linking textures of the prepass renderer\r\n   */\n\n\n  GeometryBufferRenderer.prototype._setAttachments = function (attachments) {\n    this._attachments = attachments;\n  };\n  /**\r\n   * @hidden\r\n   * Replaces the first texture which is hard coded as a depth texture in the geometry buffer\r\n   * Useful when linking textures of the prepass renderer\r\n   */\n\n\n  GeometryBufferRenderer.prototype._linkInternalTexture = function (internalTexture) {\n    this._multiRenderTarget._texture = internalTexture;\n  };\n\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"renderList\", {\n    /**\r\n     * Gets the render list (meshes to be rendered) used in the G buffer.\r\n     */\n    get: function get() {\n      return this._multiRenderTarget.renderList;\n    },\n\n    /**\r\n     * Set the render list (meshes to be rendered) used in the G buffer.\r\n     */\n    set: function set(meshes) {\n      this._multiRenderTarget.renderList = meshes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"isSupported\", {\n    /**\r\n     * Gets wether or not G buffer are supported by the running hardware.\r\n     * This requires draw buffer supports\r\n     */\n    get: function get() {\n      return this._multiRenderTarget.isSupported;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the index of the given texture type in the G-Buffer textures array\r\n   * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX\r\n   * @returns the index of the given texture type in the G-Buffer textures array\r\n   */\n\n  GeometryBufferRenderer.prototype.getTextureIndex = function (textureType) {\n    switch (textureType) {\n      case GeometryBufferRenderer.POSITION_TEXTURE_TYPE:\n        return this._positionIndex;\n\n      case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:\n        return this._velocityIndex;\n\n      case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:\n        return this._reflectivityIndex;\n\n      default:\n        return -1;\n    }\n  };\n\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"enablePosition\", {\n    /**\r\n     * Gets a boolean indicating if objects positions are enabled for the G buffer.\r\n     */\n    get: function get() {\n      return this._enablePosition;\n    },\n\n    /**\r\n     * Sets whether or not objects positions are enabled for the G buffer.\r\n     */\n    set: function set(enable) {\n      this._enablePosition = enable; // PrePass handles index and texture links\n\n      if (!this._linkedWithPrePass) {\n        this.dispose();\n\n        this._createRenderTargets();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"enableVelocity\", {\n    /**\r\n     * Gets a boolean indicating if objects velocities are enabled for the G buffer.\r\n     */\n    get: function get() {\n      return this._enableVelocity;\n    },\n\n    /**\r\n     * Sets wether or not objects velocities are enabled for the G buffer.\r\n     */\n    set: function set(enable) {\n      this._enableVelocity = enable;\n\n      if (!enable) {\n        this._previousTransformationMatrices = {};\n      }\n\n      if (!this._linkedWithPrePass) {\n        this.dispose();\n\n        this._createRenderTargets();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"enableReflectivity\", {\n    /**\r\n     * Gets a boolean indicating if objects roughness are enabled in the G buffer.\r\n     */\n    get: function get() {\n      return this._enableReflectivity;\n    },\n\n    /**\r\n     * Sets wether or not objects roughness are enabled for the G buffer.\r\n     */\n    set: function set(enable) {\n      this._enableReflectivity = enable;\n\n      if (!this._linkedWithPrePass) {\n        this.dispose();\n\n        this._createRenderTargets();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"scene\", {\n    /**\r\n     * Gets the scene associated with the buffer.\r\n     */\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"ratio\", {\n    /**\r\n     * Gets the ratio used by the buffer during its creation.\r\n     * How big is the buffer related to the main canvas.\r\n     */\n    get: function get() {\n      return this._ratio;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Checks wether everything is ready to render a submesh to the G buffer.\r\n   * @param subMesh the submesh to check readiness for\r\n   * @param useInstances is the mesh drawn using instance or not\r\n   * @returns true if ready otherwise false\r\n   */\n\n  GeometryBufferRenderer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n\n    if (material && material.disableDepthWrite) {\n      return false;\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n    var mesh = subMesh.getMesh(); // Alpha test\n\n    if (material) {\n      var needUv = false;\n\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n        needUv = true;\n      }\n\n      if (material.bumpTexture && StandardMaterial.BumpTextureEnabled) {\n        defines.push(\"#define BUMP\");\n        defines.push(\"#define BUMPDIRECTUV 0\");\n        needUv = true;\n      }\n\n      if (this._enableReflectivity) {\n        if (material instanceof StandardMaterial && material.specularTexture) {\n          defines.push(\"#define HAS_SPECULAR\");\n          needUv = true;\n        } else if (material instanceof PBRMaterial && material.reflectivityTexture) {\n          defines.push(\"#define HAS_REFLECTIVITY\");\n          needUv = true;\n        }\n      }\n\n      if (needUv) {\n        defines.push(\"#define NEED_UV\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          attribs.push(VertexBuffer.UVKind);\n          defines.push(\"#define UV1\");\n        }\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n          attribs.push(VertexBuffer.UV2Kind);\n          defines.push(\"#define UV2\");\n        }\n      }\n    } // PrePass\n\n\n    if (this._linkedWithPrePass) {\n      defines.push(\"#define PREPASS\");\n\n      if (this._depthNormalIndex !== -1) {\n        defines.push(\"#define DEPTHNORMAL_INDEX \" + this._depthNormalIndex);\n        defines.push(\"#define PREPASS_DEPTHNORMAL\");\n      }\n    } // Buffers\n\n\n    if (this._enablePosition) {\n      defines.push(\"#define POSITION\");\n      defines.push(\"#define POSITION_INDEX \" + this._positionIndex);\n    }\n\n    if (this._enableVelocity) {\n      defines.push(\"#define VELOCITY\");\n      defines.push(\"#define VELOCITY_INDEX \" + this._velocityIndex);\n\n      if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\n        defines.push(\"#define BONES_VELOCITY_ENABLED\");\n      }\n    }\n\n    if (this._enableReflectivity) {\n      defines.push(\"#define REFLECTIVITY\");\n      defines.push(\"#define REFLECTIVITY_INDEX \" + this._reflectivityIndex);\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var morphTargetManager = mesh.morphTargetManager;\n    var numMorphInfluencers = 0;\n\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Setup textures count\n\n\n    if (this._linkedWithPrePass) {\n      defines.push(\"#define RENDER_TARGET_COUNT \" + this._attachments.length);\n    } else {\n      defines.push(\"#define RENDER_TARGET_COUNT \" + this._multiRenderTarget.textures.length);\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effect = this._scene.getEngine().createEffect(\"geometry\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"view\", \"previousWorld\", \"previousViewProjection\", \"mPreviousBones\", \"morphTargetInfluences\", \"bumpMatrix\", \"reflectivityMatrix\", \"vTangentSpaceParams\", \"vBumpInfos\"], [\"diffuseSampler\", \"bumpSampler\", \"reflectivitySampler\"], join, undefined, undefined, undefined, {\n        buffersCount: this._multiRenderTarget.textures.length - 1,\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      });\n    }\n\n    return this._effect.isReady();\n  };\n  /**\r\n   * Gets the current underlying G Buffer.\r\n   * @returns the buffer\r\n   */\n\n\n  GeometryBufferRenderer.prototype.getGBuffer = function () {\n    return this._multiRenderTarget;\n  };\n\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"samples\", {\n    /**\r\n     * Gets the number of samples used to render the buffer (anti aliasing).\r\n     */\n    get: function get() {\n      return this._multiRenderTarget.samples;\n    },\n\n    /**\r\n     * Sets the number of samples used to render the buffer (anti aliasing).\r\n     */\n    set: function set(value) {\n      this._multiRenderTarget.samples = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes the renderer and frees up associated resources.\r\n   */\n\n  GeometryBufferRenderer.prototype.dispose = function () {\n    if (this._resizeObserver) {\n      var engine = this._scene.getEngine();\n\n      engine.onResizeObservable.remove(this._resizeObserver);\n      this._resizeObserver = null;\n    }\n\n    this.getGBuffer().dispose();\n  };\n\n  GeometryBufferRenderer.prototype._assignRenderTargetIndices = function () {\n    var count = 2;\n\n    if (this._enablePosition) {\n      this._positionIndex = count;\n      count++;\n    }\n\n    if (this._enableVelocity) {\n      this._velocityIndex = count;\n      count++;\n    }\n\n    if (this._enableReflectivity) {\n      this._reflectivityIndex = count;\n      count++;\n    }\n\n    return count;\n  };\n\n  GeometryBufferRenderer.prototype._createRenderTargets = function () {\n    var _this = this;\n\n    var engine = this._scene.getEngine();\n\n    var count = this._assignRenderTargetIndices();\n\n    this._multiRenderTarget = new MultiRenderTarget(\"gBuffer\", {\n      width: engine.getRenderWidth() * this._ratio,\n      height: engine.getRenderHeight() * this._ratio\n    }, count, this._scene, {\n      generateMipMaps: false,\n      generateDepthTexture: true,\n      defaultType: 1\n    });\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._multiRenderTarget.refreshRate = 1;\n    this._multiRenderTarget.renderParticles = false;\n    this._multiRenderTarget.renderList = null; // set default depth value to 1.0 (far away)\n\n    this._multiRenderTarget.onClearObservable.add(function (engine) {\n      engine.clear(new Color4(0.0, 0.0, 0.0, 1.0), true, true, true);\n    });\n\n    this._resizeObserver = engine.onResizeObservable.add(function () {\n      if (_this._multiRenderTarget) {\n        _this._multiRenderTarget.resize({\n          width: engine.getRenderWidth() * _this._ratio,\n          height: engine.getRenderHeight() * _this._ratio\n        });\n      }\n    }); // Custom render function\n\n    var renderSubMesh = function renderSubMesh(subMesh) {\n      var renderingMesh = subMesh.getRenderingMesh();\n      var effectiveMesh = subMesh.getEffectiveMesh();\n      var scene = _this._scene;\n      var engine = scene.getEngine();\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        return;\n      }\n\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false; // Velocity\n\n      if (_this._enableVelocity && !_this._previousTransformationMatrices[effectiveMesh.uniqueId]) {\n        _this._previousTransformationMatrices[effectiveMesh.uniqueId] = {\n          world: Matrix.Identity(),\n          viewProjection: scene.getTransformMatrix()\n        };\n\n        if (renderingMesh.skeleton) {\n          var bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);\n          _this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = _this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));\n        }\n      } // Managing instances\n\n\n      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n      if (batch.mustReturn) {\n        return;\n      }\n\n      var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n      var world = effectiveMesh.getWorldMatrix();\n\n      if (_this.isReady(subMesh, hardwareInstancedRendering)) {\n        engine.enableEffect(_this._effect);\n\n        renderingMesh._bind(subMesh, _this._effect, material.fillMode);\n\n        _this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n        _this._effect.setMatrix(\"view\", scene.getViewMatrix());\n\n        if (material) {\n          var sideOrientation;\n          var instanceDataStorage = effectiveMesh._instanceDataStorage;\n\n          if (!instanceDataStorage.isFrozen && (material.backFaceCulling || material.overrideMaterialSideOrientation !== null)) {\n            var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n\n            sideOrientation = material.overrideMaterialSideOrientation;\n\n            if (sideOrientation == null) {\n              sideOrientation = material.sideOrientation;\n            }\n\n            if (mainDeterminant < 0) {\n              sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n            }\n          } else {\n            sideOrientation = instanceDataStorage.sideOrientation;\n          }\n\n          material._preBind(_this._effect, sideOrientation); // Alpha test\n\n\n          if (material.needAlphaTesting()) {\n            var alphaTexture = material.getAlphaTestTexture();\n\n            if (alphaTexture) {\n              _this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n\n              _this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          } // Bump\n\n\n          if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\n            _this._effect.setFloat3(\"vBumpInfos\", material.bumpTexture.coordinatesIndex, 1.0 / material.bumpTexture.level, material.parallaxScaleBias);\n\n            _this._effect.setMatrix(\"bumpMatrix\", material.bumpTexture.getTextureMatrix());\n\n            _this._effect.setTexture(\"bumpSampler\", material.bumpTexture);\n\n            _this._effect.setFloat2(\"vTangentSpaceParams\", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);\n          } // Roughness\n\n\n          if (_this._enableReflectivity) {\n            if (material instanceof StandardMaterial && material.specularTexture) {\n              _this._effect.setMatrix(\"reflectivityMatrix\", material.specularTexture.getTextureMatrix());\n\n              _this._effect.setTexture(\"reflectivitySampler\", material.specularTexture);\n            } else if (material instanceof PBRMaterial && material.reflectivityTexture) {\n              _this._effect.setMatrix(\"reflectivityMatrix\", material.reflectivityTexture.getTextureMatrix());\n\n              _this._effect.setTexture(\"reflectivitySampler\", material.reflectivityTexture);\n            }\n          }\n        } // Bones\n\n\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          _this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n\n          if (_this._enableVelocity) {\n            _this._effect.setMatrices(\"mPreviousBones\", _this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);\n          }\n        } // Morph targets\n\n\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, _this._effect); // Velocity\n\n        if (_this._enableVelocity) {\n          _this._effect.setMatrix(\"previousWorld\", _this._previousTransformationMatrices[effectiveMesh.uniqueId].world);\n\n          _this._effect.setMatrix(\"previousViewProjection\", _this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);\n        } // Draw\n\n\n        renderingMesh._processRendering(effectiveMesh, subMesh, _this._effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, w) {\n          return _this._effect.setMatrix(\"world\", w);\n        });\n      } // Velocity\n\n\n      if (_this._enableVelocity) {\n        _this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();\n        _this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = _this._scene.getTransformMatrix().clone();\n\n        if (renderingMesh.skeleton) {\n          _this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), _this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);\n        }\n      }\n    };\n\n    this._multiRenderTarget.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      var index;\n\n      if (_this._linkedWithPrePass) {\n        if (!_this._prePassRenderer.enabled) {\n          return;\n        }\n\n        _this._scene.getEngine().bindAttachments(_this._attachments);\n      }\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      if (_this.renderTransparentMeshes) {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          renderSubMesh(transparentSubMeshes.data[index]);\n        }\n      }\n    };\n  }; // Copies the bones transformation matrices into the target array and returns the target's reference\n\n\n  GeometryBufferRenderer.prototype._copyBonesTransformationMatrices = function (source, target) {\n    for (var i = 0; i < source.length; i++) {\n      target[i] = source[i];\n    }\n\n    return target;\n  };\n  /**\r\n   * Constant used to retrieve the depth + normal texture index in the G-Buffer textures array\r\n   * using getIndex(GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_INDEX)\r\n   */\n\n\n  GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE = 0;\n  /**\r\n   * Constant used to retrieve the position texture index in the G-Buffer textures array\r\n   * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)\r\n   */\n\n  GeometryBufferRenderer.POSITION_TEXTURE_TYPE = 1;\n  /**\r\n   * Constant used to retrieve the velocity texture index in the G-Buffer textures array\r\n   * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)\r\n   */\n\n  GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 2;\n  /**\r\n   * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array\r\n   * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)\r\n   */\n\n  GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 3;\n  /** @hidden */\n\n  GeometryBufferRenderer._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"GeometryBufferRendererSceneComponent\");\n  };\n\n  return GeometryBufferRenderer;\n}();\n\nexport { GeometryBufferRenderer };","map":null,"metadata":{},"sourceType":"module"}