{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar types_1 = require(\"../discriminator/types\");\n\nvar compile_1 = require(\"../../compile\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: function message(_ref) {\n    var _ref$params = _ref.params,\n        discrError = _ref$params.discrError,\n        tagName = _ref$params.tagName;\n    return discrError === types_1.DiscrError.Tag ? \"tag \\\"\".concat(tagName, \"\\\" must be string\") : \"value of tag \\\"\".concat(tagName, \"\\\" must be in oneOf\");\n  },\n  params: function params(_ref2) {\n    var _ref2$params = _ref2.params,\n        discrError = _ref2$params.discrError,\n        tag = _ref2$params.tag,\n        tagName = _ref2$params.tagName;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{error: \", \", tag: \", \", tagValue: \", \"}\"])), discrError, tagName, tag);\n  }\n};\nvar def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        schema = cxt.schema,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    var oneOf = parentSchema.oneOf;\n\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n\n    var tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    var valid = gen.let(\"valid\", false);\n    var tag = gen.const(\"tag\", (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\", \"\"])), data, (0, codegen_1.getProperty)(tagName)));\n    gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"typeof \", \" == \\\"string\\\"\"])), tag), function () {\n      return validateMapping();\n    }, function () {\n      return cxt.error(false, {\n        discrError: types_1.DiscrError.Tag,\n        tag: tag,\n        tagName: tagName\n      });\n    });\n    cxt.ok(valid);\n\n    function validateMapping() {\n      var mapping = getMapping();\n      gen.if(false);\n\n      for (var tagValue in mapping) {\n        gen.elseIf((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), tag, tagValue));\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag: tag,\n        tagName: tagName\n      });\n      gen.endIf();\n    }\n\n    function applyTagSchema(schemaProp) {\n      var _valid = gen.name(\"valid\");\n\n      var schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp: schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n\n    function getMapping() {\n      var _a;\n\n      var oneOfMapping = {};\n      var topRequired = hasRequired(parentSchema);\n      var tagRequired = true;\n\n      for (var i = 0; i < oneOf.length; i++) {\n        var sch = oneOf[i];\n\n        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n          if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;\n        }\n\n        var propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n\n        if (typeof propSch != \"object\") {\n          throw new Error(\"discriminator: oneOf subschemas (or referenced schemas) must have \\\"properties/\".concat(tagName, \"\\\"\"));\n        }\n\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n\n      if (!tagRequired) throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" must be required\"));\n      return oneOfMapping;\n\n      function hasRequired(_ref3) {\n        var required = _ref3.required;\n        return Array.isArray(required) && required.includes(tagName);\n      }\n\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          var _iterator = _createForOfIteratorHelper(sch.enum),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var tagValue = _step.value;\n              addMapping(tagValue, i);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          throw new Error(\"discriminator: \\\"properties/\".concat(tagName, \"\\\" must have \\\"const\\\" or \\\"enum\\\"\"));\n        }\n      }\n\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" values must be unique strings\"));\n        }\n\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}