{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport \"../../Engines/Extensions/engine.videoTexture\";\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\n/**\r\n * If you want to display a video in your scene, this is the special texture for that.\r\n * This special texture works similar to other textures, with the exception of a few parameters.\r\n * @see https://doc.babylonjs.com/how_to/video_texture\r\n */\n\nvar VideoTexture =\n/** @class */\nfunction (_super) {\n  __extends(VideoTexture, _super);\n  /**\r\n   * Creates a video texture.\r\n   * If you want to display a video in your scene, this is the special texture for that.\r\n   * This special texture works similar to other textures, with the exception of a few parameters.\r\n   * @see https://doc.babylonjs.com/how_to/video_texture\r\n   * @param name optional name, will detect from video source, if not defined\r\n   * @param src can be used to provide an url, array of urls or an already setup HTML video element.\r\n   * @param scene is obviously the current scene.\r\n   * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\r\n   * @param invertY is false by default but can be used to invert video on Y axis\r\n   * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\r\n   * @param settings allows finer control over video usage\r\n   */\n\n\n  function VideoTexture(name, src, scene, generateMipMaps, invertY, samplingMode, settings) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (settings === void 0) {\n      settings = {\n        autoPlay: true,\n        loop: true,\n        autoUpdateTexture: true\n      };\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;\n\n    _this._onUserActionRequestedObservable = null;\n    _this._stillImageCaptured = false;\n    _this._displayingPosterTexture = false;\n    _this._frameId = -1;\n    _this._currentSrc = null;\n\n    _this._createInternalTexture = function () {\n      if (_this._texture != null) {\n        if (_this._displayingPosterTexture) {\n          _this._texture.dispose();\n\n          _this._displayingPosterTexture = false;\n        } else {\n          return;\n        }\n      }\n\n      if (!_this._getEngine().needPOTTextures || Tools.IsExponentOfTwo(_this.video.videoWidth) && Tools.IsExponentOfTwo(_this.video.videoHeight)) {\n        _this.wrapU = Texture.WRAP_ADDRESSMODE;\n        _this.wrapV = Texture.WRAP_ADDRESSMODE;\n      } else {\n        _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        _this._generateMipMaps = false;\n      }\n\n      _this._texture = _this._getEngine().createDynamicTexture(_this.video.videoWidth, _this.video.videoHeight, _this._generateMipMaps, _this.samplingMode);\n\n      if (!_this.video.autoplay && !_this._settings.poster) {\n        var oldHandler_1 = _this.video.onplaying;\n        var error_1 = false;\n        var oldMuted_1 = _this.video.muted;\n        _this.video.muted = true;\n\n        _this.video.onplaying = function () {\n          _this.video.muted = oldMuted_1;\n          _this.video.onplaying = oldHandler_1;\n          _this._texture.isReady = true;\n\n          _this._updateInternalTexture();\n\n          if (!error_1) {\n            _this.video.pause();\n          }\n\n          if (_this.onLoadObservable.hasObservers()) {\n            _this.onLoadObservable.notifyObservers(_this);\n          }\n        };\n\n        var playing = _this.video.play();\n\n        if (playing) {\n          playing.then(function () {// Everything is good.\n          }).catch(function () {\n            error_1 = true; // On Chrome for instance, new policies might prevent playing without user interaction.\n\n            if (_this._onUserActionRequestedObservable && _this._onUserActionRequestedObservable.hasObservers()) {\n              _this._onUserActionRequestedObservable.notifyObservers(_this);\n            }\n          });\n        } else {\n          _this.video.onplaying = oldHandler_1;\n          _this._texture.isReady = true;\n\n          _this._updateInternalTexture();\n\n          if (_this.onLoadObservable.hasObservers()) {\n            _this.onLoadObservable.notifyObservers(_this);\n          }\n        }\n      } else {\n        _this._texture.isReady = true;\n\n        _this._updateInternalTexture();\n\n        if (_this.onLoadObservable.hasObservers()) {\n          _this.onLoadObservable.notifyObservers(_this);\n        }\n      }\n    };\n\n    _this.reset = function () {\n      if (_this._texture == null) {\n        return;\n      }\n\n      if (!_this._displayingPosterTexture) {\n        _this._texture.dispose();\n\n        _this._texture = null;\n      }\n    };\n\n    _this._updateInternalTexture = function () {\n      if (_this._texture == null || !_this._texture.isReady) {\n        return;\n      }\n\n      if (_this.video.readyState < _this.video.HAVE_CURRENT_DATA) {\n        return;\n      }\n\n      if (_this._displayingPosterTexture) {\n        return;\n      }\n\n      var frameId = _this.getScene().getFrameId();\n\n      if (_this._frameId === frameId) {\n        return;\n      }\n\n      _this._frameId = frameId;\n\n      _this._getEngine().updateVideoTexture(_this._texture, _this.video, _this._invertY);\n    };\n\n    _this._generateMipMaps = generateMipMaps;\n    _this._initialSamplingMode = samplingMode;\n    _this.autoUpdateTexture = settings.autoUpdateTexture;\n    _this._currentSrc = src;\n    _this.name = name || _this._getName(src);\n    _this.video = _this._getVideo(src);\n    _this._settings = settings;\n\n    if (settings.poster) {\n      _this.video.poster = settings.poster;\n    }\n\n    if (settings.autoPlay !== undefined) {\n      _this.video.autoplay = settings.autoPlay;\n    }\n\n    if (settings.loop !== undefined) {\n      _this.video.loop = settings.loop;\n    }\n\n    if (settings.muted !== undefined) {\n      _this.video.muted = settings.muted;\n    }\n\n    _this.video.setAttribute(\"playsinline\", \"\");\n\n    _this.video.addEventListener(\"paused\", _this._updateInternalTexture);\n\n    _this.video.addEventListener(\"seeked\", _this._updateInternalTexture);\n\n    _this.video.addEventListener(\"emptied\", _this.reset);\n\n    _this._createInternalTextureOnEvent = settings.poster && !settings.autoPlay ? \"play\" : \"canplay\";\n\n    _this.video.addEventListener(_this._createInternalTextureOnEvent, _this._createInternalTexture);\n\n    if (settings.autoPlay) {\n      _this.video.play();\n    }\n\n    var videoHasEnoughData = _this.video.readyState >= _this.video.HAVE_CURRENT_DATA;\n\n    if (settings.poster && (!settings.autoPlay || !videoHasEnoughData)) {\n      _this._texture = _this._getEngine().createTexture(settings.poster, false, !_this.invertY, scene);\n      _this._displayingPosterTexture = true;\n    } else if (videoHasEnoughData) {\n      _this._createInternalTexture();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(VideoTexture.prototype, \"onUserActionRequestedObservable\", {\n    /**\r\n     * Event triggerd when a dom action is required by the user to play the video.\r\n     * This happens due to recent changes in browser policies preventing video to auto start.\r\n     */\n    get: function get() {\n      if (!this._onUserActionRequestedObservable) {\n        this._onUserActionRequestedObservable = new Observable();\n      }\n\n      return this._onUserActionRequestedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VideoTexture.prototype._getName = function (src) {\n    if (src instanceof HTMLVideoElement) {\n      return src.currentSrc;\n    }\n\n    if (typeof src === \"object\") {\n      return src.toString();\n    }\n\n    return src;\n  };\n\n  VideoTexture.prototype._getVideo = function (src) {\n    if (src instanceof HTMLVideoElement) {\n      Tools.SetCorsBehavior(src.currentSrc, src);\n      return src;\n    }\n\n    var video = document.createElement(\"video\");\n\n    if (typeof src === \"string\") {\n      Tools.SetCorsBehavior(src, video);\n      video.src = src;\n    } else {\n      Tools.SetCorsBehavior(src[0], video);\n      src.forEach(function (url) {\n        var source = document.createElement(\"source\");\n        source.src = url;\n        video.appendChild(source);\n      });\n    }\n\n    return video;\n  };\n  /**\r\n   * @hidden Internal method to initiate `update`.\r\n   */\n\n\n  VideoTexture.prototype._rebuild = function () {\n    this.update();\n  };\n  /**\r\n   * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\r\n   */\n\n\n  VideoTexture.prototype.update = function () {\n    if (!this.autoUpdateTexture) {\n      // Expecting user to call `updateTexture` manually\n      return;\n    }\n\n    this.updateTexture(true);\n  };\n  /**\r\n   * Update Texture in `manual` mode. Does not do anything if not visible or paused.\r\n   * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.\r\n   */\n\n\n  VideoTexture.prototype.updateTexture = function (isVisible) {\n    if (!isVisible) {\n      return;\n    }\n\n    if (this.video.paused && this._stillImageCaptured) {\n      return;\n    }\n\n    this._stillImageCaptured = true;\n\n    this._updateInternalTexture();\n  };\n  /**\r\n   * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\r\n   * @param url New url.\r\n   */\n\n\n  VideoTexture.prototype.updateURL = function (url) {\n    this.video.src = url;\n    this._currentSrc = url;\n  };\n  /**\r\n   * Clones the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  VideoTexture.prototype.clone = function () {\n    return new VideoTexture(this.name, this._currentSrc, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\n  };\n  /**\r\n   * Dispose the texture and release its associated resources.\r\n   */\n\n\n  VideoTexture.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._currentSrc = null;\n\n    if (this._onUserActionRequestedObservable) {\n      this._onUserActionRequestedObservable.clear();\n\n      this._onUserActionRequestedObservable = null;\n    }\n\n    this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\n    this.video.removeEventListener(\"paused\", this._updateInternalTexture);\n    this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\n    this.video.removeEventListener(\"emptied\", this.reset);\n    this.video.pause();\n  };\n  /**\r\n   * Creates a video texture straight from a stream.\r\n   * @param scene Define the scene the texture should be created in\r\n   * @param stream Define the stream the texture should be created from\r\n   * @returns The created video texture as a promise\r\n   */\n\n\n  VideoTexture.CreateFromStreamAsync = function (scene, stream) {\n    var video = document.createElement(\"video\");\n\n    if (scene.getEngine()._badOS) {\n      // Yes... I know and I hope to remove it soon...\n      document.body.appendChild(video);\n      video.style.transform = 'scale(0.0001, 0.0001)';\n      video.style.opacity = '0';\n      video.style.position = 'fixed';\n      video.style.bottom = '0px';\n      video.style.right = '0px';\n    }\n\n    video.setAttribute('autoplay', '');\n    video.setAttribute('muted', 'true');\n    video.setAttribute('playsinline', '');\n    video.muted = true;\n\n    if (video.mozSrcObject !== undefined) {\n      // hack for Firefox < 19\n      video.mozSrcObject = stream;\n    } else {\n      if (typeof video.srcObject == \"object\") {\n        video.srcObject = stream;\n      } else {\n        window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n        video.src = window.URL && window.URL.createObjectURL(stream);\n      }\n    }\n\n    return new Promise(function (resolve) {\n      var onPlaying = function onPlaying() {\n        resolve(new VideoTexture(\"video\", video, scene, true, true));\n        video.removeEventListener(\"playing\", onPlaying);\n      };\n\n      video.addEventListener(\"playing\", onPlaying);\n      video.play();\n    });\n  };\n  /**\r\n   * Creates a video texture straight from your WebCam video feed.\r\n   * @param scene Define the scene the texture should be created in\r\n   * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n   * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n   * @returns The created video texture as a promise\r\n   */\n\n\n  VideoTexture.CreateFromWebCamAsync = function (scene, constraints, audioConstaints) {\n    var _this = this;\n\n    if (audioConstaints === void 0) {\n      audioConstaints = false;\n    }\n\n    var constraintsDeviceId;\n\n    if (constraints && constraints.deviceId) {\n      constraintsDeviceId = {\n        exact: constraints.deviceId\n      };\n    }\n\n    if (navigator.mediaDevices) {\n      return navigator.mediaDevices.getUserMedia({\n        video: constraints,\n        audio: audioConstaints\n      }).then(function (stream) {\n        return _this.CreateFromStreamAsync(scene, stream);\n      });\n    } else {\n      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n\n      if (navigator.getUserMedia) {\n        navigator.getUserMedia({\n          video: {\n            deviceId: constraintsDeviceId,\n            width: {\n              min: constraints && constraints.minWidth || 256,\n              max: constraints && constraints.maxWidth || 640\n            },\n            height: {\n              min: constraints && constraints.minHeight || 256,\n              max: constraints && constraints.maxHeight || 480\n            }\n          },\n          audio: audioConstaints\n        }, function (stream) {\n          return _this.CreateFromStreamAsync(scene, stream);\n        }, function (e) {\n          Logger.Error(e.name);\n        });\n      }\n    }\n\n    return Promise.reject(\"No support for userMedia on this device\");\n  };\n  /**\r\n   * Creates a video texture straight from your WebCam video feed.\r\n   * @param scene Define the scene the texture should be created in\r\n   * @param onReady Define a callback to triggered once the texture will be ready\r\n   * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n   * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n   */\n\n\n  VideoTexture.CreateFromWebCam = function (scene, onReady, constraints, audioConstaints) {\n    if (audioConstaints === void 0) {\n      audioConstaints = false;\n    }\n\n    this.CreateFromWebCamAsync(scene, constraints, audioConstaints).then(function (videoTexture) {\n      if (onReady) {\n        onReady(videoTexture);\n      }\n    }).catch(function (err) {\n      Logger.Error(err.name);\n    });\n  };\n\n  return VideoTexture;\n}(Texture);\n\nexport { VideoTexture };","map":null,"metadata":{},"sourceType":"module"}