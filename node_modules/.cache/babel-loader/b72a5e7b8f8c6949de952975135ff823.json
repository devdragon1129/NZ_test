{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\nimport \"../Meshes/Builders/sphereBuilder\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Axis } from \"../Maths/math\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\n/**\r\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\r\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\n\nvar TextureDome =\n/** @class */\nfunction (_super) {\n  __extends(TextureDome, _super);\n  /**\r\n   * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\r\n   * @param name Element's name, child elements will append suffixes for their own names.\r\n   * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\r\n   * @param options An object containing optional or exposed sub element properties\r\n   */\n\n\n  function TextureDome(name, textureUrlOrElement, options, scene, onError) {\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _this = _super.call(this, name, scene) || this;\n\n    _this.onError = onError;\n    _this._halfDome = false;\n    _this._crossEye = false;\n    _this._useDirectMapping = false;\n    _this._textureMode = TextureDome.MODE_MONOSCOPIC;\n    /**\r\n     * Oberserver used in Stereoscopic VR Mode.\r\n     */\n\n    _this._onBeforeCameraRenderObserver = null;\n    /**\r\n     * Observable raised when an error occured while loading the 360 image\r\n     */\n\n    _this.onLoadErrorObservable = new Observable();\n    scene = _this.getScene(); // set defaults and manage values\n\n    name = name || \"textureDome\";\n    options.resolution = Math.abs(options.resolution) | 0 || 32;\n    options.clickToPlay = Boolean(options.clickToPlay);\n    options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\n    options.loop = options.loop === undefined ? true : Boolean(options.loop);\n    options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\n\n    if (options.useDirectMapping === undefined) {\n      _this._useDirectMapping = true;\n    } else {\n      _this._useDirectMapping = options.useDirectMapping;\n    }\n\n    if (options.faceForward === undefined) {\n      options.faceForward = true;\n    }\n\n    _this._setReady(false);\n\n    _this._mesh = Mesh.CreateSphere(name + \"_mesh\", options.resolution, options.size, scene, false, Mesh.BACKSIDE); // configure material\n\n    var material = _this._material = new BackgroundMaterial(name + \"_material\", scene);\n    material.useEquirectangularFOV = true;\n    material.fovMultiplier = 1.0;\n    material.opacityFresnel = false;\n\n    var texture = _this._initTexture(textureUrlOrElement, scene, options);\n\n    _this.texture = texture; // configure mesh\n\n    _this._mesh.material = material;\n    _this._mesh.parent = _this; // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\n\n    _this._halfDomeMask = SphereBuilder.CreateSphere(\"\", {\n      slice: 0.5,\n      diameter: options.size * 0.98,\n      segments: options.resolution * 2,\n      sideOrientation: Mesh.BACKSIDE\n    }, scene);\n\n    _this._halfDomeMask.rotate(Axis.X, -Math.PI / 2); // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\n\n\n    _this._halfDomeMask.parent = _this._mesh;\n    _this._halfDome = !!options.halfDomeMode; // enable or disable according to the settings\n\n    _this._halfDomeMask.setEnabled(_this._halfDome);\n\n    _this._crossEye = !!options.crossEyeMode; // create\n\n    _this._texture.anisotropicFilteringLevel = 1;\n\n    _this._texture.onLoadObservable.addOnce(function () {\n      _this._setReady(true);\n    }); // Initial rotation\n\n\n    if (options.faceForward && scene.activeCamera) {\n      var camera = scene.activeCamera;\n      var forward = Vector3.Forward();\n      var direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\n      direction.normalize();\n      _this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\n    }\n\n    _this._changeTextureMode(_this._textureMode);\n\n    return _this;\n  }\n\n  Object.defineProperty(TextureDome.prototype, \"texture\", {\n    /**\r\n     * Gets the texture being displayed on the sphere\r\n     */\n    get: function get() {\n      return this._texture;\n    },\n\n    /**\r\n     * Sets the texture being displayed on the sphere\r\n     */\n    set: function set(newTexture) {\n      if (this._texture === newTexture) {\n        return;\n      }\n\n      this._texture = newTexture;\n\n      if (this._useDirectMapping) {\n        this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._material.diffuseTexture = this._texture;\n      } else {\n        this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\n\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._material.reflectionTexture = this._texture;\n      }\n\n      this._changeTextureMode(this._textureMode);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"mesh\", {\n    /**\r\n     * Gets the mesh used for the dome.\r\n     */\n    get: function get() {\n      return this._mesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"fovMultiplier\", {\n    /**\r\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\r\n     * Also see the options.resolution property.\r\n     */\n    get: function get() {\n      return this._material.fovMultiplier;\n    },\n    set: function set(value) {\n      this._material.fovMultiplier = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"textureMode\", {\n    /**\r\n     * Gets or set the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\n    get: function get() {\n      return this._textureMode;\n    },\n\n    /**\r\n     * Sets the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\n    set: function set(value) {\n      if (this._textureMode === value) {\n        return;\n      }\n\n      this._changeTextureMode(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"halfDome\", {\n    /**\r\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\r\n     */\n    get: function get() {\n      return this._halfDome;\n    },\n\n    /**\r\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\r\n     */\n    set: function set(enabled) {\n      this._halfDome = enabled;\n\n      this._halfDomeMask.setEnabled(enabled);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"crossEye\", {\n    /**\r\n     * Is it a cross-eye texture?\r\n     */\n    get: function get() {\n      return this._crossEye;\n    },\n\n    /**\r\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\r\n     */\n    set: function set(enabled) {\n      this._crossEye = enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"material\", {\n    /**\r\n     * The background material of this dome.\r\n     */\n    get: function get() {\n      return this._material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureDome.prototype._changeTextureMode = function (value) {\n    var _this = this;\n\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n\n    this._textureMode = value; // Default Setup and Reset.\n\n    this._texture.uScale = 1;\n    this._texture.vScale = 1;\n    this._texture.uOffset = 0;\n    this._texture.vOffset = 0;\n    this._texture.vAng = 0;\n\n    switch (value) {\n      case TextureDome.MODE_MONOSCOPIC:\n        if (this._halfDome) {\n          this._texture.uScale = 2;\n          this._texture.uOffset = -1;\n        }\n\n        break;\n\n      case TextureDome.MODE_SIDEBYSIDE:\n        // in half-dome mode the uScale should be double of 360 texture\n        // Use 0.99999 to boost perf by not switching program\n        this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\n        var rightOffset_1 = this._halfDome ? 0.0 : 0.5;\n        var leftOffset_1 = this._halfDome ? -0.5 : 0.0;\n        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function (camera) {\n          var isRightCamera = camera.isRightCamera;\n\n          if (_this._crossEye) {\n            isRightCamera = !isRightCamera;\n          }\n\n          if (isRightCamera) {\n            _this._texture.uOffset = rightOffset_1;\n          } else {\n            _this._texture.uOffset = leftOffset_1;\n          }\n        });\n        break;\n\n      case TextureDome.MODE_TOPBOTTOM:\n        // in half-dome mode the vScale should be double of 360 texture\n        // Use 0.99999 to boost perf by not switching program\n        this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\n        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function (camera) {\n          var isRightCamera = camera.isRightCamera; // allow \"cross-eye\" if left and right were switched in this mode\n\n          if (_this._crossEye) {\n            isRightCamera = !isRightCamera;\n          }\n\n          _this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\n        });\n        break;\n    }\n  };\n  /**\r\n   * Releases resources associated with this node.\r\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n   */\n\n\n  TextureDome.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    this._texture.dispose();\n\n    this._mesh.dispose();\n\n    this._material.dispose();\n\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n\n    this.onLoadErrorObservable.clear();\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\r\n   * Define the source as a Monoscopic panoramic 360/180.\r\n   */\n\n\n  TextureDome.MODE_MONOSCOPIC = 0;\n  /**\r\n   * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\r\n   */\n\n  TextureDome.MODE_TOPBOTTOM = 1;\n  /**\r\n   * Define the source as a Stereoscopic Side by Side panoramic 360/180.\r\n   */\n\n  TextureDome.MODE_SIDEBYSIDE = 2;\n  return TextureDome;\n}(TransformNode);\n\nexport { TextureDome };","map":null,"metadata":{},"sourceType":"module"}