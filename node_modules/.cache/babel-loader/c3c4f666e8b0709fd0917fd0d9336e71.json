{"ast":null,"code":"import { Vector3, Quaternion, Matrix } from '@babylonjs/core/Maths/math.vector';\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { TmpVectors } from '@babylonjs/core/Maths/math.vector';\nvar NAME = \"EXT_mesh_gpu_instancing\";\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1691)\r\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\n\nvar EXT_mesh_gpu_instancing =\n/** @class */\nfunction () {\n  /** @hidden */\n  function EXT_mesh_gpu_instancing(loader) {\n    /**\r\n     * The name of this extension.\r\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  EXT_mesh_gpu_instancing.prototype.dispose = function () {\n    this._loader = null;\n  };\n  /** @hidden */\n\n\n  EXT_mesh_gpu_instancing.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n      _this._loader._disableInstancedMesh++;\n\n      var promise = _this._loader.loadNodeAsync(\"/nodes/\" + node.index, node, assign);\n\n      _this._loader._disableInstancedMesh--;\n\n      if (!node._primitiveBabylonMeshes) {\n        return promise;\n      }\n\n      var promises = new Array();\n      var instanceCount = 0;\n\n      var loadAttribute = function loadAttribute(attribute) {\n        if (extension.attributes[attribute] == undefined) {\n          promises.push(Promise.resolve(null));\n          return;\n        }\n\n        var accessor = ArrayItem.Get(extensionContext + \"/attributes/\" + attribute, _this._loader.gltf.accessors, extension.attributes[attribute]);\n        promises.push(_this._loader._loadFloatAccessorAsync(\"/accessors/\" + accessor.bufferView, accessor));\n\n        if (instanceCount === 0) {\n          instanceCount = accessor.count;\n        } else if (instanceCount !== accessor.count) {\n          throw new Error(extensionContext + \"/attributes: Instance buffer accessors do not have the same count.\");\n        }\n      };\n\n      loadAttribute(\"TRANSLATION\");\n      loadAttribute(\"ROTATION\");\n      loadAttribute(\"SCALE\");\n      return promise.then(function (babylonTransformNode) {\n        return Promise.all(promises).then(function (_a) {\n          var translationBuffer = _a[0],\n              rotationBuffer = _a[1],\n              scaleBuffer = _a[2];\n          var matrices = new Float32Array(instanceCount * 16);\n          TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\n\n          TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\n\n          TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\n\n          for (var i = 0; i < instanceCount; ++i) {\n            translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\n            rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\n            scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\n            Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\n            TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\n          }\n\n          for (var _i = 0, _b = node._primitiveBabylonMeshes; _i < _b.length; _i++) {\n            var babylonMesh = _b[_i];\n            babylonMesh.thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\n          }\n\n          return babylonTransformNode;\n        });\n      });\n    });\n  };\n\n  return EXT_mesh_gpu_instancing;\n}();\n\nexport { EXT_mesh_gpu_instancing };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new EXT_mesh_gpu_instancing(loader);\n});","map":null,"metadata":{},"sourceType":"module"}