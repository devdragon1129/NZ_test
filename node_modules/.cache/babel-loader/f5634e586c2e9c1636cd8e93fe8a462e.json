{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { _MeshCollisionData } from '../Collisions/meshCollisionData';\nimport { _DevTools } from '../Misc/devTools';\nimport { extractMinAndMax } from '../Maths/math.functions';\nimport { Color3, Color4 } from '../Maths/math.color';\nimport { Epsilon } from '../Maths/math.constants';\nimport { Axis } from '../Maths/math.axis';\nimport { _TypeStore } from '../Misc/typeStore';\n/** @hidden */\n\nvar _FacetDataStorage =\n/** @class */\nfunction () {\n  function _FacetDataStorage() {\n    this.facetNb = 0; // facet number\n\n    this.partitioningSubdivisions = 10; // number of subdivisions per axis in the partioning space\n\n    this.partitioningBBoxRatio = 1.01; // the partioning array space is by default 1% bigger than the bounding box\n\n    this.facetDataEnabled = false; // is the facet data feature enabled on this mesh ?\n\n    this.facetParameters = {}; // keep a reference to the object parameters to avoid memory re-allocation\n\n    this.bbSize = Vector3.Zero(); // bbox size approximated for facet data\n\n    this.subDiv = {\n      max: 1,\n      X: 1,\n      Y: 1,\n      Z: 1\n    };\n    this.facetDepthSort = false; // is the facet depth sort to be computed\n\n    this.facetDepthSortEnabled = false; // is the facet depth sort initialized\n  }\n\n  return _FacetDataStorage;\n}();\n/**\r\n * @hidden\r\n **/\n\n\nvar _InternalAbstractMeshDataInfo =\n/** @class */\nfunction () {\n  function _InternalAbstractMeshDataInfo() {\n    this._hasVertexAlpha = false;\n    this._useVertexColors = true;\n    this._numBoneInfluencers = 4;\n    this._applyFog = true;\n    this._receiveShadows = false;\n    this._facetData = new _FacetDataStorage();\n    this._visibility = 1.0;\n    this._skeleton = null;\n    this._layerMask = 0x0FFFFFFF;\n    this._computeBonesUsingShaders = true;\n    this._isActive = false;\n    this._onlyForInstances = false;\n    this._isActiveIntermediate = false;\n    this._onlyForInstancesIntermediate = false;\n    this._actAsRegularMesh = false;\n    this._currentLOD = null;\n    this._currentLODIsUpToDate = false;\n  }\n\n  return _InternalAbstractMeshDataInfo;\n}();\n/**\r\n * Class used to store all common mesh properties\r\n */\n\n\nvar AbstractMesh =\n/** @class */\nfunction (_super) {\n  __extends(AbstractMesh, _super); // Constructor\n\n  /**\r\n   * Creates a new AbstractMesh\r\n   * @param name defines the name of the mesh\r\n   * @param scene defines the hosting scene\r\n   */\n\n\n  function AbstractMesh(name, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var _this = _super.call(this, name, scene, false) || this; // Internal data\n\n    /** @hidden */\n\n\n    _this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\n    /**\r\n     * The culling strategy to use to check whether the mesh must be rendered or not.\r\n     * This value can be changed at any time and will be used on the next render mesh selection.\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * Please read each static variable documentation to get details about the culling process.\r\n     * */\n\n    _this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY; // Events\n\n    /**\r\n    * An event triggered when this mesh collides with another one\r\n    */\n\n    _this.onCollideObservable = new Observable();\n    /**\r\n    * An event triggered when the collision's position changes\r\n    */\n\n    _this.onCollisionPositionChangeObservable = new Observable();\n    /**\r\n    * An event triggered when material is changed\r\n    */\n\n    _this.onMaterialChangedObservable = new Observable(); // Properties\n\n    /**\r\n     * Gets or sets the orientation for POV movement & rotation\r\n     */\n\n    _this.definedFacingForward = true;\n    /** @hidden */\n\n    _this._occlusionQuery = null;\n    /** @hidden */\n\n    _this._renderingGroup = null;\n    /** Gets or sets the alpha index used to sort transparent meshes\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index\r\n     */\n\n    _this.alphaIndex = Number.MAX_VALUE;\n    /**\r\n     * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true\r\n     */\n\n    _this.isVisible = true;\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\n\n    _this.isPickable = true;\n    /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\n\n    _this.showSubMeshesBoundingBox = false;\n    /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n     */\n\n    _this.isBlocker = false;\n    /**\r\n     * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\r\n     */\n\n    _this.enablePointerMoveEvents = false;\n    _this._renderingGroupId = 0;\n    _this._material = null;\n    /** Defines color to use when rendering outline */\n\n    _this.outlineColor = Color3.Red();\n    /** Define width to use when rendering outline */\n\n    _this.outlineWidth = 0.02;\n    /** Defines color to use when rendering overlay */\n\n    _this.overlayColor = Color3.Red();\n    /** Defines alpha to use when rendering overlay */\n\n    _this.overlayAlpha = 0.5;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\n\n    _this.useOctreeForRenderingSelection = true;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\n\n    _this.useOctreeForPicking = true;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\n\n    _this.useOctreeForCollisions = true;\n    /**\r\n     * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\r\n     */\n\n    _this.alwaysSelectAsActiveMesh = false;\n    /**\r\n     * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\r\n     */\n\n    _this.doNotSyncBoundingInfo = false;\n    /**\r\n     * Gets or sets the current action manager\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n     */\n\n    _this.actionManager = null; // Collisions\n\n    _this._meshCollisionData = new _MeshCollisionData();\n    /**\r\n     * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n\n    _this.ellipsoid = new Vector3(0.5, 1, 0.5);\n    /**\r\n     * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n\n    _this.ellipsoidOffset = new Vector3(0, 0, 0); // Edges\n\n    /**\r\n     * Defines edge width used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\n\n    _this.edgesWidth = 1;\n    /**\r\n     * Defines edge color used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\n\n    _this.edgesColor = new Color4(1, 0, 0, 1);\n    /** @hidden */\n\n    _this._edgesRenderer = null;\n    /** @hidden */\n\n    _this._masterMesh = null;\n    /** @hidden */\n\n    _this._boundingInfo = null;\n    /** @hidden */\n\n    _this._renderId = 0;\n    /** @hidden */\n\n    _this._intersectionsInProgress = new Array();\n    /** @hidden */\n\n    _this._unIndexed = false;\n    /** @hidden */\n\n    _this._lightSources = new Array(); // Loading properties\n\n    /** @hidden */\n\n    _this._waitingData = {\n      lods: null,\n      actions: null,\n      freezeWorldMatrix: null\n    };\n    /** @hidden */\n\n    _this._bonesTransformMatrices = null;\n    /** @hidden */\n\n    _this._transformMatrixTexture = null;\n    /**\r\n     * An event triggered when the mesh is rebuilt.\r\n     */\n\n    _this.onRebuildObservable = new Observable();\n\n    _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n      if (collidedMesh === void 0) {\n        collidedMesh = null;\n      }\n\n      newPosition.subtractToRef(_this._meshCollisionData._oldPositionForCollisions, _this._meshCollisionData._diffPositionForCollisions);\n\n      if (_this._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {\n        _this.position.addInPlace(_this._meshCollisionData._diffPositionForCollisions);\n      }\n\n      if (collidedMesh) {\n        _this.onCollideObservable.notifyObservers(collidedMesh);\n      }\n\n      _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);\n    };\n\n    _this.getScene().addMesh(_this);\n\n    _this._resyncLightSources();\n\n    return _this;\n  }\n\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_NONE\", {\n    /**\r\n     * No billboard\r\n     */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_X\", {\n    /** Billboard on X axis */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_X;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Y\", {\n    /** Billboard on Y axis */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_Y;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Z\", {\n    /** Billboard on Z axis */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_Z;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_ALL\", {\n    /** Billboard on all axes */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_ALL;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_USE_POSITION\", {\n    /** Billboard on using position instead of orientation */\n    get: function get() {\n      return TransformNode.BILLBOARDMODE_USE_POSITION;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"facetNb\", {\n    /**\r\n     * Gets the number of facets in the mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.facetNb;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"partitioningSubdivisions\", {\n    /**\r\n     * Gets or set the number (integer) of subdivisions per axis in the partioning space\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\n    },\n    set: function set(nb) {\n      this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"partitioningBBoxRatio\", {\n    /**\r\n     * The ratio (float) to apply to the bouding box size to set to the partioning space.\r\n     * Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\n    },\n    set: function set(ratio) {\n      this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"mustDepthSortFacets\", {\n    /**\r\n     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\r\n     * Works only for updatable meshes.\r\n     * Doesn't work with multi-materials\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\n    },\n    set: function set(sort) {\n      this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"facetDepthSortFrom\", {\n    /**\r\n     * The location (Vector3) where the facet depth sort must be computed from.\r\n     * By default, the active camera position.\r\n     * Used only when facet depth sort is enabled\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\n    },\n    set: function set(location) {\n      this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"isFacetDataEnabled\", {\n    /**\r\n     * gets a boolean indicating if facetData is enabled\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  AbstractMesh.prototype._updateNonUniformScalingState = function (value) {\n    if (!_super.prototype._updateNonUniformScalingState.call(this, value)) {\n      return false;\n    }\n\n    this._markSubMeshesAsMiscDirty();\n\n    return true;\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"onCollide\", {\n    /** Set a function to call when this mesh collides with another one */\n    set: function set(callback) {\n      if (this._meshCollisionData._onCollideObserver) {\n        this.onCollideObservable.remove(this._meshCollisionData._onCollideObserver);\n      }\n\n      this._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"onCollisionPositionChange\", {\n    /** Set a function to call when the collision's position changes */\n    set: function set(callback) {\n      if (this._meshCollisionData._onCollisionPositionChangeObserver) {\n        this.onCollisionPositionChangeObservable.remove(this._meshCollisionData._onCollisionPositionChangeObserver);\n      }\n\n      this._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"visibility\", {\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._visibility;\n    },\n\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._visibility === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._visibility = value;\n\n      this._markSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"renderingGroupId\", {\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\r\n     */\n    get: function get() {\n      return this._renderingGroupId;\n    },\n    set: function set(value) {\n      this._renderingGroupId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"material\", {\n    /** Gets or sets current material */\n    get: function get() {\n      return this._material;\n    },\n    set: function set(value) {\n      if (this._material === value) {\n        return;\n      } // remove from material mesh map id needed\n\n\n      if (this._material && this._material.meshMap) {\n        this._material.meshMap[this.uniqueId] = undefined;\n      }\n\n      this._material = value;\n\n      if (value && value.meshMap) {\n        value.meshMap[this.uniqueId] = this;\n      }\n\n      if (this.onMaterialChangedObservable.hasObservers()) {\n        this.onMaterialChangedObservable.notifyObservers(this);\n      }\n\n      if (!this.subMeshes) {\n        return;\n      }\n\n      this._unBindEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"receiveShadows\", {\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can receive realtime shadows\r\n     * @see https://doc.babylonjs.com/babylon101/shadows\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._receiveShadows;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._receiveShadows = value;\n\n      this._markSubMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasVertexAlpha\", {\n    /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._hasVertexAlpha;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\n\n      this._markSubMeshesAsAttributesDirty();\n\n      this._markSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"useVertexColors\", {\n    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._useVertexColors;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._useVertexColors = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"computeBonesUsingShaders\", {\n    /**\r\n     * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"numBoneInfluencers\", {\n    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._numBoneInfluencers;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"applyFog\", {\n    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._applyFog;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._applyFog === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._applyFog = value;\n\n      this._markSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"layerMask\", {\n    /**\r\n     * Gets or sets the current layer mask (default is 0x0FFFFFFF)\r\n     * @see https://doc.babylonjs.com/how_to/layermasks_and_multi-cam_textures\r\n     */\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._layerMask;\n    },\n    set: function set(value) {\n      if (value === this._internalAbstractMeshDataInfo._layerMask) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._layerMask = value;\n\n      this._resyncLightSources();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionMask\", {\n    /**\r\n     * Gets or sets a collision mask used to mask collisions (default is -1).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\n    get: function get() {\n      return this._meshCollisionData._collisionMask;\n    },\n    set: function set(mask) {\n      this._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionResponse\", {\n    /**\r\n     * Gets or sets a collision response flag (default is true).\r\n     * when collisionResponse is false, events are still triggered but colliding entity has no response\r\n     * This helps creating trigger volume when user wants collision feedback events but not position/velocity\r\n     * to respond to the collision.\r\n     */\n    get: function get() {\n      return this._meshCollisionData._collisionResponse;\n    },\n    set: function set(response) {\n      this._meshCollisionData._collisionResponse = response;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionGroup\", {\n    /**\r\n     * Gets or sets the current collision group mask (-1 by default).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\n    get: function get() {\n      return this._meshCollisionData._collisionGroup;\n    },\n    set: function set(mask) {\n      this._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"surroundingMeshes\", {\n    /**\r\n     * Gets or sets current surrounding meshes (null by default).\r\n     *\r\n     * By default collision detection is tested against every mesh in the scene.\r\n     * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\r\n     * meshes will be tested for the collision.\r\n     *\r\n     * Note: if set to an empty array no collision will happen when this mesh is moved.\r\n     */\n    get: function get() {\n      return this._meshCollisionData._surroundingMeshes;\n    },\n    set: function set(meshes) {\n      this._meshCollisionData._surroundingMeshes = meshes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"lightSources\", {\n    /** Gets the list of lights affecting that mesh */\n    get: function get() {\n      return this._lightSources;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"_positions\", {\n    /** @hidden */\n    get: function get() {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"skeleton\", {\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._skeleton;\n    },\n\n    /**\r\n     * Gets or sets a skeleton to apply skining transformations\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n     */\n    set: function set(value) {\n      var skeleton = this._internalAbstractMeshDataInfo._skeleton;\n\n      if (skeleton && skeleton.needInitialSkinMatrix) {\n        skeleton._unregisterMeshWithPoseMatrix(this);\n      }\n\n      if (value && value.needInitialSkinMatrix) {\n        value._registerMeshWithPoseMatrix(this);\n      }\n\n      this._internalAbstractMeshDataInfo._skeleton = value;\n\n      if (!this._internalAbstractMeshDataInfo._skeleton) {\n        this._bonesTransformMatrices = null;\n      }\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"AbstractMesh\"\r\n   * @returns \"AbstractMesh\"\r\n   */\n\n  AbstractMesh.prototype.getClassName = function () {\n    return \"AbstractMesh\";\n  };\n  /**\r\n   * Gets a string representation of the current mesh\r\n   * @param fullDetails defines a boolean indicating if full details must be included\r\n   * @returns a string representation of the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() !== \"InstancedMesh\" ? \"YES\" : \"NO\");\n    ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\n    var skeleton = this._internalAbstractMeshDataInfo._skeleton;\n\n    if (skeleton) {\n      ret += \", skeleton: \" + skeleton.name;\n    }\n\n    if (fullDetails) {\n      ret += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode];\n      ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\n    }\n\n    return ret;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  AbstractMesh.prototype._getEffectiveParent = function () {\n    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n      return this._masterMesh;\n    }\n\n    return _super.prototype._getEffectiveParent.call(this);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._getActionManagerForTrigger = function (trigger, initialCall) {\n    if (initialCall === void 0) {\n      initialCall = true;\n    }\n\n    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\n      if (trigger) {\n        if (this.actionManager.hasSpecificTrigger(trigger)) {\n          return this.actionManager;\n        }\n      } else {\n        return this.actionManager;\n      }\n    }\n\n    if (!this.parent) {\n      return null;\n    }\n\n    return this.parent._getActionManagerForTrigger(trigger, false);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._rebuild = function () {\n    this.onRebuildObservable.notifyObservers(this);\n\n    if (this._occlusionQuery) {\n      this._occlusionQuery = null;\n    }\n\n    if (!this.subMeshes) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n\n      subMesh._rebuild();\n    }\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._resyncLightSources = function () {\n    this._lightSources.length = 0;\n\n    for (var _i = 0, _a = this.getScene().lights; _i < _a.length; _i++) {\n      var light = _a[_i];\n\n      if (!light.isEnabled()) {\n        continue;\n      }\n\n      if (light.canAffectMesh(this)) {\n        this._lightSources.push(light);\n      }\n    }\n\n    this._markSubMeshesAsLightDirty();\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._resyncLightSource = function (light) {\n    var isIn = light.isEnabled() && light.canAffectMesh(this);\n\n    var index = this._lightSources.indexOf(light);\n\n    var removed = false;\n\n    if (index === -1) {\n      if (!isIn) {\n        return;\n      }\n\n      this._lightSources.push(light);\n    } else {\n      if (isIn) {\n        return;\n      }\n\n      removed = true;\n\n      this._lightSources.splice(index, 1);\n    }\n\n    this._markSubMeshesAsLightDirty(removed);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._unBindEffect = function () {\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n      subMesh.setEffect(null);\n    }\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._removeLightSource = function (light, dispose) {\n    var index = this._lightSources.indexOf(light);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._lightSources.splice(index, 1);\n\n    this._markSubMeshesAsLightDirty(dispose);\n  };\n\n  AbstractMesh.prototype._markSubMeshesAsDirty = function (func) {\n    if (!this.subMeshes) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n\n      if (subMesh._materialDefines) {\n        func(subMesh._materialDefines);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._markSubMeshesAsLightDirty = function (dispose) {\n    if (dispose === void 0) {\n      dispose = false;\n    }\n\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsLightDirty(dispose);\n    });\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._markSubMeshesAsAttributesDirty = function () {\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsAttributesDirty();\n    });\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._markSubMeshesAsMiscDirty = function () {\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsMiscDirty();\n    });\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"scaling\", {\n    /**\r\n    * Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)\r\n    */\n    get: function get() {\n      return this._scaling;\n    },\n    set: function set(newScaling) {\n      this._scaling = newScaling;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"isBlocked\", {\n    // Methods\n\n    /**\r\n     * Returns true if the mesh is blocked. Implemented by child classes\r\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the mesh itself by default. Implemented by child classes\r\n   * @param camera defines the camera to use to pick the right LOD level\r\n   * @returns the currentAbstractMesh\r\n   */\n\n  AbstractMesh.prototype.getLOD = function (camera) {\n    return this;\n  };\n  /**\r\n   * Returns 0 by default. Implemented by child classes\r\n   * @returns an integer\r\n   */\n\n\n  AbstractMesh.prototype.getTotalVertices = function () {\n    return 0;\n  };\n  /**\r\n   * Returns a positive integer : the total number of indices in this mesh geometry.\r\n   * @returns the numner of indices or zero if the mesh has no geometry.\r\n   */\n\n\n  AbstractMesh.prototype.getTotalIndices = function () {\n    return 0;\n  };\n  /**\r\n   * Returns null by default. Implemented by child classes\r\n   * @returns null\r\n   */\n\n\n  AbstractMesh.prototype.getIndices = function () {\n    return null;\n  };\n  /**\r\n   * Returns the array of the requested vertex data kind. Implemented by child classes\r\n   * @param kind defines the vertex data kind to use\r\n   * @returns null\r\n   */\n\n\n  AbstractMesh.prototype.getVerticesData = function (kind) {\n    return null;\n  };\n  /**\r\n   * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n   * Note that a new underlying VertexBuffer object is created each call.\r\n   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n   * @param kind defines vertex data kind:\r\n   * * VertexBuffer.PositionKind\r\n   * * VertexBuffer.UVKind\r\n   * * VertexBuffer.UV2Kind\r\n   * * VertexBuffer.UV3Kind\r\n   * * VertexBuffer.UV4Kind\r\n   * * VertexBuffer.UV5Kind\r\n   * * VertexBuffer.UV6Kind\r\n   * * VertexBuffer.ColorKind\r\n   * * VertexBuffer.MatricesIndicesKind\r\n   * * VertexBuffer.MatricesIndicesExtraKind\r\n   * * VertexBuffer.MatricesWeightsKind\r\n   * * VertexBuffer.MatricesWeightsExtraKind\r\n   * @param data defines the data source\r\n   * @param updatable defines if the data must be flagged as updatable (or static)\r\n   * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    return this;\n  };\n  /**\r\n   * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n   * If the mesh has no geometry, it is simply returned as it is.\r\n   * @param kind defines vertex data kind:\r\n   * * VertexBuffer.PositionKind\r\n   * * VertexBuffer.UVKind\r\n   * * VertexBuffer.UV2Kind\r\n   * * VertexBuffer.UV3Kind\r\n   * * VertexBuffer.UV4Kind\r\n   * * VertexBuffer.UV5Kind\r\n   * * VertexBuffer.UV6Kind\r\n   * * VertexBuffer.ColorKind\r\n   * * VertexBuffer.MatricesIndicesKind\r\n   * * VertexBuffer.MatricesIndicesExtraKind\r\n   * * VertexBuffer.MatricesWeightsKind\r\n   * * VertexBuffer.MatricesWeightsExtraKind\r\n   * @param data defines the data source\r\n   * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\r\n   * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n    return this;\n  };\n  /**\r\n   * Sets the mesh indices,\r\n   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n   * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\r\n   * @param totalVertices Defines the total number of vertices\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.setIndices = function (indices, totalVertices) {\n    return this;\n  };\n  /**\r\n   * Gets a boolean indicating if specific vertex data is present\r\n   * @param kind defines the vertex data kind to use\r\n   * @returns true is data kind is present\r\n   */\n\n\n  AbstractMesh.prototype.isVerticesDataPresent = function (kind) {\n    return false;\n  };\n  /**\r\n   * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\r\n   * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\r\n   * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\r\n   * @returns a BoundingInfo\r\n   */\n\n\n  AbstractMesh.prototype.getBoundingInfo = function () {\n    if (this._masterMesh) {\n      return this._masterMesh.getBoundingInfo();\n    }\n\n    if (!this._boundingInfo) {\n      // this._boundingInfo is being created here\n      this._updateBoundingInfo();\n    } // cannot be null.\n\n\n    return this._boundingInfo;\n  };\n  /**\r\n   * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n   * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n   * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n   * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.normalizeToUnitCube = function (includeDescendants, ignoreRotation, predicate) {\n    if (includeDescendants === void 0) {\n      includeDescendants = true;\n    }\n\n    if (ignoreRotation === void 0) {\n      ignoreRotation = false;\n    }\n\n    return _super.prototype.normalizeToUnitCube.call(this, includeDescendants, ignoreRotation, predicate);\n  };\n  /**\r\n   * Overwrite the current bounding info\r\n   * @param boundingInfo defines the new bounding info\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.setBoundingInfo = function (boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"useBones\", {\n    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\n    get: function get() {\n      return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  AbstractMesh.prototype._preActivate = function () {};\n  /** @hidden */\n\n\n  AbstractMesh.prototype._preActivateForIntermediateRendering = function (renderId) {};\n  /** @hidden */\n\n\n  AbstractMesh.prototype._activate = function (renderId, intermediateRendering) {\n    this._renderId = renderId;\n    return true;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._postActivate = function () {// Do nothing\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._freeze = function () {// Do nothing\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._unFreeze = function () {// Do nothing\n  };\n  /**\r\n   * Gets the current world matrix\r\n   * @returns a Matrix\r\n   */\n\n\n  AbstractMesh.prototype.getWorldMatrix = function () {\n    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\n      return this._masterMesh.getWorldMatrix();\n    }\n\n    return _super.prototype.getWorldMatrix.call(this);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._getWorldMatrixDeterminant = function () {\n    if (this._masterMesh) {\n      return this._masterMesh._getWorldMatrixDeterminant();\n    }\n\n    return _super.prototype._getWorldMatrixDeterminant.call(this);\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"isAnInstance\", {\n    /**\r\n     * Gets a boolean indicating if this mesh is an instance or a regular mesh\r\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasInstances\", {\n    /**\r\n     * Gets a boolean indicating if this mesh has instances\r\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasThinInstances\", {\n    /**\r\n     * Gets a boolean indicating if this mesh has thin instances\r\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  }); // ================================== Point of View Movement =================================\n\n  /**\r\n   * Perform relative position change from the point of view of behind the front of the mesh.\r\n   * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n   * Supports definition of mesh facing forward or backward\r\n   * @param amountRight defines the distance on the right axis\r\n   * @param amountUp defines the distance on the up axis\r\n   * @param amountForward defines the distance on the forward axis\r\n   * @returns the current mesh\r\n   */\n\n  AbstractMesh.prototype.movePOV = function (amountRight, amountUp, amountForward) {\n    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\n    return this;\n  };\n  /**\r\n   * Calculate relative position change from the point of view of behind the front of the mesh.\r\n   * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n   * Supports definition of mesh facing forward or backward\r\n   * @param amountRight defines the distance on the right axis\r\n   * @param amountUp defines the distance on the up axis\r\n   * @param amountForward defines the distance on the forward axis\r\n   * @returns the new displacement vector\r\n   */\n\n\n  AbstractMesh.prototype.calcMovePOV = function (amountRight, amountUp, amountForward) {\n    var rotMatrix = new Matrix();\n    var rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n    rotQuaternion.toRotationMatrix(rotMatrix);\n    var translationDelta = Vector3.Zero();\n    var defForwardMult = this.definedFacingForward ? -1 : 1;\n    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\n    return translationDelta;\n  }; // ================================== Point of View Rotation =================================\n\n  /**\r\n   * Perform relative rotation change from the point of view of behind the front of the mesh.\r\n   * Supports definition of mesh facing forward or backward\r\n   * @param flipBack defines the flip\r\n   * @param twirlClockwise defines the twirl\r\n   * @param tiltRight defines the tilt\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.rotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\n    return this;\n  };\n  /**\r\n   * Calculate relative rotation change from the point of view of behind the front of the mesh.\r\n   * Supports definition of mesh facing forward or backward.\r\n   * @param flipBack defines the flip\r\n   * @param twirlClockwise defines the twirl\r\n   * @param tiltRight defines the tilt\r\n   * @returns the new rotation vector\r\n   */\n\n\n  AbstractMesh.prototype.calcRotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n    var defForwardMult = this.definedFacingForward ? 1 : -1;\n    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\n  };\n  /**\r\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n   * This means the mesh underlying bounding box and sphere are recomputed.\r\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.refreshBoundingInfo = function (applySkeleton) {\n    if (applySkeleton === void 0) {\n      applySkeleton = false;\n    }\n\n    if (this._boundingInfo && this._boundingInfo.isLocked) {\n      return this;\n    }\n\n    this._refreshBoundingInfo(this._getPositionData(applySkeleton), null);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._refreshBoundingInfo = function (data, bias) {\n    if (data) {\n      var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\n\n      if (this._boundingInfo) {\n        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n      } else {\n        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n      }\n    }\n\n    if (this.subMeshes) {\n      for (var index = 0; index < this.subMeshes.length; index++) {\n        this.subMeshes[index].refreshBoundingInfo(data);\n      }\n    }\n\n    this._updateBoundingInfo();\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._getPositionData = function (applySkeleton) {\n    var data = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (data && applySkeleton && this.skeleton) {\n      data = Tools.Slice(data);\n\n      this._generatePointsArray();\n\n      var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n      var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n\n      if (matricesWeightsData && matricesIndicesData) {\n        var needExtras = this.numBoneInfluencers > 4;\n        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n        this.skeleton.prepare();\n        var skeletonMatrices = this.skeleton.getTransformMatrices(this);\n        var tempVector = TmpVectors.Vector3[0];\n        var finalMatrix = TmpVectors.Matrix[0];\n        var tempMatrix = TmpVectors.Matrix[1];\n        var matWeightIdx = 0;\n\n        for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {\n          finalMatrix.reset();\n          var inf;\n          var weight;\n\n          for (inf = 0; inf < 4; inf++) {\n            weight = matricesWeightsData[matWeightIdx + inf];\n\n            if (weight > 0) {\n              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n              finalMatrix.addToSelf(tempMatrix);\n            }\n          }\n\n          if (needExtras) {\n            for (inf = 0; inf < 4; inf++) {\n              weight = matricesWeightsExtraData[matWeightIdx + inf];\n\n              if (weight > 0) {\n                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                finalMatrix.addToSelf(tempMatrix);\n              }\n            }\n          }\n\n          Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\n          tempVector.toArray(data, index);\n\n          if (this._positions) {\n            this._positions[index / 3].copyFrom(tempVector);\n          }\n        }\n      }\n    }\n\n    return data;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._updateBoundingInfo = function () {\n    var effectiveMesh = this._effectiveMesh;\n\n    if (this._boundingInfo) {\n      this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);\n    } else {\n      this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);\n    }\n\n    this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._updateSubMeshesBoundingInfo = function (matrix) {\n    if (!this.subMeshes) {\n      return this;\n    }\n\n    var count = this.subMeshes.length;\n\n    for (var subIndex = 0; subIndex < count; subIndex++) {\n      var subMesh = this.subMeshes[subIndex];\n\n      if (count > 1 || !subMesh.IsGlobal) {\n        subMesh.updateBoundingInfo(matrix);\n      }\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._afterComputeWorldMatrix = function () {\n    if (this.doNotSyncBoundingInfo) {\n      return;\n    } // Bounding info\n\n\n    this._updateBoundingInfo();\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"_effectiveMesh\", {\n    /** @hidden */\n    get: function get() {\n      return this.skeleton && this.skeleton.overrideMesh || this;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\r\n   * A mesh is in the frustum if its bounding box intersects the frustum\r\n   * @param frustumPlanes defines the frustum to test\r\n   * @returns true if the mesh is in the frustum planes\r\n   */\n\n  AbstractMesh.prototype.isInFrustum = function (frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\n  };\n  /**\r\n   * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\r\n   * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\r\n   * @param frustumPlanes defines the frustum to test\r\n   * @returns true if the mesh is completely in the frustum planes\r\n   */\n\n\n  AbstractMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  };\n  /**\r\n   * True if the mesh intersects another mesh or a SolidParticle object\r\n   * @param mesh defines a target mesh or SolidParticle to test\r\n   * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\r\n   * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  AbstractMesh.prototype.intersectsMesh = function (mesh, precise, includeDescendants) {\n    if (precise === void 0) {\n      precise = false;\n    }\n\n    if (!this._boundingInfo || !mesh._boundingInfo) {\n      return false;\n    }\n\n    if (this._boundingInfo.intersects(mesh._boundingInfo, precise)) {\n      return true;\n    }\n\n    if (includeDescendants) {\n      for (var _i = 0, _a = this.getChildMeshes(); _i < _a.length; _i++) {\n        var child = _a[_i];\n\n        if (child.intersectsMesh(mesh, precise, true)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns true if the passed point (Vector3) is inside the mesh bounding box\r\n   * @param point defines the point to test\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  AbstractMesh.prototype.intersectsPoint = function (point) {\n    if (!this._boundingInfo) {\n      return false;\n    }\n\n    return this._boundingInfo.intersectsPoint(point);\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"checkCollisions\", {\n    // Collisions\n\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can be used in the collision engine\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n    get: function get() {\n      return this._meshCollisionData._checkCollisions;\n    },\n    set: function set(collisionEnabled) {\n      this._meshCollisionData._checkCollisions = collisionEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collider\", {\n    /**\r\n     * Gets Collider object used to compute collisions (not physics)\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n    get: function get() {\n      return this._meshCollisionData._collider;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Move the mesh using collision engine\r\n   * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n   * @param displacement defines the requested displacement vector\r\n   * @returns the current mesh\r\n   */\n\n  AbstractMesh.prototype.moveWithCollisions = function (displacement) {\n    var globalPosition = this.getAbsolutePosition();\n    globalPosition.addToRef(this.ellipsoidOffset, this._meshCollisionData._oldPositionForCollisions);\n    var coordinator = this.getScene().collisionCoordinator;\n\n    if (!this._meshCollisionData._collider) {\n      this._meshCollisionData._collider = coordinator.createCollider();\n    }\n\n    this._meshCollisionData._collider._radius = this.ellipsoid;\n    coordinator.getNewPosition(this._meshCollisionData._oldPositionForCollisions, displacement, this._meshCollisionData._collider, 3, this, this._onCollisionPositionChange, this.uniqueId);\n    return this;\n  }; // Collisions\n\n  /** @hidden */\n\n\n  AbstractMesh.prototype._collideForSubMesh = function (subMesh, transformMatrix, collider) {\n    this._generatePointsArray();\n\n    if (!this._positions) {\n      return this;\n    } // Transformation\n\n\n    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {\n      subMesh._lastColliderTransformMatrix = transformMatrix.clone();\n      subMesh._lastColliderWorldVertices = [];\n      subMesh._trianglePlanes = [];\n      var start = subMesh.verticesStart;\n      var end = subMesh.verticesStart + subMesh.verticesCount;\n\n      for (var i = start; i < end; i++) {\n        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\n      }\n    } // Collide\n\n\n    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._processCollisionsForSubMeshes = function (collider, transformMatrix) {\n    var subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\n\n    var len = subMeshes.length;\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index]; // Bounding test\n\n      if (len > 1 && !subMesh._checkCollision(collider)) {\n        continue;\n      }\n\n      this._collideForSubMesh(subMesh, transformMatrix, collider);\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._checkCollision = function (collider) {\n    // Bounding box test\n    if (!this._boundingInfo || !this._boundingInfo._checkCollision(collider)) {\n      return this;\n    } // Transformation matrix\n\n\n    var collisionsScalingMatrix = TmpVectors.Matrix[0];\n    var collisionsTransformMatrix = TmpVectors.Matrix[1];\n    Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\n    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\n\n    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\n\n    return this;\n  }; // Picking\n\n  /** @hidden */\n\n\n  AbstractMesh.prototype._generatePointsArray = function () {\n    return false;\n  };\n  /**\r\n   * Checks if the passed Ray intersects with the mesh\r\n   * @param ray defines the ray to use\r\n   * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n   * @returns the picking info\r\n   * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n   */\n\n\n  AbstractMesh.prototype.intersects = function (ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo) {\n    var _a;\n\n    if (onlyBoundingInfo === void 0) {\n      onlyBoundingInfo = false;\n    }\n\n    if (skipBoundingInfo === void 0) {\n      skipBoundingInfo = false;\n    }\n\n    var pickingInfo = new PickingInfo();\n    var intersectionThreshold = this.getClassName() === \"InstancedLinesMesh\" || this.getClassName() === \"LinesMesh\" ? this.intersectionThreshold : 0;\n    var boundingInfo = this._boundingInfo;\n\n    if (!this.subMeshes || !boundingInfo) {\n      return pickingInfo;\n    }\n\n    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {\n      return pickingInfo;\n    }\n\n    if (onlyBoundingInfo) {\n      pickingInfo.hit = skipBoundingInfo ? false : true;\n      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\n      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n      pickingInfo.subMeshId = 0;\n      return pickingInfo;\n    }\n\n    if (!this._generatePointsArray()) {\n      return pickingInfo;\n    }\n\n    var intersectInfo = null;\n\n    var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\n\n    var len = subMeshes.length; // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\n    // if no submesh can be picked that way, then fallback to BBox picking\n\n    var anySubmeshSupportIntersect = false;\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index];\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        continue;\n      }\n\n      if (((_a = this.getIndices()) === null || _a === void 0 ? void 0 : _a.length) && (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2)) {\n        anySubmeshSupportIntersect = true;\n        break;\n      }\n    } // no sub mesh support intersection, fallback to BBox that has already be done\n\n\n    if (!anySubmeshSupportIntersect) {\n      pickingInfo.hit = true;\n      pickingInfo.pickedMesh = this;\n      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n      pickingInfo.subMeshId = -1;\n      return pickingInfo;\n    } // at least 1 submesh supports intersection, keep going\n\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index]; // Bounding test\n\n      if (len > 1 && !subMesh.canIntersects(ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);\n\n      if (currentIntersectInfo) {\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.subMeshId = index;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (intersectInfo) {\n      // Get picked point\n      var world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.skeleton && this.skeleton.overrideMesh ? this.skeleton.overrideMesh.getWorldMatrix() : this.getWorldMatrix();\n      var worldOrigin = TmpVectors.Vector3[0];\n      var direction = TmpVectors.Vector3[1];\n      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\n      ray.direction.scaleToRef(intersectInfo.distance, direction);\n      var worldDirection = Vector3.TransformNormal(direction, world);\n      var pickedPoint = worldDirection.addInPlace(worldOrigin); // Return result\n\n      pickingInfo.hit = true;\n      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\n      pickingInfo.pickedPoint = pickedPoint;\n      pickingInfo.pickedMesh = this;\n      pickingInfo.bu = intersectInfo.bu || 0;\n      pickingInfo.bv = intersectInfo.bv || 0;\n      pickingInfo.subMeshFaceId = intersectInfo.faceId;\n      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\n      pickingInfo.subMeshId = intersectInfo.subMeshId;\n      return pickingInfo;\n    }\n\n    return pickingInfo;\n  };\n  /**\r\n   * Clones the current mesh\r\n   * @param name defines the mesh name\r\n   * @param newParent defines the new mesh parent\r\n   * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\r\n   * @returns the new mesh\r\n   */\n\n\n  AbstractMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    return null;\n  };\n  /**\r\n   * Disposes all the submeshes of the current meshnp\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.releaseSubMeshes = function () {\n    if (this.subMeshes) {\n      while (this.subMeshes.length) {\n        this.subMeshes[0].dispose();\n      }\n    } else {\n      this.subMeshes = new Array();\n    }\n\n    return this;\n  };\n  /**\r\n   * Releases resources associated with this abstract mesh.\r\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n   */\n\n\n  AbstractMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    var _this = this;\n\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    var index; // mesh map release.\n\n    if (this._scene.useMaterialMeshMap) {\n      // remove from material mesh map id needed\n      if (this._material && this._material.meshMap) {\n        this._material.meshMap[this.uniqueId] = undefined;\n      }\n    } // Smart Array Retainers.\n\n\n    this.getScene().freeActiveMeshes();\n    this.getScene().freeRenderingGroups(); // Action manager\n\n    if (this.actionManager !== undefined && this.actionManager !== null) {\n      this.actionManager.dispose();\n      this.actionManager = null;\n    } // Skeleton\n\n\n    this._internalAbstractMeshDataInfo._skeleton = null;\n\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n\n      this._transformMatrixTexture = null;\n    } // Intersections in progress\n\n\n    for (index = 0; index < this._intersectionsInProgress.length; index++) {\n      var other = this._intersectionsInProgress[index];\n\n      var pos = other._intersectionsInProgress.indexOf(this);\n\n      other._intersectionsInProgress.splice(pos, 1);\n    }\n\n    this._intersectionsInProgress = []; // Lights\n\n    var lights = this.getScene().lights;\n    lights.forEach(function (light) {\n      var meshIndex = light.includedOnlyMeshes.indexOf(_this);\n\n      if (meshIndex !== -1) {\n        light.includedOnlyMeshes.splice(meshIndex, 1);\n      }\n\n      meshIndex = light.excludedMeshes.indexOf(_this);\n\n      if (meshIndex !== -1) {\n        light.excludedMeshes.splice(meshIndex, 1);\n      } // Shadow generators\n\n\n      var generator = light.getShadowGenerator();\n\n      if (generator) {\n        var shadowMap = generator.getShadowMap();\n\n        if (shadowMap && shadowMap.renderList) {\n          meshIndex = shadowMap.renderList.indexOf(_this);\n\n          if (meshIndex !== -1) {\n            shadowMap.renderList.splice(meshIndex, 1);\n          }\n        }\n      }\n    }); // SubMeshes\n\n    if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\n      this.releaseSubMeshes();\n    } // Query\n\n\n    var engine = this.getScene().getEngine();\n\n    if (this._occlusionQuery) {\n      this.isOcclusionQueryInProgress = false;\n      engine.deleteQuery(this._occlusionQuery);\n      this._occlusionQuery = null;\n    } // Engine\n\n\n    engine.wipeCaches(); // Remove from scene\n\n    this.getScene().removeMesh(this);\n\n    if (disposeMaterialAndTextures) {\n      if (this.material) {\n        if (this.material.getClassName() === \"MultiMaterial\") {\n          this.material.dispose(false, true, true);\n        } else {\n          this.material.dispose(false, true);\n        }\n      }\n    }\n\n    if (!doNotRecurse) {\n      // Particles\n      for (index = 0; index < this.getScene().particleSystems.length; index++) {\n        if (this.getScene().particleSystems[index].emitter === this) {\n          this.getScene().particleSystems[index].dispose();\n          index--;\n        }\n      }\n    } // facet data\n\n\n    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\n      this.disableFacetData();\n    }\n\n    this.onAfterWorldMatrixUpdateObservable.clear();\n    this.onCollideObservable.clear();\n    this.onCollisionPositionChangeObservable.clear();\n    this.onRebuildObservable.clear();\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\r\n   * Adds the passed mesh as a child to the current mesh\r\n   * @param mesh defines the child mesh\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.addChild = function (mesh) {\n    mesh.setParent(this);\n    return this;\n  };\n  /**\r\n   * Removes the passed mesh from the current mesh children list\r\n   * @param mesh defines the child mesh\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.removeChild = function (mesh) {\n    mesh.setParent(null);\n    return this;\n  }; // Facet data\n\n  /** @hidden */\n\n\n  AbstractMesh.prototype._initFacetData = function () {\n    var data = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!data.facetNormals) {\n      data.facetNormals = new Array();\n    }\n\n    if (!data.facetPositions) {\n      data.facetPositions = new Array();\n    }\n\n    if (!data.facetPartitioning) {\n      data.facetPartitioning = new Array();\n    }\n\n    data.facetNb = this.getIndices().length / 3 | 0;\n    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\n\n    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\n\n    for (var f = 0; f < data.facetNb; f++) {\n      data.facetNormals[f] = Vector3.Zero();\n      data.facetPositions[f] = Vector3.Zero();\n    }\n\n    data.facetDataEnabled = true;\n    return this;\n  };\n  /**\r\n   * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\r\n   * This method can be called within the render loop.\r\n   * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\r\n   * @returns the current mesh\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.updateFacetData = function () {\n    var data = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!data.facetDataEnabled) {\n      this._initFacetData();\n    }\n\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n    var indices = this.getIndices();\n    var normals = this.getVerticesData(VertexBuffer.NormalKind);\n    var bInfo = this.getBoundingInfo();\n\n    if (data.facetDepthSort && !data.facetDepthSortEnabled) {\n      // init arrays, matrix and sort function on first call\n      data.facetDepthSortEnabled = true;\n\n      if (indices instanceof Uint16Array) {\n        data.depthSortedIndices = new Uint16Array(indices);\n      } else if (indices instanceof Uint32Array) {\n        data.depthSortedIndices = new Uint32Array(indices);\n      } else {\n        var needs32bits = false;\n\n        for (var i = 0; i < indices.length; i++) {\n          if (indices[i] > 65535) {\n            needs32bits = true;\n            break;\n          }\n        }\n\n        if (needs32bits) {\n          data.depthSortedIndices = new Uint32Array(indices);\n        } else {\n          data.depthSortedIndices = new Uint16Array(indices);\n        }\n      }\n\n      data.facetDepthSortFunction = function (f1, f2) {\n        return f2.sqDistance - f1.sqDistance;\n      };\n\n      if (!data.facetDepthSortFrom) {\n        var camera = this.getScene().activeCamera;\n        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();\n      }\n\n      data.depthSortedFacets = [];\n\n      for (var f = 0; f < data.facetNb; f++) {\n        var depthSortedFacet = {\n          ind: f * 3,\n          sqDistance: 0.0\n        };\n        data.depthSortedFacets.push(depthSortedFacet);\n      }\n\n      data.invertedMatrix = Matrix.Identity();\n      data.facetDepthSortOrigin = Vector3.Zero();\n    }\n\n    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\n    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\n    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\n    var bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;\n    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;\n    data.subDiv.max = data.partitioningSubdivisions;\n    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax); // adjust the number of subdivisions per axis\n\n    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax); // according to each bbox size per axis\n\n    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);\n    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X; // at least one subdivision\n\n    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\n    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z; // set the parameters for ComputeNormals()\n\n    data.facetParameters.facetNormals = this.getFacetLocalNormals();\n    data.facetParameters.facetPositions = this.getFacetLocalPositions();\n    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\n    data.facetParameters.bInfo = bInfo;\n    data.facetParameters.bbSize = data.bbSize;\n    data.facetParameters.subDiv = data.subDiv;\n    data.facetParameters.ratio = this.partitioningBBoxRatio;\n    data.facetParameters.depthSort = data.facetDepthSort;\n\n    if (data.facetDepthSort && data.facetDepthSortEnabled) {\n      this.computeWorldMatrix(true);\n\n      this._worldMatrix.invertToRef(data.invertedMatrix);\n\n      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\n      data.facetParameters.distanceTo = data.facetDepthSortOrigin;\n    }\n\n    data.facetParameters.depthSortedFacets = data.depthSortedFacets;\n    VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\n\n    if (data.facetDepthSort && data.facetDepthSortEnabled) {\n      data.depthSortedFacets.sort(data.facetDepthSortFunction);\n      var l = data.depthSortedIndices.length / 3 | 0;\n\n      for (var f = 0; f < l; f++) {\n        var sind = data.depthSortedFacets[f].ind;\n        data.depthSortedIndices[f * 3] = indices[sind];\n        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];\n        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];\n      }\n\n      this.updateIndices(data.depthSortedIndices, undefined, true);\n    }\n\n    return this;\n  };\n  /**\r\n   * Returns the facetLocalNormals array.\r\n   * The normals are expressed in the mesh local spac\r\n   * @returns an array of Vector3\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalNormals = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetNormals) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetNormals;\n  };\n  /**\r\n   * Returns the facetLocalPositions array.\r\n   * The facet positions are expressed in the mesh local space\r\n   * @returns an array of Vector3\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalPositions = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetPositions) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetPositions;\n  };\n  /**\r\n   * Returns the facetLocalPartioning array\r\n   * @returns an array of array of numbers\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalPartitioning = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetPartitioning) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetPartitioning;\n  };\n  /**\r\n   * Returns the i-th facet position in the world system.\r\n   * This method allocates a new Vector3 per call\r\n   * @param i defines the facet index\r\n   * @returns a new Vector3\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetPosition = function (i) {\n    var pos = Vector3.Zero();\n    this.getFacetPositionToRef(i, pos);\n    return pos;\n  };\n  /**\r\n   * Sets the reference Vector3 with the i-th facet position in the world system\r\n   * @param i defines the facet index\r\n   * @param ref defines the target vector\r\n   * @returns the current mesh\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetPositionToRef = function (i, ref) {\n    var localPos = this.getFacetLocalPositions()[i];\n    var world = this.getWorldMatrix();\n    Vector3.TransformCoordinatesToRef(localPos, world, ref);\n    return this;\n  };\n  /**\r\n   * Returns the i-th facet normal in the world system.\r\n   * This method allocates a new Vector3 per call\r\n   * @param i defines the facet index\r\n   * @returns a new Vector3\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetNormal = function (i) {\n    var norm = Vector3.Zero();\n    this.getFacetNormalToRef(i, norm);\n    return norm;\n  };\n  /**\r\n   * Sets the reference Vector3 with the i-th facet normal in the world system\r\n   * @param i defines the facet index\r\n   * @param ref defines the target vector\r\n   * @returns the current mesh\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetNormalToRef = function (i, ref) {\n    var localNorm = this.getFacetLocalNormals()[i];\n    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\n    return this;\n  };\n  /**\r\n   * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\r\n   * @param x defines x coordinate\r\n   * @param y defines y coordinate\r\n   * @param z defines z coordinate\r\n   * @returns the array of facet indexes\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetsAtLocalCoordinates = function (x, y, z) {\n    var bInfo = this.getBoundingInfo();\n    var data = this._internalAbstractMeshDataInfo._facetData;\n    var ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);\n    var oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);\n    var oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);\n\n    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\n      return null;\n    }\n\n    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\n  };\n  /**\r\n   * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\r\n   * @param projected sets as the (x,y,z) world projection on the facet\r\n   * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n   * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n   * @param x defines x coordinate\r\n   * @param y defines y coordinate\r\n   * @param z defines z coordinate\r\n   * @returns the face index if found (or null instead)\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getClosestFacetAtCoordinates = function (x, y, z, projected, checkFace, facing) {\n    if (checkFace === void 0) {\n      checkFace = false;\n    }\n\n    if (facing === void 0) {\n      facing = true;\n    }\n\n    var world = this.getWorldMatrix();\n    var invMat = TmpVectors.Matrix[5];\n    world.invertToRef(invMat);\n    var invVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\n\n    var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\n\n    if (projected) {\n      // tranform the local computed projected vector to world coordinates\n      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\n    }\n\n    return closest;\n  };\n  /**\r\n   * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\r\n   * @param projected sets as the (x,y,z) local projection on the facet\r\n   * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n   * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n   * @param x defines x coordinate\r\n   * @param y defines y coordinate\r\n   * @param z defines z coordinate\r\n   * @returns the face index if found (or null instead)\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getClosestFacetAtLocalCoordinates = function (x, y, z, projected, checkFace, facing) {\n    if (checkFace === void 0) {\n      checkFace = false;\n    }\n\n    if (facing === void 0) {\n      facing = true;\n    }\n\n    var closest = null;\n    var tmpx = 0.0;\n    var tmpy = 0.0;\n    var tmpz = 0.0;\n    var d = 0.0; // tmp dot facet normal * facet position\n\n    var t0 = 0.0;\n    var projx = 0.0;\n    var projy = 0.0;\n    var projz = 0.0; // Get all the facets in the same partitioning block than (x, y, z)\n\n    var facetPositions = this.getFacetLocalPositions();\n    var facetNormals = this.getFacetLocalNormals();\n    var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\n\n    if (!facetsInBlock) {\n      return null;\n    } // Get the closest facet to (x, y, z)\n\n\n    var shortest = Number.MAX_VALUE; // init distance vars\n\n    var tmpDistance = shortest;\n    var fib; // current facet in the block\n\n    var norm; // current facet normal\n\n    var p0; // current facet barycenter position\n    // loop on all the facets in the current partitioning block\n\n    for (var idx = 0; idx < facetsInBlock.length; idx++) {\n      fib = facetsInBlock[idx];\n      norm = facetNormals[fib];\n      p0 = facetPositions[fib];\n      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\n\n      if (!checkFace || checkFace && facing && d >= 0.0 || checkFace && !facing && d <= 0.0) {\n        // compute (x,y,z) projection on the facet = (projx, projy, projz)\n        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\n        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\n        projx = x + norm.x * t0;\n        projy = y + norm.y * t0;\n        projz = z + norm.z * t0;\n        tmpx = projx - x;\n        tmpy = projy - y;\n        tmpz = projz - z;\n        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\n\n        if (tmpDistance < shortest) {\n          // just keep the closest facet to (x, y, z)\n          shortest = tmpDistance;\n          closest = fib;\n\n          if (projected) {\n            projected.x = projx;\n            projected.y = projy;\n            projected.z = projz;\n          }\n        }\n      }\n    }\n\n    return closest;\n  };\n  /**\r\n   * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\r\n   * @returns the parameters\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetDataParameters = function () {\n    return this._internalAbstractMeshDataInfo._facetData.facetParameters;\n  };\n  /**\r\n   * Disables the feature FacetData and frees the related memory\r\n   * @returns the current mesh\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.disableFacetData = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (facetData.facetDataEnabled) {\n      facetData.facetDataEnabled = false;\n      facetData.facetPositions = new Array();\n      facetData.facetNormals = new Array();\n      facetData.facetPartitioning = new Array();\n      facetData.facetParameters = null;\n      facetData.depthSortedIndices = new Uint32Array(0);\n    }\n\n    return this;\n  };\n  /**\r\n   * Updates the AbstractMesh indices array\r\n   * @param indices defines the data source\r\n   * @param offset defines the offset in the index buffer where to store the new data (can be null)\r\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n    if (gpuMemoryOnly === void 0) {\n      gpuMemoryOnly = false;\n    }\n\n    return this;\n  };\n  /**\r\n   * Creates new normals data for the mesh\r\n   * @param updatable defines if the normal vertex buffer must be flagged as updatable\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.createNormals = function (updatable) {\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n    var indices = this.getIndices();\n    var normals;\n\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      normals = this.getVerticesData(VertexBuffer.NormalKind);\n    } else {\n      normals = [];\n    }\n\n    VertexData.ComputeNormals(positions, indices, normals, {\n      useRightHandedSystem: this.getScene().useRightHandedSystem\n    });\n    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\n    return this;\n  };\n  /**\r\n   * Align the mesh with a normal\r\n   * @param normal defines the normal to use\r\n   * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.alignWithNormal = function (normal, upDirection) {\n    if (!upDirection) {\n      upDirection = Axis.Y;\n    }\n\n    var axisX = TmpVectors.Vector3[0];\n    var axisZ = TmpVectors.Vector3[1];\n    Vector3.CrossToRef(upDirection, normal, axisZ);\n    Vector3.CrossToRef(normal, axisZ, axisX);\n\n    if (this.rotationQuaternion) {\n      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\n    } else {\n      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._checkOcclusionQuery = function () {\n    return false;\n  };\n  /**\r\n   * Disables the mesh edge rendering mode\r\n   * @returns the currentAbstractMesh\r\n   */\n\n\n  AbstractMesh.prototype.disableEdgesRendering = function () {\n    throw _DevTools.WarnImport(\"EdgesRenderer\");\n  };\n  /**\r\n   * Enables the edge rendering mode on the mesh.\r\n   * This mode makes the mesh edges visible\r\n   * @param epsilon defines the maximal distance between two angles to detect a face\r\n   * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\r\n   * @param options options to the edge renderer\r\n   * @returns the currentAbstractMesh\r\n   * @see https://www.babylonjs-playground.com/#19O9TU#0\r\n   */\n\n\n  AbstractMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices, options) {\n    throw _DevTools.WarnImport(\"EdgesRenderer\");\n  };\n  /**\r\n   * This function returns all of the particle systems in the scene that use the mesh as an emitter.\r\n   * @returns an array of particle systems in the scene that use the mesh as an emitter\r\n   */\n\n\n  AbstractMesh.prototype.getConnectedParticleSystems = function () {\n    var _this = this;\n\n    return this._scene.particleSystems.filter(function (particleSystem) {\n      return particleSystem.emitter === _this;\n    });\n  };\n  /** No occlusion */\n\n\n  AbstractMesh.OCCLUSION_TYPE_NONE = 0;\n  /** Occlusion set to optimisitic */\n\n  AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;\n  /** Occlusion set to strict */\n\n  AbstractMesh.OCCLUSION_TYPE_STRICT = 2;\n  /** Use an accurante occlusion algorithm */\n\n  AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\n  /** Use a conservative occlusion algorithm */\n\n  AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\n  /** Default culling strategy : this is an exclusion test and it's the more accurate.\r\n   *  Test order :\r\n   *  Is the bounding sphere outside the frustum ?\r\n   *  If not, are the bounding box vertices outside the frustum ?\r\n   *  It not, then the cullable object is in the frustum.\r\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_STANDARD = 0;\n  /** Culling strategy : Bounding Sphere Only.\r\n   *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\r\n   *  It's also less accurate than the standard because some not visible objects can still be selected.\r\n   *  Test : is the bounding sphere outside the frustum ?\r\n   *  If not, then the cullable object is in the frustum.\r\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;\n  /** Culling strategy : Optimistic Inclusion.\r\n   *  This in an inclusion test first, then the standard exclusion test.\r\n   *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\r\n   *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\r\n   *  Anyway, it's as accurate as the standard strategy.\r\n   *  Test :\r\n   *  Is the cullable object bounding sphere center in the frustum ?\r\n   *  If not, apply the default culling strategy.\r\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;\n  /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\r\n   *  This in an inclusion test first, then the bounding sphere only exclusion test.\r\n   *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\r\n   *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\r\n   *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\r\n   *  Test :\r\n   *  Is the cullable object bounding sphere center in the frustum ?\r\n   *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\r\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;\n  return AbstractMesh;\n}(TransformNode);\n\nexport { AbstractMesh };\n_TypeStore.RegisteredTypes[\"BABYLON.AbstractMesh\"] = AbstractMesh;","map":null,"metadata":{},"sourceType":"module"}