{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { SubMesh } from \"../Meshes/subMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { AsyncLoop } from \"../Misc/tools\";\nimport { Epsilon } from '../Maths/math.constants';\n/**\r\n * Class used to specify simplification options\r\n * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification\r\n */\n\nvar SimplificationSettings =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a SimplificationSettings\r\n   * @param quality expected quality\r\n   * @param distance distance when this optimized version should be used\r\n   * @param optimizeMesh already optimized mesh\r\n   */\n  function SimplificationSettings(\n  /** expected quality */\n  quality,\n  /** distance when this optimized version should be used */\n  distance,\n  /** already optimized mesh  */\n  optimizeMesh) {\n    this.quality = quality;\n    this.distance = distance;\n    this.optimizeMesh = optimizeMesh;\n  }\n\n  return SimplificationSettings;\n}();\n\nexport { SimplificationSettings };\n/**\r\n * Queue used to order the simplification tasks\r\n * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification\r\n */\n\nvar SimplificationQueue =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new queue\r\n   */\n  function SimplificationQueue() {\n    this.running = false;\n    this._simplificationArray = [];\n  }\n  /**\r\n   * Adds a new simplification task\r\n   * @param task defines a task to add\r\n   */\n\n\n  SimplificationQueue.prototype.addTask = function (task) {\n    this._simplificationArray.push(task);\n  };\n  /**\r\n   * Execute next task\r\n   */\n\n\n  SimplificationQueue.prototype.executeNext = function () {\n    var task = this._simplificationArray.pop();\n\n    if (task) {\n      this.running = true;\n      this.runSimplification(task);\n    } else {\n      this.running = false;\n    }\n  };\n  /**\r\n   * Execute a simplification task\r\n   * @param task defines the task to run\r\n   */\n\n\n  SimplificationQueue.prototype.runSimplification = function (task) {\n    var _this = this;\n\n    if (task.parallelProcessing) {\n      //parallel simplifier\n      task.settings.forEach(function (setting) {\n        var simplifier = _this.getSimplifier(task);\n\n        simplifier.simplify(setting, function (newMesh) {\n          if (setting.distance !== undefined) {\n            task.mesh.addLODLevel(setting.distance, newMesh);\n          }\n\n          newMesh.isVisible = true; //check if it is the last\n\n          if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {\n            //all done, run the success callback.\n            task.successCallback();\n          }\n\n          _this.executeNext();\n        });\n      });\n    } else {\n      //single simplifier.\n      var simplifier = this.getSimplifier(task);\n\n      var runDecimation = function runDecimation(setting, callback) {\n        simplifier.simplify(setting, function (newMesh) {\n          if (setting.distance !== undefined) {\n            task.mesh.addLODLevel(setting.distance, newMesh);\n          }\n\n          newMesh.isVisible = true; //run the next quality level\n\n          callback();\n        });\n      };\n\n      AsyncLoop.Run(task.settings.length, function (loop) {\n        runDecimation(task.settings[loop.index], function () {\n          loop.executeNext();\n        });\n      }, function () {\n        //execution ended, run the success callback.\n        if (task.successCallback) {\n          task.successCallback();\n        }\n\n        _this.executeNext();\n      });\n    }\n  };\n\n  SimplificationQueue.prototype.getSimplifier = function (task) {\n    switch (task.simplificationType) {\n      case SimplificationType.QUADRATIC:\n      default:\n        return new QuadraticErrorSimplification(task.mesh);\n    }\n  };\n\n  return SimplificationQueue;\n}();\n\nexport { SimplificationQueue };\n/**\r\n * The implemented types of simplification\r\n * At the moment only Quadratic Error Decimation is implemented\r\n * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification\r\n */\n\nexport var SimplificationType;\n\n(function (SimplificationType) {\n  /** Quadratic error decimation */\n  SimplificationType[SimplificationType[\"QUADRATIC\"] = 0] = \"QUADRATIC\";\n})(SimplificationType || (SimplificationType = {}));\n\nvar DecimationTriangle =\n/** @class */\nfunction () {\n  function DecimationTriangle(vertices) {\n    this.vertices = vertices;\n    this.error = new Array(4);\n    this.deleted = false;\n    this.isDirty = false;\n    this.deletePending = false;\n    this.borderFactor = 0;\n  }\n\n  return DecimationTriangle;\n}();\n\nvar DecimationVertex =\n/** @class */\nfunction () {\n  function DecimationVertex(position, id) {\n    this.position = position;\n    this.id = id;\n    this.isBorder = true;\n    this.q = new QuadraticMatrix();\n    this.triangleCount = 0;\n    this.triangleStart = 0;\n    this.originalOffsets = [];\n  }\n\n  DecimationVertex.prototype.updatePosition = function (newPosition) {\n    this.position.copyFrom(newPosition);\n  };\n\n  return DecimationVertex;\n}();\n\nvar QuadraticMatrix =\n/** @class */\nfunction () {\n  function QuadraticMatrix(data) {\n    this.data = new Array(10);\n\n    for (var i = 0; i < 10; ++i) {\n      if (data && data[i]) {\n        this.data[i] = data[i];\n      } else {\n        this.data[i] = 0;\n      }\n    }\n  }\n\n  QuadraticMatrix.prototype.det = function (a11, a12, a13, a21, a22, a23, a31, a32, a33) {\n    var det = this.data[a11] * this.data[a22] * this.data[a33] + this.data[a13] * this.data[a21] * this.data[a32] + this.data[a12] * this.data[a23] * this.data[a31] - this.data[a13] * this.data[a22] * this.data[a31] - this.data[a11] * this.data[a23] * this.data[a32] - this.data[a12] * this.data[a21] * this.data[a33];\n    return det;\n  };\n\n  QuadraticMatrix.prototype.addInPlace = function (matrix) {\n    for (var i = 0; i < 10; ++i) {\n      this.data[i] += matrix.data[i];\n    }\n  };\n\n  QuadraticMatrix.prototype.addArrayInPlace = function (data) {\n    for (var i = 0; i < 10; ++i) {\n      this.data[i] += data[i];\n    }\n  };\n\n  QuadraticMatrix.prototype.add = function (matrix) {\n    var m = new QuadraticMatrix();\n\n    for (var i = 0; i < 10; ++i) {\n      m.data[i] = this.data[i] + matrix.data[i];\n    }\n\n    return m;\n  };\n\n  QuadraticMatrix.FromData = function (a, b, c, d) {\n    return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));\n  }; //returning an array to avoid garbage collection\n\n\n  QuadraticMatrix.DataFromNumbers = function (a, b, c, d) {\n    return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];\n  };\n\n  return QuadraticMatrix;\n}();\n\nvar Reference =\n/** @class */\nfunction () {\n  function Reference(vertexId, triangleId) {\n    this.vertexId = vertexId;\n    this.triangleId = triangleId;\n  }\n\n  return Reference;\n}();\n/**\r\n * An implementation of the Quadratic Error simplification algorithm.\r\n * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf\r\n * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS\r\n * @author RaananW\r\n * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification\r\n */\n\n\nvar QuadraticErrorSimplification =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new QuadraticErrorSimplification\r\n   * @param _mesh defines the target mesh\r\n   */\n  function QuadraticErrorSimplification(_mesh) {\n    this._mesh = _mesh;\n    /** Gets or sets the number pf sync interations */\n\n    this.syncIterations = 5000;\n    this.aggressiveness = 7;\n    this.decimationIterations = 100;\n    this.boundingBoxEpsilon = Epsilon;\n  }\n  /**\r\n   * Simplification of a given mesh according to the given settings.\r\n   * Since this requires computation, it is assumed that the function runs async.\r\n   * @param settings The settings of the simplification, including quality and distance\r\n   * @param successCallback A callback that will be called after the mesh was simplified.\r\n   */\n\n\n  QuadraticErrorSimplification.prototype.simplify = function (settings, successCallback) {\n    var _this = this;\n\n    this.initDecimatedMesh(); //iterating through the submeshes array, one after the other.\n\n    AsyncLoop.Run(this._mesh.subMeshes.length, function (loop) {\n      _this.initWithMesh(loop.index, function () {\n        _this.runDecimation(settings, loop.index, function () {\n          loop.executeNext();\n        });\n      }, settings.optimizeMesh);\n    }, function () {\n      setTimeout(function () {\n        successCallback(_this._reconstructedMesh);\n      }, 0);\n    });\n  };\n\n  QuadraticErrorSimplification.prototype.runDecimation = function (settings, submeshIndex, successCallback) {\n    var _this = this;\n\n    var targetCount = ~~(this.triangles.length * settings.quality);\n    var deletedTriangles = 0;\n    var triangleCount = this.triangles.length;\n\n    var iterationFunction = function iterationFunction(iteration, callback) {\n      setTimeout(function () {\n        if (iteration % 5 === 0) {\n          _this.updateMesh(iteration === 0);\n        }\n\n        for (var i = 0; i < _this.triangles.length; ++i) {\n          _this.triangles[i].isDirty = false;\n        }\n\n        var threshold = 0.000000001 * Math.pow(iteration + 3, _this.aggressiveness);\n\n        var trianglesIterator = function trianglesIterator(i) {\n          var tIdx = ~~((_this.triangles.length / 2 + i) % _this.triangles.length);\n          var t = _this.triangles[tIdx];\n\n          if (!t) {\n            return;\n          }\n\n          if (t.error[3] > threshold || t.deleted || t.isDirty) {\n            return;\n          }\n\n          for (var j = 0; j < 3; ++j) {\n            if (t.error[j] < threshold) {\n              var deleted0 = [];\n              var deleted1 = [];\n              var v0 = t.vertices[j];\n              var v1 = t.vertices[(j + 1) % 3];\n\n              if (v0.isBorder || v1.isBorder) {\n                continue;\n              }\n\n              var p = Vector3.Zero(); // var n = Vector3.Zero();\n              // var uv = Vector2.Zero();\n              // var color = new Color4(0, 0, 0, 1);\n\n              _this.calculateError(v0, v1, p);\n\n              var delTr = new Array();\n\n              if (_this.isFlipped(v0, v1, p, deleted0, delTr)) {\n                continue;\n              }\n\n              if (_this.isFlipped(v1, v0, p, deleted1, delTr)) {\n                continue;\n              }\n\n              if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {\n                continue;\n              }\n\n              var uniqueArray = new Array();\n              delTr.forEach(function (deletedT) {\n                if (uniqueArray.indexOf(deletedT) === -1) {\n                  deletedT.deletePending = true;\n                  uniqueArray.push(deletedT);\n                }\n              });\n\n              if (uniqueArray.length % 2 !== 0) {\n                continue;\n              }\n\n              v0.q = v1.q.add(v0.q);\n              v0.updatePosition(p);\n              var tStart = _this.references.length;\n              deletedTriangles = _this.updateTriangles(v0, v0, deleted0, deletedTriangles);\n              deletedTriangles = _this.updateTriangles(v0, v1, deleted1, deletedTriangles);\n              var tCount = _this.references.length - tStart;\n\n              if (tCount <= v0.triangleCount) {\n                if (tCount) {\n                  for (var c = 0; c < tCount; c++) {\n                    _this.references[v0.triangleStart + c] = _this.references[tStart + c];\n                  }\n                }\n              } else {\n                v0.triangleStart = tStart;\n              }\n\n              v0.triangleCount = tCount;\n              break;\n            }\n          }\n        };\n\n        AsyncLoop.SyncAsyncForLoop(_this.triangles.length, _this.syncIterations, trianglesIterator, callback, function () {\n          return triangleCount - deletedTriangles <= targetCount;\n        });\n      }, 0);\n    };\n\n    AsyncLoop.Run(this.decimationIterations, function (loop) {\n      if (triangleCount - deletedTriangles <= targetCount) {\n        loop.breakLoop();\n      } else {\n        iterationFunction(loop.index, function () {\n          loop.executeNext();\n        });\n      }\n    }, function () {\n      setTimeout(function () {\n        //reconstruct this part of the mesh\n        _this.reconstructMesh(submeshIndex);\n\n        successCallback();\n      }, 0);\n    });\n  };\n\n  QuadraticErrorSimplification.prototype.initWithMesh = function (submeshIndex, callback, optimizeMesh) {\n    var _this = this;\n\n    this.vertices = [];\n    this.triangles = [];\n\n    var positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);\n\n    var indices = this._mesh.getIndices();\n\n    var submesh = this._mesh.subMeshes[submeshIndex];\n\n    var findInVertices = function findInVertices(positionToSearch) {\n      if (optimizeMesh) {\n        for (var ii = 0; ii < _this.vertices.length; ++ii) {\n          if (_this.vertices[ii].position.equalsWithEpsilon(positionToSearch, 0.0001)) {\n            return _this.vertices[ii];\n          }\n        }\n      }\n\n      return null;\n    };\n\n    var vertexReferences = [];\n\n    var vertexInit = function vertexInit(i) {\n      if (!positionData) {\n        return;\n      }\n\n      var offset = i + submesh.verticesStart;\n      var position = Vector3.FromArray(positionData, offset * 3);\n      var vertex = findInVertices(position) || new DecimationVertex(position, _this.vertices.length);\n      vertex.originalOffsets.push(offset);\n\n      if (vertex.id === _this.vertices.length) {\n        _this.vertices.push(vertex);\n      }\n\n      vertexReferences.push(vertex.id);\n    }; //var totalVertices = mesh.getTotalVertices();\n\n\n    var totalVertices = submesh.verticesCount;\n    AsyncLoop.SyncAsyncForLoop(totalVertices, this.syncIterations / 4 >> 0, vertexInit, function () {\n      var indicesInit = function indicesInit(i) {\n        if (!indices) {\n          return;\n        }\n\n        var offset = submesh.indexStart / 3 + i;\n        var pos = offset * 3;\n        var i0 = indices[pos + 0];\n        var i1 = indices[pos + 1];\n        var i2 = indices[pos + 2];\n        var v0 = _this.vertices[vertexReferences[i0 - submesh.verticesStart]];\n        var v1 = _this.vertices[vertexReferences[i1 - submesh.verticesStart]];\n        var v2 = _this.vertices[vertexReferences[i2 - submesh.verticesStart]];\n        var triangle = new DecimationTriangle([v0, v1, v2]);\n        triangle.originalOffset = pos;\n\n        _this.triangles.push(triangle);\n      };\n\n      AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, _this.syncIterations, indicesInit, function () {\n        _this.init(callback);\n      });\n    });\n  };\n\n  QuadraticErrorSimplification.prototype.init = function (callback) {\n    var _this = this;\n\n    var triangleInit1 = function triangleInit1(i) {\n      var t = _this.triangles[i];\n      t.normal = Vector3.Cross(t.vertices[1].position.subtract(t.vertices[0].position), t.vertices[2].position.subtract(t.vertices[0].position)).normalize();\n\n      for (var j = 0; j < 3; j++) {\n        t.vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -Vector3.Dot(t.normal, t.vertices[0].position)));\n      }\n    };\n\n    AsyncLoop.SyncAsyncForLoop(this.triangles.length, this.syncIterations, triangleInit1, function () {\n      var triangleInit2 = function triangleInit2(i) {\n        var t = _this.triangles[i];\n\n        for (var j = 0; j < 3; ++j) {\n          t.error[j] = _this.calculateError(t.vertices[j], t.vertices[(j + 1) % 3]);\n        }\n\n        t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n      };\n\n      AsyncLoop.SyncAsyncForLoop(_this.triangles.length, _this.syncIterations, triangleInit2, function () {\n        callback();\n      });\n    });\n  };\n\n  QuadraticErrorSimplification.prototype.reconstructMesh = function (submeshIndex) {\n    var newTriangles = [];\n    var i;\n\n    for (i = 0; i < this.vertices.length; ++i) {\n      this.vertices[i].triangleCount = 0;\n    }\n\n    var t;\n    var j;\n\n    for (i = 0; i < this.triangles.length; ++i) {\n      if (!this.triangles[i].deleted) {\n        t = this.triangles[i];\n\n        for (j = 0; j < 3; ++j) {\n          t.vertices[j].triangleCount = 1;\n        }\n\n        newTriangles.push(t);\n      }\n    }\n\n    var newPositionData = this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || [];\n    var newNormalData = this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || [];\n    var newUVsData = this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || [];\n    var newColorsData = this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || [];\n\n    var normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);\n\n    var uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);\n\n    var colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);\n\n    var vertexCount = 0;\n\n    for (i = 0; i < this.vertices.length; ++i) {\n      var vertex = this.vertices[i];\n      vertex.id = vertexCount;\n\n      if (vertex.triangleCount) {\n        vertex.originalOffsets.forEach(function (originalOffset) {\n          newPositionData.push(vertex.position.x);\n          newPositionData.push(vertex.position.y);\n          newPositionData.push(vertex.position.z);\n\n          if (normalData && normalData.length) {\n            newNormalData.push(normalData[originalOffset * 3]);\n            newNormalData.push(normalData[originalOffset * 3 + 1]);\n            newNormalData.push(normalData[originalOffset * 3 + 2]);\n          }\n\n          if (uvs && uvs.length) {\n            newUVsData.push(uvs[originalOffset * 2]);\n            newUVsData.push(uvs[originalOffset * 2 + 1]);\n          }\n\n          if (colorsData && colorsData.length) {\n            newColorsData.push(colorsData[originalOffset * 4]);\n            newColorsData.push(colorsData[originalOffset * 4 + 1]);\n            newColorsData.push(colorsData[originalOffset * 4 + 2]);\n            newColorsData.push(colorsData[originalOffset * 4 + 3]);\n          }\n\n          ++vertexCount;\n        });\n      }\n    }\n\n    var startingIndex = this._reconstructedMesh.getTotalIndices();\n\n    var startingVertex = this._reconstructedMesh.getTotalVertices();\n\n    var submeshesArray = this._reconstructedMesh.subMeshes;\n    this._reconstructedMesh.subMeshes = [];\n\n    var newIndicesArray = this._reconstructedMesh.getIndices(); //[];\n\n\n    var originalIndices = this._mesh.getIndices();\n\n    for (i = 0; i < newTriangles.length; ++i) {\n      t = newTriangles[i]; //now get the new referencing point for each vertex\n\n      [0, 1, 2].forEach(function (idx) {\n        var id = originalIndices[t.originalOffset + idx];\n        var offset = t.vertices[idx].originalOffsets.indexOf(id);\n\n        if (offset < 0) {\n          offset = 0;\n        }\n\n        newIndicesArray.push(t.vertices[idx].id + offset + startingVertex);\n      });\n    } //overwriting the old vertex buffers and indices.\n\n\n    this._reconstructedMesh.setIndices(newIndicesArray);\n\n    this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);\n\n    if (newNormalData.length > 0) {\n      this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);\n    }\n\n    if (newUVsData.length > 0) {\n      this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);\n    }\n\n    if (newColorsData.length > 0) {\n      this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);\n    } //create submesh\n\n\n    var originalSubmesh = this._mesh.subMeshes[submeshIndex];\n\n    if (submeshIndex > 0) {\n      this._reconstructedMesh.subMeshes = [];\n      submeshesArray.forEach(function (submesh) {\n        SubMesh.AddToMesh(submesh.materialIndex, submesh.verticesStart, submesh.verticesCount,\n        /* 0, newPositionData.length/3, */\n        submesh.indexStart, submesh.indexCount, submesh.getMesh());\n      });\n      SubMesh.AddToMesh(originalSubmesh.materialIndex, startingVertex, vertexCount,\n      /* 0, newPositionData.length / 3, */\n      startingIndex, newTriangles.length * 3, this._reconstructedMesh);\n    }\n  };\n\n  QuadraticErrorSimplification.prototype.initDecimatedMesh = function () {\n    this._reconstructedMesh = new Mesh(this._mesh.name + \"Decimated\", this._mesh.getScene());\n    this._reconstructedMesh.material = this._mesh.material;\n    this._reconstructedMesh.parent = this._mesh.parent;\n    this._reconstructedMesh.isVisible = false;\n    this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;\n  };\n\n  QuadraticErrorSimplification.prototype.isFlipped = function (vertex1, vertex2, point, deletedArray, delTr) {\n    for (var i = 0; i < vertex1.triangleCount; ++i) {\n      var t = this.triangles[this.references[vertex1.triangleStart + i].triangleId];\n\n      if (t.deleted) {\n        continue;\n      }\n\n      var s = this.references[vertex1.triangleStart + i].vertexId;\n      var v1 = t.vertices[(s + 1) % 3];\n      var v2 = t.vertices[(s + 2) % 3];\n\n      if (v1 === vertex2 || v2 === vertex2) {\n        deletedArray[i] = true;\n        delTr.push(t);\n        continue;\n      }\n\n      var d1 = v1.position.subtract(point);\n      d1 = d1.normalize();\n      var d2 = v2.position.subtract(point);\n      d2 = d2.normalize();\n\n      if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {\n        return true;\n      }\n\n      var normal = Vector3.Cross(d1, d2).normalize();\n      deletedArray[i] = false;\n\n      if (Vector3.Dot(normal, t.normal) < 0.2) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  QuadraticErrorSimplification.prototype.updateTriangles = function (origVertex, vertex, deletedArray, deletedTriangles) {\n    var newDeleted = deletedTriangles;\n\n    for (var i = 0; i < vertex.triangleCount; ++i) {\n      var ref = this.references[vertex.triangleStart + i];\n      var t = this.triangles[ref.triangleId];\n\n      if (t.deleted) {\n        continue;\n      }\n\n      if (deletedArray[i] && t.deletePending) {\n        t.deleted = true;\n        newDeleted++;\n        continue;\n      }\n\n      t.vertices[ref.vertexId] = origVertex;\n      t.isDirty = true;\n      t.error[0] = this.calculateError(t.vertices[0], t.vertices[1]) + t.borderFactor / 2;\n      t.error[1] = this.calculateError(t.vertices[1], t.vertices[2]) + t.borderFactor / 2;\n      t.error[2] = this.calculateError(t.vertices[2], t.vertices[0]) + t.borderFactor / 2;\n      t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n      this.references.push(ref);\n    }\n\n    return newDeleted;\n  };\n\n  QuadraticErrorSimplification.prototype.identifyBorder = function () {\n    for (var i = 0; i < this.vertices.length; ++i) {\n      var vCount = [];\n      var vId = [];\n      var v = this.vertices[i];\n      var j;\n\n      for (j = 0; j < v.triangleCount; ++j) {\n        var triangle = this.triangles[this.references[v.triangleStart + j].triangleId];\n\n        for (var ii = 0; ii < 3; ii++) {\n          var ofs = 0;\n          var vv = triangle.vertices[ii];\n\n          while (ofs < vCount.length) {\n            if (vId[ofs] === vv.id) {\n              break;\n            }\n\n            ++ofs;\n          }\n\n          if (ofs === vCount.length) {\n            vCount.push(1);\n            vId.push(vv.id);\n          } else {\n            vCount[ofs]++;\n          }\n        }\n      }\n\n      for (j = 0; j < vCount.length; ++j) {\n        if (vCount[j] === 1) {\n          this.vertices[vId[j]].isBorder = true;\n        } else {\n          this.vertices[vId[j]].isBorder = false;\n        }\n      }\n    }\n  };\n\n  QuadraticErrorSimplification.prototype.updateMesh = function (identifyBorders) {\n    if (identifyBorders === void 0) {\n      identifyBorders = false;\n    }\n\n    var i;\n\n    if (!identifyBorders) {\n      var newTrianglesVector = [];\n\n      for (i = 0; i < this.triangles.length; ++i) {\n        if (!this.triangles[i].deleted) {\n          newTrianglesVector.push(this.triangles[i]);\n        }\n      }\n\n      this.triangles = newTrianglesVector;\n    }\n\n    for (i = 0; i < this.vertices.length; ++i) {\n      this.vertices[i].triangleCount = 0;\n      this.vertices[i].triangleStart = 0;\n    }\n\n    var t;\n    var j;\n    var v;\n\n    for (i = 0; i < this.triangles.length; ++i) {\n      t = this.triangles[i];\n\n      for (j = 0; j < 3; ++j) {\n        v = t.vertices[j];\n        v.triangleCount++;\n      }\n    }\n\n    var tStart = 0;\n\n    for (i = 0; i < this.vertices.length; ++i) {\n      this.vertices[i].triangleStart = tStart;\n      tStart += this.vertices[i].triangleCount;\n      this.vertices[i].triangleCount = 0;\n    }\n\n    var newReferences = new Array(this.triangles.length * 3);\n\n    for (i = 0; i < this.triangles.length; ++i) {\n      t = this.triangles[i];\n\n      for (j = 0; j < 3; ++j) {\n        v = t.vertices[j];\n        newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);\n        v.triangleCount++;\n      }\n    }\n\n    this.references = newReferences;\n\n    if (identifyBorders) {\n      this.identifyBorder();\n    }\n  };\n\n  QuadraticErrorSimplification.prototype.vertexError = function (q, point) {\n    var x = point.x;\n    var y = point.y;\n    var z = point.z;\n    return q.data[0] * x * x + 2 * q.data[1] * x * y + 2 * q.data[2] * x * z + 2 * q.data[3] * x + q.data[4] * y * y + 2 * q.data[5] * y * z + 2 * q.data[6] * y + q.data[7] * z * z + 2 * q.data[8] * z + q.data[9];\n  };\n\n  QuadraticErrorSimplification.prototype.calculateError = function (vertex1, vertex2, pointResult) {\n    var q = vertex1.q.add(vertex2.q);\n    var border = vertex1.isBorder && vertex2.isBorder;\n    var error = 0;\n    var qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);\n\n    if (qDet !== 0 && !border) {\n      if (!pointResult) {\n        pointResult = Vector3.Zero();\n      }\n\n      pointResult.x = -1 / qDet * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);\n      pointResult.y = 1 / qDet * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);\n      pointResult.z = -1 / qDet * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);\n      error = this.vertexError(q, pointResult);\n    } else {\n      var p3 = vertex1.position.add(vertex2.position).divide(new Vector3(2, 2, 2)); //var norm3 = (vertex1.normal.add(vertex2.normal)).divide(new Vector3(2, 2, 2)).normalize();\n\n      var error1 = this.vertexError(q, vertex1.position);\n      var error2 = this.vertexError(q, vertex2.position);\n      var error3 = this.vertexError(q, p3);\n      error = Math.min(error1, error2, error3);\n\n      if (error === error1) {\n        if (pointResult) {\n          pointResult.copyFrom(vertex1.position);\n        }\n      } else if (error === error2) {\n        if (pointResult) {\n          pointResult.copyFrom(vertex2.position);\n        }\n      } else {\n        if (pointResult) {\n          pointResult.copyFrom(p3);\n        }\n      }\n    }\n\n    return error;\n  };\n\n  return QuadraticErrorSimplification;\n}();\n\nexport { QuadraticErrorSimplification };","map":null,"metadata":{},"sourceType":"module"}