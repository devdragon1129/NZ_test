{"ast":null,"code":"import { __assign, __decorate } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\nimport { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { SubMesh } from \"../Meshes/subMesh\";\nimport { UniformBuffer } from \"./uniformBuffer\";\nimport { Logger } from \"../Misc/logger\";\nimport { Plane } from '../Maths/math.plane';\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\n\nvar Material =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a material instance\r\n   * @param name defines the name of the material\r\n   * @param scene defines the scene to reference\r\n   * @param doNotAdd specifies if the material should be added to the scene\r\n   */\n  function Material(name, scene, doNotAdd) {\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\n    this.shadowDepthWrapper = null;\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\n\n    this.allowShaderHotSwapping = true;\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\n\n    this.metadata = null;\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\n\n    this.reservedDataStore = null;\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\n\n    this.checkReadyOnEveryCall = false;\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\n\n    this.checkReadyOnlyOnce = false;\n    /**\r\n     * The state of the material\r\n     */\n\n    this.state = \"\";\n    /**\r\n     * The alpha value of the material\r\n     */\n\n    this._alpha = 1.0;\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\n\n    this._backFaceCulling = true;\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\n\n    this.onCompiled = null;\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\n\n    this.onError = null;\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\n\n    this.getRenderTargetTextures = null;\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\n\n    this.doNotSerialize = false;\n    /**\r\n     * @hidden\r\n     */\n\n    this._storeEffectOnSubMeshes = false;\n    /**\r\n     * Stores the animations for the material\r\n     */\n\n    this.animations = null;\n    /**\r\n    * An event triggered when the material is disposed\r\n    */\n\n    this.onDisposeObservable = new Observable();\n    /**\r\n     * An observer which watches for dispose events\r\n     */\n\n    this._onDisposeObserver = null;\n    this._onUnBindObservable = null;\n    /**\r\n     * An observer which watches for bind events\r\n     */\n\n    this._onBindObserver = null;\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\n\n    this._alphaMode = 2;\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\n\n    this._needDepthPrePass = false;\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\n\n    this.disableDepthWrite = false;\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\n\n    this.disableColorWrite = false;\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\n\n    this.forceDepthWrite = false;\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\n\n    this.depthFunction = 0;\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\n\n    this.separateCullingPass = false;\n    /**\r\n     * Stores the state specifing if fog should be enabled\r\n     */\n\n    this._fogEnabled = true;\n    /**\r\n     * Stores the size of points\r\n     */\n\n    this.pointSize = 1.0;\n    /**\r\n     * Stores the z offset value\r\n     */\n\n    this.zOffset = 0;\n    /**\r\n     * @hidden\r\n     * Stores the effects for the material\r\n     */\n\n    this._effect = null;\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\n\n    this._useUBO = false;\n    /**\r\n     * Stores the fill mode state\r\n     */\n\n    this._fillMode = Material.TriangleFillMode;\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\n\n    this._cachedDepthWriteState = false;\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\n\n    this._cachedColorWriteState = false;\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\n\n    this._cachedDepthFunctionState = 0;\n    /** @hidden */\n\n    this._indexInSceneMaterialArray = -1;\n    /** @hidden */\n\n    this.meshMap = null;\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\n\n    this._forceAlphaTest = false;\n    /**\r\n     * The transparency mode of the material.\r\n     */\n\n    this._transparencyMode = null;\n    this.name = name;\n    var idSubscript = 1;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.id = name || Tools.RandomId();\n\n    while (this._scene.getMaterialByID(this.id)) {\n      this.id = name + \" \" + idSubscript++;\n    }\n\n    this.uniqueId = this._scene.getUniqueId();\n\n    if (this._scene.useRightHandedSystem) {\n      this.sideOrientation = Material.ClockWiseSideOrientation;\n    } else {\n      this.sideOrientation = Material.CounterClockWiseSideOrientation;\n    }\n\n    this._uniformBuffer = new UniformBuffer(this._scene.getEngine());\n    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\n\n    if (!doNotAdd) {\n      this._scene.addMaterial(this);\n    }\n\n    if (this._scene.useMaterialMeshMap) {\n      this.meshMap = {};\n    }\n  }\n\n  Object.defineProperty(Material.prototype, \"canRenderToMRT\", {\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\n    get: function get() {\n      // By default, shaders are not compatible with MRTs\n      // Base classes should override that if their shader supports MRT\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"alpha\", {\n    /**\r\n     * Gets the alpha value of the material\r\n     */\n    get: function get() {\n      return this._alpha;\n    },\n\n    /**\r\n     * Sets the alpha value of the material\r\n     */\n    set: function set(value) {\n      if (this._alpha === value) {\n        return;\n      }\n\n      this._alpha = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"backFaceCulling\", {\n    /**\r\n     * Gets the back-face culling state\r\n     */\n    get: function get() {\n      return this._backFaceCulling;\n    },\n\n    /**\r\n     * Sets the back-face culling state\r\n     */\n    set: function set(value) {\n      if (this._backFaceCulling === value) {\n        return;\n      }\n\n      this._backFaceCulling = value;\n      this.markAsDirty(Material.TextureDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"hasRenderTargetTextures\", {\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onDispose\", {\n    /**\r\n     * Called during a dispose event\r\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onBindObservable\", {\n    /**\r\n    * An event triggered when the material is bound\r\n    */\n    get: function get() {\n      if (!this._onBindObservable) {\n        this._onBindObservable = new Observable();\n      }\n\n      return this._onBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onBind\", {\n    /**\r\n     * Called during a bind event\r\n     */\n    set: function set(callback) {\n      if (this._onBindObserver) {\n        this.onBindObservable.remove(this._onBindObserver);\n      }\n\n      this._onBindObserver = this.onBindObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onUnBindObservable\", {\n    /**\r\n    * An event triggered when the material is unbound\r\n    */\n    get: function get() {\n      if (!this._onUnBindObservable) {\n        this._onUnBindObservable = new Observable();\n      }\n\n      return this._onUnBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onEffectCreatedObservable\", {\n    /**\r\n    * An event triggered when the effect is (re)created\r\n    */\n    get: function get() {\n      if (!this._onEffectCreatedObservable) {\n        this._onEffectCreatedObservable = new Observable();\n      }\n\n      return this._onEffectCreatedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"alphaMode\", {\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\n    get: function get() {\n      return this._alphaMode;\n    },\n\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\n    set: function set(value) {\n      if (this._alphaMode === value) {\n        return;\n      }\n\n      this._alphaMode = value;\n      this.markAsDirty(Material.TextureDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"needDepthPrePass\", {\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\n    get: function get() {\n      return this._needDepthPrePass;\n    },\n\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\n    set: function set(value) {\n      if (this._needDepthPrePass === value) {\n        return;\n      }\n\n      this._needDepthPrePass = value;\n\n      if (this._needDepthPrePass) {\n        this.checkReadyOnEveryCall = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"fogEnabled\", {\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\n    get: function get() {\n      return this._fogEnabled;\n    },\n\n    /**\r\n     * Sets the state for enabling fog\r\n     */\n    set: function set(value) {\n      if (this._fogEnabled === value) {\n        return;\n      }\n\n      this._fogEnabled = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"wireframe\", {\n    get: function get() {\n      switch (this._fillMode) {\n        case Material.WireFrameFillMode:\n        case Material.LineListDrawMode:\n        case Material.LineLoopDrawMode:\n        case Material.LineStripDrawMode:\n          return true;\n      }\n\n      return this._scene.forceWireframe;\n    },\n\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\n    set: function set(value) {\n      this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"pointsCloud\", {\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\n    get: function get() {\n      switch (this._fillMode) {\n        case Material.PointFillMode:\n        case Material.PointListDrawMode:\n          return true;\n      }\n\n      return this._scene.forcePointsCloud;\n    },\n\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\n    set: function set(value) {\n      this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"fillMode\", {\n    /**\r\n     * Gets the material fill mode\r\n     */\n    get: function get() {\n      return this._fillMode;\n    },\n\n    /**\r\n     * Sets the material fill mode\r\n     */\n    set: function set(value) {\n      if (this._fillMode === value) {\n        return;\n      }\n\n      this._fillMode = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns a string representation of the current material\r\n   * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n   * @returns a string with material information\r\n   */\n\n  Material.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n\n    if (fullDetails) {}\n\n    return ret;\n  };\n  /**\r\n   * Gets the class name of the material\r\n   * @returns a string with the class name of the material\r\n   */\n\n\n  Material.prototype.getClassName = function () {\n    return \"Material\";\n  };\n\n  Object.defineProperty(Material.prototype, \"isFrozen\", {\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\n    get: function get() {\n      return this.checkReadyOnlyOnce;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Locks updates for the material\r\n   */\n\n  Material.prototype.freeze = function () {\n    this.markDirty();\n    this.checkReadyOnlyOnce = true;\n  };\n  /**\r\n   * Unlocks updates for the material\r\n   */\n\n\n  Material.prototype.unfreeze = function () {\n    this.markDirty();\n    this.checkReadyOnlyOnce = false;\n  };\n  /**\r\n   * Specifies if the material is ready to be used\r\n   * @param mesh defines the mesh to check\r\n   * @param useInstances specifies if instances should be used\r\n   * @returns a boolean indicating if the material is ready to be used\r\n   */\n\n\n  Material.prototype.isReady = function (mesh, useInstances) {\n    return true;\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used\r\n   * @param mesh defines the mesh to check\r\n   * @param subMesh defines which submesh to check\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns a boolean indicating that the submesh is ready or not\r\n   */\n\n\n  Material.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    return false;\n  };\n  /**\r\n   * Returns the material effect\r\n   * @returns the effect associated with the material\r\n   */\n\n\n  Material.prototype.getEffect = function () {\n    return this._effect;\n  };\n  /**\r\n   * Returns the current scene\r\n   * @returns a Scene\r\n   */\n\n\n  Material.prototype.getScene = function () {\n    return this._scene;\n  };\n\n  Object.defineProperty(Material.prototype, \"transparencyMode\", {\n    /**\r\n     * Gets the current transparency mode.\r\n     */\n    get: function get() {\n      return this._transparencyMode;\n    },\n\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\n    set: function set(value) {\n      if (this._transparencyMode === value) {\n        return;\n      }\n\n      this._transparencyMode = value;\n      this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;\n\n      this._markAllSubMeshesAsTexturesAndMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"_disableAlphaBlending\", {\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\n    get: function get() {\n      return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Specifies whether or not this material should be rendered in alpha blend mode.\r\n   * @returns a boolean specifying if alpha blending is needed\r\n   */\n\n  Material.prototype.needAlphaBlending = function () {\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n\n    return this.alpha < 1.0;\n  };\n  /**\r\n   * Specifies if the mesh will require alpha blending\r\n   * @param mesh defines the mesh to check\r\n   * @returns a boolean specifying if alpha blending is needed for the mesh\r\n   */\n\n\n  Material.prototype.needAlphaBlendingForMesh = function (mesh) {\n    if (this._disableAlphaBlending && mesh.visibility >= 1.0) {\n      return false;\n    }\n\n    return this.needAlphaBlending() || mesh.visibility < 1.0 || mesh.hasVertexAlpha;\n  };\n  /**\r\n   * Specifies whether or not this material should be rendered in alpha test mode.\r\n   * @returns a boolean specifying if an alpha test is needed.\r\n   */\n\n\n  Material.prototype.needAlphaTesting = function () {\n    if (this._forceAlphaTest) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Specifies if material alpha testing should be turned on for the mesh\r\n   * @param mesh defines the mesh to check\r\n   */\n\n\n  Material.prototype._shouldTurnAlphaTestOn = function (mesh) {\n    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\n  };\n  /**\r\n   * Gets the texture used for the alpha test\r\n   * @returns the texture to use for alpha testing\r\n   */\n\n\n  Material.prototype.getAlphaTestTexture = function () {\n    return null;\n  };\n  /**\r\n   * Marks the material to indicate that it needs to be re-calculated\r\n   */\n\n\n  Material.prototype.markDirty = function () {\n    var meshes = this.getScene().meshes;\n\n    for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\n      var mesh = meshes_1[_i];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        if (!subMesh.effect) {\n          continue;\n        }\n\n        subMesh.effect._wasPreviouslyReady = false;\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Material.prototype._preBind = function (effect, overrideOrientation) {\n    if (overrideOrientation === void 0) {\n      overrideOrientation = null;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\n    var reverse = orientation === Material.ClockWiseSideOrientation;\n    engine.enableEffect(effect ? effect : this._effect);\n    engine.setState(this.backFaceCulling, this.zOffset, false, reverse);\n    return reverse;\n  };\n  /**\r\n   * Binds the material to the mesh\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh to bind the material to\r\n   */\n\n\n  Material.prototype.bind = function (world, mesh) {};\n  /**\r\n   * Binds the submesh to the material\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh containing the submesh\r\n   * @param subMesh defines the submesh to bind the material to\r\n   */\n\n\n  Material.prototype.bindForSubMesh = function (world, mesh, subMesh) {};\n  /**\r\n   * Binds the world matrix to the material\r\n   * @param world defines the world transformation matrix\r\n   */\n\n\n  Material.prototype.bindOnlyWorldMatrix = function (world) {};\n  /**\r\n   * Binds the scene's uniform buffer to the effect.\r\n   * @param effect defines the effect to bind to the scene uniform buffer\r\n   * @param sceneUbo defines the uniform buffer storing scene data\r\n   */\n\n\n  Material.prototype.bindSceneUniformBuffer = function (effect, sceneUbo) {\n    sceneUbo.bindToEffect(effect, \"Scene\");\n  };\n  /**\r\n   * Binds the view matrix to the effect\r\n   * @param effect defines the effect to bind the view matrix to\r\n   */\n\n\n  Material.prototype.bindView = function (effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n    } else {\n      this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n    }\n  };\n  /**\r\n   * Binds the view projection matrix to the effect\r\n   * @param effect defines the effect to bind the view projection matrix to\r\n   */\n\n\n  Material.prototype.bindViewProjection = function (effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n    } else {\n      this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n    }\n  };\n  /**\r\n   * Processes to execute after binding the material to a mesh\r\n   * @param mesh defines the rendered mesh\r\n   */\n\n\n  Material.prototype._afterBind = function (mesh) {\n    this._scene._cachedMaterial = this;\n\n    if (mesh) {\n      this._scene._cachedVisibility = mesh.visibility;\n    } else {\n      this._scene._cachedVisibility = 1;\n    }\n\n    if (this._onBindObservable && mesh) {\n      this._onBindObservable.notifyObservers(mesh);\n    }\n\n    if (this.disableDepthWrite) {\n      var engine = this._scene.getEngine();\n\n      this._cachedDepthWriteState = engine.getDepthWrite();\n      engine.setDepthWrite(false);\n    }\n\n    if (this.disableColorWrite) {\n      var engine = this._scene.getEngine();\n\n      this._cachedColorWriteState = engine.getColorWrite();\n      engine.setColorWrite(false);\n    }\n\n    if (this.depthFunction !== 0) {\n      var engine = this._scene.getEngine();\n\n      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\n      engine.setDepthFunction(this.depthFunction);\n    }\n  };\n  /**\r\n   * Unbinds the material from the mesh\r\n   */\n\n\n  Material.prototype.unbind = function () {\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.notifyObservers(this);\n    }\n\n    if (this.depthFunction !== 0) {\n      var engine = this._scene.getEngine();\n\n      engine.setDepthFunction(this._cachedDepthFunctionState);\n    }\n\n    if (this.disableDepthWrite) {\n      var engine = this._scene.getEngine();\n\n      engine.setDepthWrite(this._cachedDepthWriteState);\n    }\n\n    if (this.disableColorWrite) {\n      var engine = this._scene.getEngine();\n\n      engine.setColorWrite(this._cachedColorWriteState);\n    }\n  };\n  /**\r\n   * Gets the active textures from the material\r\n   * @returns an array of textures\r\n   */\n\n\n  Material.prototype.getActiveTextures = function () {\n    return [];\n  };\n  /**\r\n   * Specifies if the material uses a texture\r\n   * @param texture defines the texture to check against the material\r\n   * @returns a boolean specifying if the material uses the texture\r\n   */\n\n\n  Material.prototype.hasTexture = function (texture) {\n    return false;\n  };\n  /**\r\n   * Makes a duplicate of the material, and gives it a new name\r\n   * @param name defines the new name for the duplicated material\r\n   * @returns the cloned material\r\n   */\n\n\n  Material.prototype.clone = function (name) {\n    return null;\n  };\n  /**\r\n   * Gets the meshes bound to the material\r\n   * @returns an array of meshes bound to the material\r\n   */\n\n\n  Material.prototype.getBindedMeshes = function () {\n    var _this = this;\n\n    if (this.meshMap) {\n      var result = new Array();\n\n      for (var meshId in this.meshMap) {\n        var mesh = this.meshMap[meshId];\n\n        if (mesh) {\n          result.push(mesh);\n        }\n      }\n\n      return result;\n    } else {\n      var meshes = this._scene.meshes;\n      return meshes.filter(function (mesh) {\n        return mesh.material === _this;\n      });\n    }\n  };\n  /**\r\n   * Force shader compilation\r\n   * @param mesh defines the mesh associated with this material\r\n   * @param onCompiled defines a function to execute once the material is compiled\r\n   * @param options defines the options to configure the compilation\r\n   * @param onError defines a function to execute if the material fails compiling\r\n   */\n\n\n  Material.prototype.forceCompilation = function (mesh, onCompiled, options, onError) {\n    var _this = this;\n\n    var localOptions = __assign({\n      clipPlane: false,\n      useInstances: false\n    }, options);\n\n    var scene = this.getScene();\n    var currentHotSwapingState = this.allowShaderHotSwapping;\n    this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\n\n    var checkReady = function checkReady() {\n      if (!_this._scene || !_this._scene.getEngine()) {\n        return;\n      }\n\n      var clipPlaneState = scene.clipPlane;\n\n      if (localOptions.clipPlane) {\n        scene.clipPlane = new Plane(0, 0, 0, 1);\n      }\n\n      if (_this._storeEffectOnSubMeshes) {\n        var allDone = true,\n            lastError = null;\n\n        if (mesh.subMeshes) {\n          var tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\n\n          if (tempSubMesh._materialDefines) {\n            tempSubMesh._materialDefines._renderId = -1;\n          }\n\n          if (!_this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\n            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\n              lastError = tempSubMesh.effect.getCompilationError();\n            } else {\n              allDone = false;\n              setTimeout(checkReady, 16);\n            }\n          }\n        }\n\n        if (allDone) {\n          _this.allowShaderHotSwapping = currentHotSwapingState;\n\n          if (lastError) {\n            if (onError) {\n              onError(lastError);\n            }\n          }\n\n          if (onCompiled) {\n            onCompiled(_this);\n          }\n        }\n      } else {\n        if (_this.isReady()) {\n          _this.allowShaderHotSwapping = currentHotSwapingState;\n\n          if (onCompiled) {\n            onCompiled(_this);\n          }\n        } else {\n          setTimeout(checkReady, 16);\n        }\n      }\n\n      if (localOptions.clipPlane) {\n        scene.clipPlane = clipPlaneState;\n      }\n    };\n\n    checkReady();\n  };\n  /**\r\n   * Force shader compilation\r\n   * @param mesh defines the mesh that will use this material\r\n   * @param options defines additional options for compiling the shaders\r\n   * @returns a promise that resolves when the compilation completes\r\n   */\n\n\n  Material.prototype.forceCompilationAsync = function (mesh, options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.forceCompilation(mesh, function () {\n        resolve();\n      }, options, function (reason) {\n        reject(reason);\n      });\n    });\n  };\n  /**\r\n   * Marks a define in the material to indicate that it needs to be re-computed\r\n   * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n   */\n\n\n  Material.prototype.markAsDirty = function (flag) {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    Material._DirtyCallbackArray.length = 0;\n\n    if (flag & Material.TextureDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\n    }\n\n    if (flag & Material.LightDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\n    }\n\n    if (flag & Material.FresnelDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\n    }\n\n    if (flag & Material.AttributesDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\n    }\n\n    if (flag & Material.MiscDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\n    }\n\n    if (flag & Material.PrePassDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\n    }\n\n    if (Material._DirtyCallbackArray.length) {\n      this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\n    }\n\n    this.getScene().resetCachedMaterial();\n  };\n  /**\r\n   * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n   * @param func defines a function which checks material defines against the submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsDirty = function (func) {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    var meshes = this.getScene().meshes;\n\n    for (var _i = 0, meshes_2 = meshes; _i < meshes_2.length; _i++) {\n      var mesh = meshes_2[_i];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        if (!subMesh._materialDefines) {\n          continue;\n        }\n\n        func(subMesh._materialDefines);\n      }\n    }\n  };\n  /**\r\n   * Indicates that the scene should check if the rendering now needs a prepass\r\n   */\n\n\n  Material.prototype._markScenePrePassDirty = function () {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    var prePassRenderer = this.getScene().enablePrePassRenderer();\n\n    if (prePassRenderer) {\n      prePassRenderer.markAsDirty();\n    }\n  };\n  /**\r\n   * Indicates that we need to re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsAllDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\n  };\n  /**\r\n   * Indicates that image processing needs to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsImageProcessingDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\n  };\n  /**\r\n   * Indicates that textures need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\n  };\n  /**\r\n   * Indicates that fresnel needs to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsFresnelDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\n  };\n  /**\r\n   * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\n  };\n  /**\r\n   * Indicates that lights need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsLightsDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\n  };\n  /**\r\n   * Indicates that attributes need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsAttributesDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\n  };\n  /**\r\n   * Indicates that misc needs to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  };\n  /**\r\n   * Indicates that prepass needs to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsPrePassDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  };\n  /**\r\n   * Indicates that textures and misc need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\n  };\n  /**\r\n   * Sets the required values to the prepass renderer.\r\n   * @param prePassRenderer defines the prepass renderer to setup.\r\n   * @returns true if the pre pass is needed.\r\n   */\n\n\n  Material.prototype.setPrePassRenderer = function (prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  };\n  /**\r\n   * Disposes the material\r\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n   */\n\n\n  Material.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    var scene = this.getScene(); // Animations\n\n    scene.stopAnimation(this);\n    scene.freeProcessedMaterials(); // Remove from scene\n\n    scene.removeMaterial(this);\n\n    if (notBoundToMesh !== true) {\n      // Remove from meshes\n      if (this.meshMap) {\n        for (var meshId in this.meshMap) {\n          var mesh = this.meshMap[meshId];\n\n          if (mesh) {\n            mesh.material = null; // will set the entry in the map to undefined\n\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      } else {\n        var meshes = scene.meshes;\n\n        for (var _i = 0, meshes_3 = meshes; _i < meshes_3.length; _i++) {\n          var mesh = meshes_3[_i];\n\n          if (mesh.material === this && !mesh.sourceMesh) {\n            mesh.material = null;\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      }\n    }\n\n    this._uniformBuffer.dispose(); // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\n\n\n    if (forceDisposeEffect && this._effect) {\n      if (!this._storeEffectOnSubMeshes) {\n        this._effect.dispose();\n      }\n\n      this._effect = null;\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n\n    if (this._onBindObservable) {\n      this._onBindObservable.clear();\n    }\n\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.clear();\n    }\n\n    if (this._onEffectCreatedObservable) {\n      this._onEffectCreatedObservable.clear();\n    }\n  };\n  /** @hidden */\n\n\n  Material.prototype.releaseVertexArrayObject = function (mesh, forceDisposeEffect) {\n    if (mesh.geometry) {\n      var geometry = mesh.geometry;\n\n      if (this._storeEffectOnSubMeshes) {\n        for (var _i = 0, _a = mesh.subMeshes; _i < _a.length; _i++) {\n          var subMesh = _a[_i];\n\n          geometry._releaseVertexArrayObject(subMesh._materialEffect);\n\n          if (forceDisposeEffect && subMesh._materialEffect) {\n            subMesh._materialEffect.dispose();\n          }\n        }\n      } else {\n        geometry._releaseVertexArrayObject(this._effect);\n      }\n    }\n  };\n  /**\r\n   * Serializes this material\r\n   * @returns the serialized material object\r\n   */\n\n\n  Material.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Creates a material from parsed material data\r\n   * @param parsedMaterial defines parsed material data\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures\r\n   * @returns a new material\r\n   */\n\n\n  Material.Parse = function (parsedMaterial, scene, rootUrl) {\n    if (!parsedMaterial.customType) {\n      parsedMaterial.customType = \"BABYLON.StandardMaterial\";\n    } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\n      parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\n\n      if (!BABYLON.LegacyPBRMaterial) {\n        Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\n        return null;\n      }\n    }\n\n    var materialType = Tools.Instantiate(parsedMaterial.customType);\n    return materialType.Parse(parsedMaterial, scene, rootUrl);\n  };\n  /**\r\n   * Returns the triangle fill mode\r\n   */\n\n\n  Material.TriangleFillMode = 0;\n  /**\r\n   * Returns the wireframe mode\r\n   */\n\n  Material.WireFrameFillMode = 1;\n  /**\r\n   * Returns the point fill mode\r\n   */\n\n  Material.PointFillMode = 2;\n  /**\r\n   * Returns the point list draw mode\r\n   */\n\n  Material.PointListDrawMode = 3;\n  /**\r\n   * Returns the line list draw mode\r\n   */\n\n  Material.LineListDrawMode = 4;\n  /**\r\n   * Returns the line loop draw mode\r\n   */\n\n  Material.LineLoopDrawMode = 5;\n  /**\r\n   * Returns the line strip draw mode\r\n   */\n\n  Material.LineStripDrawMode = 6;\n  /**\r\n   * Returns the triangle strip draw mode\r\n   */\n\n  Material.TriangleStripDrawMode = 7;\n  /**\r\n   * Returns the triangle fan draw mode\r\n   */\n\n  Material.TriangleFanDrawMode = 8;\n  /**\r\n   * Stores the clock-wise side orientation\r\n   */\n\n  Material.ClockWiseSideOrientation = 0;\n  /**\r\n   * Stores the counter clock-wise side orientation\r\n   */\n\n  Material.CounterClockWiseSideOrientation = 1;\n  /**\r\n   * The dirty texture flag value\r\n   */\n\n  Material.TextureDirtyFlag = 1;\n  /**\r\n   * The dirty light flag value\r\n   */\n\n  Material.LightDirtyFlag = 2;\n  /**\r\n   * The dirty fresnel flag value\r\n   */\n\n  Material.FresnelDirtyFlag = 4;\n  /**\r\n   * The dirty attribute flag value\r\n   */\n\n  Material.AttributesDirtyFlag = 8;\n  /**\r\n   * The dirty misc flag value\r\n   */\n\n  Material.MiscDirtyFlag = 16;\n  /**\r\n   * The dirty prepass flag value\r\n   */\n\n  Material.PrePassDirtyFlag = 32;\n  /**\r\n   * The all dirty flag value\r\n   */\n\n  Material.AllDirtyFlag = 63;\n  /**\r\n   * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n   */\n\n  Material.MATERIAL_OPAQUE = 0;\n  /**\r\n   * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n   */\n\n  Material.MATERIAL_ALPHATEST = 1;\n  /**\r\n   * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n   */\n\n  Material.MATERIAL_ALPHABLEND = 2;\n  /**\r\n   * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n   * They are also discarded below the alpha cutoff threshold to improve performances.\r\n   */\n\n  Material.MATERIAL_ALPHATESTANDBLEND = 3;\n  /**\r\n   * The Whiteout method is used to blend normals.\r\n   * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n   */\n\n  Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\n  /**\r\n   * The Reoriented Normal Mapping method is used to blend normals.\r\n   * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n   */\n\n  Material.MATERIAL_NORMALBLENDMETHOD_RNM = 1;\n\n  Material._AllDirtyCallBack = function (defines) {\n    return defines.markAllAsDirty();\n  };\n\n  Material._ImageProcessingDirtyCallBack = function (defines) {\n    return defines.markAsImageProcessingDirty();\n  };\n\n  Material._TextureDirtyCallBack = function (defines) {\n    return defines.markAsTexturesDirty();\n  };\n\n  Material._FresnelDirtyCallBack = function (defines) {\n    return defines.markAsFresnelDirty();\n  };\n\n  Material._MiscDirtyCallBack = function (defines) {\n    return defines.markAsMiscDirty();\n  };\n\n  Material._PrePassDirtyCallBack = function (defines) {\n    return defines.markAsPrePassDirty();\n  };\n\n  Material._LightsDirtyCallBack = function (defines) {\n    return defines.markAsLightDirty();\n  };\n\n  Material._AttributeDirtyCallBack = function (defines) {\n    return defines.markAsAttributesDirty();\n  };\n\n  Material._FresnelAndMiscDirtyCallBack = function (defines) {\n    Material._FresnelDirtyCallBack(defines);\n\n    Material._MiscDirtyCallBack(defines);\n  };\n\n  Material._TextureAndMiscDirtyCallBack = function (defines) {\n    Material._TextureDirtyCallBack(defines);\n\n    Material._MiscDirtyCallBack(defines);\n  };\n\n  Material._DirtyCallbackArray = [];\n\n  Material._RunDirtyCallBacks = function (defines) {\n    for (var _i = 0, _a = Material._DirtyCallbackArray; _i < _a.length; _i++) {\n      var cb = _a[_i];\n      cb(defines);\n    }\n  };\n\n  __decorate([serialize()], Material.prototype, \"id\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"name\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"checkReadyOnEveryCall\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"checkReadyOnlyOnce\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"state\", void 0);\n\n  __decorate([serialize(\"alpha\")], Material.prototype, \"_alpha\", void 0);\n\n  __decorate([serialize(\"backFaceCulling\")], Material.prototype, \"_backFaceCulling\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"sideOrientation\", void 0);\n\n  __decorate([serialize(\"alphaMode\")], Material.prototype, \"_alphaMode\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"_needDepthPrePass\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"disableDepthWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"disableColorWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"forceDepthWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"depthFunction\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"separateCullingPass\", void 0);\n\n  __decorate([serialize(\"fogEnabled\")], Material.prototype, \"_fogEnabled\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"pointSize\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"zOffset\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"pointsCloud\", null);\n\n  __decorate([serialize()], Material.prototype, \"fillMode\", null);\n\n  __decorate([serialize()], Material.prototype, \"transparencyMode\", null);\n\n  return Material;\n}();\n\nexport { Material };","map":null,"metadata":{},"sourceType":"module"}