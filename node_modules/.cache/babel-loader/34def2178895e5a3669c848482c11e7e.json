{"ast":null,"code":"import { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { Color3, Color4 } from '../Maths/math.color';\nimport { Mesh } from \"../Meshes/mesh\";\nimport { LinesBuilder } from \"../Meshes/Builders/linesBuilder\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { Material } from '../Materials/material';\nimport { ShaderMaterial } from '../Materials/shaderMaterial';\nimport { DynamicTexture } from '../Materials/Textures/dynamicTexture';\nimport { VertexBuffer } from '../Meshes/buffer';\nimport { Effect } from '../Materials/effect';\nimport { SphereBuilder } from '../Meshes/Builders/sphereBuilder';\nimport { ShapeBuilder } from '../Meshes/Builders/shapeBuilder';\n/**\r\n * Class used to render a debug view of a given skeleton\r\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\r\n */\n\nvar SkeletonViewer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new SkeletonViewer\r\n   * @param skeleton defines the skeleton to render\r\n   * @param mesh defines the mesh attached to the skeleton\r\n   * @param scene defines the hosting scene\r\n   * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\r\n   * @param renderingGroupId defines the rendering group id to use with the viewer\r\n   * @param options All of the extra constructor options for the SkeletonViewer\r\n   */\n  function SkeletonViewer(\n  /** defines the skeleton to render */\n  skeleton,\n  /** defines the mesh attached to the skeleton */\n  mesh,\n  /** The Scene scope*/\n  scene,\n  /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\n  autoUpdateBonesMatrices,\n  /** defines the rendering group id to use with the viewer */\n  renderingGroupId,\n  /** is the options for the viewer */\n  options) {\n    if (autoUpdateBonesMatrices === void 0) {\n      autoUpdateBonesMatrices = true;\n    }\n\n    if (renderingGroupId === void 0) {\n      renderingGroupId = 3;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    this.skeleton = skeleton;\n    this.mesh = mesh;\n    this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;\n    this.renderingGroupId = renderingGroupId;\n    this.options = options;\n    /** Gets or sets the color used to render the skeleton */\n\n    this.color = Color3.White();\n    /** Array of the points of the skeleton fo the line view. */\n\n    this._debugLines = new Array();\n    /** The local axes Meshes. */\n\n    this._localAxes = null;\n    /** If SkeletonViewer is enabled. */\n\n    this._isEnabled = false;\n    /** SkeletonViewer render observable. */\n\n    this._obs = null;\n    this._scene = scene;\n    this._ready = false; //Defaults\n\n    options.pauseAnimations = (_a = options.pauseAnimations) !== null && _a !== void 0 ? _a : true;\n    options.returnToRest = (_c = options.returnToRest) !== null && _c !== void 0 ? _c : false;\n    options.displayMode = (_d = options.displayMode) !== null && _d !== void 0 ? _d : SkeletonViewer.DISPLAY_LINES;\n    options.displayOptions = (_e = options.displayOptions) !== null && _e !== void 0 ? _e : {};\n    options.displayOptions.midStep = (_f = options.displayOptions.midStep) !== null && _f !== void 0 ? _f : 0.235;\n    options.displayOptions.midStepFactor = (_g = options.displayOptions.midStepFactor) !== null && _g !== void 0 ? _g : 0.155;\n    options.displayOptions.sphereBaseSize = (_h = options.displayOptions.sphereBaseSize) !== null && _h !== void 0 ? _h : 0.15;\n    options.displayOptions.sphereScaleUnit = (_j = options.displayOptions.sphereScaleUnit) !== null && _j !== void 0 ? _j : 2;\n    options.displayOptions.sphereFactor = (_k = options.displayOptions.sphereFactor) !== null && _k !== void 0 ? _k : 0.865;\n    options.displayOptions.spurFollowsChild = (_l = options.displayOptions.spurFollowsChild) !== null && _l !== void 0 ? _l : false;\n    options.displayOptions.showLocalAxes = (_m = options.displayOptions.showLocalAxes) !== null && _m !== void 0 ? _m : false;\n    options.displayOptions.localAxesSize = (_o = options.displayOptions.localAxesSize) !== null && _o !== void 0 ? _o : 0.075;\n    options.computeBonesUsingShaders = (_p = options.computeBonesUsingShaders) !== null && _p !== void 0 ? _p : true;\n    options.useAllBones = (_q = options.useAllBones) !== null && _q !== void 0 ? _q : true;\n    var initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    var initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    this._boneIndices = new Set();\n\n    if (!options.useAllBones) {\n      if (initialMeshBoneIndices && initialMeshBoneWeights) {\n        for (var i = 0; i < initialMeshBoneIndices.length; ++i) {\n          var index = initialMeshBoneIndices[i],\n              weight = initialMeshBoneWeights[i];\n\n          if (weight !== 0) {\n            this._boneIndices.add(index);\n          }\n        }\n      }\n    }\n    /* Create Utility Layer */\n\n\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n    var displayMode = this.options.displayMode || 0;\n\n    if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      displayMode = SkeletonViewer.DISPLAY_LINES;\n    }\n\n    this.displayMode = displayMode; //Prep the Systems\n\n    this.update();\n\n    this._bindObs();\n  }\n  /** public static method to create a BoneWeight Shader\r\n   * @param options The constructor options\r\n   * @param scene The scene that the shader is scoped to\r\n   * @returns The created ShaderMaterial\r\n   * @see http://www.babylonjs-playground.com/#1BZJVJ#395\r\n   */\n\n\n  SkeletonViewer.CreateBoneWeightShader = function (options, scene) {\n    var _a, _c, _d, _e, _f, _g;\n\n    var skeleton = options.skeleton;\n    var colorBase = (_a = options.colorBase) !== null && _a !== void 0 ? _a : Color3.Black();\n    var colorZero = (_c = options.colorZero) !== null && _c !== void 0 ? _c : Color3.Blue();\n    var colorQuarter = (_d = options.colorQuarter) !== null && _d !== void 0 ? _d : Color3.Green();\n    var colorHalf = (_e = options.colorHalf) !== null && _e !== void 0 ? _e : Color3.Yellow();\n    var colorFull = (_f = options.colorFull) !== null && _f !== void 0 ? _f : Color3.Red();\n    var targetBoneIndex = (_g = options.targetBoneIndex) !== null && _g !== void 0 ? _g : 0;\n    Effect.ShadersStore['boneWeights:' + skeleton.name + \"VertexShader\"] = \"precision highp float;\\n\\n        attribute vec3 position;\\n        attribute vec2 uv;\\n\\n        uniform mat4 view;\\n        uniform mat4 projection;\\n        uniform mat4 worldViewProjection;\\n\\n        #include<bonesDeclaration>\\n        #if NUM_BONE_INFLUENCERS == 0\\n            attribute vec4 matricesIndices;\\n            attribute vec4 matricesWeights;\\n        #endif\\n\\n        #include<instancesDeclaration>\\n\\n        varying vec3 vColor;\\n\\n        uniform vec3 colorBase;\\n        uniform vec3 colorZero;\\n        uniform vec3 colorQuarter;\\n        uniform vec3 colorHalf;\\n        uniform vec3 colorFull;\\n\\n        uniform float targetBoneIndex;\\n\\n        void main() {\\n            vec3 positionUpdated = position;\\n\\n            #include<instancesVertex>\\n            #include<bonesVertex>\\n\\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\\n\\n            vec3 color = colorBase;\\n            float totalWeight = 0.;\\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\\n                totalWeight += matricesWeights[0];\\n            }\\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\\n                totalWeight += matricesWeights[1];\\n            }\\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\\n                totalWeight += matricesWeights[2];\\n            }\\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\\n                totalWeight += matricesWeights[3];\\n            }\\n\\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\\n            vColor = color;\\n\\n        gl_Position = projection * view * worldPos;\\n        }\";\n    Effect.ShadersStore['boneWeights:' + skeleton.name + \"FragmentShader\"] = \"\\n            precision highp float;\\n            varying vec3 vPosition;\\n\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec4 color = vec4(vColor, 1.0);\\n                gl_FragColor = color;\\n            }\\n        \";\n    var shader = new ShaderMaterial('boneWeight:' + skeleton.name, scene, {\n      vertex: 'boneWeights:' + skeleton.name,\n      fragment: 'boneWeights:' + skeleton.name\n    }, {\n      attributes: ['position', 'normal', 'matricesIndices', 'matricesWeights'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'projection', 'viewProjection', 'colorBase', 'colorZero', 'colorQuarter', 'colorHalf', 'colorFull', 'targetBoneIndex']\n    });\n    shader.setColor3('colorBase', colorBase);\n    shader.setColor3('colorZero', colorZero);\n    shader.setColor3('colorQuarter', colorQuarter);\n    shader.setColor3('colorHalf', colorHalf);\n    shader.setColor3('colorFull', colorFull);\n    shader.setFloat('targetBoneIndex', targetBoneIndex);\n\n    shader.getClassName = function () {\n      return \"BoneWeightShader\";\n    };\n\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  };\n  /** public static method to create a BoneWeight Shader\r\n   * @param options The constructor options\r\n   * @param scene The scene that the shader is scoped to\r\n   * @returns The created ShaderMaterial\r\n   */\n\n\n  SkeletonViewer.CreateSkeletonMapShader = function (options, scene) {\n    var _a;\n\n    var skeleton = options.skeleton;\n    var colorMap = (_a = options.colorMap) !== null && _a !== void 0 ? _a : [{\n      color: new Color3(1, 0.38, 0.18),\n      location: 0\n    }, {\n      color: new Color3(.59, 0.18, 1.00),\n      location: 0.2\n    }, {\n      color: new Color3(0.59, 1, 0.18),\n      location: 0.4\n    }, {\n      color: new Color3(1, 0.87, 0.17),\n      location: 0.6\n    }, {\n      color: new Color3(1, 0.17, 0.42),\n      location: 0.8\n    }, {\n      color: new Color3(0.17, 0.68, 1.0),\n      location: 1.0\n    }];\n    var bufferWidth = skeleton.bones.length + 1;\n\n    var colorMapBuffer = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\n\n    var shader = new ShaderMaterial('boneWeights:' + skeleton.name, scene, {\n      vertexSource: \"precision highp float;\\n\\n            attribute vec3 position;\\n            attribute vec2 uv;\\n\\n            uniform mat4 view;\\n            uniform mat4 projection;\\n            uniform mat4 worldViewProjection;\\n            uniform float colorMap[\" + skeleton.bones.length * 4 + \"];\\n\\n            #include<bonesDeclaration>\\n            #if NUM_BONE_INFLUENCERS == 0\\n                attribute vec4 matricesIndices;\\n                attribute vec4 matricesWeights;\\n            #endif\\n            #include<instancesDeclaration>\\n\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec3 positionUpdated = position;\\n\\n                #include<instancesVertex>\\n                #include<bonesVertex>\\n\\n                vec3 color = vec3(0.);\\n                bool first = true;\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int boneIdx = int(matricesIndices[i]);\\n                    float boneWgt = matricesWeights[i];\\n\\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\\n\\n                    if (boneWgt > 0.) {\\n                        if (first) {\\n                            first = false;\\n                            color = c;\\n                        } else {\\n                            color = mix(color, c, boneWgt);\\n                        }\\n                    }\\n                }\\n\\n                vColor = color;\\n\\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\\n\\n                gl_Position = projection * view * worldPos;\\n            }\",\n      fragmentSource: \"\\n            precision highp float;\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec4 color = vec4( vColor, 1.0 );\\n                gl_FragColor = color;\\n            }\\n            \"\n    }, {\n      attributes: ['position', 'normal', 'matricesIndices', 'matricesWeights'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'projection', 'viewProjection', 'colorMap']\n    });\n    shader.setFloats('colorMap', colorMapBuffer);\n\n    shader.getClassName = function () {\n      return \"SkeletonMapShader\";\n    };\n\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  };\n  /** private static method to create a BoneWeight Shader\r\n   * @param size The size of the buffer to create (usually the bone count)\r\n   * @param colorMap The gradient data to generate\r\n   * @param scene The scene that the shader is scoped to\r\n   * @returns an Array of floats from the color gradient values\r\n   */\n\n\n  SkeletonViewer._CreateBoneMapColorBuffer = function (size, colorMap, scene) {\n    var tempGrad = new DynamicTexture('temp', {\n      width: size,\n      height: 1\n    }, scene, false);\n    var ctx = tempGrad.getContext();\n    var grad = ctx.createLinearGradient(0, 0, size, 0);\n    colorMap.forEach(function (stop) {\n      grad.addColorStop(stop.location, stop.color.toHexString());\n    });\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, size, 1);\n    tempGrad.update();\n    var buffer = [];\n    var data = ctx.getImageData(0, 0, size, 1).data;\n    var rUnit = 1 / 255;\n\n    for (var i = 0; i < data.length; i++) {\n      buffer.push(data[i] * rUnit);\n    }\n\n    tempGrad.dispose();\n    return buffer;\n  };\n\n  Object.defineProperty(SkeletonViewer.prototype, \"scene\", {\n    /** Gets the Scene. */\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"utilityLayer\", {\n    /** Gets the utilityLayer. */\n    get: function get() {\n      return this._utilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"isReady\", {\n    /** Checks Ready Status. */\n    get: function get() {\n      return this._ready;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"ready\", {\n    /** Sets Ready Status. */\n    set: function set(value) {\n      this._ready = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"debugMesh\", {\n    /** Gets the debugMesh */\n    get: function get() {\n      return this._debugMesh;\n    },\n\n    /** Sets the debugMesh */\n    set: function set(value) {\n      this._debugMesh = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"displayMode\", {\n    /** Gets the displayMode */\n    get: function get() {\n      return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\n    },\n\n    /** Sets the displayMode */\n    set: function set(value) {\n      if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n        value = SkeletonViewer.DISPLAY_LINES;\n      }\n\n      this.options.displayMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** The Dynamic bindings for the update functions */\n\n  SkeletonViewer.prototype._bindObs = function () {\n    var _this = this;\n\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._obs = this.scene.onBeforeRenderObservable.add(function () {\n            _this._displayLinesUpdate();\n          });\n          break;\n        }\n    }\n  };\n  /** Update the viewer to sync with current skeleton state, only used to manually update. */\n\n\n  SkeletonViewer.prototype.update = function () {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._displayLinesUpdate();\n\n          break;\n        }\n\n      case SkeletonViewer.DISPLAY_SPHERES:\n        {\n          this._buildSpheresAndSpurs(true);\n\n          break;\n        }\n\n      case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS:\n        {\n          this._buildSpheresAndSpurs(false);\n\n          break;\n        }\n    }\n\n    this._buildLocalAxes();\n  };\n\n  Object.defineProperty(SkeletonViewer.prototype, \"isEnabled\", {\n    get: function get() {\n      return this._isEnabled;\n    },\n\n    /** Gets or sets a boolean indicating if the viewer is enabled */\n    set: function set(value) {\n      if (this.isEnabled === value) {\n        return;\n      }\n\n      this._isEnabled = value;\n\n      if (this.debugMesh) {\n        this.debugMesh.setEnabled(value);\n      }\n\n      if (value && !this._obs) {\n        this._bindObs();\n      } else if (!value && this._obs) {\n        this.scene.onBeforeRenderObservable.remove(this._obs);\n        this._obs = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  SkeletonViewer.prototype._getBonePosition = function (position, bone, meshMat, x, y, z) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    if (z === void 0) {\n      z = 0;\n    }\n\n    var tmat = TmpVectors.Matrix[0];\n    var parentBone = bone.getParent();\n    tmat.copyFrom(bone.getLocalMatrix());\n\n    if (x !== 0 || y !== 0 || z !== 0) {\n      var tmat2 = TmpVectors.Matrix[1];\n      Matrix.IdentityToRef(tmat2);\n      tmat2.setTranslationFromFloats(x, y, z);\n      tmat2.multiplyToRef(tmat, tmat);\n    }\n\n    if (parentBone) {\n      tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);\n    }\n\n    tmat.multiplyToRef(meshMat, tmat);\n    position.x = tmat.m[12];\n    position.y = tmat.m[13];\n    position.z = tmat.m[14];\n  };\n\n  SkeletonViewer.prototype._getLinesForBonesWithLength = function (bones, meshMat) {\n    var len = bones.length;\n    var mesh = this.mesh._effectiveMesh;\n    var meshPos = mesh.position;\n    var idx = 0;\n\n    for (var i = 0; i < len; i++) {\n      var bone = bones[i];\n      var points = this._debugLines[idx];\n\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[idx] = points;\n      }\n\n      this._getBonePosition(points[0], bone, meshMat);\n\n      this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\n\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      idx++;\n    }\n  };\n\n  SkeletonViewer.prototype._getLinesForBonesNoLength = function (bones) {\n    var len = bones.length;\n    var boneNum = 0;\n    var mesh = this.mesh._effectiveMesh;\n    var meshPos = mesh.position;\n\n    for (var i = len - 1; i >= 0; i--) {\n      var childBone = bones[i];\n      var parentBone = childBone.getParent();\n\n      if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      var points = this._debugLines[boneNum];\n\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[boneNum] = points;\n      }\n\n      childBone.getAbsolutePositionToRef(mesh, points[0]);\n      parentBone.getAbsolutePositionToRef(mesh, points[1]);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      boneNum++;\n    }\n  };\n  /** function to revert the mesh and scene back to the initial state. */\n\n\n  SkeletonViewer.prototype._revert = function (animationState) {\n    if (this.options.pauseAnimations) {\n      this.scene.animationsEnabled = animationState;\n      this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;\n    }\n  };\n  /** function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy. */\n\n\n  SkeletonViewer.prototype._getAbsoluteBindPoseToRef = function (bone, matrix) {\n    if (bone === null || bone._index === -1) {\n      matrix.copyFrom(Matrix.Identity());\n      return;\n    }\n\n    this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\n\n    bone.getBindPose().multiplyToRef(matrix, matrix);\n    return;\n  };\n  /** function to build and bind sphere joint points and spur bone representations. */\n\n\n  SkeletonViewer.prototype._buildSpheresAndSpurs = function (spheresOnly) {\n    var _a, _c;\n\n    if (spheresOnly === void 0) {\n      spheresOnly = true;\n    }\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n      this.ready = false;\n    }\n\n    this._ready = false;\n    var utilityLayerScene = (_a = this.utilityLayer) === null || _a === void 0 ? void 0 : _a.utilityLayerScene;\n    var bones = this.skeleton.bones;\n    var spheres = [];\n    var spurs = [];\n    var animationState = this.scene.animationsEnabled;\n\n    try {\n      if (this.options.pauseAnimations) {\n        this.scene.animationsEnabled = false;\n        utilityLayerScene.animationsEnabled = false;\n      }\n\n      if (this.options.returnToRest) {\n        this.skeleton.returnToRest();\n      }\n\n      if (this.autoUpdateBonesMatrices) {\n        this.skeleton.computeAbsoluteTransforms();\n      }\n\n      var longestBoneLength_1 = Number.NEGATIVE_INFINITY;\n      var displayOptions_1 = this.options.displayOptions || {};\n\n      var _loop_1 = function _loop_1(i) {\n        var bone = bones[i];\n\n        if (bone._index === -1 || !this_1._boneIndices.has(bone.getIndex()) && !this_1.options.useAllBones) {\n          return \"continue\";\n        }\n\n        var boneAbsoluteBindPoseTransform = new Matrix();\n\n        this_1._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n\n        var anchorPoint = new Vector3();\n        boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\n        bone.children.forEach(function (bc, i) {\n          var childAbsoluteBindPoseTransform = new Matrix();\n          bc.getBindPose().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\n          var childPoint = new Vector3();\n          childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\n          var distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\n\n          if (distanceFromParent > longestBoneLength_1) {\n            longestBoneLength_1 = distanceFromParent;\n          }\n\n          if (spheresOnly) {\n            return;\n          }\n\n          var dir = childPoint.clone().subtract(anchorPoint.clone());\n          var h = dir.length();\n          var up = dir.normalize().scale(h);\n          var midStep = displayOptions_1.midStep || 0.165;\n          var midStepFactor = displayOptions_1.midStepFactor || 0.215;\n          var up0 = up.scale(midStep);\n          var spur = ShapeBuilder.ExtrudeShapeCustom('skeletonViewer', {\n            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\n            path: [Vector3.Zero(), up0, up],\n            scaleFunction: function scaleFunction(i) {\n              switch (i) {\n                case 0:\n                case 2:\n                  return 0;\n\n                case 1:\n                  return h * midStepFactor;\n              }\n\n              return 0;\n            },\n            sideOrientation: Mesh.DEFAULTSIDE,\n            updatable: false\n          }, utilityLayerScene);\n          var numVertices = spur.getTotalVertices();\n          var mwk = [],\n              mik = [];\n\n          for (var i_1 = 0; i_1 < numVertices; i_1++) {\n            mwk.push(1, 0, 0, 0); // Select verts at end of spur (ie vert 10 to 14) and bind to child\n            // bone if spurFollowsChild is enabled.\n\n            if (displayOptions_1.spurFollowsChild && i_1 > 9) {\n              mik.push(bc.getIndex(), 0, 0, 0);\n            } else {\n              mik.push(bone.getIndex(), 0, 0, 0);\n            }\n          }\n\n          spur.position = anchorPoint.clone();\n          spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n          spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n          spur.convertToFlatShadedMesh();\n          spurs.push(spur);\n        });\n        var sphereBaseSize = displayOptions_1.sphereBaseSize || 0.2;\n        var sphere = SphereBuilder.CreateSphere('skeletonViewer', {\n          segments: 6,\n          diameter: sphereBaseSize,\n          updatable: true\n        }, utilityLayerScene);\n        var numVertices = sphere.getTotalVertices();\n        var mwk = [],\n            mik = [];\n\n        for (var i_2 = 0; i_2 < numVertices; i_2++) {\n          mwk.push(1, 0, 0, 0);\n          mik.push(bone.getIndex(), 0, 0, 0);\n        }\n\n        sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n        sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n        sphere.position = anchorPoint.clone();\n        spheres.push([sphere, bone]);\n      };\n\n      var this_1 = this;\n\n      for (var i = 0; i < bones.length; i++) {\n        _loop_1(i);\n      }\n\n      var sphereScaleUnit = displayOptions_1.sphereScaleUnit || 2;\n      var sphereFactor = displayOptions_1.sphereFactor || 0.85;\n      var meshes = [];\n\n      for (var i = 0; i < spheres.length; i++) {\n        var _d = spheres[i],\n            sphere = _d[0],\n            bone = _d[1];\n        var scale = 1 / (sphereScaleUnit / longestBoneLength_1);\n        var _stepsOut = 0;\n        var _b = bone;\n\n        while (_b.getParent() && _b.getParent().getIndex() !== -1) {\n          _stepsOut++;\n          _b = _b.getParent();\n        }\n\n        sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\n        meshes.push(sphere);\n      }\n\n      this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\n\n      if (this.debugMesh) {\n        this.debugMesh.renderingGroupId = this.renderingGroupId;\n        this.debugMesh.skeleton = this.skeleton;\n        this.debugMesh.parent = this.mesh;\n        this.debugMesh.computeBonesUsingShaders = (_c = this.options.computeBonesUsingShaders) !== null && _c !== void 0 ? _c : true;\n        this.debugMesh.alwaysSelectAsActiveMesh = true;\n      }\n\n      var light = this.utilityLayer._getSharedGizmoLight();\n\n      light.intensity = 0.7;\n\n      this._revert(animationState);\n\n      this.ready = true;\n    } catch (err) {\n      console.error(err);\n\n      this._revert(animationState);\n\n      this.dispose();\n    }\n  };\n\n  SkeletonViewer.prototype._buildLocalAxes = function () {\n    var _a;\n\n    if (this._localAxes) {\n      this._localAxes.dispose();\n    }\n\n    this._localAxes = null;\n    var displayOptions = this.options.displayOptions || {};\n\n    if (!displayOptions.showLocalAxes) {\n      return;\n    }\n\n    var targetScene = this._utilityLayer.utilityLayerScene;\n    var size = displayOptions.localAxesSize || 0.075;\n    var lines = [];\n    var colors = [];\n    var red = new Color4(1, 0, 0, 1);\n    var green = new Color4(0, 1, 0, 1);\n    var blue = new Color4(0, 0, 1, 1);\n    var mwk = [];\n    var mik = [];\n    var vertsPerBone = 6;\n\n    for (var i in this.skeleton.bones) {\n      var bone = this.skeleton.bones[i];\n\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      var boneAbsoluteBindPoseTransform = new Matrix();\n      var boneOrigin = new Vector3();\n\n      this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n\n      boneAbsoluteBindPoseTransform.decompose(undefined, undefined, boneOrigin);\n      var m = bone.getBindPose().getRotationMatrix();\n      var boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\n      var boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\n      var boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\n      var axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\n      var axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\n      var axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\n      var linePoints = [axisX, axisY, axisZ];\n      var lineColors = [[red, red], [green, green], [blue, blue]];\n      lines.push.apply(lines, linePoints);\n      colors.push.apply(colors, lineColors);\n\n      for (var j = 0; j < vertsPerBone; j++) {\n        mwk.push(1, 0, 0, 0);\n        mik.push(bone.getIndex(), 0, 0, 0);\n      }\n    }\n\n    this._localAxes = LinesBuilder.CreateLineSystem('localAxes', {\n      lines: lines,\n      colors: colors,\n      updatable: true\n    }, targetScene);\n\n    this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n\n    this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n\n    this._localAxes.skeleton = this.skeleton;\n    this._localAxes.renderingGroupId = this.renderingGroupId;\n    this._localAxes.parent = this.mesh;\n    this._localAxes.computeBonesUsingShaders = (_a = this.options.computeBonesUsingShaders) !== null && _a !== void 0 ? _a : true;\n  };\n  /** Update the viewer to sync with current skeleton state, only used for the line display. */\n\n\n  SkeletonViewer.prototype._displayLinesUpdate = function () {\n    if (!this._utilityLayer) {\n      return;\n    }\n\n    if (this.autoUpdateBonesMatrices) {\n      this.skeleton.computeAbsoluteTransforms();\n    }\n\n    var mesh = this.mesh._effectiveMesh;\n\n    if (this.skeleton.bones[0].length === undefined) {\n      this._getLinesForBonesNoLength(this.skeleton.bones);\n    } else {\n      this._getLinesForBonesWithLength(this.skeleton.bones, mesh.getWorldMatrix());\n    }\n\n    var targetScene = this._utilityLayer.utilityLayerScene;\n\n    if (targetScene) {\n      if (!this._debugMesh) {\n        this._debugMesh = LinesBuilder.CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: null\n        }, targetScene);\n        this._debugMesh.renderingGroupId = this.renderingGroupId;\n      } else {\n        LinesBuilder.CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: this._debugMesh\n        }, targetScene);\n      }\n\n      this._debugMesh.position.copyFrom(this.mesh.position);\n\n      this._debugMesh.color = this.color;\n    }\n  };\n  /** Changes the displayMode of the skeleton viewer\r\n   * @param mode The displayMode numerical value\r\n   */\n\n\n  SkeletonViewer.prototype.changeDisplayMode = function (mode) {\n    var wasEnabled = this.isEnabled ? true : false;\n\n    if (this.displayMode !== mode) {\n      this.isEnabled = false;\n\n      if (this._debugMesh) {\n        this._debugMesh.dispose();\n\n        this._debugMesh = null;\n        this.ready = false;\n      }\n\n      this.displayMode = mode;\n      this.update();\n\n      this._bindObs();\n\n      this.isEnabled = wasEnabled;\n    }\n  };\n  /** Sets a display option of the skeleton viewer\r\n   *\r\n   * | Option           | Type    | Default | Description |\r\n   * | ---------------- | ------- | ------- | ----------- |\r\n   * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n   * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n   * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n   * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n   * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\r\n   * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\r\n   * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\r\n   *\r\n   * @param option String of the option name\r\n   * @param value The numerical option value\r\n   */\n\n\n  SkeletonViewer.prototype.changeDisplayOptions = function (option, value) {\n    var wasEnabled = this.isEnabled ? true : false;\n    this.options.displayOptions[option] = value;\n    this.isEnabled = false;\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n      this.ready = false;\n    }\n\n    this.update();\n\n    this._bindObs();\n\n    this.isEnabled = wasEnabled;\n  };\n  /** Release associated resources */\n\n\n  SkeletonViewer.prototype.dispose = function () {\n    this.isEnabled = false;\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n    }\n\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n\n      this._utilityLayer = null;\n    }\n\n    this.ready = false;\n  };\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\n\n\n  SkeletonViewer.DISPLAY_LINES = 0;\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\n\n  SkeletonViewer.DISPLAY_SPHERES = 1;\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\n\n  SkeletonViewer.DISPLAY_SPHERE_AND_SPURS = 2;\n  return SkeletonViewer;\n}();\n\nexport { SkeletonViewer };","map":null,"metadata":{},"sourceType":"module"}