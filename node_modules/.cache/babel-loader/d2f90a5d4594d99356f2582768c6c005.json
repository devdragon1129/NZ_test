{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { TmpVectors } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\nimport { TransformNode } from './transformNode';\nimport { VertexBuffer } from './buffer';\nimport { BoundingInfo } from '../Culling/boundingInfo';\nimport { Tools } from '../Misc/tools';\n\nMesh._instancedMeshFactory = function (name, mesh) {\n  var instance = new InstancedMesh(name, mesh);\n\n  if (mesh.instancedBuffers) {\n    instance.instancedBuffers = {};\n\n    for (var key in mesh.instancedBuffers) {\n      instance.instancedBuffers[key] = mesh.instancedBuffers[key];\n    }\n  }\n\n  return instance;\n};\n/**\r\n * Creates an instance based on a source mesh.\r\n */\n\n\nvar InstancedMesh =\n/** @class */\nfunction (_super) {\n  __extends(InstancedMesh, _super);\n\n  function InstancedMesh(name, source) {\n    var _this = _super.call(this, name, source.getScene()) || this;\n    /** @hidden */\n\n\n    _this._indexInSourceMeshInstanceArray = -1;\n    source.addInstance(_this);\n    _this._sourceMesh = source;\n    _this._unIndexed = source._unIndexed;\n\n    _this.position.copyFrom(source.position);\n\n    _this.rotation.copyFrom(source.rotation);\n\n    _this.scaling.copyFrom(source.scaling);\n\n    if (source.rotationQuaternion) {\n      _this.rotationQuaternion = source.rotationQuaternion.clone();\n    }\n\n    _this.animations = Tools.Slice(source.animations);\n\n    for (var _i = 0, _a = source.getAnimationRanges(); _i < _a.length; _i++) {\n      var range = _a[_i];\n\n      if (range != null) {\n        _this.createAnimationRange(range.name, range.from, range.to);\n      }\n    }\n\n    _this.infiniteDistance = source.infiniteDistance;\n\n    _this.setPivotMatrix(source.getPivotMatrix());\n\n    _this.refreshBoundingInfo();\n\n    _this._syncSubMeshes();\n\n    return _this;\n  }\n  /**\r\n   * Returns the string \"InstancedMesh\".\r\n   */\n\n\n  InstancedMesh.prototype.getClassName = function () {\n    return \"InstancedMesh\";\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"lightSources\", {\n    /** Gets the list of lights affecting that mesh */\n    get: function get() {\n      return this._sourceMesh._lightSources;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InstancedMesh.prototype._resyncLightSources = function () {// Do nothing as all the work will be done by source mesh\n  };\n\n  InstancedMesh.prototype._resyncLightSource = function (light) {// Do nothing as all the work will be done by source mesh\n  };\n\n  InstancedMesh.prototype._removeLightSource = function (light, dispose) {// Do nothing as all the work will be done by source mesh\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"receiveShadows\", {\n    // Methods\n\n    /**\r\n     * If the source mesh receives shadows\r\n     */\n    get: function get() {\n      return this._sourceMesh.receiveShadows;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"material\", {\n    /**\r\n     * The material of the source mesh\r\n     */\n    get: function get() {\n      return this._sourceMesh.material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"visibility\", {\n    /**\r\n     * Visibility of the source mesh\r\n     */\n    get: function get() {\n      return this._sourceMesh.visibility;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"skeleton\", {\n    /**\r\n     * Skeleton of the source mesh\r\n     */\n    get: function get() {\n      return this._sourceMesh.skeleton;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"renderingGroupId\", {\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\n    get: function get() {\n      return this._sourceMesh.renderingGroupId;\n    },\n    set: function set(value) {\n      if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\n        return;\n      } //no-op with warning\n\n\n      Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the total number of vertices (integer).\r\n   */\n\n  InstancedMesh.prototype.getTotalVertices = function () {\n    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\n  };\n  /**\r\n   * Returns a positive integer : the total number of indices in this mesh geometry.\r\n   * @returns the numner of indices or zero if the mesh has no geometry.\r\n   */\n\n\n  InstancedMesh.prototype.getTotalIndices = function () {\n    return this._sourceMesh.getTotalIndices();\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"sourceMesh\", {\n    /**\r\n     * The source mesh of the instance\r\n     */\n    get: function get() {\n      return this._sourceMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a new InstancedMesh object from the mesh model.\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n   * @param name defines the name of the new instance\r\n   * @returns a new InstancedMesh\r\n   */\n\n  InstancedMesh.prototype.createInstance = function (name) {\n    return this._sourceMesh.createInstance(name);\n  };\n  /**\r\n   * Is this node ready to be used/rendered\r\n   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n   * @return {boolean} is it ready\r\n   */\n\n\n  InstancedMesh.prototype.isReady = function (completeCheck) {\n    if (completeCheck === void 0) {\n      completeCheck = false;\n    }\n\n    return this._sourceMesh.isReady(completeCheck, true);\n  };\n  /**\r\n   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n   * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)\r\n   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n   * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.\r\n   */\n\n\n  InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {\n    return this._sourceMesh.getVerticesData(kind, copyWhenShared);\n  };\n  /**\r\n   * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n   * The `data` are either a numeric array either a Float32Array.\r\n   * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\r\n   * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n   * Note that a new underlying VertexBuffer object is created each call.\r\n   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n   *\r\n   * Possible `kind` values :\r\n   * - VertexBuffer.PositionKind\r\n   * - VertexBuffer.UVKind\r\n   * - VertexBuffer.UV2Kind\r\n   * - VertexBuffer.UV3Kind\r\n   * - VertexBuffer.UV4Kind\r\n   * - VertexBuffer.UV5Kind\r\n   * - VertexBuffer.UV6Kind\r\n   * - VertexBuffer.ColorKind\r\n   * - VertexBuffer.MatricesIndicesKind\r\n   * - VertexBuffer.MatricesIndicesExtraKind\r\n   * - VertexBuffer.MatricesWeightsKind\r\n   * - VertexBuffer.MatricesWeightsExtraKind\r\n   *\r\n   * Returns the Mesh.\r\n   */\n\n\n  InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    if (this.sourceMesh) {\n      this.sourceMesh.setVerticesData(kind, data, updatable, stride);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\r\n   * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n   * If the mesh has no geometry, it is simply returned as it is.\r\n   * The `data` are either a numeric array either a Float32Array.\r\n   * No new underlying VertexBuffer object is created.\r\n   * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n   * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n   *\r\n   * Possible `kind` values :\r\n   * - VertexBuffer.PositionKind\r\n   * - VertexBuffer.UVKind\r\n   * - VertexBuffer.UV2Kind\r\n   * - VertexBuffer.UV3Kind\r\n   * - VertexBuffer.UV4Kind\r\n   * - VertexBuffer.UV5Kind\r\n   * - VertexBuffer.UV6Kind\r\n   * - VertexBuffer.ColorKind\r\n   * - VertexBuffer.MatricesIndicesKind\r\n   * - VertexBuffer.MatricesIndicesExtraKind\r\n   * - VertexBuffer.MatricesWeightsKind\r\n   * - VertexBuffer.MatricesWeightsExtraKind\r\n   *\r\n   * Returns the Mesh.\r\n   */\n\n\n  InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n    if (this.sourceMesh) {\n      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\r\n   * Sets the mesh indices.\r\n   * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n   * This method creates a new index buffer each call.\r\n   * Returns the Mesh.\r\n   */\n\n\n  InstancedMesh.prototype.setIndices = function (indices, totalVertices) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    if (this.sourceMesh) {\n      this.sourceMesh.setIndices(indices, totalVertices);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\r\n   * Boolean : True if the mesh owns the requested kind of data.\r\n   */\n\n\n  InstancedMesh.prototype.isVerticesDataPresent = function (kind) {\n    return this._sourceMesh.isVerticesDataPresent(kind);\n  };\n  /**\r\n   * Returns an array of indices (IndicesArray).\r\n   */\n\n\n  InstancedMesh.prototype.getIndices = function () {\n    return this._sourceMesh.getIndices();\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"_positions\", {\n    get: function get() {\n      return this._sourceMesh._positions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n   * This means the mesh underlying bounding box and sphere are recomputed.\r\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n   * @returns the current mesh\r\n   */\n\n  InstancedMesh.prototype.refreshBoundingInfo = function (applySkeleton) {\n    if (applySkeleton === void 0) {\n      applySkeleton = false;\n    }\n\n    if (this._boundingInfo && this._boundingInfo.isLocked) {\n      return this;\n    }\n\n    var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\n\n    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._preActivate = function () {\n    if (this._currentLOD) {\n      this._currentLOD._preActivate();\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._activate = function (renderId, intermediateRendering) {\n    if (!this._sourceMesh.subMeshes) {\n      Logger.Warn(\"Instances should only be created for meshes with geometry.\");\n    }\n\n    if (this._currentLOD) {\n      var differentSign = this._currentLOD._getWorldMatrixDeterminant() > 0 !== this._getWorldMatrixDeterminant() > 0;\n\n      if (differentSign) {\n        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\n        return true;\n      }\n\n      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\n\n      this._currentLOD._registerInstanceForRenderId(this, renderId);\n\n      if (intermediateRendering) {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\n          return true;\n        }\n      } else {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._postActivate = function () {\n    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer of the source mesh\n      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\n\n      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\n    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer defined for this instance\n      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\n    }\n  };\n\n  InstancedMesh.prototype.getWorldMatrix = function () {\n    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\n      var tempMaster = this._currentLOD._masterMesh;\n      this._currentLOD._masterMesh = this;\n      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\n\n      this._currentLOD.position.set(0, 0, 0);\n\n      TmpVectors.Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));\n\n      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\n\n      this._currentLOD._masterMesh = tempMaster;\n      return TmpVectors.Matrix[0];\n    }\n\n    return _super.prototype.getWorldMatrix.call(this);\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"isAnInstance\", {\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the current associated LOD AbstractMesh.\r\n   */\n\n  InstancedMesh.prototype.getLOD = function (camera) {\n    if (!camera) {\n      return this;\n    }\n\n    var boundingInfo = this.getBoundingInfo();\n    this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\n\n    if (this._currentLOD === this.sourceMesh) {\n      return this.sourceMesh;\n    }\n\n    return this._currentLOD;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._preActivateForIntermediateRendering = function (renderId) {\n    return this.sourceMesh._preActivateForIntermediateRendering(renderId);\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._syncSubMeshes = function () {\n    this.releaseSubMeshes();\n\n    if (this._sourceMesh.subMeshes) {\n      for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\n        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\n      }\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._generatePointsArray = function () {\n    return this._sourceMesh._generatePointsArray();\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._updateBoundingInfo = function () {\n    var effectiveMesh = this;\n\n    if (this._boundingInfo) {\n      this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);\n    } else {\n      this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);\n    }\n\n    this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);\n\n    return this;\n  };\n  /**\r\n   * Creates a new InstancedMesh from the current mesh.\r\n   * - name (string) : the cloned mesh name\r\n   * - newParent (optional Node) : the optional Node to parent the clone to.\r\n   * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n   *\r\n   * Returns the clone.\r\n   */\n\n\n  InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    var result = this._sourceMesh.createInstance(name); // Deep copy\n\n\n    DeepCopier.DeepCopy(this, result, [\"name\", \"subMeshes\", \"uniqueId\", \"parent\", \"lightSources\", \"receiveShadows\", \"material\", \"visibility\", \"skeleton\", \"sourceMesh\", \"isAnInstance\", \"facetNb\", \"isFacetDataEnabled\", \"isBlocked\", \"useBones\", \"hasInstances\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\"], []); // Bounding info\n\n    this.refreshBoundingInfo(); // Parent\n\n    if (newParent) {\n      result.parent = newParent;\n    }\n\n    if (!doNotCloneChildren) {\n      // Children\n      for (var index = 0; index < this.getScene().meshes.length; index++) {\n        var mesh = this.getScene().meshes[index];\n\n        if (mesh.parent === this) {\n          mesh.clone(mesh.name, result);\n        }\n      }\n    }\n\n    result.computeWorldMatrix(true);\n    return result;\n  };\n  /**\r\n   * Disposes the InstancedMesh.\r\n   * Returns nothing.\r\n   */\n\n\n  InstancedMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    } // Remove from mesh\n\n\n    this._sourceMesh.removeInstance(this);\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n\n  return InstancedMesh;\n}(AbstractMesh);\n\nexport { InstancedMesh };\nMesh.prototype.edgesShareWithInstances = false;\n\nMesh.prototype.registerInstancedBuffer = function (kind, stride) {\n  // Remove existing one\n  this.removeVerticesData(kind); // Creates the instancedBuffer field if not present\n\n  if (!this.instancedBuffers) {\n    this.instancedBuffers = {};\n\n    for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {\n      var instance = _a[_i];\n      instance.instancedBuffers = {};\n    }\n\n    this._userInstancedBuffersStorage = {\n      data: {},\n      vertexBuffers: {},\n      strides: {},\n      sizes: {}\n    };\n  } // Creates an empty property for this kind\n\n\n  this.instancedBuffers[kind] = null;\n  this._userInstancedBuffersStorage.strides[kind] = stride;\n  this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\n\n  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\n  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n  this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);\n\n  for (var _b = 0, _c = this.instances; _b < _c.length; _b++) {\n    var instance = _c[_b];\n    instance.instancedBuffers[kind] = null;\n  }\n};\n\nMesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\n  var instanceCount = visibleInstances.length;\n\n  for (var kind in this.instancedBuffers) {\n    var size = this._userInstancedBuffersStorage.sizes[kind];\n    var stride = this._userInstancedBuffersStorage.strides[kind]; // Resize if required\n\n    var expectedSize = (instanceCount + 1) * stride;\n\n    while (size < expectedSize) {\n      size *= 2;\n    }\n\n    if (this._userInstancedBuffersStorage.data[kind].length != size) {\n      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\n      this._userInstancedBuffersStorage.sizes[kind] = size;\n\n      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n\n        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n      }\n    }\n\n    var data = this._userInstancedBuffersStorage.data[kind]; // Update data buffer\n\n    var offset = 0;\n\n    if (renderSelf) {\n      var value = this.instancedBuffers[kind];\n\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else {\n        value.copyToArray(data, offset);\n      }\n\n      offset += stride;\n    }\n\n    for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\n      var instance = visibleInstances[instanceIndex];\n      var value = instance.instancedBuffers[kind];\n\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else {\n        value.copyToArray(data, offset);\n      }\n\n      offset += stride;\n    } // Update vertex buffer\n\n\n    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n      this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);\n    } else {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);\n    }\n  }\n};\n\nMesh.prototype._disposeInstanceSpecificData = function () {\n  if (this._instanceDataStorage.instancesBuffer) {\n    this._instanceDataStorage.instancesBuffer.dispose();\n\n    this._instanceDataStorage.instancesBuffer = null;\n  }\n\n  while (this.instances.length) {\n    this.instances[0].dispose();\n  }\n\n  for (var kind in this.instancedBuffers) {\n    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n    }\n  }\n\n  this.instancedBuffers = {};\n};","map":null,"metadata":{},"sourceType":"module"}