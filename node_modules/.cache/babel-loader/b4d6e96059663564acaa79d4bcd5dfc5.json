{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Matrix, Vector2 } from \"../Maths/math.vector\";\nimport { PostProcess } from \"./postProcess\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration\";\nimport \"../Animations/animatable\";\nimport '../Rendering/geometryBufferRendererSceneComponent';\nimport \"../Shaders/motionBlur.fragment\";\nimport { serialize, SerializationHelper } from '../Misc/decorators';\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\n\nvar MotionBlurPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(MotionBlurPostProcess, _super);\n  /**\r\n   * Creates a new instance MotionBlurPostProcess\r\n   * @param name The name of the effect.\r\n   * @param scene The scene containing the objects to blur according to their velocity.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass.\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   * @param textureType Type of textures used when performing the post process. (default: 0)\r\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n   */\n\n\n  function MotionBlurPostProcess(name, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation, forceGeometryBuffer) {\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (forceGeometryBuffer === void 0) {\n      forceGeometryBuffer = true;\n    }\n\n    var _this = _super.call(this, name, \"motionBlur\", [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\"], [\"velocitySampler\"], options, camera, samplingMode, engine, reusable, \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\", textureType, undefined, null, blockCompilation) || this;\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\n\n\n    _this.motionStrength = 1;\n    _this._motionBlurSamples = 32;\n    _this._isObjectBased = true;\n    _this._forceGeometryBuffer = false;\n    _this._geometryBufferRenderer = null;\n    _this._prePassRenderer = null;\n    _this._invViewProjection = null;\n    _this._previousViewProjection = null;\n    _this._forceGeometryBuffer = forceGeometryBuffer; // Set up assets\n\n    if (_this._forceGeometryBuffer) {\n      _this._geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n\n      if (_this._geometryBufferRenderer) {\n        _this._geometryBufferRenderer.enableVelocity = true;\n      }\n    } else {\n      _this._prePassRenderer = scene.enablePrePassRenderer();\n\n      if (_this._prePassRenderer) {\n        _this._prePassRenderer.markAsDirty();\n\n        _this._prePassEffectConfiguration = new MotionBlurConfiguration();\n      }\n    }\n\n    _this._applyMode();\n\n    return _this;\n  }\n\n  Object.defineProperty(MotionBlurPostProcess.prototype, \"motionBlurSamples\", {\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\n    get: function get() {\n      return this._motionBlurSamples;\n    },\n\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\n    set: function set(samples) {\n      this._motionBlurSamples = samples;\n\n      this._updateEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MotionBlurPostProcess.prototype, \"isObjectBased\", {\n    /**\r\n     * Gets wether or not the motion blur post-process is in object based mode.\r\n     */\n    get: function get() {\n      return this._isObjectBased;\n    },\n\n    /**\r\n     * Sets wether or not the motion blur post-process is in object based mode.\r\n     */\n    set: function set(value) {\n      if (this._isObjectBased === value) {\n        return;\n      }\n\n      this._isObjectBased = value;\n\n      this._applyMode();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"MotionBlurPostProcess\" string\r\n   */\n\n  MotionBlurPostProcess.prototype.getClassName = function () {\n    return \"MotionBlurPostProcess\";\n  };\n  /**\r\n   * Excludes the given skinned mesh from computing bones velocities.\r\n   * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n   * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n   */\n\n\n  MotionBlurPostProcess.prototype.excludeSkinnedMesh = function (skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      var list = void 0;\n\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n\n      list.push(skinnedMesh);\n    }\n  };\n  /**\r\n   * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n   * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n   * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n   */\n\n\n  MotionBlurPostProcess.prototype.removeExcludedSkinnedMesh = function (skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      var list = void 0;\n\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n\n      var index = list.indexOf(skinnedMesh);\n\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    }\n  };\n  /**\r\n   * Disposes the post process.\r\n   * @param camera The camera to dispose the post process on.\r\n   */\n\n\n  MotionBlurPostProcess.prototype.dispose = function (camera) {\n    if (this._geometryBufferRenderer) {\n      // Clear previous transformation matrices dictionary used to compute objects velocities\n      this._geometryBufferRenderer._previousTransformationMatrices = {};\n      this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\n      this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\n    }\n\n    _super.prototype.dispose.call(this, camera);\n  };\n  /**\r\n   * Called on the mode changed (object based or screen based).\r\n   */\n\n\n  MotionBlurPostProcess.prototype._applyMode = function () {\n    var _this = this;\n\n    if (!this._geometryBufferRenderer && !this._prePassRenderer) {\n      // We can't get a velocity or depth texture. So, work as a passthrough.\n      Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\n      return this.updateEffect();\n    }\n\n    this._updateEffect();\n\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n\n    if (this.isObjectBased) {\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 2;\n      }\n\n      this.onApply = function (effect) {\n        return _this._onApplyObjectBased(effect);\n      };\n    } else {\n      this._invViewProjection = Matrix.Identity();\n      this._previousViewProjection = Matrix.Identity();\n\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 5;\n      }\n\n      this.onApply = function (effect) {\n        return _this._onApplyScreenBased(effect);\n      };\n    }\n  };\n  /**\r\n   * Called on the effect is applied when the motion blur post-process is in object based mode.\r\n   */\n\n\n  MotionBlurPostProcess.prototype._onApplyObjectBased = function (effect) {\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n\n    if (this._geometryBufferRenderer) {\n      var velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\n\n      effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n    } else if (this._prePassRenderer) {\n      var velocityIndex = this._prePassRenderer.getIndex(2);\n\n      effect.setTexture(\"velocitySampler\", this._prePassRenderer.prePassRT.textures[velocityIndex]);\n    }\n  };\n  /**\r\n   * Called on the effect is applied when the motion blur post-process is in screen based mode.\r\n   */\n\n\n  MotionBlurPostProcess.prototype._onApplyScreenBased = function (effect) {\n    var viewProjection = this._scene.getProjectionMatrix().multiply(this._scene.getViewMatrix());\n\n    viewProjection.invertToRef(this._invViewProjection);\n    effect.setMatrix(\"inverseViewProjection\", this._invViewProjection);\n    effect.setMatrix(\"prevViewProjection\", this._previousViewProjection);\n    this._previousViewProjection = viewProjection;\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n\n    if (this._geometryBufferRenderer) {\n      var depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE);\n\n      effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n    } else if (this._prePassRenderer) {\n      var depthIndex = this._prePassRenderer.getIndex(5);\n\n      effect.setTexture(\"depthSampler\", this._prePassRenderer.prePassRT.textures[depthIndex]);\n    }\n  };\n  /**\r\n   * Called on the effect must be updated (changed mode, samples count, etc.).\r\n   */\n\n\n  MotionBlurPostProcess.prototype._updateEffect = function () {\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      var defines = [\"#define GEOMETRY_SUPPORTED\", \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1), this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\"];\n      this.updateEffect(defines.join(\"\\n\"));\n    }\n  };\n  /** @hidden */\n\n\n  MotionBlurPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new MotionBlurPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"motionStrength\", void 0);\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"motionBlurSamples\", null);\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"isObjectBased\", null);\n\n  return MotionBlurPostProcess;\n}(PostProcess);\n\nexport { MotionBlurPostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.MotionBlurPostProcess\"] = MotionBlurPostProcess;","map":null,"metadata":{},"sourceType":"module"}