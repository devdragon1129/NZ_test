{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\n\nvar batch = require('it-batch');\n/**\n * @typedef {import('cids')} CID\n * @typedef {import('ipfs-unixfs').UnixFS} UnixFS\n * @typedef {import('../../types').ImporterOptions} ImporterOptions\n * @typedef {import('../../types').InProgressImportResult} InProgressImportResult\n * @typedef {import('../../types').TrickleDagNode} TrickleDagNode\n * @typedef {import('../../types').Reducer} Reducer\n * @typedef {import('../../types').FileDAGBuilder} FileDAGBuilder\n */\n\n/**\n * @type {FileDAGBuilder}\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _trickleStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, reduce, options) {\n    var root, iteration, maxDepth, subTree, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, layer;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            root = new Root(options.layerRepeat);\n            iteration = 0;\n            maxDepth = 1;\n            /** @type {SubTree} */\n\n            subTree = root;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 6;\n            _iterator = _asyncIterator(batch(source, options.maxChildrenPerNode));\n\n          case 8:\n            _context.next = 10;\n            return _iterator.next();\n\n          case 10:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 26;\n              break;\n            }\n\n            layer = _step.value;\n\n            if (!subTree.isFull()) {\n              _context.next = 22;\n              break;\n            }\n\n            if (!(subTree !== root)) {\n              _context.next = 19;\n              break;\n            }\n\n            _context.t0 = root;\n            _context.next = 17;\n            return subTree.reduce(reduce);\n\n          case 17:\n            _context.t1 = _context.sent;\n\n            _context.t0.addChild.call(_context.t0, _context.t1);\n\n          case 19:\n            if (iteration && iteration % options.layerRepeat === 0) {\n              maxDepth++;\n            }\n\n            subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n            iteration++;\n\n          case 22:\n            subTree.append(layer);\n\n          case 23:\n            _iteratorAbruptCompletion = false;\n            _context.next = 8;\n            break;\n\n          case 26:\n            _context.next = 32;\n            break;\n\n          case 28:\n            _context.prev = 28;\n            _context.t2 = _context[\"catch\"](6);\n            _didIteratorError = true;\n            _iteratorError = _context.t2;\n\n          case 32:\n            _context.prev = 32;\n            _context.prev = 33;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 37;\n              break;\n            }\n\n            _context.next = 37;\n            return _iterator.return();\n\n          case 37:\n            _context.prev = 37;\n\n            if (!_didIteratorError) {\n              _context.next = 40;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 40:\n            return _context.finish(37);\n\n          case 41:\n            return _context.finish(32);\n\n          case 42:\n            if (!(subTree && subTree !== root)) {\n              _context.next = 48;\n              break;\n            }\n\n            _context.t3 = root;\n            _context.next = 46;\n            return subTree.reduce(reduce);\n\n          case 46:\n            _context.t4 = _context.sent;\n\n            _context.t3.addChild.call(_context.t3, _context.t4);\n\n          case 48:\n            return _context.abrupt(\"return\", root.reduce(reduce));\n\n          case 49:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[6, 28, 32, 42], [33,, 37, 41]]);\n  }));\n\n  function trickleStream(_x, _x2, _x3) {\n    return _trickleStream.apply(this, arguments);\n  }\n\n  return trickleStream;\n}();\n\nvar SubTree = /*#__PURE__*/function () {\n  /**\n   * @param {number} maxDepth\n   * @param {number} layerRepeat\n   * @param {number} [iteration=0]\n   */\n  function SubTree(maxDepth, layerRepeat) {\n    var iteration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, SubTree);\n\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n    /** @type {TrickleDagNode} */\n\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth: maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n\n  _createClass(SubTree, [{\n    key: \"isFull\",\n    value: function isFull() {\n      if (!this.root.data) {\n        return false;\n      }\n\n      if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n        // can descend\n        this._addNextNodeToParent(this.node);\n\n        return false;\n      } // try to find new node from node.parent\n\n\n      var distantRelative = this._findParent(this.node, this.currentDepth);\n\n      if (distantRelative) {\n        this._addNextNodeToParent(distantRelative);\n\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * @param {TrickleDagNode} parent\n     */\n\n  }, {\n    key: \"_addNextNodeToParent\",\n    value: function _addNextNodeToParent(parent) {\n      this.parent = parent; // find site for new node\n\n      var nextNode = {\n        children: [],\n        depth: parent.depth + 1,\n        parent: parent,\n        maxDepth: this.maxDepth,\n        maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n      }; // @ts-ignore\n\n      parent.children.push(nextNode);\n      this.currentDepth = nextNode.depth;\n      this.node = nextNode;\n    }\n    /**\n     *\n     * @param {InProgressImportResult[]} layer\n     */\n\n  }, {\n    key: \"append\",\n    value: function append(layer) {\n      this.node.data = layer;\n    }\n    /**\n     * @param {Reducer} reduce\n     */\n\n  }, {\n    key: \"reduce\",\n    value: function reduce(_reduce) {\n      return this._reduce(this.root, _reduce);\n    }\n    /**\n     * @param {TrickleDagNode} node\n     * @param {Reducer} reduce\n     * @returns {Promise<InProgressImportResult>}\n     */\n\n  }, {\n    key: \"_reduce\",\n    value: function () {\n      var _reduce2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(node, reduce) {\n        var _this = this;\n\n        var children;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                /** @type {InProgressImportResult[]} */\n                children = [];\n\n                if (!node.children.length) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return Promise.all(node.children // @ts-ignore\n                .filter(function (child) {\n                  return child.data;\n                }) // @ts-ignore\n                .map(function (child) {\n                  return _this._reduce(child, reduce);\n                }));\n\n              case 4:\n                children = _context2.sent;\n\n              case 5:\n                return _context2.abrupt(\"return\", reduce((node.data || []).concat(children)));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function _reduce(_x4, _x5) {\n        return _reduce2.apply(this, arguments);\n      }\n\n      return _reduce;\n    }()\n    /**\n     * @param {TrickleDagNode} node\n     * @param {number} depth\n     * @returns {TrickleDagNode | undefined}\n     */\n\n  }, {\n    key: \"_findParent\",\n    value: function _findParent(node, depth) {\n      var parent = node.parent;\n\n      if (!parent || parent.depth === 0) {\n        return;\n      }\n\n      if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n        // this layer is full, may be able to traverse to a different branch\n        return this._findParent(parent, depth);\n      }\n\n      return parent;\n    }\n  }]);\n\n  return SubTree;\n}();\n\nvar Root = /*#__PURE__*/function (_SubTree) {\n  _inherits(Root, _SubTree);\n\n  /**\n   * @param {number} layerRepeat\n   */\n  function Root(layerRepeat) {\n    var _this2;\n\n    _classCallCheck(this, Root);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Root).call(this, 0, layerRepeat));\n    _this2.root.depth = 0;\n    _this2.currentDepth = 1;\n    return _this2;\n  }\n  /**\n   * @param {InProgressImportResult} child\n   */\n\n\n  _createClass(Root, [{\n    key: \"addChild\",\n    value: function addChild(child) {\n      this.root.children.push(child);\n    }\n    /**\n     * @param {Reducer} reduce\n     */\n\n  }, {\n    key: \"reduce\",\n    value: function reduce(_reduce3) {\n      return _reduce3((this.root.data || []).concat(this.root.children));\n    }\n  }]);\n\n  return Root;\n}(SubTree);","map":null,"metadata":{},"sourceType":"script"}