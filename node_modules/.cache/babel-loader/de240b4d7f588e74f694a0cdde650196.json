{"ast":null,"code":"import _toConsumableArray from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(assetSaga);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { call, put, takeLatest, select } from 'redux-saga/effects';\nimport { LOAD_COLLECTIBLES_REQUEST, loadCollectiblesSuccess, loadCollectiblesRequest, loadCollectiblesFailure } from './actions';\nimport { COLLECTIBLE_ASSET_PACK_ID } from 'modules/ui/sidebar/utils';\nimport { CONNECT_WALLET_SUCCESS } from 'decentraland-dapps/dist/modules/wallet/actions';\nimport { getAddress } from 'decentraland-dapps/dist/modules/wallet/selectors';\nimport { TRANSPARENT_PIXEL } from 'lib/getModelData';\nexport function assetSaga(client) {\n  var _marked, _marked2, handleConnectWallet, handleLoadCollectibles, getNFTs, _getNFTs;\n\n  return _regeneratorRuntime.wrap(function assetSaga$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _getNFTs = function _getNFTs3() {\n            _getNFTs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(owner, cursor) {\n              var response, next, nfts, nextNFTs;\n              return _regeneratorRuntime.wrap(function _callee$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      _context3.next = 2;\n                      return client.getNFTs({\n                        owner: owner,\n                        cursor: cursor\n                      });\n\n                    case 2:\n                      response = _context3.sent;\n                      next = response.next, nfts = response.nfts;\n\n                      if (!next) {\n                        _context3.next = 9;\n                        break;\n                      }\n\n                      _context3.next = 7;\n                      return getNFTs(owner, next);\n\n                    case 7:\n                      nextNFTs = _context3.sent;\n                      return _context3.abrupt(\"return\", [].concat(_toConsumableArray(nfts), _toConsumableArray(nextNFTs)));\n\n                    case 9:\n                      return _context3.abrupt(\"return\", nfts);\n\n                    case 10:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee);\n            }));\n            return _getNFTs.apply(this, arguments);\n          };\n\n          getNFTs = function _getNFTs2(_x, _x2) {\n            return _getNFTs.apply(this, arguments);\n          };\n\n          handleLoadCollectibles = function _handleLoadCollectibl(_) {\n            var address, assets, serverNFTs, _iterator, _step, openseaAsset, uri;\n\n            return _regeneratorRuntime.wrap(function handleLoadCollectibles$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return select(getAddress);\n\n                  case 2:\n                    address = _context2.sent;\n                    _context2.prev = 3;\n\n                    if (address) {\n                      _context2.next = 6;\n                      break;\n                    }\n\n                    throw new Error(\"Invalid address: \".concat(address));\n\n                  case 6:\n                    assets = [];\n                    _context2.next = 9;\n                    return call(getNFTs, address);\n\n                  case 9:\n                    serverNFTs = _context2.sent;\n                    _iterator = _createForOfIteratorHelper(serverNFTs);\n\n                    try {\n                      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                        openseaAsset = _step.value;\n                        uri = \"ethereum://\".concat(openseaAsset.contract.address, \"/\").concat(openseaAsset.tokenId);\n                        assets.push({\n                          assetPackId: COLLECTIBLE_ASSET_PACK_ID,\n                          id: uri,\n                          tags: [],\n                          category: openseaAsset.contract.name,\n                          contents: {},\n                          name: openseaAsset.name || '',\n                          model: uri,\n                          script: null,\n                          thumbnail: openseaAsset.imageThumbnailUrl || TRANSPARENT_PIXEL,\n                          metrics: {\n                            triangles: 0,\n                            materials: 0,\n                            meshes: 0,\n                            bodies: 0,\n                            entities: 0,\n                            textures: 0\n                          },\n                          parameters: [],\n                          actions: []\n                        });\n                      }\n                    } catch (err) {\n                      _iterator.e(err);\n                    } finally {\n                      _iterator.f();\n                    }\n\n                    _context2.next = 14;\n                    return put(loadCollectiblesSuccess(assets));\n\n                  case 14:\n                    _context2.next = 20;\n                    break;\n\n                  case 16:\n                    _context2.prev = 16;\n                    _context2.t0 = _context2[\"catch\"](3);\n                    _context2.next = 20;\n                    return put(loadCollectiblesFailure(_context2.t0.message));\n\n                  case 20:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _marked2, null, [[3, 16]]);\n          };\n\n          handleConnectWallet = function _handleConnectWallet() {\n            return _regeneratorRuntime.wrap(function handleConnectWallet$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return put(loadCollectiblesRequest());\n\n                  case 2:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _marked);\n          };\n\n          _marked = /*#__PURE__*/_regeneratorRuntime.mark(handleConnectWallet), _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(handleLoadCollectibles);\n          _context4.next = 7;\n          return takeLatest(LOAD_COLLECTIBLES_REQUEST, handleLoadCollectibles);\n\n        case 7:\n          _context4.next = 9;\n          return takeLatest(CONNECT_WALLET_SUCCESS, handleConnectWallet);\n\n        case 9:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked3);\n}","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/asset/sagas.ts"],"names":["assetSaga","call","put","takeLatest","select","LOAD_COLLECTIBLES_REQUEST","loadCollectiblesSuccess","loadCollectiblesRequest","loadCollectiblesFailure","COLLECTIBLE_ASSET_PACK_ID","CONNECT_WALLET_SUCCESS","getAddress","TRANSPARENT_PIXEL","client","handleConnectWallet","handleLoadCollectibles","getNFTs","owner","cursor","response","next","nfts","nextNFTs","_","address","Error","assets","serverNFTs","openseaAsset","uri","contract","tokenId","push","assetPackId","id","tags","category","name","contents","model","script","thumbnail","imageThumbnailUrl","metrics","triangles","materials","meshes","bodies","entities","textures","parameters","actions","message"],"mappings":"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","sourcesContent":["import { call, put, takeLatest, select } from 'redux-saga/effects'\nimport {\n  LoadCollectiblesRequestAction,\n  LOAD_COLLECTIBLES_REQUEST,\n  loadCollectiblesSuccess,\n  loadCollectiblesRequest,\n  loadCollectiblesFailure\n} from './actions'\nimport { Asset } from './types'\nimport { COLLECTIBLE_ASSET_PACK_ID } from 'modules/ui/sidebar/utils'\nimport { CONNECT_WALLET_SUCCESS } from 'decentraland-dapps/dist/modules/wallet/actions'\nimport { getAddress } from 'decentraland-dapps/dist/modules/wallet/selectors'\nimport { TRANSPARENT_PIXEL } from 'lib/getModelData'\nimport { BuilderClient, NFT } from '@dcl/builder-client'\n\nexport function* assetSaga(client: BuilderClient) {\n  yield takeLatest(LOAD_COLLECTIBLES_REQUEST, handleLoadCollectibles)\n  yield takeLatest(CONNECT_WALLET_SUCCESS, handleConnectWallet)\n\n  function* handleConnectWallet() {\n    yield put(loadCollectiblesRequest())\n  }\n\n  function* handleLoadCollectibles(_: LoadCollectiblesRequestAction) {\n    const address: string | null = yield select(getAddress)\n\n    try {\n      if (!address) {\n        throw new Error(`Invalid address: ${address}`)\n      }\n      const assets: Asset[] = []\n      const serverNFTs: NFT[] = yield call(getNFTs, address)\n      for (const openseaAsset of serverNFTs) {\n        const uri = `ethereum://${openseaAsset.contract.address}/${openseaAsset.tokenId}`\n        assets.push({\n          assetPackId: COLLECTIBLE_ASSET_PACK_ID,\n          id: uri,\n          tags: [],\n          category: openseaAsset.contract.name,\n          contents: {},\n          name: openseaAsset.name || '',\n          model: uri,\n          script: null,\n          thumbnail: openseaAsset.imageThumbnailUrl || TRANSPARENT_PIXEL,\n          metrics: {\n            triangles: 0,\n            materials: 0,\n            meshes: 0,\n            bodies: 0,\n            entities: 0,\n            textures: 0\n          },\n          parameters: [],\n          actions: []\n        })\n      }\n      yield put(loadCollectiblesSuccess(assets))\n    } catch (error) {\n      yield put(loadCollectiblesFailure(error.message))\n    }\n  }\n\n  async function getNFTs(owner: string, cursor?: string): Promise<NFT[]> {\n    const response = await client.getNFTs({ owner, cursor })\n\n    const { next, nfts } = response\n\n    if (next) {\n      const nextNFTs = await getNFTs(owner, next)\n\n      return [...nfts, ...nextNFTs]\n    }\n\n    return nfts\n  }\n}\n"]},"metadata":{},"sourceType":"module"}