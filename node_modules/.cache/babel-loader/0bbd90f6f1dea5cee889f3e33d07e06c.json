{"ast":null,"code":"import { Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\n/**\r\n     * Information about the result of picking within a scene\r\n     * @see https://doc.babylonjs.com/babylon101/picking_collisions\r\n     */\n\nvar PickingInfo =\n/** @class */\nfunction () {\n  function PickingInfo() {\n    /** @hidden */\n    this._pickingUnavailable = false;\n    /**\r\n     * If the pick collided with an object\r\n     */\n\n    this.hit = false;\n    /**\r\n     * Distance away where the pick collided\r\n     */\n\n    this.distance = 0;\n    /**\r\n     * The location of pick collision\r\n     */\n\n    this.pickedPoint = null;\n    /**\r\n     * The mesh corresponding the the pick collision\r\n     */\n\n    this.pickedMesh = null;\n    /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/\n\n    this.bu = 0;\n    /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/\n\n    this.bv = 0;\n    /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n\n    this.faceId = -1;\n    /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n\n    this.subMeshFaceId = -1;\n    /** Id of the the submesh that was picked */\n\n    this.subMeshId = 0;\n    /** If a sprite was picked, this will be the sprite the pick collided with */\n\n    this.pickedSprite = null;\n    /** If we are pikcing a mesh with thin instance, this will give you the picked thin instance */\n\n    this.thinInstanceIndex = -1;\n    /**\r\n     * If a mesh was used to do the picking (eg. 6dof controller) this will be populated.\r\n     */\n\n    this.originMesh = null;\n    /**\r\n     * The ray that was used to perform the picking.\r\n     */\n\n    this.ray = null;\n  }\n  /**\r\n   * Gets the normal correspodning to the face the pick collided with\r\n   * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)\r\n   * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map\r\n   * @returns The normal correspodning to the face the pick collided with\r\n   */\n\n\n  PickingInfo.prototype.getNormal = function (useWorldCoordinates, useVerticesNormals) {\n    if (useWorldCoordinates === void 0) {\n      useWorldCoordinates = false;\n    }\n\n    if (useVerticesNormals === void 0) {\n      useVerticesNormals = true;\n    }\n\n    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      return null;\n    }\n\n    var indices = this.pickedMesh.getIndices();\n\n    if (!indices) {\n      return null;\n    }\n\n    var result;\n\n    if (useVerticesNormals) {\n      var normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);\n      var normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);\n      var normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);\n      var normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);\n      normal0 = normal0.scale(this.bu);\n      normal1 = normal1.scale(this.bv);\n      normal2 = normal2.scale(1.0 - this.bu - this.bv);\n      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\n    } else {\n      var positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);\n      var vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);\n      var vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);\n      var vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);\n      var p1p2 = vertex1.subtract(vertex2);\n      var p3p2 = vertex3.subtract(vertex2);\n      result = Vector3.Cross(p1p2, p3p2);\n    }\n\n    if (useWorldCoordinates) {\n      var wm = this.pickedMesh.getWorldMatrix();\n\n      if (this.pickedMesh.nonUniformScaling) {\n        TmpVectors.Matrix[0].copyFrom(wm);\n        wm = TmpVectors.Matrix[0];\n        wm.setTranslationFromFloats(0, 0, 0);\n        wm.invert();\n        wm.transposeToRef(TmpVectors.Matrix[1]);\n        wm = TmpVectors.Matrix[1];\n      }\n\n      result = Vector3.TransformNormal(result, wm);\n    }\n\n    result.normalize();\n    return result;\n  };\n  /**\r\n   * Gets the texture coordinates of where the pick occured\r\n   * @returns the vector containing the coordnates of the texture\r\n   */\n\n\n  PickingInfo.prototype.getTextureCoordinates = function () {\n    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      return null;\n    }\n\n    var indices = this.pickedMesh.getIndices();\n\n    if (!indices) {\n      return null;\n    }\n\n    var uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);\n\n    if (!uvs) {\n      return null;\n    }\n\n    var uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\n    var uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\n    var uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\n    uv0 = uv0.scale(this.bu);\n    uv1 = uv1.scale(this.bv);\n    uv2 = uv2.scale(1.0 - this.bu - this.bv);\n    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\n  };\n\n  return PickingInfo;\n}();\n\nexport { PickingInfo };","map":null,"metadata":{},"sourceType":"module"}