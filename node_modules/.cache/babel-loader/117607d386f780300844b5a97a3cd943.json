{"ast":null,"code":"import { SmartArray } from \"../Misc/smartArray\";\nimport { Logger } from \"../Misc/logger\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { MorphTarget } from \"./morphTarget\";\n/**\r\n * This class is used to deform meshes using morphing between different targets\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n */\n\nvar MorphTargetManager =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new MorphTargetManager\r\n   * @param scene defines the current scene\r\n   */\n  function MorphTargetManager(scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this._targets = new Array();\n    this._targetInfluenceChangedObservers = new Array();\n    this._targetDataLayoutChangedObservers = new Array();\n    this._activeTargets = new SmartArray(16);\n    this._supportsNormals = false;\n    this._supportsTangents = false;\n    this._supportsUVs = false;\n    this._vertexCount = 0;\n    this._uniqueId = 0;\n    this._tempInfluences = new Array();\n    /**\r\n     * Gets or sets a boolean indicating if normals must be morphed\r\n     */\n\n    this.enableNormalMorphing = true;\n    /**\r\n     * Gets or sets a boolean indicating if tangents must be morphed\r\n     */\n\n    this.enableTangentMorphing = true;\n    /**\r\n     * Gets or sets a boolean indicating if UV must be morphed\r\n     */\n\n    this.enableUVMorphing = true;\n\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    this._scene = scene;\n\n    if (this._scene) {\n      this._scene.morphTargetManagers.push(this);\n\n      this._uniqueId = this._scene.getUniqueId();\n    }\n  }\n\n  Object.defineProperty(MorphTargetManager.prototype, \"uniqueId\", {\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\n    get: function get() {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"vertexCount\", {\n    /**\r\n     * Gets the number of vertices handled by this manager\r\n     */\n    get: function get() {\n      return this._vertexCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsNormals\", {\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of normals\r\n     */\n    get: function get() {\n      return this._supportsNormals && this.enableNormalMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsTangents\", {\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of tangents\r\n     */\n    get: function get() {\n      return this._supportsTangents && this.enableTangentMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsUVs\", {\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\r\n     */\n    get: function get() {\n      return this._supportsUVs && this.enableUVMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"numTargets\", {\n    /**\r\n     * Gets the number of targets stored in this manager\r\n     */\n    get: function get() {\n      return this._targets.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"numInfluencers\", {\n    /**\r\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\r\n     */\n    get: function get() {\n      return this._activeTargets.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"influences\", {\n    /**\r\n     * Gets the list of influences (one per target)\r\n     */\n    get: function get() {\n      return this._influences;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the active target at specified index. An active target is a target with an influence > 0\r\n   * @param index defines the index to check\r\n   * @returns the requested target\r\n   */\n\n  MorphTargetManager.prototype.getActiveTarget = function (index) {\n    return this._activeTargets.data[index];\n  };\n  /**\r\n   * Gets the target at specified index\r\n   * @param index defines the index to check\r\n   * @returns the requested target\r\n   */\n\n\n  MorphTargetManager.prototype.getTarget = function (index) {\n    return this._targets[index];\n  };\n  /**\r\n   * Add a new target to this manager\r\n   * @param target defines the target to add\r\n   */\n\n\n  MorphTargetManager.prototype.addTarget = function (target) {\n    var _this = this;\n\n    this._targets.push(target);\n\n    this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add(function (needUpdate) {\n      _this._syncActiveTargets(needUpdate);\n    }));\n\n    this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(function () {\n      _this._syncActiveTargets(true);\n    }));\n\n    this._syncActiveTargets(true);\n  };\n  /**\r\n   * Removes a target from the manager\r\n   * @param target defines the target to remove\r\n   */\n\n\n  MorphTargetManager.prototype.removeTarget = function (target) {\n    var index = this._targets.indexOf(target);\n\n    if (index >= 0) {\n      this._targets.splice(index, 1);\n\n      target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\n\n      target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\n\n      this._syncActiveTargets(true);\n    }\n  };\n  /**\r\n   * Clone the current manager\r\n   * @returns a new MorphTargetManager\r\n   */\n\n\n  MorphTargetManager.prototype.clone = function () {\n    var copy = new MorphTargetManager(this._scene);\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n      copy.addTarget(target.clone());\n    }\n\n    copy.enableNormalMorphing = this.enableNormalMorphing;\n    copy.enableTangentMorphing = this.enableTangentMorphing;\n    copy.enableUVMorphing = this.enableUVMorphing;\n    return copy;\n  };\n  /**\r\n   * Serializes the current manager into a Serialization object\r\n   * @returns the serialized object\r\n   */\n\n\n  MorphTargetManager.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.uniqueId;\n    serializationObject.targets = [];\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n      serializationObject.targets.push(target.serialize());\n    }\n\n    return serializationObject;\n  };\n\n  MorphTargetManager.prototype._syncActiveTargets = function (needUpdate) {\n    var influenceCount = 0;\n\n    this._activeTargets.reset();\n\n    this._supportsNormals = true;\n    this._supportsTangents = true;\n    this._supportsUVs = true;\n    this._vertexCount = 0;\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n\n      if (target.influence === 0) {\n        continue;\n      }\n\n      this._activeTargets.push(target);\n\n      this._tempInfluences[influenceCount++] = target.influence;\n      this._supportsNormals = this._supportsNormals && target.hasNormals;\n      this._supportsTangents = this._supportsTangents && target.hasTangents;\n      this._supportsUVs = this._supportsUVs && target.hasUVs;\n      var positions = target.getPositions();\n\n      if (positions) {\n        var vertexCount = positions.length / 3;\n\n        if (this._vertexCount === 0) {\n          this._vertexCount = vertexCount;\n        } else if (this._vertexCount !== vertexCount) {\n          Logger.Error(\"Incompatible target. Targets must all have the same vertices count.\");\n          return;\n        }\n      }\n    }\n\n    if (!this._influences || this._influences.length !== influenceCount) {\n      this._influences = new Float32Array(influenceCount);\n    }\n\n    for (var index = 0; index < influenceCount; index++) {\n      this._influences[index] = this._tempInfluences[index];\n    }\n\n    if (needUpdate) {\n      this.synchronize();\n    }\n  };\n  /**\r\n   * Syncrhonize the targets with all the meshes using this morph target manager\r\n   */\n\n\n  MorphTargetManager.prototype.synchronize = function () {\n    if (!this._scene) {\n      return;\n    } // Flag meshes as dirty to resync with the active targets\n\n\n    for (var _i = 0, _a = this._scene.meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.morphTargetManager === this) {\n        mesh._syncGeometryWithMorphTargetManager();\n      }\n    }\n  }; // Statics\n\n  /**\r\n   * Creates a new MorphTargetManager from serialized data\r\n   * @param serializationObject defines the serialized data\r\n   * @param scene defines the hosting scene\r\n   * @returns the new MorphTargetManager\r\n   */\n\n\n  MorphTargetManager.Parse = function (serializationObject, scene) {\n    var result = new MorphTargetManager(scene);\n    result._uniqueId = serializationObject.id;\n\n    for (var _i = 0, _a = serializationObject.targets; _i < _a.length; _i++) {\n      var targetData = _a[_i];\n      result.addTarget(MorphTarget.Parse(targetData));\n    }\n\n    return result;\n  };\n\n  return MorphTargetManager;\n}();\n\nexport { MorphTargetManager };","map":null,"metadata":{},"sourceType":"module"}