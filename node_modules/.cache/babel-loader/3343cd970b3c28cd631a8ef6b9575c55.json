{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsImageProcessingConfiguration, expandToProperty } from \"../../Misc/decorators\";\nimport { Logger } from \"../../Misc/logger\";\nimport { SmartArray } from \"../../Misc/smartArray\";\nimport { BRDFTextureTools } from \"../../Misc/brdfTextureTools\";\nimport { Scene } from \"../../scene\";\nimport { Vector4 } from \"../../Maths/math.vector\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\nimport { PBRClearCoatConfiguration } from \"./pbrClearCoatConfiguration\";\nimport { PBRAnisotropicConfiguration } from \"./pbrAnisotropicConfiguration\";\nimport { PBRBRDFConfiguration } from \"./pbrBRDFConfiguration\";\nimport { PBRSheenConfiguration } from \"./pbrSheenConfiguration\";\nimport { PBRSubSurfaceConfiguration } from \"./pbrSubSurfaceConfiguration\";\nimport { PrePassConfiguration } from \"../prePassConfiguration\";\nimport { Color3, TmpColors } from '../../Maths/math.color';\nimport { Scalar } from \"../../Maths/math.scalar\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\nimport { Material } from \"../../Materials/material\";\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { MaterialFlags } from \"../materialFlags\";\nimport \"../../Materials/Textures/baseTexture.polynomial\";\nimport \"../../Shaders/pbr.fragment\";\nimport \"../../Shaders/pbr.vertex\";\nimport { EffectFallbacks } from '../effectFallbacks';\nimport { DetailMapConfiguration } from '../material.detailMapConfiguration';\nvar onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/**\r\n * Manages the defines for the PBR Material.\r\n * @hidden\r\n */\n\nvar PBRMaterialDefines =\n/** @class */\nfunction (_super) {\n  __extends(PBRMaterialDefines, _super);\n  /**\r\n   * Initializes the PBR Material defines.\r\n   */\n\n\n  function PBRMaterialDefines() {\n    var _this = _super.call(this) || this;\n\n    _this.PBR = true;\n    _this.NUM_SAMPLES = \"0\";\n    _this.REALTIME_FILTERING = false;\n    _this.MAINUV1 = false;\n    _this.MAINUV2 = false;\n    _this.UV1 = false;\n    _this.UV2 = false;\n    _this.ALBEDO = false;\n    _this.GAMMAALBEDO = false;\n    _this.ALBEDODIRECTUV = 0;\n    _this.VERTEXCOLOR = false;\n    _this.DETAIL = false;\n    _this.DETAILDIRECTUV = 0;\n    _this.DETAIL_NORMALBLENDMETHOD = 0;\n    _this.AMBIENT = false;\n    _this.AMBIENTDIRECTUV = 0;\n    _this.AMBIENTINGRAYSCALE = false;\n    _this.OPACITY = false;\n    _this.VERTEXALPHA = false;\n    _this.OPACITYDIRECTUV = 0;\n    _this.OPACITYRGB = false;\n    _this.ALPHATEST = false;\n    _this.DEPTHPREPASS = false;\n    _this.ALPHABLEND = false;\n    _this.ALPHAFROMALBEDO = false;\n    _this.ALPHATESTVALUE = \"0.5\";\n    _this.SPECULAROVERALPHA = false;\n    _this.RADIANCEOVERALPHA = false;\n    _this.ALPHAFRESNEL = false;\n    _this.LINEARALPHAFRESNEL = false;\n    _this.PREMULTIPLYALPHA = false;\n    _this.EMISSIVE = false;\n    _this.EMISSIVEDIRECTUV = 0;\n    _this.REFLECTIVITY = false;\n    _this.REFLECTIVITYDIRECTUV = 0;\n    _this.SPECULARTERM = false;\n    _this.MICROSURFACEFROMREFLECTIVITYMAP = false;\n    _this.MICROSURFACEAUTOMATIC = false;\n    _this.LODBASEDMICROSFURACE = false;\n    _this.MICROSURFACEMAP = false;\n    _this.MICROSURFACEMAPDIRECTUV = 0;\n    _this.METALLICWORKFLOW = false;\n    _this.ROUGHNESSSTOREINMETALMAPALPHA = false;\n    _this.ROUGHNESSSTOREINMETALMAPGREEN = false;\n    _this.METALLNESSSTOREINMETALMAPBLUE = false;\n    _this.AOSTOREINMETALMAPRED = false;\n    _this.METALLIC_REFLECTANCE = false;\n    _this.METALLIC_REFLECTANCEDIRECTUV = 0;\n    _this.ENVIRONMENTBRDF = false;\n    _this.ENVIRONMENTBRDF_RGBD = false;\n    _this.NORMAL = false;\n    _this.TANGENT = false;\n    _this.BUMP = false;\n    _this.BUMPDIRECTUV = 0;\n    _this.OBJECTSPACE_NORMALMAP = false;\n    _this.PARALLAX = false;\n    _this.PARALLAXOCCLUSION = false;\n    _this.NORMALXYSCALE = true;\n    _this.LIGHTMAP = false;\n    _this.LIGHTMAPDIRECTUV = 0;\n    _this.USELIGHTMAPASSHADOWMAP = false;\n    _this.GAMMALIGHTMAP = false;\n    _this.RGBDLIGHTMAP = false;\n    _this.REFLECTION = false;\n    _this.REFLECTIONMAP_3D = false;\n    _this.REFLECTIONMAP_SPHERICAL = false;\n    _this.REFLECTIONMAP_PLANAR = false;\n    _this.REFLECTIONMAP_CUBIC = false;\n    _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\n    _this.REFLECTIONMAP_PROJECTION = false;\n    _this.REFLECTIONMAP_SKYBOX = false;\n    _this.REFLECTIONMAP_EXPLICIT = false;\n    _this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n    _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n    _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n    _this.INVERTCUBICMAP = false;\n    _this.USESPHERICALFROMREFLECTIONMAP = false;\n    _this.USEIRRADIANCEMAP = false;\n    _this.SPHERICAL_HARMONICS = false;\n    _this.USESPHERICALINVERTEX = false;\n    _this.REFLECTIONMAP_OPPOSITEZ = false;\n    _this.LODINREFLECTIONALPHA = false;\n    _this.GAMMAREFLECTION = false;\n    _this.RGBDREFLECTION = false;\n    _this.LINEARSPECULARREFLECTION = false;\n    _this.RADIANCEOCCLUSION = false;\n    _this.HORIZONOCCLUSION = false;\n    _this.INSTANCES = false;\n    _this.THIN_INSTANCES = false;\n    _this.PREPASS = false;\n    _this.PREPASS_IRRADIANCE = false;\n    _this.PREPASS_IRRADIANCE_INDEX = -1;\n    _this.PREPASS_ALBEDO = false;\n    _this.PREPASS_ALBEDO_INDEX = -1;\n    _this.PREPASS_DEPTHNORMAL = false;\n    _this.PREPASS_DEPTHNORMAL_INDEX = -1;\n    _this.PREPASS_POSITION = false;\n    _this.PREPASS_POSITION_INDEX = -1;\n    _this.PREPASS_VELOCITY = false;\n    _this.PREPASS_VELOCITY_INDEX = -1;\n    _this.PREPASS_REFLECTIVITY = false;\n    _this.PREPASS_REFLECTIVITY_INDEX = -1;\n    _this.SCENE_MRT_COUNT = 0;\n    _this.NUM_BONE_INFLUENCERS = 0;\n    _this.BonesPerMesh = 0;\n    _this.BONETEXTURE = false;\n    _this.BONES_VELOCITY_ENABLED = false;\n    _this.NONUNIFORMSCALING = false;\n    _this.MORPHTARGETS = false;\n    _this.MORPHTARGETS_NORMAL = false;\n    _this.MORPHTARGETS_TANGENT = false;\n    _this.MORPHTARGETS_UV = false;\n    _this.NUM_MORPH_INFLUENCERS = 0;\n    _this.IMAGEPROCESSING = false;\n    _this.VIGNETTE = false;\n    _this.VIGNETTEBLENDMODEMULTIPLY = false;\n    _this.VIGNETTEBLENDMODEOPAQUE = false;\n    _this.TONEMAPPING = false;\n    _this.TONEMAPPING_ACES = false;\n    _this.CONTRAST = false;\n    _this.COLORCURVES = false;\n    _this.COLORGRADING = false;\n    _this.COLORGRADING3D = false;\n    _this.SAMPLER3DGREENDEPTH = false;\n    _this.SAMPLER3DBGRMAP = false;\n    _this.IMAGEPROCESSINGPOSTPROCESS = false;\n    _this.EXPOSURE = false;\n    _this.MULTIVIEW = false;\n    _this.USEPHYSICALLIGHTFALLOFF = false;\n    _this.USEGLTFLIGHTFALLOFF = false;\n    _this.TWOSIDEDLIGHTING = false;\n    _this.SHADOWFLOAT = false;\n    _this.CLIPPLANE = false;\n    _this.CLIPPLANE2 = false;\n    _this.CLIPPLANE3 = false;\n    _this.CLIPPLANE4 = false;\n    _this.CLIPPLANE5 = false;\n    _this.CLIPPLANE6 = false;\n    _this.POINTSIZE = false;\n    _this.FOG = false;\n    _this.LOGARITHMICDEPTH = false;\n    _this.FORCENORMALFORWARD = false;\n    _this.SPECULARAA = false;\n    _this.CLEARCOAT = false;\n    _this.CLEARCOAT_DEFAULTIOR = false;\n    _this.CLEARCOAT_TEXTURE = false;\n    _this.CLEARCOAT_TEXTURE_ROUGHNESS = false;\n    _this.CLEARCOAT_TEXTUREDIRECTUV = 0;\n    _this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\n    _this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n    _this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;\n    _this.CLEARCOAT_BUMP = false;\n    _this.CLEARCOAT_BUMPDIRECTUV = 0;\n    _this.CLEARCOAT_REMAP_F0 = true;\n    _this.CLEARCOAT_TINT = false;\n    _this.CLEARCOAT_TINT_TEXTURE = false;\n    _this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\n    _this.ANISOTROPIC = false;\n    _this.ANISOTROPIC_TEXTURE = false;\n    _this.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n    _this.BRDF_V_HEIGHT_CORRELATED = false;\n    _this.MS_BRDF_ENERGY_CONSERVATION = false;\n    _this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;\n    _this.SHEEN = false;\n    _this.SHEEN_TEXTURE = false;\n    _this.SHEEN_TEXTURE_ROUGHNESS = false;\n    _this.SHEEN_TEXTUREDIRECTUV = 0;\n    _this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\n    _this.SHEEN_LINKWITHALBEDO = false;\n    _this.SHEEN_ROUGHNESS = false;\n    _this.SHEEN_ALBEDOSCALING = false;\n    _this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n    _this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\n    _this.SUBSURFACE = false;\n    _this.SS_REFRACTION = false;\n    _this.SS_TRANSLUCENCY = false;\n    _this.SS_SCATTERING = false;\n    _this.SS_THICKNESSANDMASK_TEXTURE = false;\n    _this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n    _this.SS_REFRACTIONMAP_3D = false;\n    _this.SS_REFRACTIONMAP_OPPOSITEZ = false;\n    _this.SS_LODINREFRACTIONALPHA = false;\n    _this.SS_GAMMAREFRACTION = false;\n    _this.SS_RGBDREFRACTION = false;\n    _this.SS_LINEARSPECULARREFRACTION = false;\n    _this.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n    _this.SS_ALBEDOFORREFRACTIONTINT = false;\n    _this.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n    _this.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = false;\n    _this.UNLIT = false;\n    _this.DEBUGMODE = 0;\n\n    _this.rebuild();\n\n    return _this;\n  }\n  /**\r\n   * Resets the PBR Material defines.\r\n   */\n\n\n  PBRMaterialDefines.prototype.reset = function () {\n    _super.prototype.reset.call(this);\n\n    this.ALPHATESTVALUE = \"0.5\";\n    this.PBR = true;\n  };\n\n  return PBRMaterialDefines;\n}(MaterialDefines);\n\nexport { PBRMaterialDefines };\n/**\r\n * The Physically based material base class of BJS.\r\n *\r\n * This offers the main features of a standard PBR material.\r\n * For more information, please refer to the documentation :\r\n * https://doc.babylonjs.com/how_to/physically_based_rendering\r\n */\n\nvar PBRBaseMaterial =\n/** @class */\nfunction (_super) {\n  __extends(PBRBaseMaterial, _super);\n  /**\r\n   * Instantiates a new PBRMaterial instance.\r\n   *\r\n   * @param name The material name\r\n   * @param scene The scene the material will be use in.\r\n   */\n\n\n  function PBRBaseMaterial(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     */\n\n\n    _this._directIntensity = 1.0;\n    /**\r\n     * Intensity of the emissive part of the material.\r\n     * This helps controlling the emissive effect without modifying the emissive color.\r\n     */\n\n    _this._emissiveIntensity = 1.0;\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the refelction for shiny ones.\r\n     */\n\n    _this._environmentIntensity = 1.0;\n    /**\r\n     * This is a special control allowing the reduction of the specular highlights coming from the\r\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\r\n     */\n\n    _this._specularIntensity = 1.0;\n    /**\r\n     * This stores the direct, emissive, environment, and specular light intensities into a Vector4.\r\n     */\n\n    _this._lightingInfos = new Vector4(_this._directIntensity, _this._emissiveIntensity, _this._environmentIntensity, _this._specularIntensity);\n    /**\r\n     * Debug Control allowing disabling the bump map on this material.\r\n     */\n\n    _this._disableBumpMap = false;\n    /**\r\n     * AKA Diffuse Texture in standard nomenclature.\r\n     */\n\n    _this._albedoTexture = null;\n    /**\r\n     * AKA Occlusion Texture in other nomenclature.\r\n     */\n\n    _this._ambientTexture = null;\n    /**\r\n     * AKA Occlusion Texture Intensity in other nomenclature.\r\n     */\n\n    _this._ambientTextureStrength = 1.0;\n    /**\r\n     * Defines how much the AO map is occluding the analytical lights (point spot...).\r\n     * 1 means it completely occludes it\r\n     * 0 mean it has no impact\r\n     */\n\n    _this._ambientTextureImpactOnAnalyticalLights = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\n    /**\r\n     * Stores the alpha values in a texture.\r\n     */\n\n    _this._opacityTexture = null;\n    /**\r\n     * Stores the reflection values in a texture.\r\n     */\n\n    _this._reflectionTexture = null;\n    /**\r\n     * Stores the emissive values in a texture.\r\n     */\n\n    _this._emissiveTexture = null;\n    /**\r\n     * AKA Specular texture in other nomenclature.\r\n     */\n\n    _this._reflectivityTexture = null;\n    /**\r\n     * Used to switch from specular/glossiness to metallic/roughness workflow.\r\n     */\n\n    _this._metallicTexture = null;\n    /**\r\n     * Specifies the metallic scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the metalness values of the metallic texture.\r\n     */\n\n    _this._metallic = null;\n    /**\r\n     * Specifies the roughness scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the roughness values of the metallic texture.\r\n     */\n\n    _this._roughness = null;\n    /**\r\n     * In metallic workflow, specifies an F0 factor to help configuring the material F0.\r\n     * By default the indexOfrefraction is used to compute F0;\r\n     *\r\n     * This is used as a factor against the default reflectance at normal incidence to tweak it.\r\n     *\r\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\r\n     * F90 = metallicReflectanceColor;\r\n     */\n\n    _this._metallicF0Factor = 1;\n    /**\r\n     * In metallic workflow, specifies an F90 color to help configuring the material F90.\r\n     * By default the F90 is always 1;\r\n     *\r\n     * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\r\n     *\r\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor\r\n     * F90 = metallicReflectanceColor;\r\n     */\n\n    _this._metallicReflectanceColor = Color3.White();\n    /**\r\n     * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\r\n     * This is multiply against the scalar values defined in the material.\r\n     */\n\n    _this._metallicReflectanceTexture = null;\n    /**\r\n     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\r\n     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\r\n     */\n\n    _this._microSurfaceTexture = null;\n    /**\r\n     * Stores surface normal data used to displace a mesh in a texture.\r\n     */\n\n    _this._bumpTexture = null;\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     */\n\n    _this._lightmapTexture = null;\n    /**\r\n     * The color of a material in ambient lighting.\r\n     */\n\n    _this._ambientColor = new Color3(0, 0, 0);\n    /**\r\n     * AKA Diffuse Color in other nomenclature.\r\n     */\n\n    _this._albedoColor = new Color3(1, 1, 1);\n    /**\r\n     * AKA Specular Color in other nomenclature.\r\n     */\n\n    _this._reflectivityColor = new Color3(1, 1, 1);\n    /**\r\n     * The color applied when light is reflected from a material.\r\n     */\n\n    _this._reflectionColor = new Color3(1, 1, 1);\n    /**\r\n     * The color applied when light is emitted from a material.\r\n     */\n\n    _this._emissiveColor = new Color3(0, 0, 0);\n    /**\r\n     * AKA Glossiness in other nomenclature.\r\n     */\n\n    _this._microSurface = 0.9;\n    /**\r\n     * Specifies that the material will use the light map as a show map.\r\n     */\n\n    _this._useLightmapAsShadowmap = false;\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     */\n\n    _this._useHorizonOcclusion = true;\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     */\n\n    _this._useRadianceOcclusion = true;\n    /**\r\n     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\r\n     */\n\n    _this._useAlphaFromAlbedoTexture = false;\n    /**\r\n     * Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).\r\n     * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.\r\n     */\n\n    _this._useSpecularOverAlpha = true;\n    /**\r\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\r\n     */\n\n    _this._useMicroSurfaceFromReflectivityMapAlpha = false;\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its alpha channel.\r\n     */\n\n    _this._useRoughnessFromMetallicTextureAlpha = true;\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its green channel.\r\n     */\n\n    _this._useRoughnessFromMetallicTextureGreen = false;\n    /**\r\n     * Specifies if the metallic texture contains the metallness information in its blue channel.\r\n     */\n\n    _this._useMetallnessFromMetallicTextureBlue = false;\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     */\n\n    _this._useAmbientOcclusionFromMetallicTextureRed = false;\n    /**\r\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\r\n     */\n\n    _this._useAmbientInGrayScale = false;\n    /**\r\n     * In case the reflectivity map does not contain the microsurface information in its alpha channel,\r\n     * The material will try to infer what glossiness each pixel should be.\r\n     */\n\n    _this._useAutoMicroSurfaceFromReflectivityMap = false;\n    /**\r\n     * Defines the  falloff type used in this material.\r\n     * It by default is Physical.\r\n     */\n\n    _this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).\r\n     * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.\r\n     */\n\n    _this._useRadianceOverAlpha = true;\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     */\n\n    _this._useObjectSpaceNormalMap = false;\n    /**\r\n     * Allows using the bump map in parallax mode.\r\n     */\n\n    _this._useParallax = false;\n    /**\r\n     * Allows using the bump map in parallax occlusion mode.\r\n     */\n\n    _this._useParallaxOcclusion = false;\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     */\n\n    _this._parallaxScaleBias = 0.05;\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     */\n\n    _this._disableLighting = false;\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\n\n    _this._maxSimultaneousLights = 4;\n    /**\r\n     * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).\r\n     */\n\n    _this._invertNormalMapX = false;\n    /**\r\n     * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).\r\n     */\n\n    _this._invertNormalMapY = false;\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\n\n    _this._twoSidedLighting = false;\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\n\n    _this._alphaCutOff = 0.4;\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\n\n    _this._forceAlphaTest = false;\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     */\n\n    _this._useAlphaFresnel = false;\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     */\n\n    _this._useLinearAlphaFresnel = false;\n    /**\r\n     * Specifies the environment BRDF texture used to comput the scale and offset roughness values\r\n     * from cos thetav and roughness:\r\n     * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n     */\n\n    _this._environmentBRDFTexture = null;\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     */\n\n    _this._forceIrradianceInFragment = false;\n    _this._realTimeFiltering = false;\n    _this._realTimeFilteringQuality = 8;\n    /**\r\n     * Force normal to face away from face.\r\n     */\n\n    _this._forceNormalForward = false;\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the bump values.\r\n     */\n\n    _this._enableSpecularAntiAliasing = false;\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\n\n    _this._imageProcessingObserver = null;\n    /**\r\n     * Stores the available render targets.\r\n     */\n\n    _this._renderTargets = new SmartArray(16);\n    /**\r\n     * Sets the global ambient color for the material used in lighting calculations.\r\n     */\n\n    _this._globalAmbientColor = new Color3(0, 0, 0);\n    /**\r\n     * Enables the use of logarithmic depth buffers, which is good for wide depth buffers.\r\n     */\n\n    _this._useLogarithmicDepth = false;\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\n\n    _this._unlit = false;\n    _this._debugMode = 0;\n    /**\r\n     * @hidden\r\n     * This is reserved for the inspector.\r\n     * Defines the material debug mode.\r\n     * It helps seeing only some components of the material while troubleshooting.\r\n     */\n\n    _this.debugMode = 0;\n    /**\r\n     * @hidden\r\n     * This is reserved for the inspector.\r\n     * Specify from where on screen the debug mode should start.\r\n     * The value goes from -1 (full screen) to 1 (not visible)\r\n     * It helps with side by side comparison against the final render\r\n     * This defaults to -1\r\n     */\n\n    _this.debugLimit = -1;\n    /**\r\n     * @hidden\r\n     * This is reserved for the inspector.\r\n     * As the default viewing range might not be enough (if the ambient is really small for instance)\r\n     * You can use the factor to better multiply the final value.\r\n     */\n\n    _this.debugFactor = 1;\n    /**\r\n     * Defines the clear coat layer parameters for the material.\r\n     */\n\n    _this.clearCoat = new PBRClearCoatConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));\n    /**\r\n     * Defines the anisotropic parameters for the material.\r\n     */\n\n    _this.anisotropy = new PBRAnisotropicConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));\n    /**\r\n     * Defines the BRDF parameters for the material.\r\n     */\n\n    _this.brdf = new PBRBRDFConfiguration(_this._markAllSubMeshesAsMiscDirty.bind(_this));\n    /**\r\n     * Defines the Sheen parameters for the material.\r\n     */\n\n    _this.sheen = new PBRSheenConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));\n    /**\r\n     * Defines the detail map parameters for the material.\r\n     */\n\n    _this.detailMap = new DetailMapConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));\n    _this._rebuildInParallel = false; // Setup the default processing configuration to the scene.\n\n    _this._attachImageProcessingConfiguration(null);\n\n    _this.getRenderTargetTextures = function () {\n      _this._renderTargets.reset();\n\n      if (MaterialFlags.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {\n        _this._renderTargets.push(_this._reflectionTexture);\n      }\n\n      _this.subSurface.fillRenderTargetTextures(_this._renderTargets);\n\n      return _this._renderTargets;\n    };\n\n    _this._environmentBRDFTexture = BRDFTextureTools.GetEnvironmentBRDFTexture(scene);\n    _this.subSurface = new PBRSubSurfaceConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this), _this._markScenePrePassDirty.bind(_this), scene);\n    _this.prePassConfiguration = new PrePassConfiguration();\n    return _this;\n  }\n\n  Object.defineProperty(PBRBaseMaterial.prototype, \"realTimeFiltering\", {\n    /**\r\n     * Enables realtime filtering on the texture.\r\n     */\n    get: function get() {\n      return this._realTimeFiltering;\n    },\n    set: function set(b) {\n      this._realTimeFiltering = b;\n      this.markAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PBRBaseMaterial.prototype, \"realTimeFilteringQuality\", {\n    /**\r\n     * Quality switch for realtime filtering\r\n     */\n    get: function get() {\n      return this._realTimeFilteringQuality;\n    },\n    set: function set(n) {\n      this._realTimeFilteringQuality = n;\n      this.markAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PBRBaseMaterial.prototype, \"canRenderToMRT\", {\n    /**\r\n     * Can this material render to several textures at once\r\n     */\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Attaches a new image processing configuration to the PBR Material.\r\n   * @param configuration\r\n   */\n\n  PBRBaseMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\n    var _this = this;\n\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    } // Detaches observer.\n\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    } // Pick the scene configuration if needed.\n\n\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    } // Attaches observer.\n\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {\n        _this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  };\n\n  Object.defineProperty(PBRBaseMaterial.prototype, \"hasRenderTargetTextures\", {\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\n    get: function get() {\n      if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n        return true;\n      }\n\n      return this.subSurface.hasRenderTargetTextures();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the name of the material class.\r\n   */\n\n  PBRBaseMaterial.prototype.getClassName = function () {\n    return \"PBRBaseMaterial\";\n  };\n\n  Object.defineProperty(PBRBaseMaterial.prototype, \"useLogarithmicDepth\", {\n    /**\r\n     * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.\r\n     */\n    get: function get() {\n      return this._useLogarithmicDepth;\n    },\n\n    /**\r\n     * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.\r\n     */\n    set: function set(value) {\n      this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PBRBaseMaterial.prototype, \"_disableAlphaBlending\", {\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\n    get: function get() {\n      return this.subSurface.disableAlphaBlending || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Specifies whether or not this material should be rendered in alpha blend mode.\r\n   */\n\n  PBRBaseMaterial.prototype.needAlphaBlending = function () {\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n\n    return this.alpha < 1.0 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();\n  };\n  /**\r\n   * Specifies whether or not this material should be rendered in alpha test mode.\r\n   */\n\n\n  PBRBaseMaterial.prototype.needAlphaTesting = function () {\n    if (this._forceAlphaTest) {\n      return true;\n    }\n\n    if (this.subSurface.disableAlphaBlending) {\n      return false;\n    }\n\n    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST);\n  };\n  /**\r\n   * Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.\r\n   */\n\n\n  PBRBaseMaterial.prototype._shouldUseAlphaFromAlbedoTexture = function () {\n    return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE;\n  };\n  /**\r\n   * Specifies whether or not there is a usable alpha channel for transparency.\r\n   */\n\n\n  PBRBaseMaterial.prototype._hasAlphaChannel = function () {\n    return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;\n  };\n  /**\r\n   * Gets the texture used for the alpha test.\r\n   */\n\n\n  PBRBaseMaterial.prototype.getAlphaTestTexture = function () {\n    return this._albedoTexture;\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used.\r\n   * @param mesh - BJS mesh.\r\n   * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.\r\n   * @param useInstances - Specifies that instances should be used.\r\n   * @returns - boolean indicating that the submesh is ready or not.\r\n   */\n\n\n  PBRBaseMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    if (subMesh.effect && this.isFrozen) {\n      if (subMesh.effect._wasPreviouslyReady) {\n        return true;\n      }\n    }\n\n    if (!subMesh._materialDefines) {\n      subMesh._materialDefines = new PBRMaterialDefines();\n    }\n\n    var defines = subMesh._materialDefines;\n\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n\n    var scene = this.getScene();\n    var engine = scene.getEngine();\n\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n          if (!this._albedoTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n          if (!this._ambientTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n          if (!this._opacityTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        var reflectionTexture = this._getReflectionTexture();\n\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n          if (!reflectionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n\n          if (reflectionTexture.irradianceTexture && !reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n          if (!this._lightmapTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n          if (!this._emissiveTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        if (MaterialFlags.SpecularTextureEnabled) {\n          if (this._metallicTexture) {\n            if (!this._metallicTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          } else if (this._reflectivityTexture) {\n            if (!this._reflectivityTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          }\n\n          if (this._metallicReflectanceTexture) {\n            if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          }\n\n          if (this._microSurfaceTexture) {\n            if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          }\n        }\n\n        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n          // Bump texture cannot be not blocking.\n          if (!this._bumpTexture.isReady()) {\n            return false;\n          }\n        }\n\n        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\n          // This is blocking.\n          if (!this._environmentBRDFTexture.isReady()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    if (!this.subSurface.isReadyForSubMesh(defines, scene) || !this.clearCoat.isReadyForSubMesh(defines, scene, engine, this._disableBumpMap) || !this.sheen.isReadyForSubMesh(defines, scene) || !this.anisotropy.isReadyForSubMesh(defines, scene) || !this.detailMap.isReadyForSubMesh(defines, scene)) {\n      return false;\n    }\n\n    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n      if (!this._imageProcessingConfiguration.isReady()) {\n        return false;\n      }\n    }\n\n    if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      mesh.createNormals(true);\n      Logger.Warn(\"PBRMaterial: Normals have been created for the mesh: \" + mesh.name);\n    }\n\n    var previousEffect = subMesh.effect;\n    var lightDisposed = defines._areLightsDisposed;\n\n    var effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\n\n    if (effect) {\n      if (this._onEffectCreatedObservable) {\n        onCreatedEffectParameters.effect = effect;\n        onCreatedEffectParameters.subMesh = subMesh;\n\n        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n      } // Use previous effect while new one is compiling\n\n\n      if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n        effect = previousEffect;\n        this._rebuildInParallel = true;\n        defines.markAsUnprocessed();\n\n        if (lightDisposed) {\n          // re register in case it takes more than one frame.\n          defines._areLightsDisposed = true;\n          return false;\n        }\n      } else {\n        this._rebuildInParallel = false;\n        scene.resetCachedMaterial();\n        subMesh.setEffect(effect, defines);\n        this.buildUniformLayout();\n      }\n    }\n\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    return true;\n  };\n  /**\r\n   * Specifies if the material uses metallic roughness workflow.\r\n   * @returns boolean specifiying if the material uses metallic roughness workflow.\r\n  */\n\n\n  PBRBaseMaterial.prototype.isMetallicWorkflow = function () {\n    if (this._metallic != null || this._roughness != null || this._metallicTexture) {\n      return true;\n    }\n\n    return false;\n  };\n\n  PBRBaseMaterial.prototype._prepareEffect = function (mesh, defines, onCompiled, onError, useInstances, useClipPlane, useThinInstances) {\n    if (onCompiled === void 0) {\n      onCompiled = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (useInstances === void 0) {\n      useInstances = null;\n    }\n\n    if (useClipPlane === void 0) {\n      useClipPlane = null;\n    }\n\n    this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);\n\n    if (!defines.isDirty) {\n      return null;\n    }\n\n    defines.markAsProcessed();\n    var scene = this.getScene();\n    var engine = scene.getEngine(); // Fallbacks\n\n    var fallbacks = new EffectFallbacks();\n    var fallbackRank = 0;\n\n    if (defines.USESPHERICALINVERTEX) {\n      fallbacks.addFallback(fallbackRank++, \"USESPHERICALINVERTEX\");\n    }\n\n    if (defines.FOG) {\n      fallbacks.addFallback(fallbackRank, \"FOG\");\n    }\n\n    if (defines.SPECULARAA) {\n      fallbacks.addFallback(fallbackRank, \"SPECULARAA\");\n    }\n\n    if (defines.POINTSIZE) {\n      fallbacks.addFallback(fallbackRank, \"POINTSIZE\");\n    }\n\n    if (defines.LOGARITHMICDEPTH) {\n      fallbacks.addFallback(fallbackRank, \"LOGARITHMICDEPTH\");\n    }\n\n    if (defines.PARALLAX) {\n      fallbacks.addFallback(fallbackRank, \"PARALLAX\");\n    }\n\n    if (defines.PARALLAXOCCLUSION) {\n      fallbacks.addFallback(fallbackRank++, \"PARALLAXOCCLUSION\");\n    }\n\n    fallbackRank = PBRAnisotropicConfiguration.AddFallbacks(defines, fallbacks, fallbackRank);\n    fallbackRank = PBRAnisotropicConfiguration.AddFallbacks(defines, fallbacks, fallbackRank);\n    fallbackRank = PBRSubSurfaceConfiguration.AddFallbacks(defines, fallbacks, fallbackRank);\n    fallbackRank = PBRSheenConfiguration.AddFallbacks(defines, fallbacks, fallbackRank);\n\n    if (defines.ENVIRONMENTBRDF) {\n      fallbacks.addFallback(fallbackRank++, \"ENVIRONMENTBRDF\");\n    }\n\n    if (defines.TANGENT) {\n      fallbacks.addFallback(fallbackRank++, \"TANGENT\");\n    }\n\n    if (defines.BUMP) {\n      fallbacks.addFallback(fallbackRank++, \"BUMP\");\n    }\n\n    fallbackRank = MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);\n\n    if (defines.SPECULARTERM) {\n      fallbacks.addFallback(fallbackRank++, \"SPECULARTERM\");\n    }\n\n    if (defines.USESPHERICALFROMREFLECTIONMAP) {\n      fallbacks.addFallback(fallbackRank++, \"USESPHERICALFROMREFLECTIONMAP\");\n    }\n\n    if (defines.USEIRRADIANCEMAP) {\n      fallbacks.addFallback(fallbackRank++, \"USEIRRADIANCEMAP\");\n    }\n\n    if (defines.LIGHTMAP) {\n      fallbacks.addFallback(fallbackRank++, \"LIGHTMAP\");\n    }\n\n    if (defines.NORMAL) {\n      fallbacks.addFallback(fallbackRank++, \"NORMAL\");\n    }\n\n    if (defines.AMBIENT) {\n      fallbacks.addFallback(fallbackRank++, \"AMBIENT\");\n    }\n\n    if (defines.EMISSIVE) {\n      fallbacks.addFallback(fallbackRank++, \"EMISSIVE\");\n    }\n\n    if (defines.VERTEXCOLOR) {\n      fallbacks.addFallback(fallbackRank++, \"VERTEXCOLOR\");\n    }\n\n    if (defines.MORPHTARGETS) {\n      fallbacks.addFallback(fallbackRank++, \"MORPHTARGETS\");\n    }\n\n    if (defines.MULTIVIEW) {\n      fallbacks.addFallback(0, \"MULTIVIEW\");\n    } //Attributes\n\n\n    var attribs = [VertexBuffer.PositionKind];\n\n    if (defines.NORMAL) {\n      attribs.push(VertexBuffer.NormalKind);\n    }\n\n    if (defines.TANGENT) {\n      attribs.push(VertexBuffer.TangentKind);\n    }\n\n    if (defines.UV1) {\n      attribs.push(VertexBuffer.UVKind);\n    }\n\n    if (defines.UV2) {\n      attribs.push(VertexBuffer.UV2Kind);\n    }\n\n    if (defines.VERTEXCOLOR) {\n      attribs.push(VertexBuffer.ColorKind);\n    }\n\n    MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n    MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n    MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\n    var shaderName = \"pbr\";\n    var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vAlbedoColor\", \"vReflectivityColor\", \"vMetallicReflectanceFactors\", \"vEmissiveColor\", \"visibility\", \"vReflectionColor\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"vAlbedoInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vReflectionPosition\", \"vReflectionSize\", \"vEmissiveInfos\", \"vReflectivityInfos\", \"vReflectionFilteringInfo\", \"vMetallicReflectanceInfos\", \"vMicroSurfaceSamplerInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"mBones\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"albedoMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"reflectivityMatrix\", \"normalMatrix\", \"microSurfaceSamplerMatrix\", \"bumpMatrix\", \"lightmapMatrix\", \"metallicReflectanceMatrix\", \"vLightingIntensity\", \"logarithmicDepthConstant\", \"vSphericalX\", \"vSphericalY\", \"vSphericalZ\", \"vSphericalXX_ZZ\", \"vSphericalYY_ZZ\", \"vSphericalZZ\", \"vSphericalXY\", \"vSphericalYZ\", \"vSphericalZX\", \"vSphericalL00\", \"vSphericalL1_1\", \"vSphericalL10\", \"vSphericalL11\", \"vSphericalL2_2\", \"vSphericalL2_1\", \"vSphericalL20\", \"vSphericalL21\", \"vSphericalL22\", \"vReflectionMicrosurfaceInfos\", \"vTangentSpaceParams\", \"boneTextureWidth\", \"vDebugMode\"];\n    var samplers = [\"albedoSampler\", \"reflectivitySampler\", \"ambientSampler\", \"emissiveSampler\", \"bumpSampler\", \"lightmapSampler\", \"opacitySampler\", \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\", \"irradianceSampler\", \"microSurfaceSampler\", \"environmentBrdfSampler\", \"boneSampler\", \"metallicReflectanceSampler\"];\n    var uniformBuffers = [\"Material\", \"Scene\"];\n    DetailMapConfiguration.AddUniforms(uniforms);\n    DetailMapConfiguration.AddSamplers(samplers);\n    PBRSubSurfaceConfiguration.AddUniforms(uniforms);\n    PBRSubSurfaceConfiguration.AddSamplers(samplers);\n    PBRClearCoatConfiguration.AddUniforms(uniforms);\n    PBRClearCoatConfiguration.AddSamplers(samplers);\n    PBRAnisotropicConfiguration.AddUniforms(uniforms);\n    PBRAnisotropicConfiguration.AddSamplers(samplers);\n    PBRSheenConfiguration.AddUniforms(uniforms);\n    PBRSheenConfiguration.AddSamplers(samplers);\n    PrePassConfiguration.AddUniforms(uniforms);\n    PrePassConfiguration.AddSamplers(uniforms);\n\n    if (ImageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n    }\n\n    MaterialHelper.PrepareUniformsAndSamplersList({\n      uniformsNames: uniforms,\n      uniformBuffersNames: uniformBuffers,\n      samplers: samplers,\n      defines: defines,\n      maxSimultaneousLights: this._maxSimultaneousLights\n    });\n    var csnrOptions = {};\n\n    if (this.customShaderNameResolve) {\n      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\n    }\n\n    var join = defines.toString();\n    return engine.createEffect(shaderName, {\n      attributes: attribs,\n      uniformsNames: uniforms,\n      uniformBuffersNames: uniformBuffers,\n      samplers: samplers,\n      defines: join,\n      fallbacks: fallbacks,\n      onCompiled: onCompiled,\n      onError: onError,\n      indexParameters: {\n        maxSimultaneousLights: this._maxSimultaneousLights,\n        maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n      },\n      processFinalCode: csnrOptions.processFinalCode,\n      multiTarget: defines.PREPASS\n    }, engine);\n  };\n\n  PBRBaseMaterial.prototype._prepareDefines = function (mesh, defines, useInstances, useClipPlane, useThinInstances) {\n    if (useInstances === void 0) {\n      useInstances = null;\n    }\n\n    if (useClipPlane === void 0) {\n      useClipPlane = null;\n    }\n\n    if (useThinInstances === void 0) {\n      useThinInstances = false;\n    }\n\n    var scene = this.getScene();\n    var engine = scene.getEngine(); // Lights\n\n    MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\n    defines._needNormals = true; // Multiview\n\n    MaterialHelper.PrepareDefinesForMultiview(scene, defines); // PrePass\n\n    MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT); // Textures\n\n    defines.METALLICWORKFLOW = this.isMetallicWorkflow();\n\n    if (defines._areTexturesDirty) {\n      defines._needUVs = false;\n\n      if (scene.texturesEnabled) {\n        if (scene.getEngine().getCaps().textureLOD) {\n          defines.LODBASEDMICROSFURACE = true;\n        }\n\n        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n          MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, defines, \"ALBEDO\");\n          defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;\n        } else {\n          defines.ALBEDO = false;\n        }\n\n        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n          MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\n          defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;\n        } else {\n          defines.AMBIENT = false;\n        }\n\n        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n          MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\n          defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\n        } else {\n          defines.OPACITY = false;\n        }\n\n        var reflectionTexture = this._getReflectionTexture();\n\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n          defines.REFLECTION = true;\n          defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\n          defines.RGBDREFLECTION = reflectionTexture.isRGBD;\n          defines.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\n          defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\n          defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;\n\n          if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {\n            defines.NUM_SAMPLES = \"\" + this.realTimeFilteringQuality;\n\n            if (engine.webGLVersion > 1) {\n              defines.NUM_SAMPLES = defines.NUM_SAMPLES + \"u\";\n            }\n\n            defines.REALTIME_FILTERING = true;\n          } else {\n            defines.REALTIME_FILTERING = false;\n          }\n\n          if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {\n            defines.INVERTCUBICMAP = true;\n          }\n\n          defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\n          defines.REFLECTIONMAP_CUBIC = false;\n          defines.REFLECTIONMAP_EXPLICIT = false;\n          defines.REFLECTIONMAP_PLANAR = false;\n          defines.REFLECTIONMAP_PROJECTION = false;\n          defines.REFLECTIONMAP_SKYBOX = false;\n          defines.REFLECTIONMAP_SPHERICAL = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n\n          switch (reflectionTexture.coordinatesMode) {\n            case Texture.EXPLICIT_MODE:\n              defines.REFLECTIONMAP_EXPLICIT = true;\n              break;\n\n            case Texture.PLANAR_MODE:\n              defines.REFLECTIONMAP_PLANAR = true;\n              break;\n\n            case Texture.PROJECTION_MODE:\n              defines.REFLECTIONMAP_PROJECTION = true;\n              break;\n\n            case Texture.SKYBOX_MODE:\n              defines.REFLECTIONMAP_SKYBOX = true;\n              break;\n\n            case Texture.SPHERICAL_MODE:\n              defines.REFLECTIONMAP_SPHERICAL = true;\n              break;\n\n            case Texture.EQUIRECTANGULAR_MODE:\n              defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\n              break;\n\n            case Texture.FIXED_EQUIRECTANGULAR_MODE:\n              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\n              break;\n\n            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\n              break;\n\n            case Texture.CUBIC_MODE:\n            case Texture.INVCUBIC_MODE:\n            default:\n              defines.REFLECTIONMAP_CUBIC = true;\n              defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;\n              break;\n          }\n\n          if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\n            if (reflectionTexture.irradianceTexture) {\n              defines.USEIRRADIANCEMAP = true;\n              defines.USESPHERICALFROMREFLECTIONMAP = false;\n            } // Assume using spherical polynomial if the reflection texture is a cube map\n            else if (reflectionTexture.isCube) {\n              defines.USESPHERICALFROMREFLECTIONMAP = true;\n              defines.USEIRRADIANCEMAP = false;\n\n              if (this._forceIrradianceInFragment || this.realTimeFiltering || scene.getEngine().getCaps().maxVaryingVectors <= 8) {\n                defines.USESPHERICALINVERTEX = false;\n              } else {\n                defines.USESPHERICALINVERTEX = true;\n              }\n            }\n          }\n        } else {\n          defines.REFLECTION = false;\n          defines.REFLECTIONMAP_3D = false;\n          defines.REFLECTIONMAP_SPHERICAL = false;\n          defines.REFLECTIONMAP_PLANAR = false;\n          defines.REFLECTIONMAP_CUBIC = false;\n          defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\n          defines.REFLECTIONMAP_PROJECTION = false;\n          defines.REFLECTIONMAP_SKYBOX = false;\n          defines.REFLECTIONMAP_EXPLICIT = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n          defines.INVERTCUBICMAP = false;\n          defines.USESPHERICALFROMREFLECTIONMAP = false;\n          defines.USEIRRADIANCEMAP = false;\n          defines.USESPHERICALINVERTEX = false;\n          defines.REFLECTIONMAP_OPPOSITEZ = false;\n          defines.LODINREFLECTIONALPHA = false;\n          defines.GAMMAREFLECTION = false;\n          defines.RGBDREFLECTION = false;\n          defines.LINEARSPECULARREFLECTION = false;\n        }\n\n        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n          MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\n          defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\n          defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;\n          defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\n        } else {\n          defines.LIGHTMAP = false;\n        }\n\n        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n          MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\n        } else {\n          defines.EMISSIVE = false;\n        }\n\n        if (MaterialFlags.SpecularTextureEnabled) {\n          if (this._metallicTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, defines, \"REFLECTIVITY\");\n            defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;\n            defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;\n            defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;\n            defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;\n          } else if (this._reflectivityTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, defines, \"REFLECTIVITY\");\n            defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;\n            defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;\n          } else {\n            defines.REFLECTIVITY = false;\n          }\n\n          if (this._metallicReflectanceTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, \"METALLIC_REFLECTANCE\");\n          } else {\n            defines.METALLIC_REFLECTANCE = false;\n          }\n\n          if (this._microSurfaceTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, \"MICROSURFACEMAP\");\n          } else {\n            defines.MICROSURFACEMAP = false;\n          }\n        } else {\n          defines.REFLECTIVITY = false;\n          defines.MICROSURFACEMAP = false;\n        }\n\n        if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n          MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\n\n          if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n            defines.PARALLAX = true;\n            defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;\n          } else {\n            defines.PARALLAX = false;\n          }\n\n          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\n        } else {\n          defines.BUMP = false;\n        }\n\n        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\n          defines.ENVIRONMENTBRDF = true; // Not actual true RGBD, only the B chanel is encoded as RGBD for sheen.\n\n          defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;\n        } else {\n          defines.ENVIRONMENTBRDF = false;\n          defines.ENVIRONMENTBRDF_RGBD = false;\n        }\n\n        if (this._shouldUseAlphaFromAlbedoTexture()) {\n          defines.ALPHAFROMALBEDO = true;\n        } else {\n          defines.ALPHAFROMALBEDO = false;\n        }\n      }\n\n      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\n\n      if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {\n        defines.USEPHYSICALLIGHTFALLOFF = false;\n        defines.USEGLTFLIGHTFALLOFF = false;\n      } else if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {\n        defines.USEPHYSICALLIGHTFALLOFF = false;\n        defines.USEGLTFLIGHTFALLOFF = true;\n      } else {\n        defines.USEPHYSICALLIGHTFALLOFF = true;\n        defines.USEGLTFLIGHTFALLOFF = false;\n      }\n\n      defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;\n\n      if (!this.backFaceCulling && this._twoSidedLighting) {\n        defines.TWOSIDEDLIGHTING = true;\n      } else {\n        defines.TWOSIDEDLIGHTING = false;\n      }\n\n      defines.SPECULARAA = scene.getEngine().getCaps().standardDerivatives && this._enableSpecularAntiAliasing;\n    }\n\n    if (defines._areTexturesDirty || defines._areMiscDirty) {\n      defines.ALPHATESTVALUE = \"\" + this._alphaCutOff + (this._alphaCutOff % 1 === 0 ? \".\" : \"\");\n      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;\n      defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);\n      defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;\n      defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;\n    }\n\n    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(defines);\n    }\n\n    defines.FORCENORMALFORWARD = this._forceNormalForward;\n    defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;\n    defines.HORIZONOCCLUSION = this._useHorizonOcclusion; // Misc.\n\n    if (defines._areMiscDirty) {\n      MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);\n      defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n      defines.DEBUGMODE = this._debugMode;\n    } // External config\n\n\n    this.detailMap.prepareDefines(defines, scene);\n    this.subSurface.prepareDefines(defines, scene);\n    this.clearCoat.prepareDefines(defines, scene);\n    this.anisotropy.prepareDefines(defines, mesh, scene);\n    this.brdf.prepareDefines(defines);\n    this.sheen.prepareDefines(defines, scene); // Values that need to be evaluated on every frame\n\n    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false, useClipPlane, useThinInstances); // Attribs\n\n    MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE);\n  };\n  /**\r\n   * Force shader compilation\r\n   */\n\n\n  PBRBaseMaterial.prototype.forceCompilation = function (mesh, onCompiled, options) {\n    var _this = this;\n\n    var localOptions = __assign({\n      clipPlane: false,\n      useInstances: false\n    }, options);\n\n    var defines = new PBRMaterialDefines();\n\n    var effect = this._prepareEffect(mesh, defines, undefined, undefined, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);\n\n    if (this._onEffectCreatedObservable) {\n      onCreatedEffectParameters.effect = effect;\n      onCreatedEffectParameters.subMesh = null;\n\n      this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n    }\n\n    if (effect.isReady()) {\n      if (onCompiled) {\n        onCompiled(this);\n      }\n    } else {\n      effect.onCompileObservable.add(function () {\n        if (onCompiled) {\n          onCompiled(_this);\n        }\n      });\n    }\n  };\n  /**\r\n   * Initializes the uniform buffer layout for the shader.\r\n   */\n\n\n  PBRBaseMaterial.prototype.buildUniformLayout = function () {\n    // Order is important !\n    var ubo = this._uniformBuffer;\n    ubo.addUniform(\"vAlbedoInfos\", 2);\n    ubo.addUniform(\"vAmbientInfos\", 4);\n    ubo.addUniform(\"vOpacityInfos\", 2);\n    ubo.addUniform(\"vEmissiveInfos\", 2);\n    ubo.addUniform(\"vLightmapInfos\", 2);\n    ubo.addUniform(\"vReflectivityInfos\", 3);\n    ubo.addUniform(\"vMicroSurfaceSamplerInfos\", 2);\n    ubo.addUniform(\"vReflectionInfos\", 2);\n    ubo.addUniform(\"vReflectionFilteringInfo\", 2);\n    ubo.addUniform(\"vReflectionPosition\", 3);\n    ubo.addUniform(\"vReflectionSize\", 3);\n    ubo.addUniform(\"vBumpInfos\", 3);\n    ubo.addUniform(\"albedoMatrix\", 16);\n    ubo.addUniform(\"ambientMatrix\", 16);\n    ubo.addUniform(\"opacityMatrix\", 16);\n    ubo.addUniform(\"emissiveMatrix\", 16);\n    ubo.addUniform(\"lightmapMatrix\", 16);\n    ubo.addUniform(\"reflectivityMatrix\", 16);\n    ubo.addUniform(\"microSurfaceSamplerMatrix\", 16);\n    ubo.addUniform(\"bumpMatrix\", 16);\n    ubo.addUniform(\"vTangentSpaceParams\", 2);\n    ubo.addUniform(\"reflectionMatrix\", 16);\n    ubo.addUniform(\"vReflectionColor\", 3);\n    ubo.addUniform(\"vAlbedoColor\", 4);\n    ubo.addUniform(\"vLightingIntensity\", 4);\n    ubo.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\n    ubo.addUniform(\"pointSize\", 1);\n    ubo.addUniform(\"vReflectivityColor\", 4);\n    ubo.addUniform(\"vEmissiveColor\", 3);\n    ubo.addUniform(\"visibility\", 1);\n    ubo.addUniform(\"vMetallicReflectanceFactors\", 4);\n    ubo.addUniform(\"vMetallicReflectanceInfos\", 2);\n    ubo.addUniform(\"metallicReflectanceMatrix\", 16);\n    PBRClearCoatConfiguration.PrepareUniformBuffer(ubo);\n    PBRAnisotropicConfiguration.PrepareUniformBuffer(ubo);\n    PBRSheenConfiguration.PrepareUniformBuffer(ubo);\n    PBRSubSurfaceConfiguration.PrepareUniformBuffer(ubo);\n    DetailMapConfiguration.PrepareUniformBuffer(ubo);\n    ubo.create();\n  };\n  /**\r\n   * Unbinds the material from the mesh\r\n   */\n\n\n  PBRBaseMaterial.prototype.unbind = function () {\n    if (this._activeEffect) {\n      var needFlag = false;\n\n      if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n        this._activeEffect.setTexture(\"reflection2DSampler\", null);\n\n        needFlag = true;\n      }\n\n      if (this.subSurface.unbind(this._activeEffect)) {\n        needFlag = true;\n      }\n\n      if (needFlag) {\n        this._markAllSubMeshesAsTexturesDirty();\n      }\n    }\n\n    _super.prototype.unbind.call(this);\n  };\n  /**\r\n   * Binds the submesh data.\r\n   * @param world - The world matrix.\r\n   * @param mesh - The BJS mesh.\r\n   * @param subMesh - A submesh of the BJS mesh.\r\n   */\n\n\n  PBRBaseMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n    var scene = this.getScene();\n    var defines = subMesh._materialDefines;\n\n    if (!defines) {\n      return;\n    }\n\n    var effect = subMesh.effect;\n\n    if (!effect) {\n      return;\n    }\n\n    this._activeEffect = effect; // Matrices\n\n    if (!defines.INSTANCES || defines.THIN_INSTANCES) {\n      this.bindOnlyWorldMatrix(world);\n    } // PrePass\n\n\n    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen); // Normal Matrix\n\n    if (defines.OBJECTSPACE_NORMALMAP) {\n      world.toNormalMatrix(this._normalMatrix);\n      this.bindOnlyNormalMatrix(this._normalMatrix);\n    }\n\n    var mustRebind = this._mustRebind(scene, effect, mesh.visibility); // Bones\n\n\n    MaterialHelper.BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);\n    var reflectionTexture = null;\n    var ubo = this._uniformBuffer;\n\n    if (mustRebind) {\n      var engine = scene.getEngine();\n      ubo.bindToEffect(effect, \"Material\");\n      this.bindViewProjection(effect);\n      reflectionTexture = this._getReflectionTexture();\n\n      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {\n        // Texture uniforms\n        if (scene.texturesEnabled) {\n          if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n            ubo.updateFloat2(\"vAlbedoInfos\", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);\n            MaterialHelper.BindTextureMatrix(this._albedoTexture, ubo, \"albedo\");\n          }\n\n          if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n            ubo.updateFloat4(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);\n            MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\n          }\n\n          if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n            ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\n            MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\n          }\n\n          if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n            ubo.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\n            ubo.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, 0);\n\n            if (reflectionTexture.boundingBoxSize) {\n              var cubeTexture = reflectionTexture;\n              ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\n              ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\n            }\n\n            if (this.realTimeFiltering) {\n              var width = reflectionTexture.getSize().width;\n              ubo.updateFloat2(\"vReflectionFilteringInfo\", width, Scalar.Log2(width));\n            }\n\n            if (!defines.USEIRRADIANCEMAP) {\n              var polynomials = reflectionTexture.sphericalPolynomial;\n\n              if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\n                if (defines.SPHERICAL_HARMONICS) {\n                  var preScaledHarmonics = polynomials.preScaledHarmonics;\n\n                  this._activeEffect.setVector3(\"vSphericalL00\", preScaledHarmonics.l00);\n\n                  this._activeEffect.setVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\n\n                  this._activeEffect.setVector3(\"vSphericalL10\", preScaledHarmonics.l10);\n\n                  this._activeEffect.setVector3(\"vSphericalL11\", preScaledHarmonics.l11);\n\n                  this._activeEffect.setVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\n\n                  this._activeEffect.setVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\n\n                  this._activeEffect.setVector3(\"vSphericalL20\", preScaledHarmonics.l20);\n\n                  this._activeEffect.setVector3(\"vSphericalL21\", preScaledHarmonics.l21);\n\n                  this._activeEffect.setVector3(\"vSphericalL22\", preScaledHarmonics.l22);\n                } else {\n                  this._activeEffect.setFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\n\n                  this._activeEffect.setFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\n\n                  this._activeEffect.setFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\n\n                  this._activeEffect.setFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\n\n                  this._activeEffect.setFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\n\n                  this._activeEffect.setFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\n\n                  this._activeEffect.setFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\n\n                  this._activeEffect.setFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\n\n                  this._activeEffect.setFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\n                }\n              }\n            }\n\n            ubo.updateFloat3(\"vReflectionMicrosurfaceInfos\", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n          }\n\n          if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n            ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\n            MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\n          }\n\n          if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n            ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\n            MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\n          }\n\n          if (MaterialFlags.SpecularTextureEnabled) {\n            if (this._metallicTexture) {\n              ubo.updateFloat3(\"vReflectivityInfos\", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);\n              MaterialHelper.BindTextureMatrix(this._metallicTexture, ubo, \"reflectivity\");\n            } else if (this._reflectivityTexture) {\n              ubo.updateFloat3(\"vReflectivityInfos\", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1.0);\n              MaterialHelper.BindTextureMatrix(this._reflectivityTexture, ubo, \"reflectivity\");\n            }\n\n            if (this._metallicReflectanceTexture) {\n              ubo.updateFloat2(\"vMetallicReflectanceInfos\", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);\n              MaterialHelper.BindTextureMatrix(this._metallicReflectanceTexture, ubo, \"metallicReflectance\");\n            }\n\n            if (this._microSurfaceTexture) {\n              ubo.updateFloat2(\"vMicroSurfaceSamplerInfos\", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);\n              MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, ubo, \"microSurfaceSampler\");\n            }\n          }\n\n          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n            ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);\n            MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\n\n            if (scene._mirroredCameraPosition) {\n              ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\n            } else {\n              ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\n            }\n          }\n        } // Point size\n\n\n        if (this.pointsCloud) {\n          ubo.updateFloat(\"pointSize\", this.pointSize);\n        } // Colors\n\n\n        if (defines.METALLICWORKFLOW) {\n          TmpColors.Color3[0].r = this._metallic === undefined || this._metallic === null ? 1 : this._metallic;\n          TmpColors.Color3[0].g = this._roughness === undefined || this._roughness === null ? 1 : this._roughness;\n          ubo.updateColor4(\"vReflectivityColor\", TmpColors.Color3[0], 1);\n          var ior = this.subSurface.indexOfRefraction;\n          var outside_ior = 1; // consider air as clear coat and other layaers would remap in the shader.\n          // We are here deriving our default reflectance from a common value for none metallic surface.\n          // Based of the schlick fresnel approximation model\n          // for dielectrics.\n\n          var f0 = Math.pow((ior - outside_ior) / (ior + outside_ior), 2); // Tweak the default F0 and F90 based on our given setup\n\n          this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);\n\n          var metallicF90 = this._metallicF0Factor;\n          ubo.updateColor4(\"vMetallicReflectanceFactors\", TmpColors.Color3[0], metallicF90);\n        } else {\n          ubo.updateColor4(\"vReflectivityColor\", this._reflectivityColor, this._microSurface);\n        }\n\n        ubo.updateColor3(\"vEmissiveColor\", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);\n        ubo.updateColor3(\"vReflectionColor\", this._reflectionColor);\n\n        if (!defines.SS_REFRACTION && this.subSurface.linkRefractionWithTransparency) {\n          ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, 1);\n        } else {\n          ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, this.alpha);\n        } // Misc\n\n\n        this._lightingInfos.x = this._directIntensity;\n        this._lightingInfos.y = this._emissiveIntensity;\n        this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;\n        this._lightingInfos.w = this._specularIntensity;\n        ubo.updateVector4(\"vLightingIntensity\", this._lightingInfos);\n      } // Visibility\n\n\n      ubo.updateFloat(\"visibility\", mesh.visibility); // Textures\n\n      if (scene.texturesEnabled) {\n        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n          ubo.setTexture(\"albedoSampler\", this._albedoTexture);\n        }\n\n        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n          ubo.setTexture(\"ambientSampler\", this._ambientTexture);\n        }\n\n        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n          ubo.setTexture(\"opacitySampler\", this._opacityTexture);\n        }\n\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n          if (defines.LODBASEDMICROSFURACE) {\n            ubo.setTexture(\"reflectionSampler\", reflectionTexture);\n          } else {\n            ubo.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\n            ubo.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\n            ubo.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\n          }\n\n          if (defines.USEIRRADIANCEMAP) {\n            ubo.setTexture(\"irradianceSampler\", reflectionTexture.irradianceTexture);\n          }\n        }\n\n        if (defines.ENVIRONMENTBRDF) {\n          ubo.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture);\n        }\n\n        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n          ubo.setTexture(\"emissiveSampler\", this._emissiveTexture);\n        }\n\n        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n          ubo.setTexture(\"lightmapSampler\", this._lightmapTexture);\n        }\n\n        if (MaterialFlags.SpecularTextureEnabled) {\n          if (this._metallicTexture) {\n            ubo.setTexture(\"reflectivitySampler\", this._metallicTexture);\n          } else if (this._reflectivityTexture) {\n            ubo.setTexture(\"reflectivitySampler\", this._reflectivityTexture);\n          }\n\n          if (this._metallicReflectanceTexture) {\n            ubo.setTexture(\"metallicReflectanceSampler\", this._metallicReflectanceTexture);\n          }\n\n          if (this._microSurfaceTexture) {\n            ubo.setTexture(\"microSurfaceSampler\", this._microSurfaceTexture);\n          }\n        }\n\n        if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n          ubo.setTexture(\"bumpSampler\", this._bumpTexture);\n        }\n      }\n\n      this.detailMap.bindForSubMesh(ubo, scene, this.isFrozen);\n      this.subSurface.bindForSubMesh(ubo, scene, engine, this.isFrozen, defines.LODBASEDMICROSFURACE, this.realTimeFiltering);\n      this.clearCoat.bindForSubMesh(ubo, scene, engine, this._disableBumpMap, this.isFrozen, this._invertNormalMapX, this._invertNormalMapY, subMesh);\n      this.anisotropy.bindForSubMesh(ubo, scene, this.isFrozen);\n      this.sheen.bindForSubMesh(ubo, scene, this.isFrozen, subMesh); // Clip plane\n\n      MaterialHelper.BindClipPlane(this._activeEffect, scene); // Colors\n\n      scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);\n      var eyePosition = scene._forcedViewPosition ? scene._forcedViewPosition : scene._mirroredCameraPosition ? scene._mirroredCameraPosition : scene.activeCamera.globalPosition;\n      var invertNormal = scene.useRightHandedSystem === (scene._mirroredCameraPosition != null);\n      effect.setFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n      effect.setColor3(\"vAmbientColor\", this._globalAmbientColor);\n      effect.setFloat2(\"vDebugMode\", this.debugLimit, this.debugFactor);\n    }\n\n    if (mustRebind || !this.isFrozen) {\n      // Lights\n      if (scene.lightsEnabled && !this._disableLighting) {\n        MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights, this._rebuildInParallel);\n      } // View\n\n\n      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture) {\n        this.bindView(effect);\n      } // Fog\n\n\n      MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true); // Morph targets\n\n      if (defines.NUM_MORPH_INFLUENCERS) {\n        MaterialHelper.BindMorphTargetParameters(mesh, this._activeEffect);\n      } // image processing\n\n\n      this._imageProcessingConfiguration.bind(this._activeEffect); // Log. depth\n\n\n      MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);\n    }\n\n    ubo.update();\n\n    this._afterBind(mesh, this._activeEffect);\n  };\n  /**\r\n   * Returns the animatable textures.\r\n   * @returns - Array of animatable textures.\r\n   */\n\n\n  PBRBaseMaterial.prototype.getAnimatables = function () {\n    var results = [];\n\n    if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {\n      results.push(this._albedoTexture);\n    }\n\n    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\n      results.push(this._ambientTexture);\n    }\n\n    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\n      results.push(this._opacityTexture);\n    }\n\n    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\n      results.push(this._reflectionTexture);\n    }\n\n    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\n      results.push(this._emissiveTexture);\n    }\n\n    if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {\n      results.push(this._metallicTexture);\n    } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {\n      results.push(this._reflectivityTexture);\n    }\n\n    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\n      results.push(this._bumpTexture);\n    }\n\n    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\n      results.push(this._lightmapTexture);\n    }\n\n    this.detailMap.getAnimatables(results);\n    this.subSurface.getAnimatables(results);\n    this.clearCoat.getAnimatables(results);\n    this.sheen.getAnimatables(results);\n    this.anisotropy.getAnimatables(results);\n    return results;\n  };\n  /**\r\n   * Returns the texture used for reflections.\r\n   * @returns - Reflection texture if present.  Otherwise, returns the environment texture.\r\n   */\n\n\n  PBRBaseMaterial.prototype._getReflectionTexture = function () {\n    if (this._reflectionTexture) {\n      return this._reflectionTexture;\n    }\n\n    return this.getScene().environmentTexture;\n  };\n  /**\r\n   * Returns an array of the actively used textures.\r\n   * @returns - Array of BaseTextures\r\n   */\n\n\n  PBRBaseMaterial.prototype.getActiveTextures = function () {\n    var activeTextures = _super.prototype.getActiveTextures.call(this);\n\n    if (this._albedoTexture) {\n      activeTextures.push(this._albedoTexture);\n    }\n\n    if (this._ambientTexture) {\n      activeTextures.push(this._ambientTexture);\n    }\n\n    if (this._opacityTexture) {\n      activeTextures.push(this._opacityTexture);\n    }\n\n    if (this._reflectionTexture) {\n      activeTextures.push(this._reflectionTexture);\n    }\n\n    if (this._emissiveTexture) {\n      activeTextures.push(this._emissiveTexture);\n    }\n\n    if (this._reflectivityTexture) {\n      activeTextures.push(this._reflectivityTexture);\n    }\n\n    if (this._metallicTexture) {\n      activeTextures.push(this._metallicTexture);\n    }\n\n    if (this._metallicReflectanceTexture) {\n      activeTextures.push(this._metallicReflectanceTexture);\n    }\n\n    if (this._microSurfaceTexture) {\n      activeTextures.push(this._microSurfaceTexture);\n    }\n\n    if (this._bumpTexture) {\n      activeTextures.push(this._bumpTexture);\n    }\n\n    if (this._lightmapTexture) {\n      activeTextures.push(this._lightmapTexture);\n    }\n\n    this.detailMap.getActiveTextures(activeTextures);\n    this.subSurface.getActiveTextures(activeTextures);\n    this.clearCoat.getActiveTextures(activeTextures);\n    this.sheen.getActiveTextures(activeTextures);\n    this.anisotropy.getActiveTextures(activeTextures);\n    return activeTextures;\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param texture - Base texture to use.\r\n   * @returns - Boolean specifying if a texture is used in the material.\r\n   */\n\n\n  PBRBaseMaterial.prototype.hasTexture = function (texture) {\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    if (this._albedoTexture === texture) {\n      return true;\n    }\n\n    if (this._ambientTexture === texture) {\n      return true;\n    }\n\n    if (this._opacityTexture === texture) {\n      return true;\n    }\n\n    if (this._reflectionTexture === texture) {\n      return true;\n    }\n\n    if (this._reflectivityTexture === texture) {\n      return true;\n    }\n\n    if (this._metallicTexture === texture) {\n      return true;\n    }\n\n    if (this._metallicReflectanceTexture === texture) {\n      return true;\n    }\n\n    if (this._microSurfaceTexture === texture) {\n      return true;\n    }\n\n    if (this._bumpTexture === texture) {\n      return true;\n    }\n\n    if (this._lightmapTexture === texture) {\n      return true;\n    }\n\n    return this.detailMap.hasTexture(texture) || this.subSurface.hasTexture(texture) || this.clearCoat.hasTexture(texture) || this.sheen.hasTexture(texture) || this.anisotropy.hasTexture(texture);\n  };\n  /**\r\n   * Sets the required values to the prepass renderer.\r\n   * @param prePassRenderer defines the prepass renderer to setup\r\n   */\n\n\n  PBRBaseMaterial.prototype.setPrePassRenderer = function (prePassRenderer) {\n    if (this.subSurface.isScatteringEnabled) {\n      var subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();\n\n      if (subSurfaceConfiguration) {\n        subSurfaceConfiguration.enabled = true;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Disposes the resources of the material.\r\n   * @param forceDisposeEffect - Forces the disposal of effects.\r\n   * @param forceDisposeTextures - Forces the disposal of all textures.\r\n   */\n\n\n  PBRBaseMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n    if (forceDisposeTextures) {\n      if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {\n        this._environmentBRDFTexture.dispose();\n      }\n\n      (_a = this._albedoTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n      (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();\n      (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();\n      (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();\n      (_f = this._metallicTexture) === null || _f === void 0 ? void 0 : _f.dispose();\n      (_g = this._reflectivityTexture) === null || _g === void 0 ? void 0 : _g.dispose();\n      (_h = this._bumpTexture) === null || _h === void 0 ? void 0 : _h.dispose();\n      (_j = this._lightmapTexture) === null || _j === void 0 ? void 0 : _j.dispose();\n      (_k = this._metallicReflectanceTexture) === null || _k === void 0 ? void 0 : _k.dispose();\n      (_l = this._microSurfaceTexture) === null || _l === void 0 ? void 0 : _l.dispose();\n    }\n\n    this.detailMap.dispose(forceDisposeTextures);\n    this.subSurface.dispose(forceDisposeTextures);\n    this.clearCoat.dispose(forceDisposeTextures);\n    this.sheen.dispose(forceDisposeTextures);\n    this.anisotropy.dispose(forceDisposeTextures);\n\n    this._renderTargets.dispose();\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\n  };\n  /**\r\n   * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n   */\n\n\n  PBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;\n  /**\r\n   * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n   */\n\n  PBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;\n  /**\r\n   * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n   */\n\n  PBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;\n  /**\r\n   * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n   * They are also discarded below the alpha cutoff threshold to improve performances.\r\n   */\n\n  PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;\n  /**\r\n   * Defines the default value of how much AO map is occluding the analytical lights\r\n   * (point spot...).\r\n   */\n\n  PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;\n  /**\r\n   * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.\r\n   */\n\n  PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;\n  /**\r\n   * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document\r\n   * to enhance interoperability with other engines.\r\n   */\n\n  PBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;\n  /**\r\n   * PBRMaterialLightFalloff Standard: light is falling off like in the standard material\r\n   * to enhance interoperability with other materials.\r\n   */\n\n  PBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;\n\n  __decorate([serializeAsImageProcessingConfiguration()], PBRBaseMaterial.prototype, \"_imageProcessingConfiguration\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsMiscDirty\")], PBRBaseMaterial.prototype, \"debugMode\", void 0);\n\n  __decorate([serialize()], PBRBaseMaterial.prototype, \"useLogarithmicDepth\", null);\n\n  return PBRBaseMaterial;\n}(PushMaterial);\n\nexport { PBRBaseMaterial };","map":null,"metadata":{},"sourceType":"module"}