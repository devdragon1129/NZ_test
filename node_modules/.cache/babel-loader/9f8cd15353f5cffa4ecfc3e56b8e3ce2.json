{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateMultipleHashesADR32LegacyQmHash = exports.calculateMultipleHashesADR32 = exports.prepareADR32Data = exports.compareStrings = exports.sortKeys = void 0;\n\nvar node_1 = require(\"./node\"); // Compare both by key and hash\n// @internal\n\n\nfunction sortKeys(a, b) {\n  return compareStrings(a.hash, b.hash) || compareStrings(a.file, b.file) || 0;\n}\n\nexports.sortKeys = sortKeys; // Compare strings\n// @internal\n\nfunction compareStrings(a, b) {\n  if (a == b) return 0;\n\n  for (var i = 0; i < Math.max(a.length, b.length); i++) {\n    if (a.charAt(i) > b.charAt(i)) return 1;\n    if (a.charAt(i) < b.charAt(i)) return -1;\n  }\n\n  if (a.length > b.length) return 1;\n  return -1;\n}\n\nexports.compareStrings = compareStrings; // @internal\n\nfunction prepareADR32Data(contents, metadata) {\n  return new TextEncoder().encode(JSON.stringify({\n    content: contents.sort(sortKeys).map(function (entry) {\n      return {\n        key: entry.file,\n        hash: entry.hash\n      };\n    }),\n    metadata: metadata\n  }));\n}\n\nexports.prepareADR32Data = prepareADR32Data;\n/**\n * Calculates the content hash of multiple files to be used consistently by the builder\n * and other content-based applications when hashes need to be stored on-chain.\n *\n * Returns the CIDv1 of the data prepared to sign\n * @public\n */\n\nfunction calculateMultipleHashesADR32(_x, _x2) {\n  return _calculateMultipleHashesADR.apply(this, arguments);\n}\n\nfunction _calculateMultipleHashesADR() {\n  _calculateMultipleHashesADR = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(contents, metadata) {\n    var data;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            data = prepareADR32Data(contents, metadata);\n            _context.t0 = data;\n            _context.next = 4;\n            return (0, node_1.hashV1)(data);\n\n          case 4:\n            _context.t1 = _context.sent;\n            return _context.abrupt(\"return\", {\n              data: _context.t0,\n              hash: _context.t1\n            });\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _calculateMultipleHashesADR.apply(this, arguments);\n}\n\nexports.calculateMultipleHashesADR32 = calculateMultipleHashesADR32;\n/**\n * Calculates the content hash of multiple files to be used consistently by the builder\n * and other content-based applications when hashes need to be stored on-chain.\n *\n * @deprecated this is maintained only for compatibility reasons with calculateBufferHash (Qm prefix)\n * @public\n */\n\nfunction calculateMultipleHashesADR32LegacyQmHash(_x3, _x4) {\n  return _calculateMultipleHashesADR32LegacyQmHash.apply(this, arguments);\n}\n\nfunction _calculateMultipleHashesADR32LegacyQmHash() {\n  _calculateMultipleHashesADR32LegacyQmHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(contents, metadata) {\n    var data;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            data = prepareADR32Data(contents, metadata);\n            _context2.t0 = data;\n            _context2.next = 4;\n            return (0, node_1.hashV0)(data);\n\n          case 4:\n            _context2.t1 = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              data: _context2.t0,\n              hash: _context2.t1\n            });\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _calculateMultipleHashesADR32LegacyQmHash.apply(this, arguments);\n}\n\nexports.calculateMultipleHashesADR32LegacyQmHash = calculateMultipleHashesADR32LegacyQmHash;","map":null,"metadata":{},"sourceType":"script"}