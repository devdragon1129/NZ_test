{"ast":null,"code":"import { __extends } from \"tslib\";\n/**\r\n * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.\r\n */\n\nvar SmartArray =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a Smart Array.\r\n   * @param capacity defines the default capacity of the array.\r\n   */\n  function SmartArray(capacity) {\n    /**\r\n     * The active length of the array.\r\n     */\n    this.length = 0;\n    this.data = new Array(capacity);\n    this._id = SmartArray._GlobalId++;\n  }\n  /**\r\n   * Pushes a value at the end of the active data.\r\n   * @param value defines the object to push in the array.\r\n   */\n\n\n  SmartArray.prototype.push = function (value) {\n    this.data[this.length++] = value;\n\n    if (this.length > this.data.length) {\n      this.data.length *= 2;\n    }\n  };\n  /**\r\n   * Iterates over the active data and apply the lambda to them.\r\n   * @param func defines the action to apply on each value.\r\n   */\n\n\n  SmartArray.prototype.forEach = function (func) {\n    for (var index = 0; index < this.length; index++) {\n      func(this.data[index]);\n    }\n  };\n  /**\r\n   * Sorts the full sets of data.\r\n   * @param compareFn defines the comparison function to apply.\r\n   */\n\n\n  SmartArray.prototype.sort = function (compareFn) {\n    this.data.sort(compareFn);\n  };\n  /**\r\n   * Resets the active data to an empty array.\r\n   */\n\n\n  SmartArray.prototype.reset = function () {\n    this.length = 0;\n  };\n  /**\r\n   * Releases all the data from the array as well as the array.\r\n   */\n\n\n  SmartArray.prototype.dispose = function () {\n    this.reset();\n\n    if (this.data) {\n      this.data.length = 0;\n      this.data = [];\n    }\n  };\n  /**\r\n   * Concats the active data with a given array.\r\n   * @param array defines the data to concatenate with.\r\n   */\n\n\n  SmartArray.prototype.concat = function (array) {\n    if (array.length === 0) {\n      return;\n    }\n\n    if (this.length + array.length > this.data.length) {\n      this.data.length = (this.length + array.length) * 2;\n    }\n\n    for (var index = 0; index < array.length; index++) {\n      this.data[this.length++] = (array.data || array)[index];\n    }\n  };\n  /**\r\n   * Returns the position of a value in the active data.\r\n   * @param value defines the value to find the index for\r\n   * @returns the index if found in the active data otherwise -1\r\n   */\n\n\n  SmartArray.prototype.indexOf = function (value) {\n    var position = this.data.indexOf(value);\n\n    if (position >= this.length) {\n      return -1;\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns whether an element is part of the active data.\r\n   * @param value defines the value to look for\r\n   * @returns true if found in the active data otherwise false\r\n   */\n\n\n  SmartArray.prototype.contains = function (value) {\n    return this.indexOf(value) !== -1;\n  }; // Statics\n\n\n  SmartArray._GlobalId = 0;\n  return SmartArray;\n}();\n\nexport { SmartArray };\n/**\r\n * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.\r\n * The data in this array can only be present once\r\n */\n\nvar SmartArrayNoDuplicate =\n/** @class */\nfunction (_super) {\n  __extends(SmartArrayNoDuplicate, _super);\n\n  function SmartArrayNoDuplicate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._duplicateId = 0;\n    return _this;\n  }\n  /**\r\n   * Pushes a value at the end of the active data.\r\n   * THIS DOES NOT PREVENT DUPPLICATE DATA\r\n   * @param value defines the object to push in the array.\r\n   */\n\n\n  SmartArrayNoDuplicate.prototype.push = function (value) {\n    _super.prototype.push.call(this, value);\n\n    if (!value.__smartArrayFlags) {\n      value.__smartArrayFlags = {};\n    }\n\n    value.__smartArrayFlags[this._id] = this._duplicateId;\n  };\n  /**\r\n   * Pushes a value at the end of the active data.\r\n   * If the data is already present, it won t be added again\r\n   * @param value defines the object to push in the array.\r\n   * @returns true if added false if it was already present\r\n   */\n\n\n  SmartArrayNoDuplicate.prototype.pushNoDuplicate = function (value) {\n    if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {\n      return false;\n    }\n\n    this.push(value);\n    return true;\n  };\n  /**\r\n   * Resets the active data to an empty array.\r\n   */\n\n\n  SmartArrayNoDuplicate.prototype.reset = function () {\n    _super.prototype.reset.call(this);\n\n    this._duplicateId++;\n  };\n  /**\r\n   * Concats the active data with a given array.\r\n   * This ensures no dupplicate will be present in the result.\r\n   * @param array defines the data to concatenate with.\r\n   */\n\n\n  SmartArrayNoDuplicate.prototype.concatWithNoDuplicate = function (array) {\n    if (array.length === 0) {\n      return;\n    }\n\n    if (this.length + array.length > this.data.length) {\n      this.data.length = (this.length + array.length) * 2;\n    }\n\n    for (var index = 0; index < array.length; index++) {\n      var item = (array.data || array)[index];\n      this.pushNoDuplicate(item);\n    }\n  };\n\n  return SmartArrayNoDuplicate;\n}(SmartArray);\n\nexport { SmartArrayNoDuplicate };","map":null,"metadata":{},"sourceType":"module"}