{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialConnectionPointDirection } from '../../nodeMaterialBlockConnectionPoint';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\n/**\r\n * Block used to implement the anisotropy module of the PBR material\r\n */\n\nvar AnisotropyBlock =\n/** @class */\nfunction (_super) {\n  __extends(AnisotropyBlock, _super);\n  /**\r\n   * Create a new AnisotropyBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function AnisotropyBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n\n    _this._isUnique = true;\n\n    _this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\n\n\n    _this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n\n    _this.registerOutput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"anisotropy\", _this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\"));\n\n    return _this;\n  }\n  /**\r\n   * Initialize the block and prepare the context for build\r\n   * @param state defines the state that will be used for the build\r\n   */\n\n\n  AnisotropyBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"anisotropicOut\");\n\n    state._excludeVariableName(\"TBN\");\n  };\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  AnisotropyBlock.prototype.getClassName = function () {\n    return \"AnisotropyBlock\";\n  };\n\n  Object.defineProperty(AnisotropyBlock.prototype, \"intensity\", {\n    /**\r\n     * Gets the intensity input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"direction\", {\n    /**\r\n     * Gets the direction input component\r\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the uv input component\r\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"worldTangent\", {\n    /**\r\n     * Gets the worldTangent input component\r\n     */\n    get: function get() {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"anisotropy\", {\n    /**\r\n     * Gets the anisotropy object output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AnisotropyBlock.prototype._generateTBNSpace = function (state) {\n    var code = \"\";\n    var comments = \"//\" + this.name;\n    var uv = this.uv;\n    var worldPosition = this.worldPositionConnectionPoint;\n    var worldNormal = this.worldNormalConnectionPoint;\n    var worldTangent = this.worldTangent;\n\n    if (!uv.isConnected) {\n      // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\n      // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\n      // it will stop the building of the node material and will lead to errors in the editor!\n      console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\n    }\n\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n\n    var tangentReplaceString = {\n      search: /defined\\(TANGENT\\)/g,\n      replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n    };\n\n    if (worldTangent.isConnected) {\n      code += \"vec3 tbnNormal = normalize(\" + worldNormal.associatedVariableName + \".xyz);\\r\\n\";\n      code += \"vec3 tbnTangent = normalize(\" + worldTangent.associatedVariableName + \".xyz);\\r\\n\";\n      code += \"vec3 tbnBitangent = cross(tbnNormal, tbnTangent);\\r\\n\";\n      code += \"mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n\";\n    }\n\n    code += \"\\n            #if defined(\" + (worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\") + \") && defined(NORMAL)\\n                mat3 TBN = vTBN;\\n            #else\\n                mat3 TBN = cotangent_frame(\" + (worldNormal.associatedVariableName + \".xyz\") + \", \" + (\"v_\" + worldPosition.associatedVariableName + \".xyz\") + \", \" + (uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\") + \", vec2(1., 1.));\\n            #endif\\r\\n\";\n\n    state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n      replaceStrings: [tangentReplaceString]\n    });\n\n    return code;\n  };\n  /**\r\n   * Gets the main code of the block (fragment side)\r\n   * @param state current state of the node material building\r\n   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n   * @returns the shader code\r\n   */\n\n\n  AnisotropyBlock.prototype.getCode = function (state, generateTBNSpace) {\n    if (generateTBNSpace === void 0) {\n      generateTBNSpace = false;\n    }\n\n    var code = \"\";\n\n    if (generateTBNSpace) {\n      code += this._generateTBNSpace(state);\n    }\n\n    var intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\n    var direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\n    code += \"anisotropicOutParams anisotropicOut;\\n            anisotropicBlock(\\n                vec3(\" + direction + \", \" + intensity + \"),\\n            #ifdef ANISOTROPIC_TEXTURE\\n                vec3(0.),\\n            #endif\\n                TBN,\\n                normalW,\\n                viewDirectionW,\\n                anisotropicOut\\n            );\\r\\n\";\n    return code;\n  };\n\n  AnisotropyBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);\n\n    defines.setValue(\"ANISOTROPIC\", true);\n    defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\n  };\n\n  AnisotropyBlock.prototype._buildBlock = function (state) {\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.blocksWithDefines.push(this);\n    }\n\n    return this;\n  };\n\n  return AnisotropyBlock;\n}(NodeMaterialBlock);\n\nexport { AnisotropyBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.AnisotropyBlock\"] = AnisotropyBlock;","map":null,"metadata":{},"sourceType":"module"}