{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\nimport { CylinderBuilder } from \"../Meshes/Builders/cylinderBuilder\";\nimport { Ray } from \"../Culling/ray\";\n/**\r\n * A helper for physics simulations\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\nvar PhysicsHelper =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the Physics helper\r\n   * @param scene Babylon.js scene\r\n   */\n  function PhysicsHelper(scene) {\n    this._scene = scene;\n    this._physicsEngine = this._scene.getPhysicsEngine();\n\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you can use the methods.');\n      return;\n    }\n  }\n  /**\r\n   * Applies a radial explosion impulse\r\n   * @param origin the origin of the explosion\r\n   * @param radiusOrEventOptions the radius or the options of radial explosion\r\n   * @param strength the explosion strength\r\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n   * @returns A physics radial explosion event, or null\r\n   */\n\n\n  PhysicsHelper.prototype.applyRadialExplosionImpulse = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call this method.');\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    var affectedImpostorsWithData = Array();\n    impostors.forEach(function (impostor) {\n      var impostorHitData = event.getImpostorHitData(impostor, origin);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);\n      affectedImpostorsWithData.push({\n        impostor: impostor,\n        hitData: impostorHitData\n      });\n    });\n    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    event.dispose(false);\n    return event;\n  };\n  /**\r\n   * Applies a radial explosion force\r\n   * @param origin the origin of the explosion\r\n   * @param radiusOrEventOptions the radius or the options of radial explosion\r\n   * @param strength the explosion strength\r\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n   * @returns A physics radial explosion event, or null\r\n   */\n\n\n  PhysicsHelper.prototype.applyRadialExplosionForce = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    var affectedImpostorsWithData = Array();\n    impostors.forEach(function (impostor) {\n      var impostorHitData = event.getImpostorHitData(impostor, origin);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n      affectedImpostorsWithData.push({\n        impostor: impostor,\n        hitData: impostorHitData\n      });\n    });\n    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    event.dispose(false);\n    return event;\n  };\n  /**\r\n   * Creates a gravitational field\r\n   * @param origin the origin of the explosion\r\n   * @param radiusOrEventOptions the radius or the options of radial explosion\r\n   * @param strength the explosion strength\r\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n   * @returns A physics gravitational field event, or null\r\n   */\n\n\n  PhysicsHelper.prototype.gravitationalField = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n  /**\r\n   * Creates a physics updraft event\r\n   * @param origin the origin of the updraft\r\n   * @param radiusOrEventOptions the radius or the options of the updraft\r\n   * @param strength the strength of the updraft\r\n   * @param height the height of the updraft\r\n   * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\r\n   * @returns A physics updraft event, or null\r\n   */\n\n\n  PhysicsHelper.prototype.updraft = function (origin, radiusOrEventOptions, strength, height, updraftMode) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\n      return null;\n    }\n\n    if (this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsUpdraftEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height || radiusOrEventOptions.height;\n      radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;\n    }\n\n    var event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n  /**\r\n   * Creates a physics vortex event\r\n   * @param origin the of the vortex\r\n   * @param radiusOrEventOptions the radius or the options of the vortex\r\n   * @param strength the strength of the vortex\r\n   * @param height   the height of the vortex\r\n   * @returns a Physics vortex event, or null\r\n   * A physics vortex event or null\r\n   */\n\n\n  PhysicsHelper.prototype.vortex = function (origin, radiusOrEventOptions, strength, height) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\n      return null;\n    }\n\n    if (this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsVortexEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height || radiusOrEventOptions.height;\n    }\n\n    var event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n\n  return PhysicsHelper;\n}();\n\nexport { PhysicsHelper };\n/**\r\n * Represents a physics radial explosion event\r\n */\n\nvar PhysicsRadialExplosionEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes a radial explosioin event\r\n   * @param _scene BabylonJS scene\r\n   * @param _options The options for the vortex event\r\n   */\n  function PhysicsRadialExplosionEvent(_scene, _options) {\n    this._scene = _scene;\n    this._options = _options;\n    this._dataFetched = false; // check if the data has been fetched. If not, do cleanup\n\n    this._options = __assign(__assign({}, new PhysicsRadialExplosionEventOptions()), this._options);\n  }\n  /**\r\n   * Returns the data related to the radial explosion event (sphere).\r\n   * @returns The radial explosion event data\r\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  };\n  /**\r\n   * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\r\n   * @param impostor A physics imposter\r\n   * @param origin the origin of the explosion\r\n   * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null\r\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.getImpostorHitData = function (impostor, origin) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {\n      return null;\n    }\n\n    if (impostor.object.getClassName() !== 'Mesh' && impostor.object.getClassName() !== 'InstancedMesh') {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n    var direction = impostorObjectCenter.subtract(origin);\n    var ray = new Ray(origin, direction, this._options.radius);\n    var hit = ray.intersectsMesh(impostor.object);\n    var contactPoint = hit.pickedPoint;\n\n    if (!contactPoint) {\n      return null;\n    }\n\n    var distanceFromOrigin = Vector3.Distance(origin, contactPoint);\n\n    if (distanceFromOrigin > this._options.radius) {\n      return null;\n    }\n\n    var multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\n    var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    return {\n      force: force,\n      contactPoint: contactPoint,\n      distanceFromOrigin: distanceFromOrigin\n    };\n  };\n  /**\r\n   * Triggers affecterd impostors callbacks\r\n   * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\r\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.triggerAffectedImpostorsCallback = function (affectedImpostorsWithData) {\n    if (this._options.affectedImpostorsCallback) {\n      this._options.affectedImpostorsCallback(affectedImpostorsWithData);\n    }\n  };\n  /**\r\n   * Disposes the sphere.\r\n   * @param force Specifies if the sphere should be disposed by force\r\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._sphere.dispose();\n        }\n      }, 0);\n    }\n  };\n  /*** Helpers ***/\n\n\n  PhysicsRadialExplosionEvent.prototype._prepareSphere = function () {\n    if (!this._sphere) {\n      this._sphere = SphereBuilder.CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\n      this._sphere.isVisible = false;\n    }\n  };\n\n  PhysicsRadialExplosionEvent.prototype._intersectsWithSphere = function (impostor, origin, radius) {\n    var impostorObject = impostor.object;\n\n    this._prepareSphere();\n\n    this._sphere.position = origin;\n    this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);\n\n    this._sphere._updateBoundingInfo();\n\n    this._sphere.computeWorldMatrix(true);\n\n    return this._sphere.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsRadialExplosionEvent;\n}();\n/**\r\n * Represents a gravitational field event\r\n */\n\n\nvar PhysicsGravitationalFieldEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the physics gravitational field event\r\n   * @param _physicsHelper A physics helper\r\n   * @param _scene BabylonJS scene\r\n   * @param _origin The origin position of the gravitational field event\r\n   * @param _options The options for the vortex event\r\n   */\n  function PhysicsGravitationalFieldEvent(_physicsHelper, _scene, _origin, _options) {\n    this._physicsHelper = _physicsHelper;\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._options = __assign(__assign({}, new PhysicsRadialExplosionEventOptions()), this._options);\n    this._tickCallback = this._tick.bind(this);\n    this._options.strength = this._options.strength * -1;\n  }\n  /**\r\n   * Returns the data related to the gravitational field event (sphere).\r\n   * @returns A gravitational field event\r\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  };\n  /**\r\n   * Enables the gravitational field.\r\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disables the gravitational field.\r\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disposes the sphere.\r\n   * @param force The force to dispose from the gravitational field event\r\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._sphere.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsGravitationalFieldEvent.prototype._tick = function () {\n    // Since the params won't change, we fetch the event only once\n    if (this._sphere) {\n      this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n    } else {\n      var radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n\n      if (radialExplosionEvent) {\n        this._sphere = radialExplosionEvent.getData().sphere.clone('radialExplosionEventSphereClone');\n      }\n    }\n  };\n\n  return PhysicsGravitationalFieldEvent;\n}();\n/**\r\n * Represents a physics updraft event\r\n */\n\n\nvar PhysicsUpdraftEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the physics updraft event\r\n   * @param _scene BabylonJS scene\r\n   * @param _origin The origin position of the updraft\r\n   * @param _options The options for the updraft event\r\n   */\n  function PhysicsUpdraftEvent(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n\n    this._originDirection = Vector3.Zero(); // used if the updraftMode is perpendicular\n\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = __assign(__assign({}, new PhysicsUpdraftEventOptions()), this._options);\n\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      this._originDirection = this._origin.subtract(this._originTop).normalize();\n    }\n\n    this._tickCallback = this._tick.bind(this);\n\n    this._prepareCylinder();\n  }\n  /**\r\n   * Returns the data related to the updraft event (cylinder).\r\n   * @returns A physics updraft event\r\n   */\n\n\n  PhysicsUpdraftEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  };\n  /**\r\n   * Enables the updraft.\r\n   */\n\n\n  PhysicsUpdraftEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disables the updraft.\r\n   */\n\n\n  PhysicsUpdraftEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disposes the cylinder.\r\n   * @param force Specifies if the updraft should be disposed by force\r\n   */\n\n\n  PhysicsUpdraftEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (!this._cylinder) {\n      return;\n    }\n\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsUpdraftEvent.prototype.getImpostorHitData = function (impostor) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithCylinder(impostor)) {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      var direction = this._originDirection;\n    } else {\n      var direction = impostorObjectCenter.subtract(this._originTop);\n    }\n\n    var distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);\n    var multiplier = this._options.strength * -1;\n    var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    return {\n      force: force,\n      contactPoint: impostorObjectCenter,\n      distanceFromOrigin: distanceFromOrigin\n    };\n  };\n\n  PhysicsUpdraftEvent.prototype._tick = function () {\n    var _this = this;\n\n    this._physicsEngine.getImpostors().forEach(function (impostor) {\n      var impostorHitData = _this.getImpostorHitData(impostor);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n    });\n  };\n  /*** Helpers ***/\n\n\n  PhysicsUpdraftEvent.prototype._prepareCylinder = function () {\n    if (!this._cylinder) {\n      this._cylinder = CylinderBuilder.CreateCylinder(\"updraftEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  };\n\n  PhysicsUpdraftEvent.prototype._intersectsWithCylinder = function (impostor) {\n    var impostorObject = impostor.object;\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsUpdraftEvent;\n}();\n/**\r\n * Represents a physics vortex event\r\n */\n\n\nvar PhysicsVortexEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the physics vortex event\r\n   * @param _scene The BabylonJS scene\r\n   * @param _origin The origin position of the vortex\r\n   * @param _options The options for the vortex event\r\n   */\n  function PhysicsVortexEvent(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = __assign(__assign({}, new PhysicsVortexEventOptions()), this._options);\n\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n\n    this._tickCallback = this._tick.bind(this);\n\n    this._prepareCylinder();\n  }\n  /**\r\n   * Returns the data related to the vortex event (cylinder).\r\n   * @returns The physics vortex event data\r\n   */\n\n\n  PhysicsVortexEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  };\n  /**\r\n   * Enables the vortex.\r\n   */\n\n\n  PhysicsVortexEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disables the cortex.\r\n   */\n\n\n  PhysicsVortexEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disposes the sphere.\r\n   * @param force\r\n   */\n\n\n  PhysicsVortexEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsVortexEvent.prototype.getImpostorHitData = function (impostor) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithCylinder(impostor)) {\n      return null;\n    }\n\n    if (impostor.object.getClassName() !== 'Mesh' && impostor.object.getClassName() !== 'InstancedMesh') {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n    var originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\n\n    var originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);\n    var ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);\n    var hit = ray.intersectsMesh(impostor.object);\n    var contactPoint = hit.pickedPoint;\n\n    if (!contactPoint) {\n      return null;\n    }\n\n    var absoluteDistanceFromOrigin = hit.distance / this._options.radius;\n    var directionToOrigin = contactPoint.normalize();\n\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      directionToOrigin = directionToOrigin.negate();\n    }\n\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      var forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\n      var forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\n      var forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\n    } else {\n      var perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();\n      var forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\n      var forceY = this._originTop.y * this._options.updraftForceMultiplier;\n      var forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\n    }\n\n    var force = new Vector3(forceX, forceY, forceZ);\n    force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);\n    return {\n      force: force,\n      contactPoint: impostorObjectCenter,\n      distanceFromOrigin: absoluteDistanceFromOrigin\n    };\n  };\n\n  PhysicsVortexEvent.prototype._tick = function () {\n    var _this = this;\n\n    this._physicsEngine.getImpostors().forEach(function (impostor) {\n      var impostorHitData = _this.getImpostorHitData(impostor);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n    });\n  };\n  /*** Helpers ***/\n\n\n  PhysicsVortexEvent.prototype._prepareCylinder = function () {\n    if (!this._cylinder) {\n      this._cylinder = CylinderBuilder.CreateCylinder(\"vortexEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  };\n\n  PhysicsVortexEvent.prototype._intersectsWithCylinder = function (impostor) {\n    var impostorObject = impostor.object;\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsVortexEvent;\n}();\n/**\r\n * Options fot the radial explosion event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\n\nvar PhysicsRadialExplosionEventOptions =\n/** @class */\nfunction () {\n  function PhysicsRadialExplosionEventOptions() {\n    /**\r\n     * The radius of the sphere for the radial explosion.\r\n     */\n    this.radius = 5;\n    /**\r\n     * The strenth of the explosion.\r\n     */\n\n    this.strength = 10;\n    /**\r\n     * The strenght of the force in correspondence to the distance of the affected object\r\n     */\n\n    this.falloff = PhysicsRadialImpulseFalloff.Constant;\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\n\n    this.sphere = {\n      segments: 32,\n      diameter: 1\n    };\n  }\n\n  return PhysicsRadialExplosionEventOptions;\n}();\n\nexport { PhysicsRadialExplosionEventOptions };\n/**\r\n * Options fot the updraft event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\nvar PhysicsUpdraftEventOptions =\n/** @class */\nfunction () {\n  function PhysicsUpdraftEventOptions() {\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\n    this.radius = 5;\n    /**\r\n     * The strenth of the updraft.\r\n     */\n\n    this.strength = 10;\n    /**\r\n     * The height of the cylinder for the updraft.\r\n     */\n\n    this.height = 10;\n    /**\r\n     * The mode for the the updraft.\r\n     */\n\n    this.updraftMode = PhysicsUpdraftMode.Center;\n  }\n\n  return PhysicsUpdraftEventOptions;\n}();\n\nexport { PhysicsUpdraftEventOptions };\n/**\r\n * Options fot the vortex event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\nvar PhysicsVortexEventOptions =\n/** @class */\nfunction () {\n  function PhysicsVortexEventOptions() {\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\n    this.radius = 5;\n    /**\r\n     * The strenth of the vortex.\r\n     */\n\n    this.strength = 10;\n    /**\r\n     * The height of the cylinder for the vortex.\r\n     */\n\n    this.height = 10;\n    /**\r\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\r\n     */\n\n    this.centripetalForceThreshold = 0.7;\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the treshold.\r\n     */\n\n    this.centripetalForceMultiplier = 5;\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the treshold.\r\n     */\n\n    this.centrifugalForceMultiplier = 0.5;\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\r\n     */\n\n    this.updraftForceMultiplier = 0.02;\n  }\n\n  return PhysicsVortexEventOptions;\n}();\n\nexport { PhysicsVortexEventOptions };\n/**\r\n* The strenght of the force in correspondence to the distance of the affected object\r\n* @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n*/\n\nexport var PhysicsRadialImpulseFalloff;\n\n(function (PhysicsRadialImpulseFalloff) {\n  /** Defines that impulse is constant in strength across it's whole radius */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Constant\"] = 0] = \"Constant\";\n  /** Defines that impulse gets weaker if it's further from the origin */\n\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Linear\"] = 1] = \"Linear\";\n})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\n\nexport var PhysicsUpdraftMode;\n\n(function (PhysicsUpdraftMode) {\n  /** Defines that the upstream forces will pull towards the top center of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Center\"] = 0] = \"Center\";\n  /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\n\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Perpendicular\"] = 1] = \"Perpendicular\";\n})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));","map":null,"metadata":{},"sourceType":"module"}