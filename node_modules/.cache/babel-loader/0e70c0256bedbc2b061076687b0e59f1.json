{"ast":null,"code":"import { Tools } from \"./tools\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\nimport { Scene } from \"../scene\";\nimport { PostProcess } from \"../PostProcesses/postProcess\";\nimport { Logger } from \"../Misc/logger\";\nimport \"../Engines/Extensions/engine.renderTargetCube\";\nimport \"../Engines/Extensions/engine.readTexture\";\nimport \"../Materials/Textures/baseTexture.polynomial\";\nimport \"../Shaders/rgbdEncode.fragment\";\nimport \"../Shaders/rgbdDecode.fragment\";\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\n\nvar EnvironmentTextureTools =\n/** @class */\nfunction () {\n  function EnvironmentTextureTools() {}\n  /**\r\n   * Gets the environment info from an env file.\r\n   * @param data The array buffer containing the .env bytes.\r\n   * @returns the environment file info (the json header) if successfully parsed.\r\n   */\n\n\n  EnvironmentTextureTools.GetEnvInfo = function (data) {\n    var dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    var pos = 0;\n\n    for (var i = 0; i < EnvironmentTextureTools._MagicBytes.length; i++) {\n      if (dataView.getUint8(pos++) !== EnvironmentTextureTools._MagicBytes[i]) {\n        Logger.Error('Not a babylon environment map');\n        return null;\n      }\n    } // Read json manifest - collect characters up to null terminator\n\n\n    var manifestString = '';\n    var charCode = 0x00;\n\n    while (charCode = dataView.getUint8(pos++)) {\n      manifestString += String.fromCharCode(charCode);\n    }\n\n    var manifest = JSON.parse(manifestString);\n\n    if (manifest.specular) {\n      // Extend the header with the position of the payload.\n      manifest.specular.specularDataPosition = pos; // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n\n      manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n    }\n\n    return manifest;\n  };\n  /**\r\n   * Creates an environment texture from a loaded cube texture.\r\n   * @param texture defines the cube texture to convert in env file\r\n   * @return a promise containing the environment data if succesfull.\r\n   */\n\n\n  EnvironmentTextureTools.CreateEnvTextureAsync = function (texture) {\n    var _this = this;\n\n    var internalTexture = texture.getInternalTexture();\n\n    if (!internalTexture) {\n      return Promise.reject(\"The cube texture is invalid.\");\n    }\n\n    var engine = internalTexture.getEngine();\n\n    if (engine && engine.premultipliedAlpha) {\n      return Promise.reject(\"Env texture can only be created when the engine is created with the premultipliedAlpha option set to false.\");\n    }\n\n    if (texture.textureType === 0) {\n      return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n    }\n\n    var canvas = engine.getRenderingCanvas();\n\n    if (!canvas) {\n      return Promise.reject(\"Env texture can only be created when the engine is associated to a canvas.\");\n    }\n\n    var textureType = 1;\n\n    if (!engine.getCaps().textureFloatRender) {\n      textureType = 2;\n\n      if (!engine.getCaps().textureHalfFloatRender) {\n        return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n      }\n    }\n\n    var cubeWidth = internalTexture.width;\n    var hostingScene = new Scene(engine);\n    var specularTextures = {};\n    var promises = []; // Read and collect all mipmaps data from the cube.\n\n    var mipmapsCount = Scalar.Log2(internalTexture.width);\n    mipmapsCount = Math.round(mipmapsCount);\n\n    var _loop_1 = function _loop_1(i) {\n      var faceWidth = Math.pow(2, mipmapsCount - i);\n\n      var _loop_2 = function _loop_2(face) {\n        var data = texture.readPixels(face, i); // Creates a temp texture with the face data.\n\n        var tempTexture = engine.createRawTexture(data, faceWidth, faceWidth, 5, false, false, 1, null, textureType); // And rgbdEncode them.\n\n        var promise = new Promise(function (resolve, reject) {\n          var rgbdPostProcess = new PostProcess(\"rgbdEncode\", \"rgbdEncode\", null, null, 1, null, 1, engine, false, undefined, 0, undefined, null, false);\n          rgbdPostProcess.getEffect().executeWhenCompiled(function () {\n            rgbdPostProcess.onApply = function (effect) {\n              effect._bindTexture(\"textureSampler\", tempTexture);\n            }; // As the process needs to happen on the main canvas, keep track of the current size\n\n\n            var currentW = engine.getRenderWidth();\n            var currentH = engine.getRenderHeight(); // Set the desired size for the texture\n\n            engine.setSize(faceWidth, faceWidth);\n            hostingScene.postProcessManager.directRender([rgbdPostProcess], null); // Reading datas from WebGL\n\n            Tools.ToBlob(canvas, function (blob) {\n              var fileReader = new FileReader();\n\n              fileReader.onload = function (event) {\n                var arrayBuffer = event.target.result;\n                specularTextures[i * 6 + face] = arrayBuffer;\n                resolve();\n              };\n\n              fileReader.readAsArrayBuffer(blob);\n            }); // Reapply the previous canvas size\n\n            engine.setSize(currentW, currentH);\n          });\n        });\n        promises.push(promise);\n      }; // All faces of the cube.\n\n\n      for (var face = 0; face < 6; face++) {\n        _loop_2(face);\n      }\n    };\n\n    for (var i = 0; i <= mipmapsCount; i++) {\n      _loop_1(i);\n    } // Once all the textures haves been collected as RGBD stored in PNGs\n\n\n    return Promise.all(promises).then(function () {\n      // We can delete the hosting scene keeping track of all the creation objects\n      hostingScene.dispose(); // Creates the json header for the env texture\n\n      var info = {\n        version: 1,\n        width: cubeWidth,\n        irradiance: _this._CreateEnvTextureIrradiance(texture),\n        specular: {\n          mipmaps: [],\n          lodGenerationScale: texture.lodGenerationScale\n        }\n      }; // Sets the specular image data information\n\n      var position = 0;\n\n      for (var i = 0; i <= mipmapsCount; i++) {\n        for (var face = 0; face < 6; face++) {\n          var byteLength = specularTextures[i * 6 + face].byteLength;\n          info.specular.mipmaps.push({\n            length: byteLength,\n            position: position\n          });\n          position += byteLength;\n        }\n      } // Encode the JSON as an array buffer\n\n\n      var infoString = JSON.stringify(info);\n      var infoBuffer = new ArrayBuffer(infoString.length + 1);\n      var infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\n\n      for (var i = 0, strLen = infoString.length; i < strLen; i++) {\n        infoView[i] = infoString.charCodeAt(i);\n      } // Ends up with a null terminator for easier parsing\n\n\n      infoView[infoString.length] = 0x00; // Computes the final required size and creates the storage\n\n      var totalSize = EnvironmentTextureTools._MagicBytes.length + position + infoBuffer.byteLength;\n      var finalBuffer = new ArrayBuffer(totalSize);\n      var finalBufferView = new Uint8Array(finalBuffer);\n      var dataView = new DataView(finalBuffer); // Copy the magic bytes identifying the file in\n\n      var pos = 0;\n\n      for (var i = 0; i < EnvironmentTextureTools._MagicBytes.length; i++) {\n        dataView.setUint8(pos++, EnvironmentTextureTools._MagicBytes[i]);\n      } // Add the json info\n\n\n      finalBufferView.set(new Uint8Array(infoBuffer), pos);\n      pos += infoBuffer.byteLength; // Finally inserts the texture data\n\n      for (var i = 0; i <= mipmapsCount; i++) {\n        for (var face = 0; face < 6; face++) {\n          var dataBuffer = specularTextures[i * 6 + face];\n          finalBufferView.set(new Uint8Array(dataBuffer), pos);\n          pos += dataBuffer.byteLength;\n        }\n      } // Voila\n\n\n      return finalBuffer;\n    });\n  };\n  /**\r\n   * Creates a JSON representation of the spherical data.\r\n   * @param texture defines the texture containing the polynomials\r\n   * @return the JSON representation of the spherical info\r\n   */\n\n\n  EnvironmentTextureTools._CreateEnvTextureIrradiance = function (texture) {\n    var polynmials = texture.sphericalPolynomial;\n\n    if (polynmials == null) {\n      return null;\n    }\n\n    return {\n      x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n      y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n      z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n      xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n      yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n      zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n      yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n      zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n      xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]\n    };\n  };\n  /**\r\n   * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n   * @param data the image data\r\n   * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n   * @return the views described by info providing access to the underlying buffer\r\n   */\n\n\n  EnvironmentTextureTools.CreateImageDataArrayBufferViews = function (data, info) {\n    if (info.version !== 1) {\n      throw new Error(\"Unsupported babylon environment map version \\\"\" + info.version + \"\\\"\");\n    }\n\n    var specularInfo = info.specular; // Double checks the enclosed info\n\n    var mipmapsCount = Scalar.Log2(info.width);\n    mipmapsCount = Math.round(mipmapsCount) + 1;\n\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n      throw new Error(\"Unsupported specular mipmaps number \\\"\" + specularInfo.mipmaps.length + \"\\\"\");\n    }\n\n    var imageData = new Array(mipmapsCount);\n\n    for (var i = 0; i < mipmapsCount; i++) {\n      imageData[i] = new Array(6);\n\n      for (var face = 0; face < 6; face++) {\n        var imageInfo = specularInfo.mipmaps[i * 6 + face];\n        imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);\n      }\n    }\n\n    return imageData;\n  };\n  /**\r\n   * Uploads the texture info contained in the env file to the GPU.\r\n   * @param texture defines the internal texture to upload to\r\n   * @param data defines the data to load\r\n   * @param info defines the texture info retrieved through the GetEnvInfo method\r\n   * @returns a promise\r\n   */\n\n\n  EnvironmentTextureTools.UploadEnvLevelsAsync = function (texture, data, info) {\n    if (info.version !== 1) {\n      throw new Error(\"Unsupported babylon environment map version \\\"\" + info.version + \"\\\"\");\n    }\n\n    var specularInfo = info.specular;\n\n    if (!specularInfo) {\n      // Nothing else parsed so far\n      return Promise.resolve();\n    }\n\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\n    var imageData = EnvironmentTextureTools.CreateImageDataArrayBufferViews(data, info);\n    return EnvironmentTextureTools.UploadLevelsAsync(texture, imageData);\n  };\n\n  EnvironmentTextureTools._OnImageReadyAsync = function (image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n    return new Promise(function (resolve, reject) {\n      if (expandTexture) {\n        var tempTexture_1 = engine.createTexture(null, true, true, null, 1, null, function (message) {\n          reject(message);\n        }, image);\n        rgbdPostProcess.getEffect().executeWhenCompiled(function () {\n          // Uncompress the data to a RTT\n          rgbdPostProcess.onApply = function (effect) {\n            effect._bindTexture(\"textureSampler\", tempTexture_1);\n\n            effect.setFloat2(\"scale\", 1, 1);\n          };\n\n          engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i); // Cleanup\n\n          engine.restoreDefaultFramebuffer();\n          tempTexture_1.dispose();\n          URL.revokeObjectURL(url);\n          resolve();\n        });\n      } else {\n        engine._uploadImageToTexture(texture, image, face, i); // Upload the face to the non lod texture support\n\n\n        if (generateNonLODTextures) {\n          var lodTexture = lodTextures[i];\n\n          if (lodTexture) {\n            engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n          }\n        }\n\n        resolve();\n      }\n    });\n  };\n  /**\r\n   * Uploads the levels of image data to the GPU.\r\n   * @param texture defines the internal texture to upload to\r\n   * @param imageData defines the array buffer views of image data [mipmap][face]\r\n   * @returns a promise\r\n   */\n\n\n  EnvironmentTextureTools.UploadLevelsAsync = function (texture, imageData) {\n    var _this = this;\n\n    if (!Tools.IsExponentOfTwo(texture.width)) {\n      throw new Error(\"Texture size must be a power of two\");\n    }\n\n    var mipmapsCount = Math.round(Scalar.Log2(texture.width)) + 1; // Gets everything ready.\n\n    var engine = texture.getEngine();\n    var expandTexture = false;\n    var generateNonLODTextures = false;\n    var rgbdPostProcess = null;\n    var cubeRtt = null;\n    var lodTextures = null;\n    var caps = engine.getCaps();\n    texture.format = 5;\n    texture.type = 0;\n    texture.generateMipMaps = true;\n    texture._cachedAnisotropicFilteringLevel = null;\n    engine.updateTextureSamplingMode(3, texture); // Add extra process if texture lod is not supported\n\n    if (!caps.textureLOD) {\n      expandTexture = false;\n      generateNonLODTextures = true;\n      lodTextures = {};\n    } // in webgl 1 there are no ways to either render or copy lod level information for float textures.\n    else if (engine.webGLVersion < 2) {\n      expandTexture = false;\n    } // If half float available we can uncompress the texture\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n      expandTexture = true;\n      texture.type = 2;\n    } // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n      expandTexture = true;\n      texture.type = 1;\n    } // Expand the texture if possible\n\n\n    if (expandTexture) {\n      // Simply run through the decode PP\n      rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false);\n      texture._isRGBD = false;\n      texture.invertY = false;\n      cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n        generateDepthBuffer: false,\n        generateMipMaps: true,\n        generateStencilBuffer: false,\n        samplingMode: 3,\n        type: texture.type,\n        format: 5\n      });\n    } else {\n      texture._isRGBD = true;\n      texture.invertY = true; // In case of missing support, applies the same patch than DDS files.\n\n      if (generateNonLODTextures) {\n        var mipSlices = 3;\n        var scale = texture._lodGenerationScale;\n        var offset = texture._lodGenerationOffset;\n\n        for (var i = 0; i < mipSlices; i++) {\n          //compute LOD from even spacing in smoothness (matching shader calculation)\n          var smoothness = i / (mipSlices - 1);\n          var roughness = 1 - smoothness;\n          var minLODIndex = offset; // roughness = 0\n\n          var maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n\n          var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n          var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n          var glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\n          glTextureFromLod.isCube = true;\n          glTextureFromLod.invertY = true;\n          glTextureFromLod.generateMipMaps = false;\n          engine.updateTextureSamplingMode(2, glTextureFromLod); // Wrap in a base texture for easy binding.\n\n          var lodTexture = new BaseTexture(null);\n          lodTexture.isCube = true;\n          lodTexture._texture = glTextureFromLod;\n          lodTextures[mipmapIndex] = lodTexture;\n\n          switch (i) {\n            case 0:\n              texture._lodTextureLow = lodTexture;\n              break;\n\n            case 1:\n              texture._lodTextureMid = lodTexture;\n              break;\n\n            case 2:\n              texture._lodTextureHigh = lodTexture;\n              break;\n          }\n        }\n      }\n    }\n\n    var promises = [];\n\n    var _loop_3 = function _loop_3(i) {\n      var _loop_4 = function _loop_4(face) {\n        // Constructs an image element from image data\n        var bytes = imageData[i][face];\n        var blob = new Blob([bytes], {\n          type: 'image/png'\n        });\n        var url = URL.createObjectURL(blob);\n        var promise = void 0;\n\n        if (typeof Image === \"undefined\") {\n          promise = createImageBitmap(blob).then(function (img) {\n            return _this._OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n          });\n        } else {\n          var image_1 = new Image();\n          image_1.src = url; // Enqueue promise to upload to the texture.\n\n          promise = new Promise(function (resolve, reject) {\n            image_1.onload = function () {\n              _this._OnImageReadyAsync(image_1, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(function () {\n                return resolve();\n              }).catch(function (reason) {\n                reject(reason);\n              });\n            };\n\n            image_1.onerror = function (error) {\n              reject(error);\n            };\n          });\n        }\n\n        promises.push(promise);\n      }; // All faces\n\n\n      for (var face = 0; face < 6; face++) {\n        _loop_4(face);\n      }\n    }; // All mipmaps up to provided number of images\n\n\n    for (var i = 0; i < imageData.length; i++) {\n      _loop_3(i);\n    } // Fill remaining mipmaps with black textures.\n\n\n    if (imageData.length < mipmapsCount) {\n      var data = void 0;\n      var size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n      var dataLength = size * size * 4;\n\n      switch (texture.type) {\n        case 0:\n          {\n            data = new Uint8Array(dataLength);\n            break;\n          }\n\n        case 2:\n          {\n            data = new Uint16Array(dataLength);\n            break;\n          }\n\n        case 1:\n          {\n            data = new Float32Array(dataLength);\n            break;\n          }\n      }\n\n      for (var i = imageData.length; i < mipmapsCount; i++) {\n        for (var face = 0; face < 6; face++) {\n          engine._uploadArrayBufferViewToTexture(texture, data, face, i);\n        }\n      }\n    } // Once all done, finishes the cleanup and return\n\n\n    return Promise.all(promises).then(function () {\n      // Release temp RTT.\n      if (cubeRtt) {\n        engine._releaseFramebufferObjects(cubeRtt);\n\n        engine._releaseTexture(texture);\n\n        cubeRtt._swapAndDie(texture);\n      } // Release temp Post Process.\n\n\n      if (rgbdPostProcess) {\n        rgbdPostProcess.dispose();\n      } // Flag internal texture as ready in case they are in use.\n\n\n      if (generateNonLODTextures) {\n        if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n          texture._lodTextureHigh._texture.isReady = true;\n        }\n\n        if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n          texture._lodTextureMid._texture.isReady = true;\n        }\n\n        if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n          texture._lodTextureLow._texture.isReady = true;\n        }\n      }\n    });\n  };\n  /**\r\n   * Uploads spherical polynomials information to the texture.\r\n   * @param texture defines the texture we are trying to upload the information to\r\n   * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n   */\n\n\n  EnvironmentTextureTools.UploadEnvSpherical = function (texture, info) {\n    if (info.version !== 1) {\n      Logger.Warn('Unsupported babylon environment map version \"' + info.version + '\"');\n    }\n\n    var irradianceInfo = info.irradiance;\n\n    if (!irradianceInfo) {\n      return;\n    }\n\n    var sp = new SphericalPolynomial();\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n    texture._sphericalPolynomial = sp;\n  };\n  /** @hidden */\n\n\n  EnvironmentTextureTools._UpdateRGBDAsync = function (internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\n    internalTexture._bufferViewArrayArray = data;\n    internalTexture._lodGenerationScale = lodScale;\n    internalTexture._lodGenerationOffset = lodOffset;\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\n    return EnvironmentTextureTools.UploadLevelsAsync(internalTexture, data).then(function () {\n      internalTexture.isReady = true;\n    });\n  };\n  /**\r\n   * Magic number identifying the env file.\r\n   */\n\n\n  EnvironmentTextureTools._MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n  return EnvironmentTextureTools;\n}();\n\nexport { EnvironmentTextureTools }; // References the dependencies.\n\nInternalTexture._UpdateRGBDAsync = EnvironmentTextureTools._UpdateRGBDAsync;","map":null,"metadata":{},"sourceType":"module"}