{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _templateObject, _templateObject2;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\n\nvar codegen_1 = require(\"./codegen\");\n\nvar error_classes_1 = require(\"./error_classes\");\n\nvar names_1 = require(\"./names\");\n\nvar resolve_1 = require(\"./resolve\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n\nvar URI = require(\"uri-js\");\n\nvar SchemaEnv = function SchemaEnv(env) {\n  _classCallCheck(this, SchemaEnv);\n\n  var _a;\n\n  this.refs = {};\n  this.dynamicAnchors = {};\n  var schema;\n  if (typeof env.schema == \"object\") schema = env.schema;\n  this.schema = env.schema;\n  this.root = env.root || this;\n  this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema === null || schema === void 0 ? void 0 : schema.$id);\n  this.localRefs = env.localRefs;\n  this.meta = env.meta;\n  this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n  this.refs = {};\n};\n\nexports.SchemaEnv = SchemaEnv; // let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\n\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  var _sch = getCompilingSchema.call(this, sch);\n\n  if (_sch) return _sch;\n  var rootId = resolve_1.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n\n  var _this$opts$code = this.opts.code,\n      es5 = _this$opts$code.es5,\n      lines = _this$opts$code.lines;\n  var ownProperties = this.opts.ownProperties;\n  var gen = new codegen_1.CodeGen(this.scope, {\n    es5: es5,\n    lines: lines,\n    ownProperties: ownProperties\n  });\n\n  var _ValidationError;\n\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: error_classes_1.ValidationError,\n      code: codegen_1._(_templateObject || (_templateObject = _taggedTemplateLiteral([\"require(\\\"ajv/dist/compile/error_classes\\\").ValidationError\"])))\n    });\n  }\n\n  var validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  var schemaCxt = {\n    gen: gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: codegen_1.stringify(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName: validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId: rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: this.opts.jtd ? \"\" : \"#\",\n    errorPath: codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\\"\\\"\"]))),\n    opts: this.opts,\n    self: this\n  };\n  var sourceCode;\n\n  try {\n    this._compilations.add(sch);\n\n    validate_1.validateFunctionCode(schemaCxt);\n    gen.optimize(this.opts.code.optimize); // gen.optimize(1)\n\n    var validateCode = gen.toString();\n    sourceCode = \"\".concat(gen.scopeRefs(names_1.default.scope), \"return \").concat(validateCode); // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch); // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n\n    var makeValidate = new Function(\"\".concat(names_1.default.self), \"\".concat(names_1.default.scope), sourceCode);\n    var validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName: validateName,\n        validateCode: validateCode,\n        scopeValues: gen._values\n      };\n    }\n\n    if (this.opts.unevaluated) {\n      var props = schemaCxt.props,\n          items = schemaCxt.items;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = codegen_1.stringify(validate.evaluated);\n    }\n\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode); // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\n\nexports.compileSchema = compileSchema;\n\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n\n  ref = resolve_1.resolveUrl(baseId, ref);\n  var schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n\n  var _sch = resolve.call(this, root, ref);\n\n  if (_sch === undefined) {\n    var schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n\n    if (schema) _sch = new SchemaEnv({\n      schema: schema,\n      root: root,\n      baseId: baseId\n    });\n  }\n\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\n\nexports.resolveRef = resolveRef;\n\nfunction inlineOrCompile(sch) {\n  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n} // Index of schema compilation in the currently compiled list\n\n\nfunction getCompilingSchema(schEnv) {\n  var _iterator = _createForOfIteratorHelper(this._compilations),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var sch = _step.value;\n      if (sameSchemaEnv(sch, schEnv)) return sch;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nexports.getCompilingSchema = getCompilingSchema;\n\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n} // resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\n\n\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n  var sch;\n\n  while (typeof (sch = this.refs[ref]) == \"string\") {\n    ref = sch;\n  }\n\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n} // Resolve schema, its root and baseId\n\n\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  var p = URI.parse(ref);\n\n  var refPath = resolve_1._getFullPath(p);\n\n  var baseId = resolve_1.getFullPath(root.baseId); // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n\n  var id = resolve_1.normalizeId(refPath);\n  var schOrRef = this.refs[id] || this.schemas[id];\n\n  if (typeof schOrRef == \"string\") {\n    var sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n\n  if (id === resolve_1.normalizeId(ref)) {\n    var schema = schOrRef.schema;\n    if (schema.$id) baseId = resolve_1.resolveUrl(baseId, schema.$id);\n    return new SchemaEnv({\n      schema: schema,\n      root: root,\n      baseId: baseId\n    });\n  }\n\n  return getJsonPointer.call(this, p, schOrRef);\n}\n\nexports.resolveSchema = resolveSchema;\nvar PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\n\nfunction getJsonPointer(parsedRef, _ref) {\n  var baseId = _ref.baseId,\n      schema = _ref.schema,\n      root = _ref.root;\n\n  var _a;\n\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n\n  var _iterator2 = _createForOfIteratorHelper(parsedRef.fragment.slice(1).split(\"/\")),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var part = _step2.value;\n      if (typeof schema == \"boolean\") return;\n      schema = schema[util_1.unescapeFragment(part)];\n      if (schema === undefined) return; // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n\n      if (!PREVENT_SCOPE_CHANGE.has(part) && typeof schema == \"object\" && schema.$id) {\n        baseId = resolve_1.resolveUrl(baseId, schema.$id);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var env;\n\n  if (typeof schema != \"boolean\" && schema.$ref && !util_1.schemaHasRulesButRef(schema, this.RULES)) {\n    var $ref = resolve_1.resolveUrl(baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  } // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n\n\n  env = env || new SchemaEnv({\n    schema: schema,\n    root: root,\n    baseId: baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"script"}