{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients\";\nimport { Observable } from \"../Misc/observable\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { Color4, TmpColors } from '../Maths/math.color';\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { Buffer } from \"../Meshes/buffer\";\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\nimport { ParticleSystem } from \"./particleSystem\";\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\nimport { Effect } from \"../Materials/effect\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { CustomParticleEmitter } from './EmitterTypes/customParticleEmitter';\nimport \"../Shaders/gpuUpdateParticles.fragment\";\nimport \"../Shaders/gpuUpdateParticles.vertex\";\nimport \"../Shaders/gpuRenderParticles.fragment\";\nimport \"../Shaders/gpuRenderParticles.vertex\";\n/**\r\n * This represents a GPU particle system in Babylon\r\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\r\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\r\n */\n\nvar GPUParticleSystem =\n/** @class */\nfunction (_super) {\n  __extends(GPUParticleSystem, _super);\n  /**\r\n   * Instantiates a GPU particle system.\r\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n   * @param name The name of the particle system\r\n   * @param options The options used to create the system\r\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n   * @param customEffect a custom effect used to change the way particles are rendered by default\r\n   */\n\n\n  function GPUParticleSystem(name, options, sceneOrEngine, isAnimationSheetEnabled, customEffect) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (customEffect === void 0) {\n      customEffect = null;\n    }\n\n    var _this = _super.call(this, name) || this;\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\n\n\n    _this.layerMask = 0x0FFFFFFF;\n    _this._accumulatedCount = 0;\n    _this._targetIndex = 0;\n    _this._currentRenderId = -1;\n    _this._started = false;\n    _this._stopped = false;\n    _this._timeDelta = 0;\n    _this._actualFrame = 0;\n    _this._rawTextureWidth = 256;\n    /**\r\n    * An event triggered when the system is disposed.\r\n    */\n\n    _this.onDisposeObservable = new Observable();\n    /**\r\n    * An event triggered when the system is stopped\r\n    */\n\n    _this.onStoppedObservable = new Observable();\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\n\n    _this.forceDepthWrite = false;\n    _this._preWarmDone = false;\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space.\r\n     */\n\n    _this.isLocal = false;\n    /** @hidden */\n\n    _this._onBeforeDrawParticlesObservable = null;\n\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      _this._engine = _this._scene.getEngine();\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.particleSystems.push(_this);\n    } else {\n      _this._engine = sceneOrEngine;\n      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100);\n    }\n\n    _this._customEffect = {\n      0: customEffect\n    }; // Setup the default processing configuration to the scene.\n\n    _this._attachImageProcessingConfiguration(null);\n\n    if (!options.randomTextureSize) {\n      delete options.randomTextureSize;\n    }\n\n    var fullOptions = __assign({\n      capacity: 50000,\n      randomTextureSize: _this._engine.getCaps().maxTextureSize\n    }, options);\n\n    var optionsAsNumber = options;\n\n    if (isFinite(optionsAsNumber)) {\n      fullOptions.capacity = optionsAsNumber;\n    }\n\n    _this._capacity = fullOptions.capacity;\n    _this._activeCount = fullOptions.capacity;\n    _this._currentActiveCount = 0;\n    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n    _this._updateEffectOptions = {\n      attributes: [\"position\", \"initialPosition\", \"age\", \"life\", \"seed\", \"size\", \"color\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\", \"cellStartOffset\", \"noiseCoordinates1\", \"noiseCoordinates2\"],\n      uniformsNames: [\"currentCount\", \"timeDelta\", \"emitterWM\", \"lifeTime\", \"color1\", \"color2\", \"sizeRange\", \"scaleRange\", \"gravity\", \"emitPower\", \"direction1\", \"direction2\", \"minEmitBox\", \"maxEmitBox\", \"radius\", \"directionRandomizer\", \"height\", \"coneAngle\", \"stopFactor\", \"angleRange\", \"radiusRange\", \"cellInfos\", \"noiseStrength\", \"limitVelocityDamping\"],\n      uniformBuffersNames: [],\n      samplers: [\"randomSampler\", \"randomSampler2\", \"sizeGradientSampler\", \"angularSpeedGradientSampler\", \"velocityGradientSampler\", \"limitVelocityGradientSampler\", \"noiseSampler\", \"dragGradientSampler\"],\n      defines: \"\",\n      fallbacks: null,\n      onCompiled: null,\n      onError: null,\n      indexParameters: null,\n      maxSimultaneousLights: 0,\n      transformFeedbackVaryings: []\n    };\n    _this.particleEmitterType = new BoxParticleEmitter(); // Random data\n\n    var maxTextureSize = Math.min(_this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\n    var d = [];\n\n    for (var i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n\n    _this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    _this._randomTexture.wrapU = 1;\n    _this._randomTexture.wrapV = 1;\n    d = [];\n\n    for (var i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n\n    _this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    _this._randomTexture2.wrapU = 1;\n    _this._randomTexture2.wrapV = 1;\n    _this._randomTextureSize = maxTextureSize;\n    return _this;\n  }\n\n  Object.defineProperty(GPUParticleSystem, \"IsSupported\", {\n    /**\r\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\r\n     */\n    get: function get() {\n      if (!EngineStore.LastCreatedEngine) {\n        return false;\n      }\n\n      return EngineStore.LastCreatedEngine.webGLVersion > 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the maximum number of particles active at the same time.\r\n   * @returns The max number of active particles.\r\n   */\n\n  GPUParticleSystem.prototype.getCapacity = function () {\n    return this._capacity;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"activeParticleCount\", {\n    /**\r\n     * Gets or set the number of active particles\r\n     */\n    get: function get() {\n      return this._activeCount;\n    },\n    set: function set(value) {\n      this._activeCount = Math.min(value, this._capacity);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Is this system ready to be used/rendered\r\n   * @return true if the system is ready\r\n   */\n\n  GPUParticleSystem.prototype.isReady = function () {\n    if (!this._updateEffect) {\n      this._recreateUpdateEffect();\n\n      this._recreateRenderEffect();\n\n      return false;\n    }\n\n    if (!this.emitter || !this._updateEffect.isReady() || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this._getEffect().isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n   * @returns True if it has been started, otherwise false.\r\n   */\n\n\n  GPUParticleSystem.prototype.isStarted = function () {\n    return this._started;\n  };\n  /**\r\n   * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\r\n   * @returns True if it has been stopped, otherwise false.\r\n   */\n\n\n  GPUParticleSystem.prototype.isStopped = function () {\n    return this._stopped;\n  };\n  /**\r\n   * Gets a boolean indicating that the system is stopping\r\n   * @returns true if the system is currently stopping\r\n   */\n\n\n  GPUParticleSystem.prototype.isStopping = function () {\n    return false; // Stop is immediate on GPU\n  };\n  /**\r\n   * Gets the number of particles active at the same time.\r\n   * @returns The number of active particles.\r\n   */\n\n\n  GPUParticleSystem.prototype.getActiveCount = function () {\n    return this._currentActiveCount;\n  };\n  /**\r\n   * Starts the particle system and begins to emit\r\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n   */\n\n\n  GPUParticleSystem.prototype.start = function (delay) {\n    var _this = this;\n\n    if (delay === void 0) {\n      delay = this.startDelay;\n    }\n\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n\n    if (delay) {\n      setTimeout(function () {\n        _this.start(0);\n      }, delay);\n      return;\n    }\n\n    this._started = true;\n    this._stopped = false;\n    this._preWarmDone = false; // Animations\n\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  };\n  /**\r\n   * Stops the particle system.\r\n   */\n\n\n  GPUParticleSystem.prototype.stop = function () {\n    if (this._stopped) {\n      return;\n    }\n\n    this._stopped = true;\n  };\n  /**\r\n   * Remove all active particles\r\n   */\n\n\n  GPUParticleSystem.prototype.reset = function () {\n    this._releaseBuffers();\n\n    this._releaseVAOs();\n\n    this._currentActiveCount = 0;\n    this._targetIndex = 0;\n  };\n  /**\r\n   * Returns the string \"GPUParticleSystem\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  GPUParticleSystem.prototype.getClassName = function () {\n    return \"GPUParticleSystem\";\n  };\n  /**\r\n   * Gets the custom effect used to render the particles\r\n   * @param blendMode Blend mode for which the effect should be retrieved\r\n   * @returns The effect\r\n   */\n\n\n  GPUParticleSystem.prototype.getCustomEffect = function (blendMode) {\n    var _a;\n\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    return (_a = this._customEffect[blendMode]) !== null && _a !== void 0 ? _a : this._customEffect[0];\n  };\n  /**\r\n   * Sets the custom effect used to render the particles\r\n   * @param effect The effect to set\r\n   * @param blendMode Blend mode for which the effect should be set\r\n   */\n\n\n  GPUParticleSystem.prototype.setCustomEffect = function (effect, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    this._customEffect[blendMode] = effect;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"onBeforeDrawParticlesObservable\", {\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\n    get: function get() {\n      if (!this._onBeforeDrawParticlesObservable) {\n        this._onBeforeDrawParticlesObservable = new Observable();\n      }\n\n      return this._onBeforeDrawParticlesObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GPUParticleSystem.prototype, \"vertexShaderName\", {\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\n    get: function get() {\n      return \"gpuRenderParticles\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  GPUParticleSystem.prototype._removeGradientAndTexture = function (gradient, gradients, texture) {\n    _super.prototype._removeGradientAndTexture.call(this, gradient, gradients, texture);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Adds a new color gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param color1 defines the color to affect to the specified gradient\r\n   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addColorGradient = function (gradient, color1, color2) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n\n    var colorGradient = new ColorGradient(gradient, color1);\n\n    this._colorGradients.push(colorGradient);\n\n    this._refreshColorGradient(true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n\n  GPUParticleSystem.prototype._refreshColorGradient = function (reorder) {\n    if (reorder === void 0) {\n      reorder = false;\n    }\n\n    if (this._colorGradients) {\n      if (reorder) {\n        this._colorGradients.sort(function (a, b) {\n          if (a.gradient < b.gradient) {\n            return -1;\n          } else if (a.gradient > b.gradient) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      if (this._colorGradientsTexture) {\n        this._colorGradientsTexture.dispose();\n\n        this._colorGradientsTexture = null;\n      }\n    }\n  };\n  /** Force the system to rebuild all gradients that need to be resync */\n\n\n  GPUParticleSystem.prototype.forceRefreshGradients = function () {\n    this._refreshColorGradient();\n\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\n\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\n\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\n\n    this.reset();\n  };\n  /**\r\n   * Remove a specific color gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeColorGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\n\n    this._colorGradientsTexture = null;\n    return this;\n  };\n\n  GPUParticleSystem.prototype._addFactorGradient = function (factorGradients, gradient, factor) {\n    var valueGradient = new FactorGradient(gradient, factor);\n    factorGradients.push(valueGradient);\n\n    this._releaseBuffers();\n  };\n  /**\r\n   * Adds a new size gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the size factor to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addSizeGradient = function (gradient, factor) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n\n    this._addFactorGradient(this._sizeGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific size gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeSizeGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\n\n    this._sizeGradientsTexture = null;\n    return this;\n  };\n\n  GPUParticleSystem.prototype._refreshFactorGradient = function (factorGradients, textureName, reorder) {\n    if (reorder === void 0) {\n      reorder = false;\n    }\n\n    if (!factorGradients) {\n      return;\n    }\n\n    if (reorder) {\n      factorGradients.sort(function (a, b) {\n        if (a.gradient < b.gradient) {\n          return -1;\n        } else if (a.gradient > b.gradient) {\n          return 1;\n        }\n\n        return 0;\n      });\n    }\n\n    var that = this;\n\n    if (that[textureName]) {\n      that[textureName].dispose();\n      that[textureName] = null;\n    }\n  };\n  /**\r\n   * Adds a new angular speed gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the angular speed to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addAngularSpeedGradient = function (gradient, factor) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific angular speed gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeAngularSpeedGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\n\n    this._angularSpeedGradientsTexture = null;\n    return this;\n  };\n  /**\r\n   * Adds a new velocity gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the velocity to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addVelocityGradient = function (gradient, factor) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n\n    this._addFactorGradient(this._velocityGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific velocity gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeVelocityGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\n\n    this._velocityGradientsTexture = null;\n    return this;\n  };\n  /**\r\n   * Adds a new limit velocity gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the limit velocity value to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addLimitVelocityGradient = function (gradient, factor) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific limit velocity gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeLimitVelocityGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\n\n    this._limitVelocityGradientsTexture = null;\n    return this;\n  };\n  /**\r\n   * Adds a new drag gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the drag value to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addDragGradient = function (gradient, factor) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n\n    this._addFactorGradient(this._dragGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific drag gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeDragGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\n\n    this._dragGradientsTexture = null;\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the emit rate value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addEmitRateGradient = function (gradient, factor, factor2) {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeEmitRateGradient = function (gradient) {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the start size value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addStartSizeGradient = function (gradient, factor, factor2) {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeStartSizeGradient = function (gradient) {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param min defines the color remap minimal range\r\n   * @param max defines the color remap maximal range\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addColorRemapGradient = function (gradient, min, max) {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeColorRemapGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param min defines the alpha remap minimal range\r\n   * @param max defines the alpha remap maximal range\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addAlphaRemapGradient = function (gradient, min, max) {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeAlphaRemapGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param color defines the color to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addRampGradient = function (gradient, color) {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeRampGradient = function () {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @returns the list of ramp gradients\r\n   */\n\n\n  GPUParticleSystem.prototype.getRampGradients = function () {\n    return null;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"useRampGradients\", {\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\r\n     */\n    get: function get() {\n      //Not supported by GPUParticleSystem\n      return false;\n    },\n    set: function set(value) {//Not supported by GPUParticleSystem\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the life time factor to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n  GPUParticleSystem.prototype.addLifeTimeGradient = function (gradient, factor, factor2) {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeLifeTimeGradient = function (gradient) {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n\n  GPUParticleSystem.prototype._reset = function () {\n    this._releaseBuffers();\n  };\n\n  GPUParticleSystem.prototype._createUpdateVAO = function (source) {\n    var updateVertexBuffers = {};\n    updateVertexBuffers[\"position\"] = source.createVertexBuffer(\"position\", 0, 3);\n    var offset = 3;\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      updateVertexBuffers[\"initialPosition\"] = source.createVertexBuffer(\"initialPosition\", offset, 3);\n      offset += 3;\n    }\n\n    updateVertexBuffers[\"age\"] = source.createVertexBuffer(\"age\", offset, 1);\n    offset += 1;\n    updateVertexBuffers[\"life\"] = source.createVertexBuffer(\"life\", offset, 1);\n    offset += 1;\n    updateVertexBuffers[\"seed\"] = source.createVertexBuffer(\"seed\", offset, 4);\n    offset += 4;\n    updateVertexBuffers[\"size\"] = source.createVertexBuffer(\"size\", offset, 3);\n    offset += 3;\n\n    if (!this._colorGradientsTexture) {\n      updateVertexBuffers[\"color\"] = source.createVertexBuffer(\"color\", offset, 4);\n      offset += 4;\n    }\n\n    updateVertexBuffers[\"direction\"] = source.createVertexBuffer(\"direction\", offset, 3);\n    offset += 3;\n\n    if (!this._isBillboardBased) {\n      updateVertexBuffers[\"initialDirection\"] = source.createVertexBuffer(\"initialDirection\", offset, 3);\n      offset += 3;\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 1);\n      offset += 1;\n    } else {\n      updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 2);\n      offset += 2;\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      updateVertexBuffers[\"cellIndex\"] = source.createVertexBuffer(\"cellIndex\", offset, 1);\n      offset += 1;\n\n      if (this.spriteRandomStartCell) {\n        updateVertexBuffers[\"cellStartOffset\"] = source.createVertexBuffer(\"cellStartOffset\", offset, 1);\n        offset += 1;\n      }\n    }\n\n    if (this.noiseTexture) {\n      updateVertexBuffers[\"noiseCoordinates1\"] = source.createVertexBuffer(\"noiseCoordinates1\", offset, 3);\n      offset += 3;\n      updateVertexBuffers[\"noiseCoordinates2\"] = source.createVertexBuffer(\"noiseCoordinates2\", offset, 3);\n      offset += 3;\n    }\n\n    var vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);\n\n    this._engine.bindArrayBuffer(null);\n\n    return vao;\n  };\n\n  GPUParticleSystem.prototype._createRenderVAO = function (source, spriteSource) {\n    var renderVertexBuffers = {};\n    renderVertexBuffers[\"position\"] = source.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\n    var offset = 3;\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      offset += 3;\n    }\n\n    renderVertexBuffers[\"age\"] = source.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\n    offset += 1;\n    renderVertexBuffers[\"life\"] = source.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\n    offset += 5;\n    renderVertexBuffers[\"size\"] = source.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\n    offset += 3;\n\n    if (!this._colorGradientsTexture) {\n      renderVertexBuffers[\"color\"] = source.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\n      offset += 4;\n    }\n\n    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      renderVertexBuffers[\"direction\"] = source.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\n    }\n\n    offset += 3; // Direction\n\n    if (!this._isBillboardBased) {\n      renderVertexBuffers[\"initialDirection\"] = source.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n    }\n\n    renderVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\n\n    if (this._angularSpeedGradientsTexture) {\n      offset++;\n    } else {\n      offset += 2;\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      renderVertexBuffers[\"cellIndex\"] = source.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\n      offset += 1;\n\n      if (this.spriteRandomStartCell) {\n        renderVertexBuffers[\"cellStartOffset\"] = source.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\n        offset += 1;\n      }\n    }\n\n    if (this.noiseTexture) {\n      renderVertexBuffers[\"noiseCoordinates1\"] = source.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n      renderVertexBuffers[\"noiseCoordinates2\"] = source.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n    }\n\n    renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\n    renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\n\n    var vao = this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._getEffect());\n\n    this._engine.bindArrayBuffer(null);\n\n    return vao;\n  };\n\n  GPUParticleSystem.prototype._initialize = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (this._buffer0 && !force) {\n      return;\n    }\n\n    var engine = this._engine;\n    var data = new Array();\n    this._attributesStrideSize = 21;\n    this._targetIndex = 0;\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      this._attributesStrideSize += 3;\n    }\n\n    if (!this.isBillboardBased) {\n      this._attributesStrideSize += 3;\n    }\n\n    if (this._colorGradientsTexture) {\n      this._attributesStrideSize -= 4;\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      this._attributesStrideSize -= 1;\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      this._attributesStrideSize += 1;\n\n      if (this.spriteRandomStartCell) {\n        this._attributesStrideSize += 1;\n      }\n    }\n\n    if (this.noiseTexture) {\n      this._attributesStrideSize += 6;\n    }\n\n    var usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\n    var tmpVector = TmpVectors.Vector3[0];\n\n    for (var particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\n      // position\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0);\n\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n      } // Age and life\n\n\n      data.push(0.0); // create the particle as a dead one to create a new one at start\n\n      data.push(0.0); // Seed\n\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random()); // Size\n\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0);\n\n      if (!this._colorGradientsTexture) {\n        // color\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      } // direction\n\n\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n      } else {\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      }\n\n      if (!this.isBillboardBased) {\n        // initialDirection\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      } // angle\n\n\n      data.push(0.0);\n\n      if (!this._angularSpeedGradientsTexture) {\n        data.push(0.0);\n      }\n\n      if (this._isAnimationSheetEnabled) {\n        data.push(0.0);\n\n        if (this.spriteRandomStartCell) {\n          data.push(0.0);\n        }\n      }\n\n      if (this.noiseTexture) {\n        // Random coordinates for reading into noise texture\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n      }\n    } // Sprite data\n\n\n    var spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, -0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0]); // Buffers\n\n    this._buffer0 = new Buffer(engine, data, false, this._attributesStrideSize);\n    this._buffer1 = new Buffer(engine, data, false, this._attributesStrideSize);\n    this._spriteBuffer = new Buffer(engine, spriteData, false, 4); // Update VAO\n\n    this._updateVAO = [];\n\n    this._updateVAO.push(this._createUpdateVAO(this._buffer0));\n\n    this._updateVAO.push(this._createUpdateVAO(this._buffer1)); // Render VAO\n\n\n    this._renderVAO = [];\n\n    this._renderVAO.push(this._createRenderVAO(this._buffer1, this._spriteBuffer));\n\n    this._renderVAO.push(this._createRenderVAO(this._buffer0, this._spriteBuffer)); // Links\n\n\n    this._sourceBuffer = this._buffer0;\n    this._targetBuffer = this._buffer1;\n  };\n  /** @hidden */\n\n\n  GPUParticleSystem.prototype._recreateUpdateEffect = function () {\n    var defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\n\n    if (this._isBillboardBased) {\n      defines += \"\\n#define BILLBOARD\";\n    }\n\n    if (this._colorGradientsTexture) {\n      defines += \"\\n#define COLORGRADIENTS\";\n    }\n\n    if (this._sizeGradientsTexture) {\n      defines += \"\\n#define SIZEGRADIENTS\";\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\n    }\n\n    if (this._velocityGradientsTexture) {\n      defines += \"\\n#define VELOCITYGRADIENTS\";\n    }\n\n    if (this._limitVelocityGradientsTexture) {\n      defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\n    }\n\n    if (this._dragGradientsTexture) {\n      defines += \"\\n#define DRAGGRADIENTS\";\n    }\n\n    if (this.isAnimationSheetEnabled) {\n      defines += \"\\n#define ANIMATESHEET\";\n\n      if (this.spriteRandomStartCell) {\n        defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\n      }\n    }\n\n    if (this.noiseTexture) {\n      defines += \"\\n#define NOISE\";\n    }\n\n    if (this.isLocal) {\n      defines += \"\\n#define LOCAL\";\n    }\n\n    if (this._updateEffect && this._updateEffectOptions.defines === defines) {\n      return;\n    }\n\n    this._updateEffectOptions.transformFeedbackVaryings = [\"outPosition\"];\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialPosition\");\n    }\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outAge\");\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outLife\");\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outSeed\");\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outSize\");\n\n    if (!this._colorGradientsTexture) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outColor\");\n    }\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outDirection\");\n\n    if (!this._isBillboardBased) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialDirection\");\n    }\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outAngle\");\n\n    if (this.isAnimationSheetEnabled) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellIndex\");\n\n      if (this.spriteRandomStartCell) {\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellStartOffset\");\n      }\n    }\n\n    if (this.noiseTexture) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates1\");\n\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates2\");\n    }\n\n    this._updateEffectOptions.defines = defines;\n    this._updateEffect = new Effect(\"gpuUpdateParticles\", this._updateEffectOptions, this._engine);\n  };\n\n  GPUParticleSystem.prototype._getEffect = function () {\n    var _a;\n\n    return (_a = this.getCustomEffect()) !== null && _a !== void 0 ? _a : this._renderEffect;\n  };\n  /**\r\n   * Fill the defines array according to the current settings of the particle system\r\n   * @param defines Array to be updated\r\n   * @param blendMode blend mode to take into account when updating the array\r\n   */\n\n\n  GPUParticleSystem.prototype.fillDefines = function (defines, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    if (this._scene) {\n      if (this._scene.clipPlane) {\n        defines.push(\"#define CLIPPLANE\");\n      }\n\n      if (this._scene.clipPlane2) {\n        defines.push(\"#define CLIPPLANE2\");\n      }\n\n      if (this._scene.clipPlane3) {\n        defines.push(\"#define CLIPPLANE3\");\n      }\n\n      if (this._scene.clipPlane4) {\n        defines.push(\"#define CLIPPLANE4\");\n      }\n\n      if (this._scene.clipPlane5) {\n        defines.push(\"#define CLIPPLANE5\");\n      }\n\n      if (this._scene.clipPlane6) {\n        defines.push(\"#define CLIPPLANE6\");\n      }\n    }\n\n    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n\n    if (this.isLocal) {\n      defines.push(\"#define LOCAL\");\n    }\n\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (this._colorGradientsTexture) {\n      defines.push(\"#define COLORGRADIENTS\");\n    }\n\n    if (this.isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n\n      defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\n    }\n  };\n  /**\r\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n   * @param uniforms Uniforms array to fill\r\n   * @param attributes Attributes array to fill\r\n   * @param samplers Samplers array to fill\r\n   */\n\n\n  GPUParticleSystem.prototype.fillUniformsAttributesAndSamplerNames = function (uniforms, attributes, samplers) {\n    attributes.push(\"position\", \"age\", \"life\", \"size\", \"color\", \"offset\", \"uv\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\");\n    uniforms.push(\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"sheetInfos\", \"translationPivot\", \"eyePosition\");\n    samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\n\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  };\n  /** @hidden */\n\n\n  GPUParticleSystem.prototype._recreateRenderEffect = function () {\n    var customEffect = this.getCustomEffect();\n\n    if (customEffect) {\n      return customEffect;\n    }\n\n    var defines = [];\n    this.fillDefines(defines);\n    var join = defines.join(\"\\n\");\n\n    if (this._renderEffect && this._renderEffect.defines === join) {\n      return this._renderEffect;\n    }\n\n    var attributes = [];\n    var uniforms = [];\n    var samplers = [];\n    this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\n    this._renderEffect = new Effect(\"gpuRenderParticles\", attributes, uniforms, samplers, this._engine, join);\n    return this._renderEffect;\n  };\n  /**\r\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n   * @param preWarm defines if we are in the pre-warmimg phase\r\n   */\n\n\n  GPUParticleSystem.prototype.animate = function (preWarm) {\n    var _a;\n\n    if (preWarm === void 0) {\n      preWarm = false;\n    }\n\n    this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);\n    this._actualFrame += this._timeDelta;\n\n    if (!this._stopped) {\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    }\n  };\n\n  GPUParticleSystem.prototype._createFactorGradientTexture = function (factorGradients, textureName) {\n    var texture = this[textureName];\n\n    if (!factorGradients || !factorGradients.length || texture) {\n      return;\n    }\n\n    var data = new Float32Array(this._rawTextureWidth);\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      var ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, factorGradients, function (currentGradient, nextGradient, scale) {\n        data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n      });\n    }\n\n    this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);\n  };\n\n  GPUParticleSystem.prototype._createSizeGradientTexture = function () {\n    this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createAngularSpeedGradientTexture = function () {\n    this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createVelocityGradientTexture = function () {\n    this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createLimitVelocityGradientTexture = function () {\n    this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createDragGradientTexture = function () {\n    this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createColorGradientTexture = function () {\n    if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\n      return;\n    }\n\n    var data = new Uint8Array(this._rawTextureWidth * 4);\n    var tmpColor = TmpColors.Color4[0];\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      var ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._colorGradients, function (currentGradient, nextGradient, scale) {\n        Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = tmpColor.a * 255;\n      });\n    }\n\n    this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  };\n  /**\r\n   * Renders the particle system in its current state\r\n   * @param preWarm defines if the system should only update the particles but not render them\r\n   * @returns the current number of particles\r\n   */\n\n\n  GPUParticleSystem.prototype.render = function (preWarm) {\n    var _a, _b;\n\n    if (preWarm === void 0) {\n      preWarm = false;\n    }\n\n    if (!this._started) {\n      return 0;\n    }\n\n    this._createColorGradientTexture();\n\n    this._createSizeGradientTexture();\n\n    this._createAngularSpeedGradientTexture();\n\n    this._createVelocityGradientTexture();\n\n    this._createLimitVelocityGradientTexture();\n\n    this._createDragGradientTexture();\n\n    this._recreateUpdateEffect();\n\n    this._recreateRenderEffect();\n\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    if (!preWarm && this._scene) {\n      if (!this._preWarmDone && this.preWarmCycles) {\n        for (var index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n          this.render(true);\n        }\n\n        this._preWarmDone = true;\n      }\n\n      if (this._currentRenderId === this._scene.getFrameId()) {\n        return 0;\n      }\n\n      this._currentRenderId = this._scene.getFrameId();\n    } // Get everything ready to render\n\n\n    this._initialize();\n\n    this._accumulatedCount += this.emitRate * this._timeDelta;\n\n    if (this._accumulatedCount > 1) {\n      var intPart = this._accumulatedCount | 0;\n      this._accumulatedCount -= intPart;\n      this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);\n    }\n\n    if (!this._currentActiveCount) {\n      return 0;\n    } // Enable update effect\n\n\n    this._engine.enableEffect(this._updateEffect);\n\n    var engine = this._engine;\n\n    if (!engine.setState) {\n      throw new Error(\"GPU particles cannot work with a full Engine. ThinEngine is not supported\");\n    }\n\n    this._updateEffect.setFloat(\"currentCount\", this._currentActiveCount);\n\n    this._updateEffect.setFloat(\"timeDelta\", this._timeDelta);\n\n    this._updateEffect.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\n\n    this._updateEffect.setTexture(\"randomSampler\", this._randomTexture);\n\n    this._updateEffect.setTexture(\"randomSampler2\", this._randomTexture2);\n\n    this._updateEffect.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\n\n    this._updateEffect.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\n\n    if (!this._colorGradientsTexture) {\n      this._updateEffect.setDirectColor4(\"color1\", this.color1);\n\n      this._updateEffect.setDirectColor4(\"color2\", this.color2);\n    }\n\n    this._updateEffect.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\n\n    this._updateEffect.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\n\n    this._updateEffect.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\n\n    this._updateEffect.setVector3(\"gravity\", this.gravity);\n\n    if (this._sizeGradientsTexture) {\n      this._updateEffect.setTexture(\"sizeGradientSampler\", this._sizeGradientsTexture);\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      this._updateEffect.setTexture(\"angularSpeedGradientSampler\", this._angularSpeedGradientsTexture);\n    }\n\n    if (this._velocityGradientsTexture) {\n      this._updateEffect.setTexture(\"velocityGradientSampler\", this._velocityGradientsTexture);\n    }\n\n    if (this._limitVelocityGradientsTexture) {\n      this._updateEffect.setTexture(\"limitVelocityGradientSampler\", this._limitVelocityGradientsTexture);\n\n      this._updateEffect.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\n    }\n\n    if (this._dragGradientsTexture) {\n      this._updateEffect.setTexture(\"dragGradientSampler\", this._dragGradientsTexture);\n    }\n\n    if (this.particleEmitterType) {\n      this.particleEmitterType.applyToShader(this._updateEffect);\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      this._updateEffect.setFloat3(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed);\n    }\n\n    if (this.noiseTexture) {\n      this._updateEffect.setTexture(\"noiseSampler\", this.noiseTexture);\n\n      this._updateEffect.setVector3(\"noiseStrength\", this.noiseStrength);\n    }\n\n    var emitterWM;\n\n    if (this.emitter.position) {\n      var emitterMesh = this.emitter;\n      emitterWM = emitterMesh.getWorldMatrix();\n    } else {\n      var emitterPosition = this.emitter;\n      emitterWM = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n\n    if (!this.isLocal) {\n      this._updateEffect.setMatrix(\"emitterWM\", emitterWM);\n    } // Bind source VAO\n\n\n    this._engine.bindVertexArrayObject(this._updateVAO[this._targetIndex], null); // Update\n\n\n    engine.bindTransformFeedbackBuffer(this._targetBuffer.getBuffer());\n    engine.setRasterizerState(false);\n    engine.beginTransformFeedback(true);\n    engine.drawArraysType(3, 0, this._currentActiveCount);\n    engine.endTransformFeedback();\n    engine.setRasterizerState(true);\n    engine.bindTransformFeedbackBuffer(null);\n\n    if (!preWarm) {\n      // Enable render effect\n      var effect = this._getEffect();\n\n      this._engine.enableEffect(effect);\n\n      var viewMatrix = ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getViewMatrix()) || Matrix.IdentityReadOnly;\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n      effect.setTexture(\"diffuseSampler\", this.particleTexture);\n      effect.setVector2(\"translationPivot\", this.translationPivot);\n      effect.setVector3(\"worldOffset\", this.worldOffset);\n\n      if (this.isLocal) {\n        effect.setMatrix(\"emitterWM\", emitterWM);\n      }\n\n      if (this._colorGradientsTexture) {\n        effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\n      } else {\n        effect.setDirectColor4(\"colorDead\", this.colorDead);\n      }\n\n      if (this._isAnimationSheetEnabled && this.particleTexture) {\n        var baseSize = this.particleTexture.getBaseSize();\n        effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\n      }\n\n      if (this._isBillboardBased && this._scene) {\n        var camera = this._scene.activeCamera;\n        effect.setVector3(\"eyePosition\", camera.globalPosition);\n      }\n\n      var defines = effect.defines;\n\n      if (this._scene) {\n        if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\n          MaterialHelper.BindClipPlane(effect, this._scene);\n        }\n      }\n\n      if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n        var invView = viewMatrix.clone();\n        invView.invert();\n        effect.setMatrix(\"invView\", invView);\n      } // image processing\n\n\n      if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n        this._imageProcessingConfiguration.bind(effect);\n      } // Draw order\n\n\n      switch (this.blendMode) {\n        case ParticleSystem.BLENDMODE_ADD:\n          this._engine.setAlphaMode(1);\n\n          break;\n\n        case ParticleSystem.BLENDMODE_ONEONE:\n          this._engine.setAlphaMode(6);\n\n          break;\n\n        case ParticleSystem.BLENDMODE_STANDARD:\n          this._engine.setAlphaMode(2);\n\n          break;\n\n        case ParticleSystem.BLENDMODE_MULTIPLY:\n          this._engine.setAlphaMode(4);\n\n          break;\n      }\n\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      } // Bind source VAO\n\n\n      this._engine.bindVertexArrayObject(this._renderVAO[this._targetIndex], null);\n\n      if (this._onBeforeDrawParticlesObservable) {\n        this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n      } // Render\n\n\n      this._engine.drawArraysType(8, 0, 4, this._currentActiveCount);\n\n      this._engine.setAlphaMode(0);\n    } // Switch VAOs\n\n\n    this._targetIndex++;\n\n    if (this._targetIndex === 2) {\n      this._targetIndex = 0;\n    } // Switch buffers\n\n\n    var tmpBuffer = this._sourceBuffer;\n    this._sourceBuffer = this._targetBuffer;\n    this._targetBuffer = tmpBuffer;\n    return this._currentActiveCount;\n  };\n  /**\r\n   * Rebuilds the particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.rebuild = function () {\n    this._initialize(true);\n  };\n\n  GPUParticleSystem.prototype._releaseBuffers = function () {\n    if (this._buffer0) {\n      this._buffer0.dispose();\n\n      this._buffer0 = null;\n    }\n\n    if (this._buffer1) {\n      this._buffer1.dispose();\n\n      this._buffer1 = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n  };\n\n  GPUParticleSystem.prototype._releaseVAOs = function () {\n    if (!this._updateVAO) {\n      return;\n    }\n\n    for (var index = 0; index < this._updateVAO.length; index++) {\n      this._engine.releaseVertexArrayObject(this._updateVAO[index]);\n    }\n\n    this._updateVAO = [];\n\n    for (var index = 0; index < this._renderVAO.length; index++) {\n      this._engine.releaseVertexArrayObject(this._renderVAO[index]);\n    }\n\n    this._renderVAO = [];\n  };\n  /**\r\n   * Disposes the particle system and free the associated resources\r\n   * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n   */\n\n\n  GPUParticleSystem.prototype.dispose = function (disposeTexture) {\n    if (disposeTexture === void 0) {\n      disposeTexture = true;\n    }\n\n    if (this._scene) {\n      var index = this._scene.particleSystems.indexOf(this);\n\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n    }\n\n    this._releaseBuffers();\n\n    this._releaseVAOs();\n\n    if (this._colorGradientsTexture) {\n      this._colorGradientsTexture.dispose();\n\n      this._colorGradientsTexture = null;\n    }\n\n    if (this._sizeGradientsTexture) {\n      this._sizeGradientsTexture.dispose();\n\n      this._sizeGradientsTexture = null;\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      this._angularSpeedGradientsTexture.dispose();\n\n      this._angularSpeedGradientsTexture = null;\n    }\n\n    if (this._velocityGradientsTexture) {\n      this._velocityGradientsTexture.dispose();\n\n      this._velocityGradientsTexture = null;\n    }\n\n    if (this._limitVelocityGradientsTexture) {\n      this._limitVelocityGradientsTexture.dispose();\n\n      this._limitVelocityGradientsTexture = null;\n    }\n\n    if (this._dragGradientsTexture) {\n      this._dragGradientsTexture.dispose();\n\n      this._dragGradientsTexture = null;\n    }\n\n    if (this._randomTexture) {\n      this._randomTexture.dispose();\n\n      this._randomTexture = null;\n    }\n\n    if (this._randomTexture2) {\n      this._randomTexture2.dispose();\n\n      this._randomTexture2 = null;\n    }\n\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    } // Callback\n\n\n    this.onStoppedObservable.clear();\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  };\n  /**\r\n   * Clones the particle system.\r\n   * @param name The name of the cloned object\r\n   * @param newEmitter The new emitter to use\r\n   * @returns the cloned particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.clone = function (name, newEmitter) {\n    var serialization = this.serialize();\n    var result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, \"\");\n\n    var custom = __assign({}, this._customEffect);\n\n    result.name = name;\n    result._customEffect = custom;\n\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n\n    result.emitter = newEmitter;\n    result.noiseTexture = this.noiseTexture;\n    return result;\n  };\n  /**\r\n   * Serializes the particle system to a JSON object\r\n   * @param serializeTexture defines if the texture must be serialized as well\r\n   * @returns the JSON object\r\n   */\n\n\n  GPUParticleSystem.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n\n    serializationObject.activeParticleCount = this.activeParticleCount;\n    serializationObject.randomTextureSize = this._randomTextureSize;\n    return serializationObject;\n  };\n  /**\r\n   * Parses a JSON object to create a GPU particle system.\r\n   * @param parsedParticleSystem The JSON object to parse\r\n   * @param sceneOrEngine The scene or the engine to create the particle system in\r\n   * @param rootUrl The root url to use to load external dependencies like texture\r\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n   * @returns the parsed GPU particle system\r\n   */\n\n\n  GPUParticleSystem.Parse = function (parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart) {\n    if (doNotStart === void 0) {\n      doNotStart = false;\n    }\n\n    var name = parsedParticleSystem.name;\n    var particleSystem = new GPUParticleSystem(name, {\n      capacity: parsedParticleSystem.capacity,\n      randomTextureSize: parsedParticleSystem.randomTextureSize\n    }, sceneOrEngine);\n\n    if (parsedParticleSystem.activeParticleCount) {\n      particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\n    }\n\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl); // Auto start\n\n\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n\n    return particleSystem;\n  };\n\n  return GPUParticleSystem;\n}(BaseParticleSystem);\n\nexport { GPUParticleSystem };","map":null,"metadata":{},"sourceType":"module"}