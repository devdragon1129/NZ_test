{"ast":null,"code":"import { Vector4 } from \"../../Maths/math.vector\";\nimport { Color4 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateBox = function (options) {\n  var nbFaces = 6;\n  var indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n  var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];\n  var uvs = [];\n  var positions = [];\n  var width = options.width || options.size || 1;\n  var height = options.height || options.size || 1;\n  var depth = options.depth || options.size || 1;\n  var wrap = options.wrap || false;\n  var topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\n  var bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\n  topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\n\n  bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\n\n  var topOrder = [2, 0, 3, 1];\n  var bottomOrder = [2, 0, 1, 3];\n  var topIndex = topOrder[topBaseAt];\n  var bottomIndex = bottomOrder[bottomBaseAt];\n  var basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];\n\n  if (wrap) {\n    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\n    basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];\n    var topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];\n    var bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];\n    var topFaceOrder = [17, 18, 19, 16];\n    var bottomFaceOrder = [22, 23, 20, 21];\n\n    while (topIndex > 0) {\n      topFaceBase.unshift(topFaceBase.pop());\n      topFaceOrder.unshift(topFaceOrder.pop());\n      topIndex--;\n    }\n\n    while (bottomIndex > 0) {\n      bottomFaceBase.unshift(bottomFaceBase.pop());\n      bottomFaceOrder.unshift(bottomFaceOrder.pop());\n      bottomIndex--;\n    }\n\n    topFaceBase = topFaceBase.flat();\n    bottomFaceBase = bottomFaceBase.flat();\n    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\n    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\n    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\n  }\n\n  var scaleArray = [width / 2, height / 2, depth / 2];\n  positions = basePositions.reduce(function (accumulator, currentValue, currentIndex) {\n    return accumulator.concat(currentValue * scaleArray[currentIndex % 3]);\n  }, []);\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var faceUV = options.faceUV || new Array(6);\n  var faceColors = options.faceColors;\n  var colors = []; // default face colors and UV if undefined\n\n  for (var f = 0; f < 6; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  } // Create each face in turn.\n\n\n  for (var index = 0; index < nbFaces; index++) {\n    uvs.push(faceUV[index].z, faceUV[index].w);\n    uvs.push(faceUV[index].x, faceUV[index].w);\n    uvs.push(faceUV[index].x, faceUV[index].y);\n    uvs.push(faceUV[index].z, faceUV[index].y);\n\n    if (faceColors) {\n      for (var c = 0; c < 4; c++) {\n        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n      }\n    }\n  } // sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n\n  return vertexData;\n};\n\nMesh.CreateBox = function (name, size, scene, updatable, sideOrientation) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    size: size,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return BoxBuilder.CreateBox(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar BoxBuilder =\n/** @class */\nfunction () {\n  function BoxBuilder() {}\n  /**\r\n   * Creates a box mesh\r\n   * * The parameter `size` sets the size (float) of each box side (default 1)\r\n   * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n   * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n   * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the box mesh\r\n   */\n\n\n  BoxBuilder.CreateBox = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var box = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    box._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateBox(options);\n    vertexData.applyToMesh(box, options.updatable);\n    return box;\n  };\n\n  return BoxBuilder;\n}();\n\nexport { BoxBuilder };","map":null,"metadata":{},"sourceType":"module"}