{"ast":null,"code":"import { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces\";\nimport { Vector2, Vector3, Vector4, Matrix } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color4 } from '@babylonjs/core/Maths/math.color';\nimport { Effect } from \"@babylonjs/core/Materials/effect\";\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\n/**\r\n* Utils functions for GLTF\r\n* @hidden\r\n*/\n\nvar GLTFUtils =\n/** @class */\nfunction () {\n  function GLTFUtils() {}\n  /**\r\n   * Sets the given \"parameter\" matrix\r\n   * @param scene: the Scene object\r\n   * @param source: the source node where to pick the matrix\r\n   * @param parameter: the GLTF technique parameter\r\n   * @param uniformName: the name of the shader's uniform\r\n   * @param shaderMaterial: the shader material\r\n   */\n\n\n  GLTFUtils.SetMatrix = function (scene, source, parameter, uniformName, shaderMaterial) {\n    var mat = null;\n\n    if (parameter.semantic === \"MODEL\") {\n      mat = source.getWorldMatrix();\n    } else if (parameter.semantic === \"PROJECTION\") {\n      mat = scene.getProjectionMatrix();\n    } else if (parameter.semantic === \"VIEW\") {\n      mat = scene.getViewMatrix();\n    } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n      mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\n    } else if (parameter.semantic === \"MODELVIEW\") {\n      mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\n    } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\n      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\n    } else if (parameter.semantic === \"MODELINVERSE\") {\n      mat = source.getWorldMatrix().invert();\n    } else if (parameter.semantic === \"VIEWINVERSE\") {\n      mat = scene.getViewMatrix().invert();\n    } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\n      mat = scene.getProjectionMatrix().invert();\n    } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\n      mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\n    } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\n      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\n    } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\n      mat = Matrix.Transpose(source.getWorldMatrix().invert());\n    } else {\n      debugger;\n    }\n\n    if (mat) {\n      switch (parameter.type) {\n        case EParameterType.FLOAT_MAT2:\n          shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\n          break;\n\n        case EParameterType.FLOAT_MAT3:\n          shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\n          break;\n\n        case EParameterType.FLOAT_MAT4:\n          shaderMaterial.setMatrix(uniformName, mat);\n          break;\n\n        default:\n          break;\n      }\n    }\n  };\n  /**\r\n   * Sets the given \"parameter\" matrix\r\n   * @param shaderMaterial: the shader material\r\n   * @param uniform: the name of the shader's uniform\r\n   * @param value: the value of the uniform\r\n   * @param type: the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n   */\n\n\n  GLTFUtils.SetUniform = function (shaderMaterial, uniform, value, type) {\n    switch (type) {\n      case EParameterType.FLOAT:\n        shaderMaterial.setFloat(uniform, value);\n        return true;\n\n      case EParameterType.FLOAT_VEC2:\n        shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\n        return true;\n\n      case EParameterType.FLOAT_VEC3:\n        shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\n        return true;\n\n      case EParameterType.FLOAT_VEC4:\n        shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\n        return true;\n\n      default:\n        return false;\n    }\n  };\n  /**\r\n  * Returns the wrap mode of the texture\r\n  * @param mode: the mode value\r\n  */\n\n\n  GLTFUtils.GetWrapMode = function (mode) {\n    switch (mode) {\n      case ETextureWrapMode.CLAMP_TO_EDGE:\n        return Texture.CLAMP_ADDRESSMODE;\n\n      case ETextureWrapMode.MIRRORED_REPEAT:\n        return Texture.MIRROR_ADDRESSMODE;\n\n      case ETextureWrapMode.REPEAT:\n        return Texture.WRAP_ADDRESSMODE;\n\n      default:\n        return Texture.WRAP_ADDRESSMODE;\n    }\n  };\n  /**\r\n   * Returns the byte stride giving an accessor\r\n   * @param accessor: the GLTF accessor objet\r\n   */\n\n\n  GLTFUtils.GetByteStrideFromType = function (accessor) {\n    // Needs this function since \"byteStride\" isn't requiered in glTF format\n    var type = accessor.type;\n\n    switch (type) {\n      case \"VEC2\":\n        return 2;\n\n      case \"VEC3\":\n        return 3;\n\n      case \"VEC4\":\n        return 4;\n\n      case \"MAT2\":\n        return 4;\n\n      case \"MAT3\":\n        return 9;\n\n      case \"MAT4\":\n        return 16;\n\n      default:\n        return 1;\n    }\n  };\n  /**\r\n   * Returns the texture filter mode giving a mode value\r\n   * @param mode: the filter mode value\r\n   */\n\n\n  GLTFUtils.GetTextureFilterMode = function (mode) {\n    switch (mode) {\n      case ETextureFilterType.LINEAR:\n      case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\n      case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\n        return Texture.TRILINEAR_SAMPLINGMODE;\n\n      case ETextureFilterType.NEAREST:\n      case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\n        return Texture.NEAREST_SAMPLINGMODE;\n\n      default:\n        return Texture.BILINEAR_SAMPLINGMODE;\n    }\n  };\n\n  GLTFUtils.GetBufferFromBufferView = function (gltfRuntime, bufferView, byteOffset, byteLength, componentType) {\n    var byteOffset = bufferView.byteOffset + byteOffset;\n    var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\n\n    if (byteOffset + byteLength > loadedBufferView.byteLength) {\n      throw new Error(\"Buffer access is out of range\");\n    }\n\n    var buffer = loadedBufferView.buffer;\n    byteOffset += loadedBufferView.byteOffset;\n\n    switch (componentType) {\n      case EComponentType.BYTE:\n        return new Int8Array(buffer, byteOffset, byteLength);\n\n      case EComponentType.UNSIGNED_BYTE:\n        return new Uint8Array(buffer, byteOffset, byteLength);\n\n      case EComponentType.SHORT:\n        return new Int16Array(buffer, byteOffset, byteLength);\n\n      case EComponentType.UNSIGNED_SHORT:\n        return new Uint16Array(buffer, byteOffset, byteLength);\n\n      default:\n        return new Float32Array(buffer, byteOffset, byteLength);\n    }\n  };\n  /**\r\n   * Returns a buffer from its accessor\r\n   * @param gltfRuntime: the GLTF runtime\r\n   * @param accessor: the GLTF accessor\r\n   */\n\n\n  GLTFUtils.GetBufferFromAccessor = function (gltfRuntime, accessor) {\n    var bufferView = gltfRuntime.bufferViews[accessor.bufferView];\n    var byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\n    return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\n  };\n  /**\r\n   * Decodes a buffer view into a string\r\n   * @param view: the buffer view\r\n   */\n\n\n  GLTFUtils.DecodeBufferToText = function (view) {\n    var result = \"\";\n    var length = view.byteLength;\n\n    for (var i = 0; i < length; ++i) {\n      result += String.fromCharCode(view[i]);\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the default material of gltf. Related to\r\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n   * @param scene: the Babylon.js scene\r\n   */\n\n\n  GLTFUtils.GetDefaultMaterial = function (scene) {\n    if (!GLTFUtils._DefaultMaterial) {\n      Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\"precision highp float;\", \"\", \"uniform mat4 worldView;\", \"uniform mat4 projection;\", \"\", \"attribute vec3 position;\", \"\", \"void main(void)\", \"{\", \"    gl_Position = projection * worldView * vec4(position, 1.0);\", \"}\"].join(\"\\n\");\n      Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\"precision highp float;\", \"\", \"uniform vec4 u_emission;\", \"\", \"void main(void)\", \"{\", \"    gl_FragColor = u_emission;\", \"}\"].join(\"\\n\");\n      var shaderPath = {\n        vertex: \"GLTFDefaultMaterial\",\n        fragment: \"GLTFDefaultMaterial\"\n      };\n      var options = {\n        attributes: [\"position\"],\n        uniforms: [\"worldView\", \"projection\", \"u_emission\"],\n        samplers: new Array(),\n        needAlphaBlending: false\n      };\n      GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\n\n      GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\n    }\n\n    return GLTFUtils._DefaultMaterial;\n  }; // The GLTF default material\n\n\n  GLTFUtils._DefaultMaterial = null;\n  return GLTFUtils;\n}();\n\nexport { GLTFUtils };","map":null,"metadata":{},"sourceType":"module"}