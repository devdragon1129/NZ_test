{"ast":null,"code":"import { Tools } from \"../../Misc/tools\";\nimport { WorkerPool } from '../../Misc/workerPool';\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\n\nfunction createDecoderAsync(wasmBinary) {\n  return new Promise(function (resolve) {\n    DracoDecoderModule({\n      wasmBinary: wasmBinary\n    }).then(function (module) {\n      resolve({\n        module: module\n      });\n    });\n  });\n}\n\nfunction decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData) {\n  var buffer = new decoderModule.DecoderBuffer();\n  buffer.Init(dataView, dataView.byteLength);\n  var decoder = new decoderModule.Decoder();\n  var geometry;\n  var status;\n\n  try {\n    var type = decoder.GetEncodedGeometryType(buffer);\n\n    switch (type) {\n      case decoderModule.TRIANGULAR_MESH:\n        geometry = new decoderModule.Mesh();\n        status = decoder.DecodeBufferToMesh(buffer, geometry);\n        break;\n\n      case decoderModule.POINT_CLOUD:\n        geometry = new decoderModule.PointCloud();\n        status = decoder.DecodeBufferToPointCloud(buffer, geometry);\n        break;\n\n      default:\n        throw new Error(\"Invalid geometry type \" + type);\n    }\n\n    if (!status.ok() || !geometry.ptr) {\n      throw new Error(status.error_msg());\n    }\n\n    if (type === decoderModule.TRIANGULAR_MESH) {\n      var numFaces = geometry.num_faces();\n      var numIndices = numFaces * 3;\n      var byteLength = numIndices * 4;\n\n      var ptr = decoderModule._malloc(byteLength);\n\n      try {\n        decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\n        var indices = new Uint32Array(numIndices);\n        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n        onIndicesData(indices);\n      } finally {\n        decoderModule._free(ptr);\n      }\n    }\n\n    var processAttribute = function processAttribute(kind, attribute) {\n      var numComponents = attribute.num_components();\n      var numPoints = geometry.num_points();\n      var numValues = numPoints * numComponents;\n      var byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\n\n      var ptr = decoderModule._malloc(byteLength);\n\n      try {\n        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\n        var values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\n\n        if (kind === \"color\" && numComponents === 3) {\n          var babylonData = new Float32Array(numPoints * 4);\n\n          for (var i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\n            babylonData[i + 0] = values[j + 0];\n            babylonData[i + 1] = values[j + 1];\n            babylonData[i + 2] = values[j + 2];\n            babylonData[i + 3] = 1;\n          }\n\n          onAttributeData(kind, babylonData);\n        } else {\n          var babylonData = new Float32Array(numValues);\n          babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\n          onAttributeData(kind, babylonData);\n        }\n      } finally {\n        decoderModule._free(ptr);\n      }\n    };\n\n    if (attributes) {\n      for (var kind in attributes) {\n        var id = attributes[kind];\n        var attribute = decoder.GetAttributeByUniqueId(geometry, id);\n        processAttribute(kind, attribute);\n      }\n    } else {\n      var nativeAttributeTypes = {\n        \"position\": \"POSITION\",\n        \"normal\": \"NORMAL\",\n        \"color\": \"COLOR\",\n        \"uv\": \"TEX_COORD\"\n      };\n\n      for (var kind in nativeAttributeTypes) {\n        var id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\n\n        if (id !== -1) {\n          var attribute = decoder.GetAttribute(geometry, id);\n          processAttribute(kind, attribute);\n        }\n      }\n    }\n  } finally {\n    if (geometry) {\n      decoderModule.destroy(geometry);\n    }\n\n    decoderModule.destroy(decoder);\n    decoderModule.destroy(buffer);\n  }\n}\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\n\n\nfunction worker() {\n  var decoderPromise;\n\n  onmessage = function onmessage(event) {\n    var data = event.data;\n\n    switch (data.id) {\n      case \"init\":\n        {\n          var decoder = data.decoder;\n\n          if (decoder.url) {\n            importScripts(decoder.url);\n            decoderPromise = DracoDecoderModule({\n              wasmBinary: decoder.wasmBinary\n            });\n          }\n\n          postMessage(\"done\");\n          break;\n        }\n\n      case \"decodeMesh\":\n        {\n          if (!decoderPromise) {\n            throw new Error(\"Draco decoder module is not available\");\n          }\n\n          decoderPromise.then(function (decoder) {\n            decodeMesh(decoder, data.dataView, data.attributes, function (indices) {\n              postMessage({\n                id: \"indices\",\n                value: indices\n              }, [indices.buffer]);\n            }, function (kind, data) {\n              postMessage({\n                id: kind,\n                value: data\n              }, [data.buffer]);\n            });\n            postMessage(\"done\");\n          });\n          break;\n        }\n    }\n  };\n}\n\nfunction getAbsoluteUrl(url) {\n  if (typeof document !== \"object\" || typeof url !== \"string\") {\n    return url;\n  }\n\n  return Tools.GetAbsoluteUrl(url);\n}\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\r\n * ```javascript\r\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\r\n * ```\r\n *\r\n * @see https://www.babylonjs-playground.com/#N3EK4B#0\r\n */\n\n\nvar DracoCompression =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n   */\n  function DracoCompression(numWorkers) {\n    if (numWorkers === void 0) {\n      numWorkers = DracoCompression.DefaultNumWorkers;\n    }\n\n    var decoder = DracoCompression.Configuration.decoder;\n    var decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" ? {\n      url: decoder.wasmUrl,\n      wasmBinaryPromise: Tools.LoadFileAsync(getAbsoluteUrl(decoder.wasmBinaryUrl))\n    } : {\n      url: decoder.fallbackUrl,\n      wasmBinaryPromise: Promise.resolve(undefined)\n    };\n\n    if (numWorkers && typeof Worker === \"function\") {\n      this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n        var workerContent = decodeMesh + \"(\" + worker + \")()\";\n        var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        var workerPromises = new Array(numWorkers);\n\n        for (var i = 0; i < workerPromises.length; i++) {\n          workerPromises[i] = new Promise(function (resolve, reject) {\n            var worker = new Worker(workerBlobUrl);\n\n            var onError = function onError(error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n            };\n\n            var onMessage = function onMessage(message) {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              id: \"init\",\n              decoder: {\n                url: getAbsoluteUrl(decoderInfo.url),\n                wasmBinary: decoderWasmBinary\n              }\n            });\n          });\n        }\n\n        return Promise.all(workerPromises).then(function (workers) {\n          return new WorkerPool(workers);\n        });\n      });\n    } else {\n      this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n        if (!decoderInfo.url) {\n          throw new Error(\"Draco decoder module is not available\");\n        }\n\n        return Tools.LoadScriptAsync(decoderInfo.url).then(function () {\n          return createDecoderAsync(decoderWasmBinary);\n        });\n      });\n    }\n  }\n\n  Object.defineProperty(DracoCompression, \"DecoderAvailable\", {\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\n    get: function get() {\n      var decoder = DracoCompression.Configuration.decoder;\n      return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" || decoder.fallbackUrl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DracoCompression.GetDefaultNumWorkers = function () {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    } // Use 50% of the available logical processors but capped at 4.\n\n\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  };\n\n  Object.defineProperty(DracoCompression, \"Default\", {\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\n    get: function get() {\n      if (!DracoCompression._Default) {\n        DracoCompression._Default = new DracoCompression();\n      }\n\n      return DracoCompression._Default;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Stop all async operations and release resources.\r\n   */\n\n  DracoCompression.prototype.dispose = function () {\n    if (this._workerPoolPromise) {\n      this._workerPoolPromise.then(function (workerPool) {\n        workerPool.dispose();\n      });\n    }\n\n    delete this._workerPoolPromise;\n    delete this._decoderModulePromise;\n  };\n  /**\r\n   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n   * @returns a promise that resolves when ready\r\n   */\n\n\n  DracoCompression.prototype.whenReadyAsync = function () {\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(function () {});\n    }\n\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(function () {});\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n    * Decode Draco compressed mesh data to vertex data.\r\n    * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n    * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n    * @returns A promise that resolves with the decoded vertex data\r\n    */\n\n\n  DracoCompression.prototype.decodeMeshAsync = function (data, attributes) {\n    var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(function (workerPool) {\n        return new Promise(function (resolve, reject) {\n          workerPool.push(function (worker, onComplete) {\n            var vertexData = new VertexData();\n\n            var onError = function onError(error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n\n            var onMessage = function onMessage(message) {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(vertexData);\n                onComplete();\n              } else if (message.data.id === \"indices\") {\n                vertexData.indices = message.data.value;\n              } else {\n                vertexData.set(message.data.value, message.data.id);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            var dataViewCopy = new Uint8Array(dataView.byteLength);\n            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n            worker.postMessage({\n              id: \"decodeMesh\",\n              dataView: dataViewCopy,\n              attributes: attributes\n            }, [dataViewCopy.buffer]);\n          });\n        });\n      });\n    }\n\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(function (decoder) {\n        var vertexData = new VertexData();\n        decodeMesh(decoder.module, dataView, attributes, function (indices) {\n          vertexData.indices = indices;\n        }, function (kind, data) {\n          vertexData.set(data, kind);\n        });\n        return vertexData;\n      });\n    }\n\n    throw new Error(\"Draco decoder module is not available\");\n  };\n  /**\r\n   * The configuration. Defaults to the following urls:\r\n   * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n   * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n   * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n   */\n\n\n  DracoCompression.Configuration = {\n    decoder: {\n      wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\n      wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\n      fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n    }\n  };\n  /**\r\n   * Default number of workers to create when creating the draco compression object.\r\n   */\n\n  DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\n  DracoCompression._Default = null;\n  return DracoCompression;\n}();\n\nexport { DracoCompression };","map":null,"metadata":{},"sourceType":"module"}