{"ast":null,"code":"import { Effect } from './effect';\nimport { GUID } from '../Misc/guid';\nimport { NodeMaterialSystemValues } from './Node/Enums/nodeMaterialSystemValues';\n\nvar MapMap =\n/** @class */\nfunction () {\n  function MapMap() {\n    this.mm = new Map();\n  }\n\n  MapMap.prototype.get = function (a, b) {\n    var m = this.mm.get(a);\n\n    if (m !== undefined) {\n      return m.get(b);\n    }\n\n    return undefined;\n  };\n\n  MapMap.prototype.set = function (a, b, v) {\n    var m = this.mm.get(a);\n\n    if (m === undefined) {\n      this.mm.set(a, m = new Map());\n    }\n\n    m.set(b, v);\n  };\n\n  return MapMap;\n}();\n/**\r\n * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material\r\n */\n\n\nvar ShadowDepthWrapper =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new shadow depth wrapper.\r\n   * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to\r\n   * generate the shadow depth map. For more information, please refer to the documentation:\r\n   * https://doc.babylonjs.com/babylon101/shadows\r\n   * @param baseMaterial Material to wrap\r\n   * @param scene Define the scene the material belongs to\r\n   * @param options Options used to create the wrapper\r\n   */\n  function ShadowDepthWrapper(baseMaterial, scene, options) {\n    var _this = this;\n\n    this._baseMaterial = baseMaterial;\n    this._scene = scene;\n    this._options = options;\n    this._subMeshToEffect = new Map();\n    this._subMeshToDepthEffect = new MapMap();\n    this._meshes = new Map();\n    var prefix = baseMaterial.getClassName() === \"NodeMaterial\" ? \"u_\" : \"\";\n\n    if (prefix) {\n      this._matriceNames = {\n        \"world\": prefix + \"World\",\n        \"view\": prefix + \"View\",\n        \"projection\": prefix + \"Projection\",\n        \"viewProjection\": prefix + \"ViewProjection\",\n        \"worldView\": prefix + \"WorldxView\",\n        \"worldViewProjection\": prefix + \"WorldxViewxProjection\"\n      };\n      var nodeMat = baseMaterial;\n      var inputBlocks = nodeMat.getInputBlocks();\n\n      for (var i = 0; i < inputBlocks.length; ++i) {\n        switch (inputBlocks[i]._systemValue) {\n          case NodeMaterialSystemValues.World:\n            this._matriceNames[\"world\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.View:\n            this._matriceNames[\"view\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.Projection:\n            this._matriceNames[\"projection\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.ViewProjection:\n            this._matriceNames[\"viewProjection\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.WorldView:\n            this._matriceNames[\"worldView\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.WorldViewProjection:\n            this._matriceNames[\"worldViewProjection\"] = inputBlocks[i].associatedVariableName;\n            break;\n        }\n      }\n    } else {\n      this._matriceNames = {\n        \"world\": prefix + \"world\",\n        \"view\": prefix + \"view\",\n        \"projection\": prefix + \"projection\",\n        \"viewProjection\": prefix + \"viewProjection\",\n        \"worldView\": prefix + \"worldView\",\n        \"worldViewProjection\": prefix + \"worldViewProjection\"\n      };\n    } // Register for onEffectCreated to store the effect of the base material when it is (re)generated. This effect will be used\n    // to create the depth effect later on\n\n\n    this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add(function (params) {\n      var _a;\n\n      var mesh = (_a = params.subMesh) === null || _a === void 0 ? void 0 : _a.getMesh();\n\n      if (mesh && !_this._meshes.has(mesh)) {\n        // Register for mesh onDispose to clean up our internal maps when a mesh is disposed\n        _this._meshes.set(mesh, mesh.onDisposeObservable.add(function (mesh) {\n          var iterator = _this._subMeshToEffect.keys();\n\n          for (var key = iterator.next(); key.done !== true; key = iterator.next()) {\n            var subMesh = key.value;\n\n            if ((subMesh === null || subMesh === void 0 ? void 0 : subMesh.getMesh()) === mesh) {\n              _this._subMeshToEffect.delete(subMesh);\n\n              _this._subMeshToDepthEffect.mm.delete(subMesh);\n            }\n          }\n        }));\n      }\n\n      _this._subMeshToEffect.set(params.subMesh, params.effect);\n\n      _this._subMeshToDepthEffect.mm.delete(params.subMesh); // trigger a depth effect recreation\n\n    });\n  }\n\n  Object.defineProperty(ShadowDepthWrapper.prototype, \"standalone\", {\n    /** Gets the standalone status of the wrapper */\n    get: function get() {\n      var _a, _b;\n\n      return (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.standalone) !== null && _b !== void 0 ? _b : false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ShadowDepthWrapper.prototype, \"baseMaterial\", {\n    /** Gets the base material the wrapper is built upon */\n    get: function get() {\n      return this._baseMaterial;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the effect to use to generate the depth map\r\n   * @param subMesh subMesh to get the effect for\r\n   * @param shadowGenerator shadow generator to get the effect for\r\n   * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified\r\n   */\n\n  ShadowDepthWrapper.prototype.getEffect = function (subMesh, shadowGenerator) {\n    var _a, _b, _c, _d, _e, _f;\n\n    return (_f = (_c = (_b = (_a = this._subMeshToDepthEffect.mm.get(subMesh)) === null || _a === void 0 ? void 0 : _a.get(shadowGenerator)) === null || _b === void 0 ? void 0 : _b.depthEffect) !== null && _c !== void 0 ? _c : (_e = (_d = this._subMeshToDepthEffect.mm.get(null)) === null || _d === void 0 ? void 0 : _d.get(shadowGenerator)) === null || _e === void 0 ? void 0 : _e.depthEffect) !== null && _f !== void 0 ? _f : null;\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used for depth rendering\r\n   * @param subMesh submesh to check\r\n   * @param defines the list of defines to take into account when checking the effect\r\n   * @param shadowGenerator combined with subMesh, it defines the effect to check\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns a boolean indicating that the submesh is ready or not\r\n   */\n\n\n  ShadowDepthWrapper.prototype.isReadyForSubMesh = function (subMesh, defines, shadowGenerator, useInstances) {\n    var _a, _b;\n\n    if (this.standalone) {\n      // will ensure the effect is (re)created for the base material\n      this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\n    }\n\n    return (_b = (_a = this._makeEffect(subMesh, defines, shadowGenerator)) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;\n  };\n  /**\r\n   * Disposes the resources\r\n   */\n\n\n  ShadowDepthWrapper.prototype.dispose = function () {\n    this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);\n\n    this._onEffectCreatedObserver = null;\n\n    var iterator = this._meshes.entries();\n\n    for (var entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\n      var _a = entry.value,\n          mesh = _a[0],\n          observer = _a[1];\n      mesh.onDisposeObservable.remove(observer);\n    }\n  };\n\n  ShadowDepthWrapper.prototype._makeEffect = function (subMesh, defines, shadowGenerator) {\n    var _a;\n\n    var origEffect = (_a = this._subMeshToEffect.get(subMesh)) !== null && _a !== void 0 ? _a : this._subMeshToEffect.get(null);\n\n    if (!origEffect) {\n      return null;\n    }\n\n    var params = this._subMeshToDepthEffect.get(subMesh, shadowGenerator);\n\n    if (!params) {\n      params = {\n        depthEffect: null,\n        depthDefines: \"\",\n        token: GUID.RandomId()\n      };\n\n      this._subMeshToDepthEffect.set(subMesh, shadowGenerator, params);\n    }\n\n    var join = defines.join(\"\\n\");\n\n    if (params.depthEffect) {\n      if (join === params.depthDefines) {\n        // we already created the depth effect and it is still up to date for this submesh + shadow generator\n        return params.depthEffect;\n      }\n    }\n\n    params.depthDefines = join; // the depth effect is either out of date or has not been created yet\n\n    var vertexCode = origEffect.rawVertexSourceCode,\n        fragmentCode = origEffect.rawFragmentSourceCode; // vertex code\n\n    var vertexNormalBiasCode = this._options && this._options.remappedVariables ? \"#include<shadowMapVertexNormalBias>(\" + this._options.remappedVariables.join(\",\") + \")\" : Effect.IncludesShadersStore[\"shadowMapVertexNormalBias\"],\n        vertexMetricCode = this._options && this._options.remappedVariables ? \"#include<shadowMapVertexMetric>(\" + this._options.remappedVariables.join(\",\") + \")\" : Effect.IncludesShadersStore[\"shadowMapVertexMetric\"],\n        fragmentSoftTransparentShadow = this._options && this._options.remappedVariables ? \"#include<shadowMapFragmentSoftTransparentShadow>(\" + this._options.remappedVariables.join(\",\") + \")\" : Effect.IncludesShadersStore[\"shadowMapFragmentSoftTransparentShadow\"],\n        fragmentBlockCode = Effect.IncludesShadersStore[\"shadowMapFragment\"];\n    vertexCode = vertexCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapVertexDeclaration\"] + \"\\r\\nvoid main\");\n    vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);\n\n    if (vertexCode.indexOf(\"#define SHADOWDEPTH_METRIC\") !== -1) {\n      vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);\n    } else {\n      vertexCode = vertexCode.replace(/}\\s*$/g, vertexMetricCode + \"\\r\\n}\");\n    }\n\n    vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\"); // fragment code\n\n    var hasLocationForSoftTransparentShadow = fragmentCode.indexOf(\"#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW\") >= 0 || fragmentCode.indexOf(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\") >= 0;\n    var hasLocationForFragment = fragmentCode.indexOf(\"#define SHADOWDEPTH_FRAGMENT\") !== -1;\n    var fragmentCodeToInjectAtEnd = \"\";\n\n    if (!hasLocationForSoftTransparentShadow) {\n      fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + \"\\r\\n\";\n    } else {\n      fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);\n    }\n\n    fragmentCode = fragmentCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapFragmentDeclaration\"] + \"\\r\\nvoid main\");\n\n    if (hasLocationForFragment) {\n      fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);\n    } else {\n      fragmentCodeToInjectAtEnd += fragmentBlockCode + \"\\r\\n\";\n    }\n\n    if (fragmentCodeToInjectAtEnd) {\n      fragmentCode = fragmentCode.replace(/}\\s*$/g, fragmentCodeToInjectAtEnd + \"}\");\n    }\n\n    fragmentCode = fragmentCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\n    var uniforms = origEffect.getUniformNames().slice();\n    uniforms.push(\"biasAndScaleSM\", \"depthValuesSM\", \"lightDataSM\", \"softTransparentShadowSM\");\n    params.depthEffect = this._scene.getEngine().createEffect({\n      vertexSource: vertexCode,\n      fragmentSource: fragmentCode,\n      vertexToken: params.token,\n      fragmentToken: params.token\n    }, {\n      attributes: origEffect.getAttributesNames(),\n      uniformsNames: uniforms,\n      uniformBuffersNames: origEffect.getUniformBuffersNames(),\n      samplers: origEffect.getSamplers(),\n      defines: join + \"\\n\" + origEffect.defines.replace(\"#define SHADOWS\", \"\").replace(/#define SHADOW\\d/g, \"\"),\n      indexParameters: origEffect.getIndexParameters()\n    }, this._scene.getEngine());\n    return params.depthEffect;\n  };\n\n  return ShadowDepthWrapper;\n}();\n\nexport { ShadowDepthWrapper };","map":null,"metadata":{},"sourceType":"module"}