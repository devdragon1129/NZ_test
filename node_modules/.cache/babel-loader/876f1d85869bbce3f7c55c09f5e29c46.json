{"ast":null,"code":"import { PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\n\nvar HDRTools =\n/** @class */\nfunction () {\n  function HDRTools() {}\n\n  HDRTools.Ldexp = function (mantissa, exponent) {\n    if (exponent > 1023) {\n      return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n    }\n\n    if (exponent < -1074) {\n      return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n    }\n\n    return mantissa * Math.pow(2, exponent);\n  };\n\n  HDRTools.Rgbe2float = function (float32array, red, green, blue, exponent, index) {\n    if (exponent > 0) {\n      /*nonzero pixel*/\n      exponent = this.Ldexp(1.0, exponent - (128 + 8));\n      float32array[index + 0] = red * exponent;\n      float32array[index + 1] = green * exponent;\n      float32array[index + 2] = blue * exponent;\n    } else {\n      float32array[index + 0] = 0;\n      float32array[index + 1] = 0;\n      float32array[index + 2] = 0;\n    }\n  };\n\n  HDRTools.readStringLine = function (uint8array, startIndex) {\n    var line = \"\";\n    var character = \"\";\n\n    for (var i = startIndex; i < uint8array.length - startIndex; i++) {\n      character = String.fromCharCode(uint8array[i]);\n\n      if (character == \"\\n\") {\n        break;\n      }\n\n      line += character;\n    }\n\n    return line;\n  };\n  /**\r\n   * Reads header information from an RGBE texture stored in a native array.\r\n   * More information on this format are available here:\r\n   * https://en.wikipedia.org/wiki/RGBE_image_format\r\n   *\r\n   * @param uint8array The binary file stored in  native array.\r\n   * @return The header information.\r\n   */\n\n\n  HDRTools.RGBE_ReadHeader = function (uint8array) {\n    var height = 0;\n    var width = 0;\n    var line = this.readStringLine(uint8array, 0);\n\n    if (line[0] != '#' || line[1] != '?') {\n      throw \"Bad HDR Format.\";\n    }\n\n    var endOfHeader = false;\n    var findFormat = false;\n    var lineIndex = 0;\n\n    do {\n      lineIndex += line.length + 1;\n      line = this.readStringLine(uint8array, lineIndex);\n\n      if (line == \"FORMAT=32-bit_rle_rgbe\") {\n        findFormat = true;\n      } else if (line.length == 0) {\n        endOfHeader = true;\n      }\n    } while (!endOfHeader);\n\n    if (!findFormat) {\n      throw \"HDR Bad header format, unsupported FORMAT\";\n    }\n\n    lineIndex += line.length + 1;\n    line = this.readStringLine(uint8array, lineIndex);\n    var sizeRegexp = /^\\-Y (.*) \\+X (.*)$/g;\n    var match = sizeRegexp.exec(line); // TODO. Support +Y and -X if needed.\n\n    if (!match || match.length < 3) {\n      throw \"HDR Bad header format, no size\";\n    }\n\n    width = parseInt(match[2]);\n    height = parseInt(match[1]);\n\n    if (width < 8 || width > 0x7fff) {\n      throw \"HDR Bad header format, unsupported size\";\n    }\n\n    lineIndex += line.length + 1;\n    return {\n      height: height,\n      width: width,\n      dataPosition: lineIndex\n    };\n  };\n  /**\r\n   * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n   * This RGBE texture needs to store the information as a panorama.\r\n   *\r\n   * More information on this format are available here:\r\n   * https://en.wikipedia.org/wiki/RGBE_image_format\r\n   *\r\n   * @param buffer The binary file stored in an array buffer.\r\n   * @param size The expected size of the extracted cubemap.\r\n   * @return The Cube Map information.\r\n   */\n\n\n  HDRTools.GetCubeMapTextureData = function (buffer, size) {\n    var uint8array = new Uint8Array(buffer);\n    var hdrInfo = this.RGBE_ReadHeader(uint8array);\n    var data = this.RGBE_ReadPixels(uint8array, hdrInfo);\n    var cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\n    return cubeMapData;\n  };\n  /**\r\n   * Returns the pixels data extracted from an RGBE texture.\r\n   * This pixels will be stored left to right up to down in the R G B order in one array.\r\n   *\r\n   * More information on this format are available here:\r\n   * https://en.wikipedia.org/wiki/RGBE_image_format\r\n   *\r\n   * @param uint8array The binary file stored in an array buffer.\r\n   * @param hdrInfo The header information of the file.\r\n   * @return The pixels data in RGB right to left up to down order.\r\n   */\n\n\n  HDRTools.RGBE_ReadPixels = function (uint8array, hdrInfo) {\n    return this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);\n  };\n\n  HDRTools.RGBE_ReadPixels_RLE = function (uint8array, hdrInfo) {\n    var num_scanlines = hdrInfo.height;\n    var scanline_width = hdrInfo.width;\n    var a, b, c, d, count;\n    var dataIndex = hdrInfo.dataPosition;\n    var index = 0,\n        endIndex = 0,\n        i = 0;\n    var scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n\n    var scanLineArray = new Uint8Array(scanLineArrayBuffer); // 3 channels of 4 bytes per pixel in float.\n\n    var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    var resultArray = new Float32Array(resultBuffer); // read in each successive scanline\n\n    while (num_scanlines > 0) {\n      a = uint8array[dataIndex++];\n      b = uint8array[dataIndex++];\n      c = uint8array[dataIndex++];\n      d = uint8array[dataIndex++];\n\n      if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\n        return this.RGBE_ReadPixels_NOT_RLE(uint8array, hdrInfo);\n      }\n\n      if ((c << 8 | d) != scanline_width) {\n        throw \"HDR Bad header format, wrong scan line width\";\n      }\n\n      index = 0; // read each of the four channels for the scanline into the buffer\n\n      for (i = 0; i < 4; i++) {\n        endIndex = (i + 1) * scanline_width;\n\n        while (index < endIndex) {\n          a = uint8array[dataIndex++];\n          b = uint8array[dataIndex++];\n\n          if (a > 128) {\n            // a run of the same value\n            count = a - 128;\n\n            if (count == 0 || count > endIndex - index) {\n              throw \"HDR Bad Format, bad scanline data (run)\";\n            }\n\n            while (count-- > 0) {\n              scanLineArray[index++] = b;\n            }\n          } else {\n            // a non-run\n            count = a;\n\n            if (count == 0 || count > endIndex - index) {\n              throw \"HDR Bad Format, bad scanline data (non-run)\";\n            }\n\n            scanLineArray[index++] = b;\n\n            if (--count > 0) {\n              for (var j = 0; j < count; j++) {\n                scanLineArray[index++] = uint8array[dataIndex++];\n              }\n            }\n          }\n        }\n      } // now convert data from buffer into floats\n\n\n      for (i = 0; i < scanline_width; i++) {\n        a = scanLineArray[i];\n        b = scanLineArray[i + scanline_width];\n        c = scanLineArray[i + 2 * scanline_width];\n        d = scanLineArray[i + 3 * scanline_width];\n        this.Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n\n      num_scanlines--;\n    }\n\n    return resultArray;\n  };\n\n  HDRTools.RGBE_ReadPixels_NOT_RLE = function (uint8array, hdrInfo) {\n    // this file is not run length encoded\n    // read values sequentially\n    var num_scanlines = hdrInfo.height;\n    var scanline_width = hdrInfo.width;\n    var a, b, c, d, i;\n    var dataIndex = hdrInfo.dataPosition; // 3 channels of 4 bytes per pixel in float.\n\n    var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    var resultArray = new Float32Array(resultBuffer); // read in each successive scanline\n\n    while (num_scanlines > 0) {\n      for (i = 0; i < hdrInfo.width; i++) {\n        a = uint8array[dataIndex++];\n        b = uint8array[dataIndex++];\n        c = uint8array[dataIndex++];\n        d = uint8array[dataIndex++];\n        this.Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n\n      num_scanlines--;\n    }\n\n    return resultArray;\n  };\n\n  return HDRTools;\n}();\n\nexport { HDRTools };","map":null,"metadata":{},"sourceType":"module"}