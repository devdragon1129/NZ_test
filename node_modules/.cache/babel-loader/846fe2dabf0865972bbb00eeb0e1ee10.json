{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\nimport { Ray } from \"../../Culling/ray\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\nimport { CylinderBuilder } from \"../../Meshes/Builders/cylinderBuilder\";\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\nimport { Animation } from \"../../Animations/animation\";\nimport { Axis } from \"../../Maths/math.axis\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\nimport { GroundBuilder } from \"../../Meshes/Builders/groundBuilder\";\nimport { TorusBuilder } from \"../../Meshes/Builders/torusBuilder\";\nimport { Curve3 } from \"../../Maths/math.path\";\nimport { LinesBuilder } from \"../../Meshes/Builders/linesBuilder\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Color3 } from \"../../Maths/math.color\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { setAndStartTimer } from \"../../Misc/timer\";\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\n\nvar WebXRMotionControllerTeleportation =\n/** @class */\nfunction (_super) {\n  __extends(WebXRMotionControllerTeleportation, _super);\n  /**\r\n   * constructs a new anchor system\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param _options configuration object for this feature\r\n   */\n\n\n  function WebXRMotionControllerTeleportation(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._controllers = {};\n    _this._snappedToPoint = false;\n    _this._tmpRay = new Ray(new Vector3(), new Vector3());\n    _this._tmpVector = new Vector3();\n    _this._tmpQuaternion = new Quaternion();\n    /**\r\n     * Is movement backwards enabled\r\n     */\n\n    _this.backwardsMovementEnabled = true;\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\n\n    _this.backwardsTeleportationDistance = 0.7;\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\n\n    _this.parabolicCheckRadius = 5;\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\n\n    _this.parabolicRayEnabled = true;\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\n\n    _this.straightRayEnabled = true;\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\n\n    _this.rotationAngle = Math.PI / 8;\n    _this._rotationEnabled = true;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId] || _this._options.forceHandedness && xrController.inputSource.handedness !== _this._options.forceHandedness) {\n        // already attached\n        return;\n      }\n\n      _this._controllers[xrController.uniqueId] = {\n        xrController: xrController,\n        teleportationState: {\n          forward: false,\n          backwards: false,\n          rotating: false,\n          currentRotation: 0,\n          baseRotation: 0\n        }\n      };\n      var controllerData = _this._controllers[xrController.uniqueId]; // motion controller only available to gamepad-enabled input sources.\n\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        var initMotionController_1 = function initMotionController_1() {\n          if (xrController.motionController) {\n            var movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\n\n            if (!movementController || _this._options.useMainComponentOnly) {\n              // use trigger to move on long press\n              var mainComponent_1 = xrController.motionController.getMainComponent();\n\n              if (!mainComponent_1) {\n                return;\n              }\n\n              controllerData.teleportationComponent = mainComponent_1;\n              controllerData.onButtonChangedObserver = mainComponent_1.onButtonStateChangedObservable.add(function () {\n                // did \"pressed\" changed?\n                if (mainComponent_1.changes.pressed) {\n                  if (mainComponent_1.changes.pressed.current) {\n                    // simulate \"forward\" thumbstick push\n                    controllerData.teleportationState.forward = true;\n                    _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                    controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                    controllerData.teleportationState.currentRotation = 0;\n                    var timeToSelect = _this._options.timeToTeleport || 3000;\n                    setAndStartTimer({\n                      timeout: timeToSelect,\n                      contextObservable: _this._xrSessionManager.onXRFrameObservable,\n                      breakCondition: function breakCondition() {\n                        return !mainComponent_1.pressed;\n                      },\n                      onEnded: function onEnded() {\n                        if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                          _this._teleportForward(xrController.uniqueId);\n                        }\n                      }\n                    });\n                  } else {\n                    controllerData.teleportationState.forward = false;\n                    _this._currentTeleportationControllerId = \"\";\n                  }\n                }\n              });\n            } else {\n              controllerData.teleportationComponent = movementController; // use thumbstick (or touchpad if thumbstick not available)\n\n              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add(function (axesData) {\n                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\n                  controllerData.teleportationState.backwards = false;\n                }\n\n                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && _this.backwardsMovementEnabled && !_this.snapPointsOnly) {\n                  // teleport backwards\n                  // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\n                  if (!controllerData.teleportationState.backwards) {\n                    controllerData.teleportationState.backwards = true; // teleport backwards ONCE\n\n                    _this._tmpQuaternion.copyFrom(_this._options.xrInput.xrCamera.rotationQuaternion);\n\n                    _this._tmpQuaternion.toEulerAnglesToRef(_this._tmpVector); // get only the y rotation\n\n\n                    _this._tmpVector.x = 0;\n                    _this._tmpVector.z = 0; // get the quaternion\n\n                    Quaternion.FromEulerVectorToRef(_this._tmpVector, _this._tmpQuaternion);\n\n                    _this._tmpVector.set(0, 0, _this.backwardsTeleportationDistance * (_this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n\n                    _this._tmpVector.rotateByQuaternionToRef(_this._tmpQuaternion, _this._tmpVector);\n\n                    _this._tmpVector.addInPlace(_this._options.xrInput.xrCamera.position);\n\n                    _this._tmpRay.origin.copyFrom(_this._tmpVector); // This will prevent the user from \"falling\" to a lower platform!\n                    // TODO - should this be a flag? 'allow falling to lower platforms'?\n\n\n                    _this._tmpRay.length = _this._options.xrInput.xrCamera.realWorldHeight + 0.1; // Right handed system had here \"1\" instead of -1. This is unneeded.\n\n                    _this._tmpRay.direction.set(0, -1, 0);\n\n                    var pick = _this._xrSessionManager.scene.pickWithRay(_this._tmpRay, function (o) {\n                      return _this._floorMeshes.indexOf(o) !== -1;\n                    }); // pick must exist, but stay safe\n\n\n                    if (pick && pick.pickedPoint) {\n                      // Teleport the users feet to where they targeted. Ignore the Y axis.\n                      // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\n                      _this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\n                      _this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\n                    }\n                  }\n                }\n\n                if (axesData.y < -0.7 && !_this._currentTeleportationControllerId && !controllerData.teleportationState.rotating) {\n                  controllerData.teleportationState.forward = true;\n                  _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                  controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                }\n\n                if (axesData.x) {\n                  if (!controllerData.teleportationState.forward) {\n                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\n                      // rotate in the right direction positive is right\n                      controllerData.teleportationState.rotating = true;\n                      var rotation = _this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (_this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n\n                      _this._options.xrInput.xrCamera.rotationQuaternion.multiplyInPlace(Quaternion.FromEulerAngles(0, rotation, 0));\n                    }\n                  } else {\n                    if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\n                      // set the rotation of the forward movement\n                      if (_this.rotationEnabled) {\n                        setTimeout(function () {\n                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (_this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));\n                        });\n                      } else {\n                        controllerData.teleportationState.currentRotation = 0;\n                      }\n                    }\n                  }\n                } else {\n                  controllerData.teleportationState.rotating = false;\n                }\n\n                if (axesData.x === 0 && axesData.y === 0) {\n                  if (controllerData.teleportationState.forward) {\n                    _this._teleportForward(xrController.uniqueId);\n                  }\n                }\n              });\n            }\n          }\n        };\n\n        if (xrController.motionController) {\n          initMotionController_1();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(function () {\n            initMotionController_1();\n          });\n        }\n      } else {\n        _this._xrSessionManager.scene.onPointerObservable.add(function (pointerInfo) {\n          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n            controllerData.teleportationState.forward = true;\n            _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n            controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n            controllerData.teleportationState.currentRotation = 0;\n            var timeToSelect = _this._options.timeToTeleport || 3000;\n            setAndStartTimer({\n              timeout: timeToSelect,\n              contextObservable: _this._xrSessionManager.onXRFrameObservable,\n              onEnded: function onEnded() {\n                if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                  _this._teleportForward(xrController.uniqueId);\n                }\n              }\n            });\n          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n            controllerData.teleportationState.forward = false;\n            _this._currentTeleportationControllerId = \"\";\n          }\n        });\n      }\n    }; // create default mesh if not provided\n\n\n    if (!_this._options.teleportationTargetMesh) {\n      _this._createDefaultTargetMesh();\n    }\n\n    _this._floorMeshes = _this._options.floorMeshes || [];\n    _this._snapToPositions = _this._options.snapPositions || [];\n\n    _this._setTargetMeshVisibility(false);\n\n    return _this;\n  }\n\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"rotationEnabled\", {\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\n    get: function get() {\n      return this._rotationEnabled;\n    },\n\n    /**\r\n     * Sets wether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\n    set: function set(enabled) {\n      this._rotationEnabled = enabled;\n\n      if (this._options.teleportationTargetMesh) {\n        var children = this._options.teleportationTargetMesh.getChildMeshes(false, function (node) {\n          return node.name === \"rotationCone\";\n        });\n\n        if (children[0]) {\n          children[0].setEnabled(enabled);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"teleportationTargetMesh\", {\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\n    get: function get() {\n      return this._options.teleportationTargetMesh || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"snapPointsOnly\", {\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\n    get: function get() {\n      return !!this._options.snapPointsOnly;\n    },\n\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\n    set: function set(snapToPoints) {\n      this._options.snapPointsOnly = snapToPoints;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Add a new mesh to the floor meshes array\r\n   * @param mesh the mesh to use as floor mesh\r\n   */\n\n  WebXRMotionControllerTeleportation.prototype.addFloorMesh = function (mesh) {\n    this._floorMeshes.push(mesh);\n  };\n  /**\r\n   * Add a new snap-to point to fix teleportation to this position\r\n   * @param newSnapPoint The new Snap-To point\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.addSnapPoint = function (newSnapPoint) {\n    this._snapToPositions.push(newSnapPoint);\n  };\n\n  WebXRMotionControllerTeleportation.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    } // Safety reset\n\n\n    this._currentTeleportationControllerId = \"\";\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    return true;\n  };\n\n  WebXRMotionControllerTeleportation.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n\n    this._setTargetMeshVisibility(false);\n\n    this._currentTeleportationControllerId = \"\";\n    this._controllers = {};\n    return true;\n  };\n\n  WebXRMotionControllerTeleportation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\n  };\n  /**\r\n   * Remove a mesh from the floor meshes array\r\n   * @param mesh the mesh to remove\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeFloorMesh = function (mesh) {\n    var index = this._floorMeshes.indexOf(mesh);\n\n    if (index !== -1) {\n      this._floorMeshes.splice(index, 1);\n    }\n  };\n  /**\r\n   * Remove a mesh from the floor meshes array using its name\r\n   * @param name the mesh name to remove\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeFloorMeshByName = function (name) {\n    var mesh = this._xrSessionManager.scene.getMeshByName(name);\n\n    if (mesh) {\n      this.removeFloorMesh(mesh);\n    }\n  };\n  /**\r\n   * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n   * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n   * @returns was the point found and removed or not\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeSnapPoint = function (snapPointToRemove) {\n    // check if the object is in the array\n    var index = this._snapToPositions.indexOf(snapPointToRemove); // if not found as an object, compare to the points\n\n\n    if (index === -1) {\n      for (var i = 0; i < this._snapToPositions.length; ++i) {\n        // equals? index is i, break the loop\n        if (this._snapToPositions[i].equals(snapPointToRemove)) {\n          index = i;\n          break;\n        }\n      }\n    } // index is not -1? remove the object\n\n\n    if (index !== -1) {\n      this._snapToPositions.splice(index, 1);\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * This function sets a selection feature that will be disabled when\r\n   * the forward ray is shown and will be reattached when hidden.\r\n   * This is used to remove the selection rays when moving.\r\n   * @param selectionFeature the feature to disable when forward movement is enabled\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.setSelectionFeature = function (selectionFeature) {\n    this._selectionFeature = selectionFeature;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    var frame = this._xrSessionManager.currentFrame;\n    var scene = this._xrSessionManager.scene;\n\n    if (!this.attach || !frame) {\n      return;\n    } // render target if needed\n\n\n    var targetMesh = this._options.teleportationTargetMesh;\n\n    if (this._currentTeleportationControllerId) {\n      if (!targetMesh) {\n        return;\n      }\n\n      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\n      var controllerData = this._controllers[this._currentTeleportationControllerId];\n\n      if (controllerData && controllerData.teleportationState.forward) {\n        // set the rotation\n        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion); // set the ray and position\n\n        var hitPossible = false;\n        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n\n        if (this.straightRayEnabled) {\n          // first check if direct ray possible\n          // pick grounds that are LOWER only. upper will use parabolic path\n          var pick = scene.pickWithRay(this._tmpRay, function (o) {\n            // check for mesh-blockers\n            if (_this._options.pickBlockerMeshes && _this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n\n            var index = _this._floorMeshes.indexOf(o);\n\n            if (index === -1) {\n              return false;\n            }\n\n            return _this._floorMeshes[index].absolutePosition.y < _this._options.xrInput.xrCamera.position.y;\n          });\n\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            return;\n          } else if (pick && pick.pickedPoint) {\n            hitPossible = true;\n\n            this._setTargetMeshPosition(pick.pickedPoint);\n\n            this._setTargetMeshVisibility(true);\n\n            this._showParabolicPath(pick);\n          }\n        } // straight ray is still the main ray, but disabling the straight line will force parabolic line.\n\n\n        if (this.parabolicRayEnabled && !hitPossible) {\n          // radius compensation according to pointer rotation around X\n          var xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;\n          var compensation = 1 + (Math.PI / 2 - Math.abs(xRotation)); // check parabolic ray\n\n          var radius = this.parabolicCheckRadius * compensation;\n\n          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\n\n          this._tmpVector.y = this._tmpRay.origin.y;\n\n          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\n\n          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\n\n          this._tmpRay.direction.normalize();\n\n          var pick = scene.pickWithRay(this._tmpRay, function (o) {\n            // check for mesh-blockers\n            if (_this._options.pickBlockerMeshes && _this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n\n            return _this._floorMeshes.indexOf(o) !== -1;\n          });\n\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            return;\n          } else if (pick && pick.pickedPoint) {\n            hitPossible = true;\n\n            this._setTargetMeshPosition(pick.pickedPoint);\n\n            this._setTargetMeshVisibility(true);\n\n            this._showParabolicPath(pick);\n          }\n        } // if needed, set visible:\n\n\n        this._setTargetMeshVisibility(hitPossible);\n      } else {\n        this._setTargetMeshVisibility(false);\n      }\n    } else {\n      this._setTargetMeshVisibility(false);\n    }\n  };\n\n  WebXRMotionControllerTeleportation.prototype._createDefaultTargetMesh = function () {\n    // set defaults\n    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    var teleportationTarget = GroundBuilder.CreateGround(\"teleportationTarget\", {\n      width: 2,\n      height: 2,\n      subdivisions: 2\n    }, sceneToRenderTo);\n    teleportationTarget.isPickable = false;\n    var length = 512;\n    var dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\n    dynamicTexture.hasAlpha = true;\n    var context = dynamicTexture.getContext();\n    var centerX = length / 2;\n    var centerY = length / 2;\n    var radius = 200;\n    context.beginPath();\n    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n    context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\n    context.fill();\n    context.lineWidth = 10;\n    context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\n    context.stroke();\n    context.closePath();\n    dynamicTexture.update();\n    var teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\n    teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n    teleportationTarget.material = teleportationCircleMaterial;\n    var torus = TorusBuilder.CreateTorus(\"torusTeleportation\", {\n      diameter: 0.75,\n      thickness: 0.1,\n      tessellation: 20\n    }, sceneToRenderTo);\n    torus.isPickable = false;\n    torus.parent = teleportationTarget;\n\n    if (!this._options.defaultTargetMeshOptions.disableAnimation) {\n      var animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n      var keys = [];\n      keys.push({\n        frame: 0,\n        value: 0\n      });\n      keys.push({\n        frame: 30,\n        value: 0.4\n      });\n      keys.push({\n        frame: 60,\n        value: 0\n      });\n      animationInnerCircle.setKeys(keys);\n      var easingFunction = new SineEase();\n      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n      animationInnerCircle.setEasingFunction(easingFunction);\n      torus.animations = [];\n      torus.animations.push(animationInnerCircle);\n      sceneToRenderTo.beginAnimation(torus, 0, 60, true);\n    }\n\n    var cone = CylinderBuilder.CreateCylinder(\"rotationCone\", {\n      diameterTop: 0,\n      tessellation: 4\n    }, sceneToRenderTo);\n    cone.isPickable = false;\n    cone.scaling.set(0.5, 0.12, 0.2);\n    cone.rotate(Axis.X, Math.PI / 2);\n    cone.position.z = 0.6;\n    cone.parent = torus;\n\n    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\n      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n    } else {\n      var torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\n      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\n\n      if (torusConeMaterial.disableLighting) {\n        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\n      } else {\n        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\n      }\n\n      torusConeMaterial.alpha = 0.9;\n      torus.material = torusConeMaterial;\n      cone.material = torusConeMaterial;\n      this._teleportationRingMaterial = torusConeMaterial;\n    }\n\n    if (this._options.renderingGroupId !== undefined) {\n      teleportationTarget.renderingGroupId = this._options.renderingGroupId;\n      torus.renderingGroupId = this._options.renderingGroupId;\n      cone.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    this._options.teleportationTargetMesh = teleportationTarget;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._detachController = function (xrControllerUniqueId) {\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.teleportationComponent) {\n      if (controllerData.onAxisChangedObserver) {\n        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\n      }\n\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    } // remove from the map\n\n\n    delete this._controllers[xrControllerUniqueId];\n  };\n\n  WebXRMotionControllerTeleportation.prototype._findClosestSnapPointWithRadius = function (realPosition, radius) {\n    if (radius === void 0) {\n      radius = this._options.snapToPositionRadius || 0.8;\n    }\n\n    var closestPoint = null;\n    var closestDistance = Number.MAX_VALUE;\n\n    if (this._snapToPositions.length) {\n      var radiusSquared_1 = radius * radius;\n\n      this._snapToPositions.forEach(function (position) {\n        var dist = Vector3.DistanceSquared(position, realPosition);\n\n        if (dist <= radiusSquared_1 && dist < closestDistance) {\n          closestDistance = dist;\n          closestPoint = position;\n        }\n      });\n    }\n\n    return closestPoint;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._setTargetMeshPosition = function (newPosition) {\n    if (!this._options.teleportationTargetMesh) {\n      return;\n    }\n\n    var snapPosition = this._findClosestSnapPointWithRadius(newPosition);\n\n    this._snappedToPoint = !!snapPosition;\n\n    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\n    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\n    }\n\n    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\n\n    this._options.teleportationTargetMesh.position.y += 0.01;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._setTargetMeshVisibility = function (visible) {\n    if (!this._options.teleportationTargetMesh) {\n      return;\n    }\n\n    if (this._options.teleportationTargetMesh.isVisible === visible) {\n      return;\n    }\n\n    this._options.teleportationTargetMesh.isVisible = visible;\n\n    this._options.teleportationTargetMesh.getChildren(undefined, false).forEach(function (m) {\n      m.isVisible = visible;\n    });\n\n    if (!visible) {\n      if (this._quadraticBezierCurve) {\n        this._quadraticBezierCurve.dispose();\n\n        this._quadraticBezierCurve = null;\n      }\n\n      if (this._selectionFeature) {\n        this._selectionFeature.attach();\n      }\n    } else {\n      if (this._selectionFeature) {\n        this._selectionFeature.detach();\n      }\n    }\n  };\n\n  WebXRMotionControllerTeleportation.prototype._showParabolicPath = function (pickInfo) {\n    if (!pickInfo.pickedPoint) {\n      return;\n    }\n\n    var controllerData = this._controllers[this._currentTeleportationControllerId];\n    var quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);\n\n    if (!this._options.generateRayPathMesh) {\n      this._quadraticBezierCurve = LinesBuilder.CreateLines(\"teleportation path line\", {\n        points: quadraticBezierVectors.getPoints(),\n        instance: this._quadraticBezierCurve,\n        updatable: true\n      });\n    } else {\n      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints());\n    }\n\n    this._quadraticBezierCurve.isPickable = false;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._teleportForward = function (controllerId) {\n    var controllerData = this._controllers[controllerId];\n\n    if (!controllerData || !controllerData.teleportationState.forward) {\n      return;\n    }\n\n    controllerData.teleportationState.forward = false;\n    this._currentTeleportationControllerId = \"\";\n\n    if (this.snapPointsOnly && !this._snappedToPoint) {\n      return;\n    } // do the movement forward here\n\n\n    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\n      var height = this._options.xrInput.xrCamera.realWorldHeight;\n\n      this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n\n      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\n\n      this._options.xrInput.xrCamera.position.y += height;\n\n      this._options.xrInput.xrCamera.rotationQuaternion.multiplyInPlace(Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0));\n\n      this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n    }\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the webxr specs version\r\n   */\n\n  WebXRMotionControllerTeleportation.Version = 1;\n  return WebXRMotionControllerTeleportation;\n}(WebXRAbstractFeature);\n\nexport { WebXRMotionControllerTeleportation };\nWebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRMotionControllerTeleportation(xrSessionManager, options);\n  };\n}, WebXRMotionControllerTeleportation.Version, true);","map":null,"metadata":{},"sourceType":"module"}