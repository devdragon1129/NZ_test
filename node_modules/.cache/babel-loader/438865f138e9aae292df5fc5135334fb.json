{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { FilesInputStore } from \"../Misc/filesInputStore\";\nimport { Scene } from \"../scene\";\nimport { Engine } from \"../Engines/engine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"../Misc/logger\";\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\n\nexport var SceneLoaderAnimationGroupLoadingMode;\n\n(function (SceneLoaderAnimationGroupLoadingMode) {\n  /**\r\n   * Reset all old animations to initial state then dispose them.\r\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\n  /**\r\n   * Stop all old animations.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\n  /**\r\n   * Restart old animations from first frame.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\n  /**\r\n   * Old animations remains untouched.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/how_to/load_from_any_file_type\r\n */\n\n\nvar SceneLoader =\n/** @class */\nfunction () {\n  function SceneLoader() {}\n\n  Object.defineProperty(SceneLoader, \"ForceFullSceneLoadingForIncremental\", {\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\n    get: function get() {\n      return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\n    },\n    set: function set(value) {\n      SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"ShowLoadingScreen\", {\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\n    get: function get() {\n      return SceneLoaderFlags.ShowLoadingScreen;\n    },\n    set: function set(value) {\n      SceneLoaderFlags.ShowLoadingScreen = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"loggingLevel\", {\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\n    get: function get() {\n      return SceneLoaderFlags.loggingLevel;\n    },\n    set: function set(value) {\n      SceneLoaderFlags.loggingLevel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"CleanBoneMatrixWeights\", {\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\n    get: function get() {\n      return SceneLoaderFlags.CleanBoneMatrixWeights;\n    },\n    set: function set(value) {\n      SceneLoaderFlags.CleanBoneMatrixWeights = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the default plugin (used to load Babylon files)\r\n   * @returns the .babylon plugin\r\n   */\n\n  SceneLoader.GetDefaultPlugin = function () {\n    return SceneLoader._registeredPlugins[\".babylon\"];\n  };\n\n  SceneLoader._GetPluginForExtension = function (extension) {\n    var registeredPlugin = SceneLoader._registeredPlugins[extension];\n\n    if (registeredPlugin) {\n      return registeredPlugin;\n    }\n\n    Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type\");\n    return SceneLoader.GetDefaultPlugin();\n  };\n\n  SceneLoader._GetPluginForDirectLoad = function (data) {\n    for (var extension in SceneLoader._registeredPlugins) {\n      var plugin = SceneLoader._registeredPlugins[extension].plugin;\n\n      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n        return SceneLoader._registeredPlugins[extension];\n      }\n    }\n\n    return SceneLoader.GetDefaultPlugin();\n  };\n\n  SceneLoader._GetPluginForFilename = function (sceneFilename) {\n    var queryStringPosition = sceneFilename.indexOf(\"?\");\n\n    if (queryStringPosition !== -1) {\n      sceneFilename = sceneFilename.substring(0, queryStringPosition);\n    }\n\n    var dotPosition = sceneFilename.lastIndexOf(\".\");\n    var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\n    return SceneLoader._GetPluginForExtension(extension);\n  };\n\n  SceneLoader._GetDirectLoad = function (sceneFilename) {\n    if (sceneFilename.substr(0, 5) === \"data:\") {\n      return sceneFilename.substr(5);\n    }\n\n    return null;\n  };\n\n  SceneLoader._LoadData = function (fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {\n    var directLoad = SceneLoader._GetDirectLoad(fileInfo.name);\n\n    var registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.name) : SceneLoader._GetPluginForFilename(fileInfo.name);\n    var plugin;\n\n    if (registeredPlugin.plugin.createPlugin !== undefined) {\n      plugin = registeredPlugin.plugin.createPlugin();\n    } else {\n      plugin = registeredPlugin.plugin;\n    }\n\n    if (!plugin) {\n      throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\n    }\n\n    SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\n\n    if (directLoad) {\n      if (plugin.directLoad) {\n        var result = plugin.directLoad(scene, directLoad);\n\n        if (result.then) {\n          result.then(function (data) {\n            onSuccess(plugin, data);\n          }).catch(function (error) {\n            onError(\"Error in directLoad of _loadData: \" + error, error);\n          });\n        } else {\n          onSuccess(plugin, result);\n        }\n      } else {\n        onSuccess(plugin, directLoad);\n      }\n\n      return plugin;\n    }\n\n    var useArrayBuffer = registeredPlugin.isBinary;\n\n    var dataCallback = function dataCallback(data, responseURL) {\n      if (scene.isDisposed) {\n        onError(\"Scene has been disposed\");\n        return;\n      }\n\n      onSuccess(plugin, data, responseURL);\n    };\n\n    var request = null;\n    var pluginDisposed = false;\n    var onDisposeObservable = plugin.onDisposeObservable;\n\n    if (onDisposeObservable) {\n      onDisposeObservable.add(function () {\n        pluginDisposed = true;\n\n        if (request) {\n          request.abort();\n          request = null;\n        }\n\n        onDispose();\n      });\n    }\n\n    var manifestChecked = function manifestChecked() {\n      if (pluginDisposed) {\n        return;\n      }\n\n      var successCallback = function successCallback(data, request) {\n        dataCallback(data, request ? request.responseURL : undefined);\n      };\n\n      var errorCallback = function errorCallback(error) {\n        onError(error.message, error);\n      };\n\n      request = plugin.requestFile ? plugin.requestFile(scene, fileInfo.url, successCallback, onProgress, useArrayBuffer, errorCallback) : scene._requestFile(fileInfo.url, successCallback, onProgress, true, useArrayBuffer, errorCallback);\n    };\n\n    var file = fileInfo.file || FilesInputStore.FilesToLoad[fileInfo.name.toLowerCase()];\n\n    if (fileInfo.rootUrl.indexOf(\"file:\") === -1 || fileInfo.rootUrl.indexOf(\"file:\") !== -1 && !file) {\n      var engine = scene.getEngine();\n      var canUseOfflineSupport = engine.enableOfflineSupport;\n\n      if (canUseOfflineSupport) {\n        // Also check for exceptions\n        var exceptionFound = false;\n\n        for (var _i = 0, _a = scene.disableOfflineSupportExceptionRules; _i < _a.length; _i++) {\n          var regex = _a[_i];\n\n          if (regex.test(fileInfo.url)) {\n            exceptionFound = true;\n            break;\n          }\n        }\n\n        canUseOfflineSupport = !exceptionFound;\n      }\n\n      if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\n        // Checking if a manifest file has been set for this scene and if offline mode has been requested\n        scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\n      } else {\n        manifestChecked();\n      }\n    } // Loading file from disk via input file or drag'n'drop\n    else {\n      if (file) {\n        var errorCallback = function errorCallback(error) {\n          onError(error.message, error);\n        };\n\n        request = plugin.readFile ? plugin.readFile(scene, file, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._readFile(file, dataCallback, onProgress, useArrayBuffer, errorCallback);\n      } else {\n        onError(\"Unable to find file named \" + fileInfo.name);\n      }\n    }\n\n    return plugin;\n  };\n\n  SceneLoader._GetFileInfo = function (rootUrl, sceneFilename) {\n    var url;\n    var name;\n    var file = null;\n\n    if (!sceneFilename) {\n      url = rootUrl;\n      name = Tools.GetFilename(rootUrl);\n      rootUrl = Tools.GetFolderPath(rootUrl);\n    } else if (sceneFilename.name) {\n      var sceneFile = sceneFilename;\n      url = rootUrl + sceneFile.name;\n      name = sceneFile.name;\n      file = sceneFile;\n    } else {\n      var filename = sceneFilename;\n\n      if (filename.substr(0, 1) === \"/\") {\n        Tools.Error(\"Wrong sceneFilename parameter\");\n        return null;\n      }\n\n      url = rootUrl + filename;\n      name = filename;\n    }\n\n    return {\n      url: url,\n      rootUrl: rootUrl,\n      name: name,\n      file: file\n    };\n  }; // Public functions\n\n  /**\r\n   * Gets a plugin that can load the given extension\r\n   * @param extension defines the extension to load\r\n   * @returns a plugin or null if none works\r\n   */\n\n\n  SceneLoader.GetPluginForExtension = function (extension) {\n    return SceneLoader._GetPluginForExtension(extension).plugin;\n  };\n  /**\r\n   * Gets a boolean indicating that the given extension can be loaded\r\n   * @param extension defines the extension to load\r\n   * @returns true if the extension is supported\r\n   */\n\n\n  SceneLoader.IsPluginForExtensionAvailable = function (extension) {\n    return !!SceneLoader._registeredPlugins[extension];\n  };\n  /**\r\n   * Adds a new plugin to the list of registered plugins\r\n   * @param plugin defines the plugin to add\r\n   */\n\n\n  SceneLoader.RegisterPlugin = function (plugin) {\n    if (typeof plugin.extensions === \"string\") {\n      var extension = plugin.extensions;\n      SceneLoader._registeredPlugins[extension.toLowerCase()] = {\n        plugin: plugin,\n        isBinary: false\n      };\n    } else {\n      var extensions = plugin.extensions;\n      Object.keys(extensions).forEach(function (extension) {\n        SceneLoader._registeredPlugins[extension.toLowerCase()] = {\n          plugin: plugin,\n          isBinary: extensions[extension].isBinary\n        };\n      });\n    }\n  };\n  /**\r\n   * Import meshes into a scene\r\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene the instance of BABYLON.Scene to append to\r\n   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.ImportMesh = function (meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to import mesh to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function disposeHandler() {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function errorHandler(message, exception) {\n      var errorMessage = \"Unable to import meshes from \" + fileInfo.url + \": \" + message;\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback: \" + e, e);\n      }\n    } : undefined;\n\n    var successHandler = function successHandler(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\n      scene.importedMeshesFiles.push(fileInfo.url);\n\n      if (onSuccess) {\n        try {\n          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback: \" + e, e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data, responseURL) {\n      if (plugin.rewriteRootURL) {\n        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\n      }\n\n      if (plugin.importMesh) {\n        var syncedPlugin = plugin;\n        var meshes = new Array();\n        var particleSystems = new Array();\n        var skeletons = new Array();\n\n        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler(meshes, particleSystems, skeletons, [], [], [], []);\n      } else {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (result) {\n          scene.loadingPluginName = plugin.name;\n          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Import meshes into a scene\r\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene the instance of BABYLON.Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n   */\n\n\n  SceneLoader.ImportMeshAsync = function (meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\n        resolve({\n          meshes: meshes,\n          particleSystems: particleSystems,\n          skeletons: skeletons,\n          animationGroups: animationGroups,\n          transformNodes: transformNodes,\n          geometries: geometries,\n          lights: lights\n        });\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Load a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.Load = function (rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (engine === void 0) {\n      engine = EngineStore.LastCreatedEngine;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!engine) {\n      Tools.Error(\"No engine available\");\n      return null;\n    }\n\n    return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\n  };\n  /**\r\n   * Load a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded scene\r\n   */\n\n\n  SceneLoader.LoadAsync = function (rootUrl, sceneFilename, engine, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (engine === void 0) {\n      engine = EngineStore.LastCreatedEngine;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.Load(rootUrl, sceneFilename, engine, function (scene) {\n        resolve(scene);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Append a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.Append = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    var _this = this;\n\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to append to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    if (SceneLoader.ShowLoadingScreen && !this._showingLoadingScreen) {\n      this._showingLoadingScreen = true;\n      scene.getEngine().displayLoadingUI();\n      scene.executeWhenReady(function () {\n        scene.getEngine().hideLoadingUI();\n        _this._showingLoadingScreen = false;\n      });\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function disposeHandler() {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function errorHandler(message, exception) {\n      var errorMessage = \"Unable to load from \" + fileInfo.url + (message ? \": \" + message : \"\");\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n\n    var successHandler = function successHandler() {\n      if (onSuccess) {\n        try {\n          onSuccess(scene);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\n      if (plugin.load) {\n        var syncedPlugin = plugin;\n\n        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler();\n      } else {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function () {\n          scene.loadingPluginName = plugin.name;\n          successHandler();\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Append a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The given scene\r\n   */\n\n\n  SceneLoader.AppendAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.Append(rootUrl, sceneFilename, scene, function (scene) {\n        resolve(scene);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Load a scene into an asset container\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.LoadAssetContainer = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to load asset container to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function disposeHandler() {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function errorHandler(message, exception) {\n      var errorMessage = \"Unable to load assets from \" + fileInfo.url + (message ? \": \" + message : \"\");\n\n      if (exception && exception.message) {\n        errorMessage += \" (\" + exception.message + \")\";\n      }\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n\n    var successHandler = function successHandler(assets) {\n      if (onSuccess) {\n        try {\n          onSuccess(assets);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\n      if (plugin.loadAssetContainer) {\n        var syncedPlugin = plugin;\n        var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\n\n        if (!assetContainer) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler(assetContainer);\n      } else if (plugin.loadAssetContainerAsync) {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (assetContainer) {\n          scene.loadingPluginName = plugin.name;\n          successHandler(assetContainer);\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      } else {\n        errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Load a scene into an asset container\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n   * @param scene is the instance of Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded asset container\r\n   */\n\n\n  SceneLoader.LoadAssetContainerAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, function (assetContainer) {\n        resolve(assetContainer);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Import animations from a file into a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   */\n\n\n  SceneLoader.ImportAnimations = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (overwriteAnimations === void 0) {\n      overwriteAnimations = true;\n    }\n\n    if (animationGroupLoadingMode === void 0) {\n      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to load animations to\");\n      return;\n    }\n\n    if (overwriteAnimations) {\n      // Reset, stop and dispose all animations before loading new ones\n      for (var _i = 0, _a = scene.animatables; _i < _a.length; _i++) {\n        var animatable = _a[_i];\n        animatable.reset();\n      }\n\n      scene.stopAllAnimations();\n      scene.animationGroups.slice().forEach(function (animationGroup) {\n        animationGroup.dispose();\n      });\n      var nodes = scene.getNodes();\n      nodes.forEach(function (node) {\n        if (node.animations) {\n          node.animations = [];\n        }\n      });\n    } else {\n      switch (animationGroupLoadingMode) {\n        case SceneLoaderAnimationGroupLoadingMode.Clean:\n          scene.animationGroups.slice().forEach(function (animationGroup) {\n            animationGroup.dispose();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.Stop:\n          scene.animationGroups.forEach(function (animationGroup) {\n            animationGroup.stop();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.Sync:\n          scene.animationGroups.forEach(function (animationGroup) {\n            animationGroup.reset();\n            animationGroup.restart();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.NoSync:\n          // nothing to do\n          break;\n\n        default:\n          Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\n          return;\n      }\n    }\n\n    var startingIndexForNewAnimatables = scene.animatables.length;\n\n    var onAssetContainerLoaded = function onAssetContainerLoaded(container) {\n      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\n      container.dispose();\n      scene.onAnimationFileImportedObservable.notifyObservers(scene);\n\n      if (onSuccess) {\n        onSuccess(scene);\n      }\n    };\n\n    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\n  };\n  /**\r\n   * Import animations from a file into a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns the updated scene with imported animations\r\n   */\n\n\n  SceneLoader.ImportAnimationsAsync = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (overwriteAnimations === void 0) {\n      overwriteAnimations = true;\n    }\n\n    if (animationGroupLoadingMode === void 0) {\n      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, function (_scene) {\n        resolve(_scene);\n      }, onProgress, function (_scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * No logging while loading\r\n   */\n\n\n  SceneLoader.NO_LOGGING = 0;\n  /**\r\n   * Minimal logging while loading\r\n   */\n\n  SceneLoader.MINIMAL_LOGGING = 1;\n  /**\r\n   * Summary logging while loading\r\n   */\n\n  SceneLoader.SUMMARY_LOGGING = 2;\n  /**\r\n   * Detailled logging while loading\r\n   */\n\n  SceneLoader.DETAILED_LOGGING = 3; // Members\n\n  /**\r\n   * Event raised when a plugin is used to load a scene\r\n   */\n\n  SceneLoader.OnPluginActivatedObservable = new Observable();\n  SceneLoader._registeredPlugins = {};\n  SceneLoader._showingLoadingScreen = false;\n  return SceneLoader;\n}();\n\nexport { SceneLoader };","map":null,"metadata":{},"sourceType":"module"}