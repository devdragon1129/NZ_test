{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { Texture } from '../../../Textures/texture';\n/**\r\n * Base block used as input for post process\r\n */\n\nvar CurrentScreenBlock =\n/** @class */\nfunction (_super) {\n  __extends(CurrentScreenBlock, _super);\n  /**\r\n   * Create a new CurrentScreenBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function CurrentScreenBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.VertexAndFragment) || this;\n\n    _this._samplerName = \"textureSampler\";\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\n\n    _this.convertToGammaSpace = false;\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\n\n    _this.convertToLinearSpace = false;\n    _this._isUnique = false;\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\n\n    _this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this._inputs[0]._prioritizeVertex = false;\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  CurrentScreenBlock.prototype.getClassName = function () {\n    return \"CurrentScreenBlock\";\n  };\n\n  Object.defineProperty(CurrentScreenBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the uv input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CurrentScreenBlock.prototype, \"rgba\", {\n    /**\r\n     * Gets the rgba output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CurrentScreenBlock.prototype, \"rgb\", {\n    /**\r\n     * Gets the rgb output component\r\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CurrentScreenBlock.prototype, \"r\", {\n    /**\r\n     * Gets the r output component\r\n     */\n    get: function get() {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CurrentScreenBlock.prototype, \"g\", {\n    /**\r\n     * Gets the g output component\r\n     */\n    get: function get() {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CurrentScreenBlock.prototype, \"b\", {\n    /**\r\n     * Gets the b output component\r\n     */\n    get: function get() {\n      return this._outputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CurrentScreenBlock.prototype, \"a\", {\n    /**\r\n     * Gets the a output component\r\n     */\n    get: function get() {\n      return this._outputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initialize the block and prepare the context for build\r\n   * @param state defines the state that will be used for the build\r\n   */\n\n  CurrentScreenBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"textureSampler\");\n  };\n\n  Object.defineProperty(CurrentScreenBlock.prototype, \"target\", {\n    get: function get() {\n      if (!this.uv.isConnected) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      if (this.uv.sourceBlock.isInput) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      return NodeMaterialBlockTargets.Fragment;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  CurrentScreenBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\n  };\n\n  CurrentScreenBlock.prototype.isReady = function () {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  CurrentScreenBlock.prototype._injectVertexCode = function (state) {\n    var uvInput = this.uv;\n\n    if (uvInput.connectedPoint.ownerBlock.isInput) {\n      var uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n\n      if (!uvInputOwnerBlock.isAttribute) {\n        state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\n      }\n    }\n\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n\n    state._emitVaryingFromString(this._mainUVName, \"vec2\");\n\n    state.compilationString += this._mainUVName + \" = \" + uvInput.associatedVariableName + \".xy;\\r\\n\";\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInVertexShader;\n    })) {\n      return;\n    }\n\n    this._writeTextureRead(state, true);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name, true);\n      }\n    }\n  };\n\n  CurrentScreenBlock.prototype._writeTextureRead = function (state, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    var uvInput = this.uv;\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + uvInput.associatedVariableName + \");\\r\\n\";\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + uvInput.associatedVariableName + \");\\r\\n\";\n      return;\n    }\n\n    state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + this._mainUVName + \");\\r\\n\";\n  };\n\n  CurrentScreenBlock.prototype._writeOutput = function (state, output, swizzle, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n      return;\n    }\n\n    state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n    state.compilationString += \"#ifdef \" + this._linearDefineName + \"\\r\\n\";\n    state.compilationString += output.associatedVariableName + \" = toGammaSpace(\" + output.associatedVariableName + \");\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef \" + this._gammaDefineName + \"\\r\\n\";\n    state.compilationString += output.associatedVariableName + \" = toLinearSpace(\" + output.associatedVariableName + \");\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n  };\n\n  CurrentScreenBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n\n    if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\n      state.sharedData.blockingBlocks.push(this);\n    }\n\n    if (state.sharedData.textureBlocks.indexOf(this) < 0) {\n      state.sharedData.textureBlocks.push(this);\n    }\n\n    if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\n      state.sharedData.blocksWithDefines.push(this);\n    }\n\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      state._emit2DSampler(this._samplerName);\n\n      this._injectVertexCode(state);\n\n      return;\n    } // Fragment\n\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInFragmentShader;\n    })) {\n      return;\n    }\n\n    state._emit2DSampler(this._samplerName);\n\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    var comments = \"//\" + this.name;\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    this._writeTextureRead(state);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n\n    return this;\n  };\n\n  CurrentScreenBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n\n    if (this.texture) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  CurrentScreenBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  };\n\n  return CurrentScreenBlock;\n}(NodeMaterialBlock);\n\nexport { CurrentScreenBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.CurrentScreenBlock\"] = CurrentScreenBlock;","map":null,"metadata":{},"sourceType":"module"}