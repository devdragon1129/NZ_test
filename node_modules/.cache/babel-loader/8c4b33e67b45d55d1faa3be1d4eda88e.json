{"ast":null,"code":"import { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\n/**\r\n * Represents one particle of a points cloud system.\r\n */\n\nvar CloudPoint =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a Point Cloud object.\r\n   * Don't create particles manually, use instead the PCS internal tools like _addParticle()\r\n   * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\r\n   * @param group (PointsGroup) is the group the particle belongs to\r\n   * @param groupId (integer) is the group identifier in the PCS.\r\n   * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\r\n   * @param pcs defines the PCS it is associated to\r\n   */\n  function CloudPoint(particleIndex, group, groupId, idxInGroup, pcs) {\n    /**\r\n     * particle global index\r\n     */\n    this.idx = 0;\n    /**\r\n     * The color of the particle\r\n     */\n\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\r\n     * The world space position of the particle.\r\n     */\n\n    this.position = Vector3.Zero();\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\n\n    this.rotation = Vector3.Zero();\n    /**\r\n     * The uv of the particle.\r\n     */\n\n    this.uv = new Vector2(0.0, 0.0);\n    /**\r\n     * The current speed of the particle.\r\n     */\n\n    this.velocity = Vector3.Zero();\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\n\n    this.pivot = Vector3.Zero();\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\n\n    this.translateFromPivot = false;\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @hidden\r\n     */\n\n    this._pos = 0;\n    /**\r\n     * @hidden Index of this particle in the global \"indices\" array (Internal use)\r\n     */\n\n    this._ind = 0;\n    /**\r\n     * Group id of this particle\r\n     */\n\n    this.groupId = 0;\n    /**\r\n     * Index of the particle in its group id (Internal use)\r\n     */\n\n    this.idxInGroup = 0;\n    /**\r\n     * @hidden Still set as invisible in order to skip useless computations (Internal use)\r\n     */\n\n    this._stillInvisible = false;\n    /**\r\n     * @hidden Last computed particle rotation matrix\r\n     */\n\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\n\n    this.parentId = null;\n    /**\r\n     * @hidden Internal global position in the PCS.\r\n     */\n\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this._group = group;\n    this.groupId = groupId;\n    this.idxInGroup = idxInGroup;\n    this._pcs = pcs;\n  }\n\n  Object.defineProperty(CloudPoint.prototype, \"size\", {\n    /**\r\n     * get point size\r\n     */\n    get: function get() {\n      return this.size;\n    },\n\n    /**\r\n     * Set point size\r\n     */\n    set: function set(scale) {\n      this.size = scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CloudPoint.prototype, \"quaternion\", {\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\n    get: function get() {\n      return this.rotationQuaternion;\n    },\n\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\n    set: function set(q) {\n      this.rotationQuaternion = q;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns a boolean. True if the particle intersects a mesh, else false\r\n   * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\r\n   * @param target is the object (point or mesh) what the intersection is computed against\r\n   * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bouding sphere is used\r\n   * @returns true if it intersects\r\n   */\n\n  CloudPoint.prototype.intersectsMesh = function (target, isSphere) {\n    if (!target._boundingInfo) {\n      return false;\n    }\n\n    isSphere = isSphere ? isSphere : false;\n\n    if (isSphere) {\n      return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n    } else {\n      var maxX = 0;\n      var minX = 0;\n      var maxY = 0;\n      var minY = 0;\n      var maxZ = 0;\n      var minZ = 0;\n      maxX = target.getBoundingInfo().boundingBox.maximumWorld.x;\n      minX = target.getBoundingInfo().boundingBox.minimumWorld.x;\n      maxY = target.getBoundingInfo().boundingBox.maximumWorld.y;\n      minY = target.getBoundingInfo().boundingBox.minimumWorld.y;\n      maxZ = target.getBoundingInfo().boundingBox.maximumWorld.z;\n      minZ = target.getBoundingInfo().boundingBox.minimumWorld.z;\n      var x = this.position.x + this._pcs.mesh.position.x;\n      var y = this.position.y + this._pcs.mesh.position.y;\n      var z = this.position.z + this._pcs.mesh.position.z;\n      return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n    }\n  };\n  /**\r\n   * get the rotation matrix of the particle\r\n   * @hidden\r\n   */\n\n\n  CloudPoint.prototype.getRotationMatrix = function (m) {\n    var quaternion;\n\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      var rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n\n    quaternion.toRotationMatrix(m);\n  };\n\n  return CloudPoint;\n}();\n\nexport { CloudPoint };\n/**\r\n * Represents a group of points in a points cloud system\r\n *  * PCS internal tool, don't use it manually.\r\n */\n\nvar PointsGroup =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a points group object. This is an internal reference to produce particles for the PCS.\r\n   * PCS internal tool, don't use it manually.\r\n   * @hidden\r\n   */\n  function PointsGroup(id, posFunction) {\n    this.groupID = id;\n    this._positionFunction = posFunction;\n  }\n\n  return PointsGroup;\n}();\n\nexport { PointsGroup };","map":null,"metadata":{},"sourceType":"module"}