{"ast":null,"code":"import { PostProcess } from \"../PostProcesses/postProcess\";\nimport \"../Shaders/rgbdDecode.fragment\";\nimport \"../Engines/Extensions/engine.renderTarget\";\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\n\nvar RGBDTextureTools =\n/** @class */\nfunction () {\n  function RGBDTextureTools() {}\n  /**\r\n   * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n   * @param texture the texture to expand.\r\n   */\n\n\n  RGBDTextureTools.ExpandRGBDTexture = function (texture) {\n    var internalTexture = texture._texture;\n\n    if (!internalTexture || !texture.isRGBD) {\n      return;\n    } // Gets everything ready.\n\n\n    var engine = internalTexture.getEngine();\n    var caps = engine.getCaps();\n    var expandTexture = false; // If half float available we can uncompress the texture\n\n    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 2;\n    } // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 1;\n    }\n\n    if (expandTexture) {\n      // Do not use during decode.\n      internalTexture.isReady = false;\n      internalTexture._isRGBD = false;\n      internalTexture.invertY = false;\n    }\n\n    texture.onLoadObservable.addOnce(function () {\n      // Expand the texture if possible\n      if (expandTexture) {\n        // Simply run through the decode PP.\n        var rgbdPostProcess_1 = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false); // Hold the output of the decoding.\n\n        var expandedTexture_1 = engine.createRenderTargetTexture(internalTexture.width, {\n          generateDepthBuffer: false,\n          generateMipMaps: false,\n          generateStencilBuffer: false,\n          samplingMode: internalTexture.samplingMode,\n          type: internalTexture.type,\n          format: 5\n        });\n        rgbdPostProcess_1.getEffect().executeWhenCompiled(function () {\n          // PP Render Pass\n          rgbdPostProcess_1.onApply = function (effect) {\n            effect._bindTexture(\"textureSampler\", internalTexture);\n\n            effect.setFloat2(\"scale\", 1, 1);\n          };\n\n          texture.getScene().postProcessManager.directRender([rgbdPostProcess_1], expandedTexture_1, true); // Cleanup\n\n          engine.restoreDefaultFramebuffer();\n\n          engine._releaseTexture(internalTexture);\n\n          engine._releaseFramebufferObjects(expandedTexture_1);\n\n          if (rgbdPostProcess_1) {\n            rgbdPostProcess_1.dispose();\n          } // Internal Swap\n\n\n          expandedTexture_1._swapAndDie(internalTexture); // Ready to get rolling again.\n\n\n          internalTexture.isReady = true;\n        });\n      }\n    });\n  };\n\n  return RGBDTextureTools;\n}();\n\nexport { RGBDTextureTools };","map":null,"metadata":{},"sourceType":"module"}