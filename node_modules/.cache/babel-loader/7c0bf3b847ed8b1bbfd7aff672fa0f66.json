{"ast":null,"code":"import { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\nimport { ImageProcessingPostProcess } from \"../PostProcesses/imageProcessingPostProcess\";\nimport { _DevTools } from '../Misc/devTools';\nimport { Color4 } from \"../Maths/math.color\";\nimport { Material } from '../Materials/material';\nimport { GeometryBufferRenderer } from '../Rendering/geometryBufferRenderer';\n/**\r\n * Renders a pre pass of the scene\r\n * This means every mesh in the scene will be rendered to a render target texture\r\n * And then this texture will be composited to the rendering canvas with post processes\r\n * It is necessary for effects like subsurface scattering or deferred shading\r\n */\n\nvar PrePassRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instanciates a prepass renderer\r\n   * @param scene The scene\r\n   */\n  function PrePassRenderer(scene) {\n    this._textureFormats = [{\n      type: 0,\n      format: 2\n    }, {\n      type: 1,\n      format: 2\n    }, {\n      type: 2,\n      format: 2\n    }, {\n      type: 3,\n      format: 0\n    }, {\n      type: 4,\n      format: 2\n    }, {\n      type: 5,\n      format: 2\n    }, {\n      type: 6,\n      format: 0\n    }];\n    /**\r\n     * To save performance, we can excluded skinned meshes from the prepass\r\n     */\n\n    this.excludedSkinnedMesh = [];\n    /**\r\n     * Force material to be excluded from the prepass\r\n     * Can be useful when `useGeometryBufferFallback` is set to `true`\r\n     * and you don't want a material to show in the effect.\r\n     */\n\n    this.excludedMaterials = [];\n    this._textureIndices = [];\n    this._isDirty = false;\n    /**\r\n     * Number of textures in the multi render target texture where the scene is directly rendered\r\n     */\n\n    this.mrtCount = 0;\n    this._postProcesses = [];\n    this._clearColor = new Color4(0, 0, 0, 0);\n    /**\r\n     * Configuration for prepass effects\r\n     */\n\n    this._effectConfigurations = [];\n    this._mrtFormats = [];\n    this._enabled = false;\n    this._useGeometryBufferFallback = false;\n    /**\r\n     * Set to true to disable gamma transform in PrePass.\r\n     * Can be useful in case you already proceed to gamma transform on a material level\r\n     * and your post processes don't need to be in linear color space.\r\n     */\n\n    this.disableGammaTransform = false;\n    this._scene = scene;\n    this._engine = scene.getEngine();\n\n    PrePassRenderer._SceneComponentInitialization(this._scene);\n\n    this._resetLayout();\n  }\n\n  Object.defineProperty(PrePassRenderer.prototype, \"enabled\", {\n    /**\r\n     * Indicates if the prepass is enabled\r\n     */\n    get: function get() {\n      return this._enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PrePassRenderer.prototype, \"samples\", {\n    /**\r\n     * How many samples are used for MSAA of the scene render target\r\n     */\n    get: function get() {\n      return this.prePassRT.samples;\n    },\n    set: function set(n) {\n      if (!this.imageProcessingPostProcess) {\n        this._createCompositionEffect();\n      }\n\n      this.prePassRT.samples = n;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PrePassRenderer.prototype, \"useGeometryBufferFallback\", {\n    /**\r\n     * Uses the geometry buffer renderer as a fallback for non prepass capable effects\r\n     */\n    get: function get() {\n      return this._useGeometryBufferFallback;\n    },\n    set: function set(value) {\n      this._useGeometryBufferFallback = value;\n\n      if (value) {\n        this._geometryBuffer = this._scene.enableGeometryBufferRenderer();\n\n        if (!this._geometryBuffer) {\n          // Not supported\n          this._useGeometryBufferFallback = false;\n          return;\n        }\n\n        this._geometryBuffer.renderList = [];\n\n        this._geometryBuffer._linkPrePassRenderer(this);\n\n        this._updateGeometryBufferLayout();\n      } else {\n        if (this._geometryBuffer) {\n          this._geometryBuffer._unlinkPrePassRenderer();\n        }\n\n        this._geometryBuffer = null;\n\n        this._scene.disableGeometryBufferRenderer();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  PrePassRenderer.prototype._initializeAttachments = function () {\n    var multiRenderLayout = [];\n    var clearLayout = [false];\n    var defaultLayout = [true];\n\n    for (var i = 0; i < this.mrtCount; i++) {\n      multiRenderLayout.push(true);\n\n      if (i > 0) {\n        clearLayout.push(true);\n        defaultLayout.push(false);\n      }\n    }\n\n    this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);\n    this._clearAttachments = this._engine.buildTextureLayout(clearLayout);\n    this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);\n  };\n\n  PrePassRenderer.prototype._createCompositionEffect = function () {\n    this.prePassRT = new MultiRenderTarget(\"sceneprePassRT\", {\n      width: this._engine.getRenderWidth(),\n      height: this._engine.getRenderHeight()\n    }, this.mrtCount, this._scene, {\n      generateMipMaps: false,\n      generateDepthTexture: true,\n      defaultType: 0,\n      types: this._mrtFormats\n    });\n    this.prePassRT.samples = 1;\n\n    this._initializeAttachments();\n\n    if (this._useGeometryBufferFallback && !this._geometryBuffer) {\n      // Initializes the link with geometry buffer\n      this.useGeometryBufferFallback = true;\n    }\n\n    this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"sceneCompositionPass\", 1, null, undefined, this._engine);\n    this.imageProcessingPostProcess.autoClear = false;\n  };\n\n  Object.defineProperty(PrePassRenderer.prototype, \"isSupported\", {\n    /**\r\n     * Indicates if rendering a prepass is supported\r\n     */\n    get: function get() {\n      return this._engine.webGLVersion > 1 || this._scene.getEngine().getCaps().drawBuffersExtension;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the proper output textures to draw in the engine.\r\n   * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.\r\n   * @param subMesh Submesh on which the effect is applied\r\n   */\n\n  PrePassRenderer.prototype.bindAttachmentsForEffect = function (effect, subMesh) {\n    if (this.enabled) {\n      if (effect._multiTarget) {\n        this._engine.bindAttachments(this._multiRenderAttachments);\n      } else {\n        this._engine.bindAttachments(this._defaultAttachments);\n\n        if (this._geometryBuffer) {\n          var material = subMesh.getMaterial();\n\n          if (material && this.excludedMaterials.indexOf(material) === -1) {\n            this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Restores attachments for single texture draw.\r\n   */\n\n\n  PrePassRenderer.prototype.restoreAttachments = function () {\n    if (this.enabled && this._defaultAttachments) {\n      this._engine.bindAttachments(this._defaultAttachments);\n    }\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  PrePassRenderer.prototype._beforeCameraDraw = function () {\n    if (this._isDirty) {\n      this._update();\n    }\n\n    if (this._geometryBuffer) {\n      this._geometryBuffer.renderList.length = 0;\n    }\n\n    this._bindFrameBuffer();\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  PrePassRenderer.prototype._afterCameraDraw = function () {\n    if (this._enabled) {\n      var firstCameraPP = this._scene.activeCamera && this._scene.activeCamera._getFirstPostProcess();\n\n      if (firstCameraPP && this._postProcesses.length) {\n        this._scene.postProcessManager._prepareFrame();\n      }\n\n      this._scene.postProcessManager.directRender(this._postProcesses, firstCameraPP ? firstCameraPP.inputTexture : null);\n    }\n  };\n\n  PrePassRenderer.prototype._checkRTSize = function () {\n    var requiredWidth = this._engine.getRenderWidth(true);\n\n    var requiredHeight = this._engine.getRenderHeight(true);\n\n    var width = this.prePassRT.getRenderWidth();\n    var height = this.prePassRT.getRenderHeight();\n\n    if (width !== requiredWidth || height !== requiredHeight) {\n      this.prePassRT.resize({\n        width: requiredWidth,\n        height: requiredHeight\n      });\n\n      this._updateGeometryBufferLayout();\n\n      this._bindPostProcessChain();\n    }\n  };\n\n  PrePassRenderer.prototype._bindFrameBuffer = function () {\n    if (this._enabled) {\n      this._checkRTSize();\n\n      var internalTexture = this.prePassRT.getInternalTexture();\n\n      if (internalTexture) {\n        this._engine.bindFramebuffer(internalTexture);\n      }\n    }\n  };\n  /**\r\n   * Clears the scene render target (in the sense of settings pixels to the scene clear color value)\r\n   */\n\n\n  PrePassRenderer.prototype.clear = function () {\n    if (this._enabled) {\n      this._bindFrameBuffer(); // Regular clear color with the scene clear color of the 1st attachment\n\n\n      this._engine.clear(this._scene.clearColor, this._scene.autoClear || this._scene.forceWireframe || this._scene.forcePointsCloud, this._scene.autoClearDepthAndStencil, this._scene.autoClearDepthAndStencil); // Clearing other attachment with 0 on all other attachments\n\n\n      this._engine.bindAttachments(this._clearAttachments);\n\n      this._engine.clear(this._clearColor, true, false, false);\n\n      this._engine.bindAttachments(this._defaultAttachments);\n    }\n  };\n\n  PrePassRenderer.prototype._setState = function (enabled) {\n    this._enabled = enabled;\n    this._scene.prePass = enabled;\n\n    if (this.imageProcessingPostProcess) {\n      this.imageProcessingPostProcess.imageProcessingConfiguration.applyByPostProcess = enabled;\n    }\n  };\n\n  PrePassRenderer.prototype._updateGeometryBufferLayout = function () {\n    if (this._geometryBuffer) {\n      this._geometryBuffer._resetLayout();\n\n      var texturesActivated = [];\n\n      for (var i = 0; i < this._mrtLayout.length; i++) {\n        texturesActivated.push(false);\n      }\n\n      this._geometryBuffer._linkInternalTexture(this.prePassRT.getInternalTexture());\n\n      var matches = [{\n        prePassConstant: 5,\n        geometryBufferConstant: GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE\n      }, {\n        prePassConstant: 1,\n        geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE\n      }, {\n        prePassConstant: 3,\n        geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE\n      }, {\n        prePassConstant: 2,\n        geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE\n      }]; // replace textures in the geometryBuffer RT\n\n      for (var i = 0; i < matches.length; i++) {\n        var index = this._mrtLayout.indexOf(matches[i].prePassConstant);\n\n        if (index !== -1) {\n          this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);\n\n          texturesActivated[index] = true;\n        }\n      }\n\n      this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));\n    }\n  };\n  /**\r\n   * Adds an effect configuration to the prepass.\r\n   * If an effect has already been added, it won't add it twice and will return the configuration\r\n   * already present.\r\n   * @param cfg the effect configuration\r\n   * @return the effect configuration now used by the prepass\r\n   */\n\n\n  PrePassRenderer.prototype.addEffectConfiguration = function (cfg) {\n    // Do not add twice\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].name === cfg.name) {\n        return this._effectConfigurations[i];\n      }\n    }\n\n    this._effectConfigurations.push(cfg);\n\n    return cfg;\n  };\n  /**\r\n   * Returns the index of a texture in the multi render target texture array.\r\n   * @param type Texture type\r\n   * @return The index\r\n   */\n\n\n  PrePassRenderer.prototype.getIndex = function (type) {\n    return this._textureIndices[type];\n  };\n\n  PrePassRenderer.prototype._enable = function () {\n    var _a, _b;\n\n    var previousMrtCount = this.mrtCount;\n\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].enabled) {\n        this._enableTextures(this._effectConfigurations[i].texturesRequired);\n      }\n    }\n\n    if (this.prePassRT && this.mrtCount !== previousMrtCount) {\n      this.prePassRT.updateCount(this.mrtCount, {\n        types: this._mrtFormats\n      });\n    }\n\n    this._updateGeometryBufferLayout();\n\n    this._resetPostProcessChain();\n\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].enabled) {\n        if (!this._effectConfigurations[i].postProcess && this._effectConfigurations[i].createPostProcess) {\n          this._effectConfigurations[i].createPostProcess();\n        }\n\n        if (this._effectConfigurations[i].postProcess) {\n          this._postProcesses.push(this._effectConfigurations[i].postProcess);\n        }\n      }\n    }\n\n    this._initializeAttachments();\n\n    if (!this.imageProcessingPostProcess) {\n      this._createCompositionEffect();\n    }\n\n    var isIPPAlreadyPresent = false;\n\n    if ((_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._postProcesses) {\n      for (var i = 0; i < this._scene.activeCamera._postProcesses.length; i++) {\n        if (((_b = this._scene.activeCamera._postProcesses[i]) === null || _b === void 0 ? void 0 : _b.getClassName()) === \"ImageProcessingPostProcess\") {\n          isIPPAlreadyPresent = true;\n        }\n      }\n    }\n\n    if (!isIPPAlreadyPresent && !this.disableGammaTransform) {\n      this._postProcesses.push(this.imageProcessingPostProcess);\n    }\n\n    this._bindPostProcessChain();\n\n    this._setState(true);\n  };\n\n  PrePassRenderer.prototype._disable = function () {\n    this._setState(false);\n\n    this._resetLayout();\n\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      this._effectConfigurations[i].enabled = false;\n    }\n  };\n\n  PrePassRenderer.prototype._resetLayout = function () {\n    for (var i = 0; i < this._textureFormats.length; i++) {\n      this._textureIndices[this._textureFormats[i].type] = -1;\n    }\n\n    this._textureIndices[4] = 0;\n    this._mrtLayout = [4];\n    this._mrtFormats = [2];\n    this.mrtCount = 1;\n  };\n\n  PrePassRenderer.prototype._resetPostProcessChain = function () {\n    this._postProcesses = [];\n\n    if (this.imageProcessingPostProcess) {\n      this.imageProcessingPostProcess.restoreDefaultInputTexture();\n    }\n\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].postProcess) {\n        this._effectConfigurations[i].postProcess.restoreDefaultInputTexture();\n      }\n    }\n  };\n\n  PrePassRenderer.prototype._bindPostProcessChain = function () {\n    var _a;\n\n    if (this._postProcesses.length) {\n      this._postProcesses[0].inputTexture = this.prePassRT.getInternalTexture();\n    } else {\n      var pp = (_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._getFirstPostProcess();\n\n      if (pp) {\n        pp.inputTexture = this.prePassRT.getInternalTexture();\n      }\n    }\n  };\n  /**\r\n   * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.\r\n   */\n\n\n  PrePassRenderer.prototype.markAsDirty = function () {\n    this._isDirty = true;\n  };\n  /**\r\n   * Enables a texture on the MultiRenderTarget for prepass\r\n   */\n\n\n  PrePassRenderer.prototype._enableTextures = function (types) {\n    for (var i = 0; i < types.length; i++) {\n      var type = types[i];\n\n      if (this._textureIndices[type] === -1) {\n        this._textureIndices[type] = this._mrtLayout.length;\n\n        this._mrtLayout.push(type);\n\n        this._mrtFormats.push(this._textureFormats[type].format);\n\n        this.mrtCount++;\n      }\n    }\n  };\n\n  PrePassRenderer.prototype._update = function () {\n    this._disable();\n\n    var enablePrePass = false;\n\n    for (var i = 0; i < this._scene.materials.length; i++) {\n      if (this._scene.materials[i].setPrePassRenderer(this)) {\n        enablePrePass = true;\n      }\n    }\n\n    var camera = this._scene.activeCamera;\n\n    if (!camera) {\n      return;\n    }\n\n    var postProcesses = camera._postProcesses.filter(function (pp) {\n      return pp != null;\n    });\n\n    if (postProcesses) {\n      for (var i = 0; i < postProcesses.length; i++) {\n        if (postProcesses[i].setPrePassRenderer(this)) {\n          enablePrePass = true;\n        }\n      }\n    }\n\n    this._markAllMaterialsAsPrePassDirty();\n\n    this._isDirty = false;\n\n    if (enablePrePass) {\n      this._enable();\n    }\n\n    if (!this.enabled) {\n      // Prepass disabled, we render only on 1 color attachment\n      this._engine.restoreDefaultFramebuffer();\n\n      this._engine.restoreSingleAttachment();\n    }\n  };\n\n  PrePassRenderer.prototype._markAllMaterialsAsPrePassDirty = function () {\n    var materials = this._scene.materials;\n\n    for (var i = 0; i < materials.length; i++) {\n      materials[i].markAsDirty(Material.PrePassDirtyFlag);\n    }\n  };\n  /**\r\n   * Disposes the prepass renderer.\r\n   */\n\n\n  PrePassRenderer.prototype.dispose = function () {\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].dispose) {\n        this._effectConfigurations[i].dispose();\n      }\n    }\n\n    this.imageProcessingPostProcess.dispose();\n    this.prePassRT.dispose();\n  };\n  /** @hidden */\n\n\n  PrePassRenderer._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"PrePassRendererSceneComponent\");\n  };\n\n  return PrePassRenderer;\n}();\n\nexport { PrePassRenderer };","map":null,"metadata":{},"sourceType":"module"}