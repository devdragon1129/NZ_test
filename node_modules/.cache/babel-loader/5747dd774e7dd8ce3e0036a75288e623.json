{"ast":null,"code":"import { Observable } from \"../../Misc/observable\";\nimport { RenderTargetCreationOptions } from \"../../Materials/Textures/renderTargetCreationOptions\";\nimport { _DevTools } from '../../Misc/devTools';\n/**\r\n * Defines the source of the internal texture\r\n */\n\nexport var InternalTextureSource;\n\n(function (InternalTextureSource) {\n  /**\r\n   * The source of the texture data is unknown\r\n   */\n  InternalTextureSource[InternalTextureSource[\"Unknown\"] = 0] = \"Unknown\";\n  /**\r\n  * Texture data comes from an URL\r\n  */\n\n  InternalTextureSource[InternalTextureSource[\"Url\"] = 1] = \"Url\";\n  /**\r\n   * Texture data is only used for temporary storage\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Temp\"] = 2] = \"Temp\";\n  /**\r\n   * Texture data comes from raw data (ArrayBuffer)\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Raw\"] = 3] = \"Raw\";\n  /**\r\n   * Texture content is dynamic (video or dynamic texture)\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Dynamic\"] = 4] = \"Dynamic\";\n  /**\r\n   * Texture content is generated by rendering to it\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"RenderTarget\"] = 5] = \"RenderTarget\";\n  /**\r\n   * Texture content is part of a multi render target process\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"MultiRenderTarget\"] = 6] = \"MultiRenderTarget\";\n  /**\r\n   * Texture data comes from a cube data file\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Cube\"] = 7] = \"Cube\";\n  /**\r\n   * Texture data comes from a raw cube data\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"CubeRaw\"] = 8] = \"CubeRaw\";\n  /**\r\n   * Texture data come from a prefiltered cube data file\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"CubePrefiltered\"] = 9] = \"CubePrefiltered\";\n  /**\r\n   * Texture content is raw 3D data\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Raw3D\"] = 10] = \"Raw3D\";\n  /**\r\n   * Texture content is raw 2D array data\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Raw2DArray\"] = 11] = \"Raw2DArray\";\n  /**\r\n   * Texture content is a depth texture\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"Depth\"] = 12] = \"Depth\";\n  /**\r\n   * Texture data comes from a raw cube data encoded with RGBD\r\n   */\n\n  InternalTextureSource[InternalTextureSource[\"CubeRawRGBD\"] = 13] = \"CubeRawRGBD\";\n})(InternalTextureSource || (InternalTextureSource = {}));\n/**\r\n * Class used to store data associated with WebGL texture data for the engine\r\n * This class should not be used directly\r\n */\n\n\nvar InternalTexture =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new InternalTexture\r\n   * @param engine defines the engine to use\r\n   * @param source defines the type of data that will be used\r\n   * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n   */\n  function InternalTexture(engine, source, delayAllocation) {\n    if (delayAllocation === void 0) {\n      delayAllocation = false;\n    }\n    /**\r\n     * Defines if the texture is ready\r\n     */\n\n\n    this.isReady = false;\n    /**\r\n     * Defines if the texture is a cube texture\r\n     */\n\n    this.isCube = false;\n    /**\r\n     * Defines if the texture contains 3D data\r\n     */\n\n    this.is3D = false;\n    /**\r\n     * Defines if the texture contains 2D array data\r\n     */\n\n    this.is2DArray = false;\n    /**\r\n     * Defines if the texture contains multiview data\r\n     */\n\n    this.isMultiview = false;\n    /**\r\n     * Gets the URL used to load this texture\r\n     */\n\n    this.url = \"\";\n    /**\r\n     * Gets the sampling mode of the texture\r\n     */\n\n    this.samplingMode = -1;\n    /**\r\n     * Gets a boolean indicating if the texture needs mipmaps generation\r\n     */\n\n    this.generateMipMaps = false;\n    /**\r\n     * Gets the number of samples used by the texture (WebGL2+ only)\r\n     */\n\n    this.samples = 0;\n    /**\r\n     * Gets the type of the texture (int, float...)\r\n     */\n\n    this.type = -1;\n    /**\r\n     * Gets the format of the texture (RGB, RGBA...)\r\n     */\n\n    this.format = -1;\n    /**\r\n     * Observable called when the texture is loaded\r\n     */\n\n    this.onLoadedObservable = new Observable();\n    /**\r\n     * Gets the width of the texture\r\n     */\n\n    this.width = 0;\n    /**\r\n     * Gets the height of the texture\r\n     */\n\n    this.height = 0;\n    /**\r\n     * Gets the depth of the texture\r\n     */\n\n    this.depth = 0;\n    /**\r\n     * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\n\n    this.baseWidth = 0;\n    /**\r\n     * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\n\n    this.baseHeight = 0;\n    /**\r\n     * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\n\n    this.baseDepth = 0;\n    /**\r\n     * Gets a boolean indicating if the texture is inverted on Y axis\r\n     */\n\n    this.invertY = false; // Private\n\n    /** @hidden */\n\n    this._invertVScale = false;\n    /** @hidden */\n\n    this._associatedChannel = -1;\n    /** @hidden */\n\n    this._source = InternalTextureSource.Unknown;\n    /** @hidden */\n\n    this._buffer = null;\n    /** @hidden */\n\n    this._bufferView = null;\n    /** @hidden */\n\n    this._bufferViewArray = null;\n    /** @hidden */\n\n    this._bufferViewArrayArray = null;\n    /** @hidden */\n\n    this._size = 0;\n    /** @hidden */\n\n    this._extension = \"\";\n    /** @hidden */\n\n    this._files = null;\n    /** @hidden */\n\n    this._workingCanvas = null;\n    /** @hidden */\n\n    this._workingContext = null;\n    /** @hidden */\n\n    this._framebuffer = null;\n    /** @hidden */\n\n    this._depthStencilBuffer = null;\n    /** @hidden */\n\n    this._MSAAFramebuffer = null;\n    /** @hidden */\n\n    this._MSAARenderBuffer = null;\n    /** @hidden */\n\n    this._attachments = null;\n    /** @hidden */\n\n    this._textureArray = null;\n    /** @hidden */\n\n    this._cachedCoordinatesMode = null;\n    /** @hidden */\n\n    this._cachedWrapU = null;\n    /** @hidden */\n\n    this._cachedWrapV = null;\n    /** @hidden */\n\n    this._cachedWrapR = null;\n    /** @hidden */\n\n    this._cachedAnisotropicFilteringLevel = null;\n    /** @hidden */\n\n    this._isDisabled = false;\n    /** @hidden */\n\n    this._compression = null;\n    /** @hidden */\n\n    this._generateStencilBuffer = false;\n    /** @hidden */\n\n    this._generateDepthBuffer = false;\n    /** @hidden */\n\n    this._comparisonFunction = 0;\n    /** @hidden */\n\n    this._sphericalPolynomial = null;\n    /** @hidden */\n\n    this._lodGenerationScale = 0;\n    /** @hidden */\n\n    this._lodGenerationOffset = 0; // Multiview\n\n    /** @hidden */\n\n    this._colorTextureArray = null;\n    /** @hidden */\n\n    this._depthStencilTextureArray = null; // The following three fields helps sharing generated fixed LODs for texture filtering\n    // In environment not supporting the textureLOD extension like EDGE. They are for internal use only.\n    // They are at the level of the gl texture to benefit from the cache.\n\n    /** @hidden */\n\n    this._lodTextureHigh = null;\n    /** @hidden */\n\n    this._lodTextureMid = null;\n    /** @hidden */\n\n    this._lodTextureLow = null;\n    /** @hidden */\n\n    this._isRGBD = false;\n    /** @hidden */\n\n    this._linearSpecularLOD = false;\n    /** @hidden */\n\n    this._irradianceTexture = null;\n    /** @hidden */\n\n    this._webGLTexture = null;\n    /** @hidden */\n\n    this._references = 1;\n    /** @hidden */\n\n    this._gammaSpace = null;\n    this._engine = engine;\n    this._source = source;\n\n    if (!delayAllocation) {\n      this._webGLTexture = engine._createTexture();\n    }\n  }\n  /**\r\n   * Gets the Engine the texture belongs to.\r\n   * @returns The babylon engine\r\n   */\n\n\n  InternalTexture.prototype.getEngine = function () {\n    return this._engine;\n  };\n\n  Object.defineProperty(InternalTexture.prototype, \"source\", {\n    /**\r\n     * Gets the data source type of the texture\r\n     */\n    get: function get() {\n      return this._source;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Increments the number of references (ie. the number of Texture that point to it)\r\n   */\n\n  InternalTexture.prototype.incrementReferences = function () {\n    this._references++;\n  };\n  /**\r\n   * Change the size of the texture (not the size of the content)\r\n   * @param width defines the new width\r\n   * @param height defines the new height\r\n   * @param depth defines the new depth (1 by default)\r\n   */\n\n\n  InternalTexture.prototype.updateSize = function (width, height, depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.baseWidth = width;\n    this.baseHeight = height;\n    this.baseDepth = depth;\n    this._size = width * height * depth;\n  };\n  /** @hidden */\n\n\n  InternalTexture.prototype._rebuild = function () {\n    var _this = this;\n\n    var _a;\n\n    var proxy;\n    this.isReady = false;\n    this._cachedCoordinatesMode = null;\n    this._cachedWrapU = null;\n    this._cachedWrapV = null;\n    this._cachedAnisotropicFilteringLevel = null;\n\n    switch (this.source) {\n      case InternalTextureSource.Temp:\n        return;\n\n      case InternalTextureSource.Url:\n        proxy = this._engine.createTexture((_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function () {\n          proxy._swapAndDie(_this);\n\n          _this.isReady = true;\n        }, null, this._buffer, undefined, this.format);\n        return;\n\n      case InternalTextureSource.Raw:\n        proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);\n\n        proxy._swapAndDie(this);\n\n        this.isReady = true;\n        return;\n\n      case InternalTextureSource.Raw3D:\n        proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);\n\n        proxy._swapAndDie(this);\n\n        this.isReady = true;\n        return;\n\n      case InternalTextureSource.Raw2DArray:\n        proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);\n\n        proxy._swapAndDie(this);\n\n        this.isReady = true;\n        return;\n\n      case InternalTextureSource.Dynamic:\n        proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);\n\n        proxy._swapAndDie(this);\n\n        this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, undefined, undefined, true); // The engine will make sure to update content so no need to flag it as isReady = true\n\n\n        return;\n\n      case InternalTextureSource.RenderTarget:\n        var options = new RenderTargetCreationOptions();\n        options.generateDepthBuffer = this._generateDepthBuffer;\n        options.generateMipMaps = this.generateMipMaps;\n        options.generateStencilBuffer = this._generateStencilBuffer;\n        options.samplingMode = this.samplingMode;\n        options.type = this.type;\n\n        if (this.isCube) {\n          proxy = this._engine.createRenderTargetCubeTexture(this.width, options);\n        } else {\n          var size_1 = {\n            width: this.width,\n            height: this.height,\n            layers: this.is2DArray ? this.depth : undefined\n          };\n          proxy = this._engine.createRenderTargetTexture(size_1, options);\n        }\n\n        proxy._swapAndDie(this);\n\n        this.isReady = true;\n        return;\n\n      case InternalTextureSource.Depth:\n        var depthTextureOptions = {\n          bilinearFiltering: this.samplingMode !== 2,\n          comparisonFunction: this._comparisonFunction,\n          generateStencil: this._generateStencilBuffer,\n          isCube: this.isCube\n        };\n        var size = {\n          width: this.width,\n          height: this.height,\n          layers: this.is2DArray ? this.depth : undefined\n        };\n        proxy = this._engine.createDepthStencilTexture(size, depthTextureOptions);\n\n        proxy._swapAndDie(this);\n\n        this.isReady = true;\n        return;\n\n      case InternalTextureSource.Cube:\n        proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function () {\n          proxy._swapAndDie(_this);\n\n          _this.isReady = true;\n        }, null, this.format, this._extension);\n        return;\n\n      case InternalTextureSource.CubeRaw:\n        proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);\n\n        proxy._swapAndDie(this);\n\n        this.isReady = true;\n        return;\n\n      case InternalTextureSource.CubeRawRGBD:\n        proxy = this._engine.createRawCubeTexture(null, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);\n\n        InternalTexture._UpdateRGBDAsync(proxy, this._bufferViewArrayArray, this._sphericalPolynomial, this._lodGenerationScale, this._lodGenerationOffset).then(function () {\n          proxy._swapAndDie(_this);\n\n          _this.isReady = true;\n        });\n\n        return;\n\n      case InternalTextureSource.CubePrefiltered:\n        proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function (proxy) {\n          if (proxy) {\n            proxy._swapAndDie(_this);\n          }\n\n          _this.isReady = true;\n        }, null, this.format, this._extension);\n        proxy._sphericalPolynomial = this._sphericalPolynomial;\n        return;\n    }\n  };\n  /** @hidden */\n\n\n  InternalTexture.prototype._swapAndDie = function (target) {\n    target._webGLTexture = this._webGLTexture;\n    target._isRGBD = this._isRGBD;\n\n    if (this._framebuffer) {\n      target._framebuffer = this._framebuffer;\n    }\n\n    if (this._depthStencilBuffer) {\n      target._depthStencilBuffer = this._depthStencilBuffer;\n    }\n\n    target._depthStencilTexture = this._depthStencilTexture;\n\n    if (this._lodTextureHigh) {\n      if (target._lodTextureHigh) {\n        target._lodTextureHigh.dispose();\n      }\n\n      target._lodTextureHigh = this._lodTextureHigh;\n    }\n\n    if (this._lodTextureMid) {\n      if (target._lodTextureMid) {\n        target._lodTextureMid.dispose();\n      }\n\n      target._lodTextureMid = this._lodTextureMid;\n    }\n\n    if (this._lodTextureLow) {\n      if (target._lodTextureLow) {\n        target._lodTextureLow.dispose();\n      }\n\n      target._lodTextureLow = this._lodTextureLow;\n    }\n\n    if (this._irradianceTexture) {\n      if (target._irradianceTexture) {\n        target._irradianceTexture.dispose();\n      }\n\n      target._irradianceTexture = this._irradianceTexture;\n    }\n\n    var cache = this._engine.getLoadedTexturesCache();\n\n    var index = cache.indexOf(this);\n\n    if (index !== -1) {\n      cache.splice(index, 1);\n    }\n\n    var index = cache.indexOf(target);\n\n    if (index === -1) {\n      cache.push(target);\n    }\n  };\n  /**\r\n   * Dispose the current allocated resources\r\n   */\n\n\n  InternalTexture.prototype.dispose = function () {\n    if (!this._webGLTexture) {\n      return;\n    }\n\n    this._references--;\n\n    if (this._references === 0) {\n      this._engine._releaseTexture(this);\n\n      this._webGLTexture = null;\n    }\n  };\n  /** @hidden */\n\n\n  InternalTexture._UpdateRGBDAsync = function (internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n    throw _DevTools.WarnImport(\"environmentTextureTools\");\n  };\n\n  return InternalTexture;\n}();\n\nexport { InternalTexture };","map":null,"metadata":{},"sourceType":"module"}