{"ast":null,"code":"import { Scene } from \"../scene\";\nimport { Observable } from \"../Misc/observable\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { HemisphericLight } from '../Lights/hemisphericLight';\nimport { Vector3 } from '../Maths/math.vector';\nimport { Color3 } from '../Maths/math.color';\n/**\r\n * Renders a layer on top of an existing scene\r\n */\n\nvar UtilityLayerRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a UtilityLayerRenderer\r\n   * @param originalScene the original scene that will be rendered on top of\r\n   * @param handleEvents boolean indicating if the utility layer should handle events\r\n   */\n  function UtilityLayerRenderer(\n  /** the original scene that will be rendered on top of */\n  originalScene, handleEvents) {\n    var _this = this;\n\n    if (handleEvents === void 0) {\n      handleEvents = true;\n    }\n\n    this.originalScene = originalScene;\n    this._pointerCaptures = {};\n    this._lastPointerEvents = {};\n    this._sharedGizmoLight = null;\n    this._renderCamera = null;\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\n\n    this.pickUtilitySceneFirst = true;\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n    */\n\n    this.shouldRender = true;\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\n\n    this.onlyCheckPointerDownEvents = true;\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\n\n    this.processAllEvents = false;\n    /**\r\n     * Observable raised when the pointer move from the utility layer scene to the main scene\r\n     */\n\n    this.onPointerOutObservable = new Observable(); // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\n\n    this.utilityLayerScene = new Scene(originalScene.getEngine(), {\n      virtual: true\n    });\n    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\n    this.utilityLayerScene._allowPostProcessClearColor = false; // Detach controls on utility scene, events will be fired by logic below to handle picking priority\n\n    this.utilityLayerScene.detachControl();\n\n    if (handleEvents) {\n      this._originalPointerObserver = originalScene.onPrePointerObservable.add(function (prePointerInfo, eventState) {\n        if (!_this.utilityLayerScene.activeCamera) {\n          return;\n        }\n\n        if (!_this.processAllEvents) {\n          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\n            return;\n          }\n        }\n\n        _this.utilityLayerScene.pointerX = originalScene.pointerX;\n        _this.utilityLayerScene.pointerY = originalScene.pointerY;\n        var pointerEvent = prePointerInfo.event;\n\n        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\n          _this._pointerCaptures[pointerEvent.pointerId] = false;\n          return;\n        }\n\n        var utilityScenePick = prePointerInfo.ray ? _this.utilityLayerScene.pickWithRay(prePointerInfo.ray) : _this.utilityLayerScene.pick(originalScene.pointerX, originalScene.pointerY);\n\n        if (!prePointerInfo.ray && utilityScenePick) {\n          prePointerInfo.ray = utilityScenePick.ray;\n        } // always fire the prepointer oversvable\n\n\n        _this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo); // allow every non pointer down event to flow to the utility layer\n\n\n        if (_this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\n          if (!prePointerInfo.skipOnPointerObservable) {\n            _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n          }\n\n          if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent.pointerId]) {\n            _this._pointerCaptures[pointerEvent.pointerId] = false;\n          }\n\n          return;\n        }\n\n        if (_this.utilityLayerScene.autoClearDepthAndStencil || _this.pickUtilitySceneFirst) {\n          // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\n          if (utilityScenePick && utilityScenePick.hit) {\n            if (!prePointerInfo.skipOnPointerObservable) {\n              _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n            }\n\n            prePointerInfo.skipOnPointerObservable = true;\n          }\n        } else {\n          var originalScenePick = prePointerInfo.ray ? originalScene.pickWithRay(prePointerInfo.ray) : originalScene.pick(originalScene.pointerX, originalScene.pointerY);\n          var pointerEvent_1 = prePointerInfo.event; // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\n\n          if (originalScenePick && utilityScenePick) {\n            // No pick in utility scene\n            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\n              if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                // We touched an utility mesh present in the main scene\n                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                _this._pointerCaptures[pointerEvent_1.pointerId] = true;\n              } else if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {\n                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);\n\n                delete _this._lastPointerEvents[pointerEvent_1.pointerId];\n              }\n            } else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\n              // We pick something in utility scene or the pick in utility is closer than the one in main scene\n              _this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent_1); // If a previous utility layer set this, do not unset this\n\n\n              if (!prePointerInfo.skipOnPointerObservable) {\n                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\n              }\n            } else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && utilityScenePick.distance > originalScenePick.distance) {\n              // We have a pick in both scenes but main is closer than utility\n              // We touched an utility mesh present in the main scene\n              if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {\n                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);\n\n                delete _this._lastPointerEvents[pointerEvent_1.pointerId];\n              }\n            }\n\n            if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent_1.pointerId]) {\n              _this._pointerCaptures[pointerEvent_1.pointerId] = false;\n            }\n          }\n        }\n      }); // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\n\n      if (this._originalPointerObserver) {\n        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\n      }\n    } // Render directly on top of existing scene without clearing\n\n\n    this.utilityLayerScene.autoClear = false;\n    this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add(function (camera) {\n      // Only render when the render camera finishes rendering\n      if (_this.shouldRender && camera == _this.getRenderCamera()) {\n        _this.render();\n      }\n    });\n    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(function () {\n      _this.dispose();\n    });\n\n    this._updateCamera();\n  }\n  /**\r\n   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n   * @returns the camera that is used when rendering the utility layer\r\n   */\n\n\n  UtilityLayerRenderer.prototype.getRenderCamera = function (getRigParentIfPossible) {\n    if (this._renderCamera) {\n      return this._renderCamera;\n    } else {\n      var activeCam = void 0;\n\n      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\n        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\n      } else {\n        activeCam = this.originalScene.activeCamera;\n      }\n\n      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\n        return activeCam.rigParent;\n      }\n\n      return activeCam;\n    }\n  };\n  /**\r\n   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n   * @param cam the camera that should be used when rendering the utility layer\r\n   */\n\n\n  UtilityLayerRenderer.prototype.setRenderCamera = function (cam) {\n    this._renderCamera = cam;\n  };\n  /**\r\n   * @hidden\r\n   * Light which used by gizmos to get light shading\r\n   */\n\n\n  UtilityLayerRenderer.prototype._getSharedGizmoLight = function () {\n    if (!this._sharedGizmoLight) {\n      this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\n      this._sharedGizmoLight.intensity = 2;\n      this._sharedGizmoLight.groundColor = Color3.Gray();\n    }\n\n    return this._sharedGizmoLight;\n  };\n\n  Object.defineProperty(UtilityLayerRenderer, \"DefaultUtilityLayer\", {\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\n    get: function get() {\n      if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n          UtilityLayerRenderer._DefaultUtilityLayer = null;\n        });\n      }\n\n      return UtilityLayerRenderer._DefaultUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UtilityLayerRenderer, \"DefaultKeepDepthUtilityLayer\", {\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\n    get: function get() {\n      if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n          UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n        });\n      }\n\n      return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  UtilityLayerRenderer.prototype._notifyObservers = function (prePointerInfo, pickInfo, pointerEvent) {\n    if (!prePointerInfo.skipOnPointerObservable) {\n      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\n      this._lastPointerEvents[pointerEvent.pointerId] = true;\n    }\n  };\n  /**\r\n   * Renders the utility layers scene on top of the original scene\r\n   */\n\n\n  UtilityLayerRenderer.prototype.render = function () {\n    this._updateCamera();\n\n    if (this.utilityLayerScene.activeCamera) {\n      // Set the camera's scene to utility layers scene\n      var oldScene = this.utilityLayerScene.activeCamera.getScene();\n      var camera = this.utilityLayerScene.activeCamera;\n      camera._scene = this.utilityLayerScene;\n\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = this.utilityLayerScene;\n      }\n\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = this.utilityLayerScene;\n      }\n\n      this.utilityLayerScene.render(false); // Reset camera's scene back to original\n\n      camera._scene = oldScene;\n\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = oldScene;\n      }\n\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = oldScene;\n      }\n    }\n  };\n  /**\r\n   * Disposes of the renderer\r\n   */\n\n\n  UtilityLayerRenderer.prototype.dispose = function () {\n    this.onPointerOutObservable.clear();\n\n    if (this._afterRenderObserver) {\n      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\n    }\n\n    if (this._sceneDisposeObserver) {\n      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n\n    if (this._originalPointerObserver) {\n      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\n    }\n\n    this.utilityLayerScene.dispose();\n  };\n\n  UtilityLayerRenderer.prototype._updateCamera = function () {\n    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\n    this.utilityLayerScene.activeCamera = this.getRenderCamera();\n  };\n\n  UtilityLayerRenderer._DefaultUtilityLayer = null;\n  UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n  return UtilityLayerRenderer;\n}();\n\nexport { UtilityLayerRenderer };","map":null,"metadata":{},"sourceType":"module"}