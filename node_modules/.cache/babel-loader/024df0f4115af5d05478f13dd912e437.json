{"ast":null,"code":"import { Scalar } from \"./math.scalar\";\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector\";\nimport { Epsilon } from \"./math.constants\";\n/**\r\n * Defines potential orientation for back face culling\r\n */\n\nexport var Orientation;\n\n(function (Orientation) {\n  /**\r\n   * Clockwise\r\n   */\n  Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n  /** Counter clockwise */\n\n  Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n})(Orientation || (Orientation = {}));\n/** Class used to represent a Bezier curve */\n\n\nvar BezierCurve =\n/** @class */\nfunction () {\n  function BezierCurve() {}\n  /**\r\n   * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\r\n   * @param t defines the time\r\n   * @param x1 defines the left coordinate on X axis\r\n   * @param y1 defines the left coordinate on Y axis\r\n   * @param x2 defines the right coordinate on X axis\r\n   * @param y2 defines the right coordinate on Y axis\r\n   * @returns the interpolated value\r\n   */\n\n\n  BezierCurve.Interpolate = function (t, x1, y1, x2, y2) {\n    // Extract X (which is equal to time here)\n    var f0 = 1 - 3 * x2 + 3 * x1;\n    var f1 = 3 * x2 - 6 * x1;\n    var f2 = 3 * x1;\n    var refinedT = t;\n\n    for (var i = 0; i < 5; i++) {\n      var refinedT2 = refinedT * refinedT;\n      var refinedT3 = refinedT2 * refinedT;\n      var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n      var slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n      refinedT -= (x - t) * slope;\n      refinedT = Math.min(1, Math.max(0, refinedT));\n    } // Resolve cubic bezier for the given x\n\n\n    return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\n  };\n\n  return BezierCurve;\n}();\n\nexport { BezierCurve };\n/**\r\n * Defines angle representation\r\n */\n\nvar Angle =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an Angle object of \"radians\" radians (float).\r\n   * @param radians the angle in radians\r\n   */\n  function Angle(radians) {\n    this._radians = radians;\n\n    if (this._radians < 0.0) {\n      this._radians += 2.0 * Math.PI;\n    }\n  }\n  /**\r\n   * Get value in degrees\r\n   * @returns the Angle value in degrees (float)\r\n   */\n\n\n  Angle.prototype.degrees = function () {\n    return this._radians * 180.0 / Math.PI;\n  };\n  /**\r\n   * Get value in radians\r\n   * @returns the Angle value in radians (float)\r\n   */\n\n\n  Angle.prototype.radians = function () {\n    return this._radians;\n  };\n  /**\r\n   * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points\r\n   * @param a defines first point as the origin\r\n   * @param b defines point\r\n   * @returns a new Angle\r\n   */\n\n\n  Angle.BetweenTwoPoints = function (a, b) {\n    var delta = b.subtract(a);\n    var theta = Math.atan2(delta.y, delta.x);\n    return new Angle(theta);\n  };\n  /**\r\n   * Gets a new Angle object from the given float in radians\r\n   * @param radians defines the angle value in radians\r\n   * @returns a new Angle\r\n   */\n\n\n  Angle.FromRadians = function (radians) {\n    return new Angle(radians);\n  };\n  /**\r\n   * Gets a new Angle object from the given float in degrees\r\n   * @param degrees defines the angle value in degrees\r\n   * @returns a new Angle\r\n   */\n\n\n  Angle.FromDegrees = function (degrees) {\n    return new Angle(degrees * Math.PI / 180.0);\n  };\n\n  return Angle;\n}();\n\nexport { Angle };\n/**\r\n * This represents an arc in a 2d space.\r\n */\n\nvar Arc2 =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an Arc object from the three given points : start, middle and end.\r\n   * @param startPoint Defines the start point of the arc\r\n   * @param midPoint Defines the midlle point of the arc\r\n   * @param endPoint Defines the end point of the arc\r\n   */\n  function Arc2(\n  /** Defines the start point of the arc */\n  startPoint,\n  /** Defines the mid point of the arc */\n  midPoint,\n  /** Defines the end point of the arc */\n  endPoint) {\n    this.startPoint = startPoint;\n    this.midPoint = midPoint;\n    this.endPoint = endPoint;\n    var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n    var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\n    var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\n    var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n    this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\n    this.radius = this.centerPoint.subtract(this.startPoint).length();\n    this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n    var a1 = this.startAngle.degrees();\n    var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n    var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees(); // angles correction\n\n    if (a2 - a1 > +180.0) {\n      a2 -= 360.0;\n    }\n\n    if (a2 - a1 < -180.0) {\n      a2 += 360.0;\n    }\n\n    if (a3 - a2 > +180.0) {\n      a3 -= 360.0;\n    }\n\n    if (a3 - a2 < -180.0) {\n      a3 += 360.0;\n    }\n\n    this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\n    this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\n  }\n\n  return Arc2;\n}();\n\nexport { Arc2 };\n/**\r\n * Represents a 2D path made up of multiple 2D points\r\n */\n\nvar Path2 =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a Path2 object from the starting 2D coordinates x and y.\r\n   * @param x the starting points x value\r\n   * @param y the starting points y value\r\n   */\n  function Path2(x, y) {\n    this._points = new Array();\n    this._length = 0.0;\n    /**\r\n     * If the path start and end point are the same\r\n     */\n\n    this.closed = false;\n\n    this._points.push(new Vector2(x, y));\n  }\n  /**\r\n   * Adds a new segment until the given coordinates (x, y) to the current Path2.\r\n   * @param x the added points x value\r\n   * @param y the added points y value\r\n   * @returns the updated Path2.\r\n   */\n\n\n  Path2.prototype.addLineTo = function (x, y) {\n    if (this.closed) {\n      return this;\n    }\n\n    var newPoint = new Vector2(x, y);\n    var previousPoint = this._points[this._points.length - 1];\n\n    this._points.push(newPoint);\n\n    this._length += newPoint.subtract(previousPoint).length();\n    return this;\n  };\n  /**\r\n   * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\r\n   * @param midX middle point x value\r\n   * @param midY middle point y value\r\n   * @param endX end point x value\r\n   * @param endY end point y value\r\n   * @param numberOfSegments (default: 36)\r\n   * @returns the updated Path2.\r\n   */\n\n\n  Path2.prototype.addArcTo = function (midX, midY, endX, endY, numberOfSegments) {\n    if (numberOfSegments === void 0) {\n      numberOfSegments = 36;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    var startPoint = this._points[this._points.length - 1];\n    var midPoint = new Vector2(midX, midY);\n    var endPoint = new Vector2(endX, endY);\n    var arc = new Arc2(startPoint, midPoint, endPoint);\n    var increment = arc.angle.radians() / numberOfSegments;\n\n    if (arc.orientation === Orientation.CW) {\n      increment *= -1;\n    }\n\n    var currentAngle = arc.startAngle.radians() + increment;\n\n    for (var i = 0; i < numberOfSegments; i++) {\n      var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n      var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n      this.addLineTo(x, y);\n      currentAngle += increment;\n    }\n\n    return this;\n  };\n  /**\r\n   * Closes the Path2.\r\n   * @returns the Path2.\r\n   */\n\n\n  Path2.prototype.close = function () {\n    this.closed = true;\n    return this;\n  };\n  /**\r\n   * Gets the sum of the distance between each sequential point in the path\r\n   * @returns the Path2 total length (float).\r\n   */\n\n\n  Path2.prototype.length = function () {\n    var result = this._length;\n\n    if (this.closed) {\n      var lastPoint = this._points[this._points.length - 1];\n      var firstPoint = this._points[0];\n      result += firstPoint.subtract(lastPoint).length();\n    }\n\n    return result;\n  };\n  /**\r\n   * Gets the points which construct the path\r\n   * @returns the Path2 internal array of points.\r\n   */\n\n\n  Path2.prototype.getPoints = function () {\n    return this._points;\n  };\n  /**\r\n   * Retreives the point at the distance aways from the starting point\r\n   * @param normalizedLengthPosition the length along the path to retreive the point from\r\n   * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\r\n   */\n\n\n  Path2.prototype.getPointAtLengthPosition = function (normalizedLengthPosition) {\n    if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n      return Vector2.Zero();\n    }\n\n    var lengthPosition = normalizedLengthPosition * this.length();\n    var previousOffset = 0;\n\n    for (var i = 0; i < this._points.length; i++) {\n      var j = (i + 1) % this._points.length;\n      var a = this._points[i];\n      var b = this._points[j];\n      var bToA = b.subtract(a);\n      var nextOffset = bToA.length() + previousOffset;\n\n      if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n        var dir = bToA.normalize();\n        var localOffset = lengthPosition - previousOffset;\n        return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\n      }\n\n      previousOffset = nextOffset;\n    }\n\n    return Vector2.Zero();\n  };\n  /**\r\n   * Creates a new path starting from an x and y position\r\n   * @param x starting x value\r\n   * @param y starting y value\r\n   * @returns a new Path2 starting at the coordinates (x, y).\r\n   */\n\n\n  Path2.StartingAt = function (x, y) {\n    return new Path2(x, y);\n  };\n\n  return Path2;\n}();\n\nexport { Path2 };\n/**\r\n * Represents a 3D path made up of multiple 3D points\r\n */\n\nvar Path3D =\n/** @class */\nfunction () {\n  /**\r\n   * new Path3D(path, normal, raw)\r\n   * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\r\n   * please read the description in the tutorial : https://doc.babylonjs.com/how_to/how_to_use_path3d\r\n   * @param path an array of Vector3, the curve axis of the Path3D\r\n   * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\r\n   * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\r\n   * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\r\n   */\n  function Path3D(\n  /**\r\n   * an array of Vector3, the curve axis of the Path3D\r\n   */\n  path, firstNormal, raw, alignTangentsWithPath) {\n    if (firstNormal === void 0) {\n      firstNormal = null;\n    }\n\n    if (alignTangentsWithPath === void 0) {\n      alignTangentsWithPath = false;\n    }\n\n    this.path = path;\n    this._curve = new Array();\n    this._distances = new Array();\n    this._tangents = new Array();\n    this._normals = new Array();\n    this._binormals = new Array(); // holds interpolated point data\n\n    this._pointAtData = {\n      id: 0,\n      point: Vector3.Zero(),\n      previousPointArrayIndex: 0,\n      position: 0,\n      subPosition: 0,\n      interpolateReady: false,\n      interpolationMatrix: Matrix.Identity()\n    };\n\n    for (var p = 0; p < path.length; p++) {\n      this._curve[p] = path[p].clone(); // hard copy\n    }\n\n    this._raw = raw || false;\n    this._alignTangentsWithPath = alignTangentsWithPath;\n\n    this._compute(firstNormal, alignTangentsWithPath);\n  }\n  /**\r\n   * Returns the Path3D array of successive Vector3 designing its curve.\r\n   * @returns the Path3D array of successive Vector3 designing its curve.\r\n   */\n\n\n  Path3D.prototype.getCurve = function () {\n    return this._curve;\n  };\n  /**\r\n   * Returns the Path3D array of successive Vector3 designing its curve.\r\n   * @returns the Path3D array of successive Vector3 designing its curve.\r\n   */\n\n\n  Path3D.prototype.getPoints = function () {\n    return this._curve;\n  };\n  /**\r\n   * @returns the computed length (float) of the path.\r\n   */\n\n\n  Path3D.prototype.length = function () {\n    return this._distances[this._distances.length - 1];\n  };\n  /**\r\n   * Returns an array populated with tangent vectors on each Path3D curve point.\r\n   * @returns an array populated with tangent vectors on each Path3D curve point.\r\n   */\n\n\n  Path3D.prototype.getTangents = function () {\n    return this._tangents;\n  };\n  /**\r\n   * Returns an array populated with normal vectors on each Path3D curve point.\r\n   * @returns an array populated with normal vectors on each Path3D curve point.\r\n   */\n\n\n  Path3D.prototype.getNormals = function () {\n    return this._normals;\n  };\n  /**\r\n   * Returns an array populated with binormal vectors on each Path3D curve point.\r\n   * @returns an array populated with binormal vectors on each Path3D curve point.\r\n   */\n\n\n  Path3D.prototype.getBinormals = function () {\n    return this._binormals;\n  };\n  /**\r\n   * Returns an array populated with distances (float) of the i-th point from the first curve point.\r\n   * @returns an array populated with distances (float) of the i-th point from the first curve point.\r\n   */\n\n\n  Path3D.prototype.getDistances = function () {\n    return this._distances;\n  };\n  /**\r\n   * Returns an interpolated point along this path\r\n   * @param position the position of the point along this path, from 0.0 to 1.0\r\n   * @returns a new Vector3 as the point\r\n   */\n\n\n  Path3D.prototype.getPointAt = function (position) {\n    return this._updatePointAtData(position).point;\n  };\n  /**\r\n   * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n   * @param position the position of the point along this path, from 0.0 to 1.0\r\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\r\n   * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\r\n   */\n\n\n  Path3D.prototype.getTangentAt = function (position, interpolated) {\n    if (interpolated === void 0) {\n      interpolated = false;\n    }\n\n    this._updatePointAtData(position, interpolated);\n\n    return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\n  };\n  /**\r\n   * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n   * @param position the position of the point along this path, from 0.0 to 1.0\r\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\r\n   * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\r\n   */\n\n\n  Path3D.prototype.getNormalAt = function (position, interpolated) {\n    if (interpolated === void 0) {\n      interpolated = false;\n    }\n\n    this._updatePointAtData(position, interpolated);\n\n    return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\n  };\n  /**\r\n   * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\r\n   * @param position the position of the point along this path, from 0.0 to 1.0\r\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\r\n   * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\r\n   */\n\n\n  Path3D.prototype.getBinormalAt = function (position, interpolated) {\n    if (interpolated === void 0) {\n      interpolated = false;\n    }\n\n    this._updatePointAtData(position, interpolated);\n\n    return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\n  };\n  /**\r\n   * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\r\n   * @param position the position of the point along this path, from 0.0 to 1.0\r\n   * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\r\n   */\n\n\n  Path3D.prototype.getDistanceAt = function (position) {\n    return this.length() * position;\n  };\n  /**\r\n   * Returns the array index of the previous point of an interpolated point along this path\r\n   * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n   * @returns the array index\r\n   */\n\n\n  Path3D.prototype.getPreviousPointIndexAt = function (position) {\n    this._updatePointAtData(position);\n\n    return this._pointAtData.previousPointArrayIndex;\n  };\n  /**\r\n   * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\r\n   * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n   * @returns the sub position\r\n   */\n\n\n  Path3D.prototype.getSubPositionAt = function (position) {\n    this._updatePointAtData(position);\n\n    return this._pointAtData.subPosition;\n  };\n  /**\r\n   * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\r\n   * @param target the vector of which to get the closest position to\r\n   * @returns the position of the closest virtual point on this path to the target vector\r\n   */\n\n\n  Path3D.prototype.getClosestPositionTo = function (target) {\n    var smallestDistance = Number.MAX_VALUE;\n    var closestPosition = 0.0;\n\n    for (var i = 0; i < this._curve.length - 1; i++) {\n      var point = this._curve[i + 0];\n\n      var tangent = this._curve[i + 1].subtract(point).normalize();\n\n      var subLength = this._distances[i + 1] - this._distances[i + 0];\n      var subPosition = Math.min(Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target) / subLength, 1.0);\n      var distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\n\n      if (distance < smallestDistance) {\n        smallestDistance = distance;\n        closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\n      }\n    }\n\n    return closestPosition;\n  };\n  /**\r\n   * Returns a sub path (slice) of this path\r\n   * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n   * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n   * @returns a sub path (slice) of this path\r\n   */\n\n\n  Path3D.prototype.slice = function (start, end) {\n    if (start === void 0) {\n      start = 0.0;\n    }\n\n    if (end === void 0) {\n      end = 1.0;\n    }\n\n    if (start < 0.0) {\n      start = 1 - start * -1.0 % 1.0;\n    }\n\n    if (end < 0.0) {\n      end = 1 - end * -1.0 % 1.0;\n    }\n\n    if (start > end) {\n      var _start = start;\n      start = end;\n      end = _start;\n    }\n\n    var curvePoints = this.getCurve();\n    var startPoint = this.getPointAt(start);\n    var startIndex = this.getPreviousPointIndexAt(start);\n    var endPoint = this.getPointAt(end);\n    var endIndex = this.getPreviousPointIndexAt(end) + 1;\n    var slicePoints = [];\n\n    if (start !== 0.0) {\n      startIndex++;\n      slicePoints.push(startPoint);\n    }\n\n    slicePoints.push.apply(slicePoints, curvePoints.slice(startIndex, endIndex));\n\n    if (end !== 1.0 || start === 1.0) {\n      slicePoints.push(endPoint);\n    }\n\n    return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\n  };\n  /**\r\n   * Forces the Path3D tangent, normal, binormal and distance recomputation.\r\n   * @param path path which all values are copied into the curves points\r\n   * @param firstNormal which should be projected onto the curve\r\n   * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\r\n   * @returns the same object updated.\r\n   */\n\n\n  Path3D.prototype.update = function (path, firstNormal, alignTangentsWithPath) {\n    if (firstNormal === void 0) {\n      firstNormal = null;\n    }\n\n    if (alignTangentsWithPath === void 0) {\n      alignTangentsWithPath = false;\n    }\n\n    for (var p = 0; p < path.length; p++) {\n      this._curve[p].x = path[p].x;\n      this._curve[p].y = path[p].y;\n      this._curve[p].z = path[p].z;\n    }\n\n    this._compute(firstNormal, alignTangentsWithPath);\n\n    return this;\n  }; // private function compute() : computes tangents, normals and binormals\n\n\n  Path3D.prototype._compute = function (firstNormal, alignTangentsWithPath) {\n    if (alignTangentsWithPath === void 0) {\n      alignTangentsWithPath = false;\n    }\n\n    var l = this._curve.length;\n\n    if (l < 2) {\n      return;\n    } // first and last tangents\n\n\n    this._tangents[0] = this._getFirstNonNullVector(0);\n\n    if (!this._raw) {\n      this._tangents[0].normalize();\n    }\n\n    this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n\n    if (!this._raw) {\n      this._tangents[l - 1].normalize();\n    } // normals and binormals at first point : arbitrary vector with _normalVector()\n\n\n    var tg0 = this._tangents[0];\n\n    var pp0 = this._normalVector(tg0, firstNormal);\n\n    this._normals[0] = pp0;\n\n    if (!this._raw) {\n      this._normals[0].normalize();\n    }\n\n    this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\n\n    if (!this._raw) {\n      this._binormals[0].normalize();\n    }\n\n    this._distances[0] = 0.0; // normals and binormals : next points\n\n    var prev; // previous vector (segment)\n\n    var cur; // current vector (segment)\n\n    var curTang; // current tangent\n    // previous normal\n\n    var prevNor; // previous normal\n\n    var prevBinor; // previous binormal\n\n    for (var i = 1; i < l; i++) {\n      // tangents\n      prev = this._getLastNonNullVector(i);\n\n      if (i < l - 1) {\n        cur = this._getFirstNonNullVector(i);\n        this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\n\n        this._tangents[i].normalize();\n      }\n\n      this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length(); // normals and binormals\n      // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n\n      curTang = this._tangents[i];\n      prevBinor = this._binormals[i - 1];\n      this._normals[i] = Vector3.Cross(prevBinor, curTang);\n\n      if (!this._raw) {\n        if (this._normals[i].length() === 0) {\n          prevNor = this._normals[i - 1];\n          this._normals[i] = prevNor.clone();\n        } else {\n          this._normals[i].normalize();\n        }\n      }\n\n      this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\n\n      if (!this._raw) {\n        this._binormals[i].normalize();\n      }\n    }\n\n    this._pointAtData.id = NaN;\n  }; // private function getFirstNonNullVector(index)\n  // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n\n\n  Path3D.prototype._getFirstNonNullVector = function (index) {\n    var i = 1;\n\n    var nNVector = this._curve[index + i].subtract(this._curve[index]);\n\n    while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n      i++;\n      nNVector = this._curve[index + i].subtract(this._curve[index]);\n    }\n\n    return nNVector;\n  }; // private function getLastNonNullVector(index)\n  // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n\n\n  Path3D.prototype._getLastNonNullVector = function (index) {\n    var i = 1;\n\n    var nLVector = this._curve[index].subtract(this._curve[index - i]);\n\n    while (nLVector.length() === 0 && index > i + 1) {\n      i++;\n      nLVector = this._curve[index].subtract(this._curve[index - i]);\n    }\n\n    return nLVector;\n  }; // private function normalVector(v0, vt, va) :\n  // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n  // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n\n\n  Path3D.prototype._normalVector = function (vt, va) {\n    var normal0;\n    var tgl = vt.length();\n\n    if (tgl === 0.0) {\n      tgl = 1.0;\n    }\n\n    if (va === undefined || va === null) {\n      var point;\n\n      if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\n        // search for a point in the plane\n        point = new Vector3(0.0, -1.0, 0.0);\n      } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\n        point = new Vector3(1.0, 0.0, 0.0);\n      } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\n        point = new Vector3(0.0, 0.0, 1.0);\n      } else {\n        point = Vector3.Zero();\n      }\n\n      normal0 = Vector3.Cross(vt, point);\n    } else {\n      normal0 = Vector3.Cross(vt, va);\n      Vector3.CrossToRef(normal0, vt, normal0);\n    }\n\n    normal0.normalize();\n    return normal0;\n  };\n  /**\r\n   * Updates the point at data for an interpolated point along this curve\r\n   * @param position the position of the point along this curve, from 0.0 to 1.0\r\n   * @interpolateTNB wether to compute the interpolated tangent, normal and binormal\r\n   * @returns the (updated) point at data\r\n   */\n\n\n  Path3D.prototype._updatePointAtData = function (position, interpolateTNB) {\n    if (interpolateTNB === void 0) {\n      interpolateTNB = false;\n    } // set an id for caching the result\n\n\n    if (this._pointAtData.id === position) {\n      if (!this._pointAtData.interpolateReady) {\n        this._updateInterpolationMatrix();\n      }\n\n      return this._pointAtData;\n    } else {\n      this._pointAtData.id = position;\n    }\n\n    var curvePoints = this.getPoints(); // clamp position between 0.0 and 1.0\n\n    if (position <= 0.0) {\n      return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\n    } else if (position >= 1.0) {\n      return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\n    }\n\n    var previousPoint = curvePoints[0];\n    var currentPoint;\n    var currentLength = 0.0;\n    var targetLength = position * this.length();\n\n    for (var i = 1; i < curvePoints.length; i++) {\n      currentPoint = curvePoints[i];\n      var distance = Vector3.Distance(previousPoint, currentPoint);\n      currentLength += distance;\n\n      if (currentLength === targetLength) {\n        return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\n      } else if (currentLength > targetLength) {\n        var toLength = currentLength - targetLength;\n        var diff = toLength / distance;\n        var dir = previousPoint.subtract(currentPoint);\n        var point = currentPoint.add(dir.scaleInPlace(diff));\n        return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\n      }\n\n      previousPoint = currentPoint;\n    }\n\n    return this._pointAtData;\n  };\n  /**\r\n   * Updates the point at data from the specified parameters\r\n   * @param position where along the path the interpolated point is, from 0.0 to 1.0\r\n   * @param point the interpolated point\r\n   * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\r\n   */\n\n\n  Path3D.prototype._setPointAtData = function (position, subPosition, point, parentIndex, interpolateTNB) {\n    this._pointAtData.point = point;\n    this._pointAtData.position = position;\n    this._pointAtData.subPosition = subPosition;\n    this._pointAtData.previousPointArrayIndex = parentIndex;\n    this._pointAtData.interpolateReady = interpolateTNB;\n\n    if (interpolateTNB) {\n      this._updateInterpolationMatrix();\n    }\n\n    return this._pointAtData;\n  };\n  /**\r\n   * Updates the point at interpolation matrix for the tangents, normals and binormals\r\n   */\n\n\n  Path3D.prototype._updateInterpolationMatrix = function () {\n    this._pointAtData.interpolationMatrix = Matrix.Identity();\n    var parentIndex = this._pointAtData.previousPointArrayIndex;\n\n    if (parentIndex !== this._tangents.length - 1) {\n      var index = parentIndex + 1;\n\n      var tangentFrom = this._tangents[parentIndex].clone();\n\n      var normalFrom = this._normals[parentIndex].clone();\n\n      var binormalFrom = this._binormals[parentIndex].clone();\n\n      var tangentTo = this._tangents[index].clone();\n\n      var normalTo = this._normals[index].clone();\n\n      var binormalTo = this._binormals[index].clone();\n\n      var quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\n      var quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\n      var quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\n      quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\n    }\n  };\n\n  return Path3D;\n}();\n\nexport { Path3D };\n/**\r\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n * A Curve3 is designed from a series of successive Vector3.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_curve3\r\n */\n\nvar Curve3 =\n/** @class */\nfunction () {\n  /**\r\n   * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n   * A Curve3 is designed from a series of successive Vector3.\r\n   * Tuto : https://doc.babylonjs.com/how_to/how_to_use_curve3#curve3-object\r\n   * @param points points which make up the curve\r\n   */\n  function Curve3(points) {\n    this._length = 0.0;\n    this._points = points;\n    this._length = this._computeLength(points);\n  }\n  /**\r\n   * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#quadratic-bezier-curve\r\n   * @param v0 (Vector3) the origin point of the Quadratic Bezier\r\n   * @param v1 (Vector3) the control point\r\n   * @param v2 (Vector3) the end point of the Quadratic Bezier\r\n   * @param nbPoints (integer) the wanted number of points in the curve\r\n   * @returns the created Curve3\r\n   */\n\n\n  Curve3.CreateQuadraticBezier = function (v0, v1, v2, nbPoints) {\n    nbPoints = nbPoints > 2 ? nbPoints : 3;\n    var bez = new Array();\n\n    var equation = function equation(t, val0, val1, val2) {\n      var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n      return res;\n    };\n\n    for (var i = 0; i <= nbPoints; i++) {\n      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n    }\n\n    return new Curve3(bez);\n  };\n  /**\r\n   * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#cubic-bezier-curve\r\n   * @param v0 (Vector3) the origin point of the Cubic Bezier\r\n   * @param v1 (Vector3) the first control point\r\n   * @param v2 (Vector3) the second control point\r\n   * @param v3 (Vector3) the end point of the Cubic Bezier\r\n   * @param nbPoints (integer) the wanted number of points in the curve\r\n   * @returns the created Curve3\r\n   */\n\n\n  Curve3.CreateCubicBezier = function (v0, v1, v2, v3, nbPoints) {\n    nbPoints = nbPoints > 3 ? nbPoints : 4;\n    var bez = new Array();\n\n    var equation = function equation(t, val0, val1, val2, val3) {\n      var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n      return res;\n    };\n\n    for (var i = 0; i <= nbPoints; i++) {\n      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n    }\n\n    return new Curve3(bez);\n  };\n  /**\r\n   * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#hermite-spline\r\n   * @param p1 (Vector3) the origin point of the Hermite Spline\r\n   * @param t1 (Vector3) the tangent vector at the origin point\r\n   * @param p2 (Vector3) the end point of the Hermite Spline\r\n   * @param t2 (Vector3) the tangent vector at the end point\r\n   * @param nbPoints (integer) the wanted number of points in the curve\r\n   * @returns the created Curve3\r\n   */\n\n\n  Curve3.CreateHermiteSpline = function (p1, t1, p2, t2, nbPoints) {\n    var hermite = new Array();\n    var step = 1.0 / nbPoints;\n\n    for (var i = 0; i <= nbPoints; i++) {\n      hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\n    }\n\n    return new Curve3(hermite);\n  };\n  /**\r\n   * Returns a Curve3 object along a CatmullRom Spline curve :\r\n   * @param points (array of Vector3) the points the spline must pass through. At least, four points required\r\n   * @param nbPoints (integer) the wanted number of points between each curve control points\r\n   * @param closed (boolean) optional with default false, when true forms a closed loop from the points\r\n   * @returns the created Curve3\r\n   */\n\n\n  Curve3.CreateCatmullRomSpline = function (points, nbPoints, closed) {\n    var catmullRom = new Array();\n    var step = 1.0 / nbPoints;\n    var amount = 0.0;\n\n    if (closed) {\n      var pointsCount = points.length;\n\n      for (var i = 0; i < pointsCount; i++) {\n        amount = 0;\n\n        for (var c = 0; c < nbPoints; c++) {\n          catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\n          amount += step;\n        }\n      }\n\n      catmullRom.push(catmullRom[0]);\n    } else {\n      var totalPoints = new Array();\n      totalPoints.push(points[0].clone());\n      Array.prototype.push.apply(totalPoints, points);\n      totalPoints.push(points[points.length - 1].clone());\n\n      for (var i = 0; i < totalPoints.length - 3; i++) {\n        amount = 0;\n\n        for (var c = 0; c < nbPoints; c++) {\n          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n          amount += step;\n        }\n      }\n\n      i--;\n      catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n    }\n\n    return new Curve3(catmullRom);\n  };\n  /**\r\n   * @returns the Curve3 stored array of successive Vector3\r\n   */\n\n\n  Curve3.prototype.getPoints = function () {\n    return this._points;\n  };\n  /**\r\n   * @returns the computed length (float) of the curve.\r\n   */\n\n\n  Curve3.prototype.length = function () {\n    return this._length;\n  };\n  /**\r\n   * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\r\n   * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\r\n   * curveA and curveB keep unchanged.\r\n   * @param curve the curve to continue from this curve\r\n   * @returns the newly constructed curve\r\n   */\n\n\n  Curve3.prototype.continue = function (curve) {\n    var lastPoint = this._points[this._points.length - 1];\n\n    var continuedPoints = this._points.slice();\n\n    var curvePoints = curve.getPoints();\n\n    for (var i = 1; i < curvePoints.length; i++) {\n      continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n    }\n\n    var continuedCurve = new Curve3(continuedPoints);\n    return continuedCurve;\n  };\n\n  Curve3.prototype._computeLength = function (path) {\n    var l = 0;\n\n    for (var i = 1; i < path.length; i++) {\n      l += path[i].subtract(path[i - 1]).length();\n    }\n\n    return l;\n  };\n\n  return Curve3;\n}();\n\nexport { Curve3 };","map":null,"metadata":{},"sourceType":"module"}