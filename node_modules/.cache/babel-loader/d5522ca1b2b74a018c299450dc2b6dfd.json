{"ast":null,"code":"import { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\nimport { Color4 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateTiledBox = function (options) {\n  var nbFaces = 6;\n  var faceUV = options.faceUV || new Array(6);\n  var faceColors = options.faceColors;\n  var flipTile = options.pattern || Mesh.NO_FLIP;\n  var width = options.width || options.size || 1;\n  var height = options.height || options.size || 1;\n  var depth = options.depth || options.size || 1;\n  var tileWidth = options.tileWidth || options.tileSize || 1;\n  var tileHeight = options.tileHeight || options.tileSize || 1;\n  var alignH = options.alignHorizontal || 0;\n  var alignV = options.alignVertical || 0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // default face colors and UV if undefined\n\n  for (var f = 0; f < nbFaces; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var halfDepth = depth / 2;\n  var faceVertexData = [];\n\n  for (var f = 0; f < 2; f++) {\n    //front and back\n    faceVertexData[f] = VertexData.CreateTiledPlane({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  for (var f = 2; f < 4; f++) {\n    //sides\n    faceVertexData[f] = VertexData.CreateTiledPlane({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: depth,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  var baseAlignV = alignV;\n\n  if (alignV === Mesh.BOTTOM) {\n    baseAlignV = Mesh.TOP;\n  } else if (alignV === Mesh.TOP) {\n    baseAlignV = Mesh.BOTTOM;\n  }\n\n  for (var f = 4; f < 6; f++) {\n    //top and bottom\n    faceVertexData[f] = VertexData.CreateTiledPlane({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: depth,\n      alignVertical: baseAlignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var indices = [];\n  var colors = [];\n  var facePositions = [];\n  var faceNormals = [];\n  var newFaceUV = [];\n  var len = 0;\n  var lu = 0;\n  var li = 0;\n\n  for (var f = 0; f < nbFaces; f++) {\n    var len = faceVertexData[f].positions.length;\n    facePositions[f] = [];\n    faceNormals[f] = [];\n\n    for (var p = 0; p < len / 3; p++) {\n      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));\n      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));\n    } // uvs\n\n\n    lu = faceVertexData[f].uvs.length;\n    newFaceUV[f] = [];\n\n    for (var i = 0; i < lu; i += 2) {\n      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];\n      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];\n    }\n\n    uvs = uvs.concat(newFaceUV[f]);\n    indices = indices.concat(faceVertexData[f].indices.map(function (x) {\n      return x + li;\n    }));\n    li += facePositions[f].length;\n\n    if (faceColors) {\n      for (var c = 0; c < 4; c++) {\n        colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n      }\n    }\n  }\n\n  var vec0 = new Vector3(0, 0, halfDepth);\n  var mtrx0 = Matrix.RotationY(Math.PI);\n  positions = facePositions[0].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx0).add(vec0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []);\n  normals = faceNormals[0].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []);\n  positions = positions.concat(facePositions[1].map(function (entry) {\n    return entry.subtract(vec0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[1].map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var vec2 = new Vector3(halfWidth, 0, 0);\n  var mtrx2 = Matrix.RotationY(-Math.PI / 2);\n  positions = positions.concat(facePositions[2].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx2).add(vec2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[2].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var mtrx3 = Matrix.RotationY(Math.PI / 2);\n  positions = positions.concat(facePositions[3].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx3).subtract(vec2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[3].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx3);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var vec4 = new Vector3(0, halfHeight, 0);\n  var mtrx4 = Matrix.RotationX(Math.PI / 2);\n  positions = positions.concat(facePositions[4].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx4).add(vec4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[4].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var mtrx5 = Matrix.RotationX(-Math.PI / 2);\n  positions = positions.concat(facePositions[5].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx5).subtract(vec4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[5].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx5);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, [])); // sides\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n\n  return vertexData;\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar TiledBoxBuilder =\n/** @class */\nfunction () {\n  function TiledBoxBuilder() {}\n  /**\r\n   * Creates a box mesh\r\n   * faceTiles sets the pattern, tile size and number of tiles for a face     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n   * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the box mesh\r\n   */\n\n\n  TiledBoxBuilder.CreateTiledBox = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var box = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    box._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateTiledBox(options);\n    vertexData.applyToMesh(box, options.updatable);\n    return box;\n  };\n\n  return TiledBoxBuilder;\n}();\n\nexport { TiledBoxBuilder };","map":null,"metadata":{},"sourceType":"module"}