{"ast":null,"code":"import { DracoCompression } from \"@babylonjs/core/Meshes/Compression/dracoCompression\";\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nvar NAME = \"KHR_draco_mesh_compression\";\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression)\r\n */\n\nvar KHR_draco_mesh_compression =\n/** @class */\nfunction () {\n  /** @hidden */\n  function KHR_draco_mesh_compression(loader) {\n    /**\r\n     * The name of this extension.\r\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  KHR_draco_mesh_compression.prototype.dispose = function () {\n    delete this.dracoCompression;\n    this._loader = null;\n  };\n  /** @hidden */\n\n\n  KHR_draco_mesh_compression.prototype._loadVertexDataAsync = function (context, primitive, babylonMesh) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function (extensionContext, extension) {\n      if (primitive.mode != undefined) {\n        if (primitive.mode !== 5\n        /* TRIANGLE_STRIP */\n        && primitive.mode !== 4\n        /* TRIANGLES */\n        ) {\n          throw new Error(context + \": Unsupported mode \" + primitive.mode);\n        } // TODO: handle triangle strips\n\n\n        if (primitive.mode === 5\n        /* TRIANGLE_STRIP */\n        ) {\n          throw new Error(context + \": Mode \" + primitive.mode + \" is not currently supported\");\n        }\n      }\n\n      var attributes = {};\n\n      var loadAttribute = function loadAttribute(name, kind) {\n        var uniqueId = extension.attributes[name];\n\n        if (uniqueId == undefined) {\n          return;\n        }\n\n        babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n\n        if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n          babylonMesh._delayInfo.push(kind);\n        }\n\n        attributes[kind] = uniqueId;\n      };\n\n      loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n      loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n      loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n      loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n      loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n      loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n      loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n      loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\n      var bufferView = ArrayItem.Get(extensionContext, _this._loader.gltf.bufferViews, extension.bufferView);\n\n      if (!bufferView._dracoBabylonGeometry) {\n        bufferView._dracoBabylonGeometry = _this._loader.loadBufferViewAsync(\"/bufferViews/\" + bufferView.index, bufferView).then(function (data) {\n          var dracoCompression = _this.dracoCompression || DracoCompression.Default;\n          return dracoCompression.decodeMeshAsync(data, attributes).then(function (babylonVertexData) {\n            var babylonGeometry = new Geometry(babylonMesh.name, _this._loader.babylonScene);\n            babylonVertexData.applyToGeometry(babylonGeometry);\n            return babylonGeometry;\n          }).catch(function (error) {\n            throw new Error(context + \": \" + error.message);\n          });\n        });\n      }\n\n      return bufferView._dracoBabylonGeometry;\n    });\n  };\n\n  return KHR_draco_mesh_compression;\n}();\n\nexport { KHR_draco_mesh_compression };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_draco_mesh_compression(loader);\n});","map":null,"metadata":{},"sourceType":"module"}