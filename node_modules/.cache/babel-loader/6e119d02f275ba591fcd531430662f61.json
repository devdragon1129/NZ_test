{"ast":null,"code":"import { Scene } from \"../../scene\";\nimport { Vector3 } from \"../../Maths/math.vector\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\nimport { Ray } from \"../../Culling/ray\";\nimport { SceneComponentConstants } from \"../../sceneComponent\";\nimport { Octree } from \"./octree\";\n\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity, maxDepth) {\n  if (maxCapacity === void 0) {\n    maxCapacity = 64;\n  }\n\n  if (maxDepth === void 0) {\n    maxDepth = 2;\n  }\n\n  var component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\n\n  if (!component) {\n    component = new OctreeSceneComponent(this);\n\n    this._addComponent(component);\n  }\n\n  if (!this._selectionOctree) {\n    this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\n  }\n\n  var worldExtends = this.getWorldExtends(); // Update octree\n\n  this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\n\n  return this._selectionOctree;\n};\n\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\n  get: function get() {\n    return this._selectionOctree;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\r\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n * @param maxCapacity defines the maximum size of each block (64 by default)\r\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n * @returns the new octree\r\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n */\n\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity, maxDepth) {\n  if (maxCapacity === void 0) {\n    maxCapacity = 64;\n  }\n\n  if (maxDepth === void 0) {\n    maxDepth = 2;\n  }\n\n  var scene = this.getScene();\n\n  var component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\n\n  if (!component) {\n    component = new OctreeSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n\n  if (!this._submeshesOctree) {\n    this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\n  }\n\n  this.computeWorldMatrix(true);\n  var boundingInfo = this.getBoundingInfo(); // Update octree\n\n  var bbox = boundingInfo.boundingBox;\n\n  this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\n\n  return this._submeshesOctree;\n};\n/**\r\n * Defines the octree scene component responsible to manage any octrees\r\n * in a given scene.\r\n */\n\n\nvar OctreeSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function OctreeSceneComponent(scene) {\n    /**\r\n     * The component name help to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_OCTREE;\n    /**\r\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\r\n     */\n\n    this.checksIsEnabled = true;\n    this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\n    this.scene = scene;\n    this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);\n    this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);\n    this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);\n    this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  OctreeSceneComponent.prototype.register = function () {\n    var _this = this;\n\n    this.scene.onMeshRemovedObservable.add(function (mesh) {\n      var sceneOctree = _this.scene.selectionOctree;\n\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        var index = sceneOctree.dynamicContent.indexOf(mesh);\n\n        if (index !== -1) {\n          sceneOctree.dynamicContent.splice(index, 1);\n        }\n      }\n    });\n    this.scene.onMeshImportedObservable.add(function (mesh) {\n      var sceneOctree = _this.scene.selectionOctree;\n\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        sceneOctree.addMesh(mesh);\n      }\n    });\n  };\n  /**\r\n   * Return the list of active meshes\r\n   * @returns the list of active meshes\r\n   */\n\n\n  OctreeSceneComponent.prototype.getActiveMeshCandidates = function () {\n    if (this.scene._selectionOctree) {\n      var selection = this.scene._selectionOctree.select(this.scene.frustumPlanes);\n\n      return selection;\n    }\n\n    return this.scene._getDefaultMeshCandidates();\n  };\n  /**\r\n   * Return the list of active sub meshes\r\n   * @param mesh The mesh to get the candidates sub meshes from\r\n   * @returns the list of active sub meshes\r\n   */\n\n\n  OctreeSceneComponent.prototype.getActiveSubMeshCandidates = function (mesh) {\n    if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\n      var intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\r\n   * Return the list of sub meshes intersecting with a given local ray\r\n   * @param mesh defines the mesh to find the submesh for\r\n   * @param localRay defines the ray in local space\r\n   * @returns the list of intersecting sub meshes\r\n   */\n\n\n  OctreeSceneComponent.prototype.getIntersectingSubMeshCandidates = function (mesh, localRay) {\n    if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\n      Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\n\n      var intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\r\n   * Return the list of sub meshes colliding with a collider\r\n   * @param mesh defines the mesh to find the submesh for\r\n   * @param collider defines the collider to evaluate the collision against\r\n   * @returns the list of colliding sub meshes\r\n   */\n\n\n  OctreeSceneComponent.prototype.getCollidingSubMeshCandidates = function (mesh, collider) {\n    if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\n      var radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\n\n      var intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  OctreeSceneComponent.prototype.rebuild = function () {// Nothing to do here.\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  OctreeSceneComponent.prototype.dispose = function () {// Nothing to do here.\n  };\n\n  return OctreeSceneComponent;\n}();\n\nexport { OctreeSceneComponent };","map":null,"metadata":{},"sourceType":"module"}