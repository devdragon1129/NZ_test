{"ast":null,"code":"import { Logger } from \"../../Misc/logger\";\nimport { Camera } from \"../../Cameras/camera\";\nimport { Vector3 } from \"../../Maths/math.vector\";\nimport { Color3, Color4 } from \"../../Maths/math.color\";\nimport { Mesh } from \"../../Meshes/mesh\";\nimport { Geometry } from \"../../Meshes/geometry\";\nimport { TransformNode } from \"../../Meshes/transformNode\";\nimport { Material } from \"../../Materials/material\";\nimport { MultiMaterial } from \"../../Materials/multiMaterial\";\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture\";\nimport { AnimationGroup } from \"../../Animations/animationGroup\";\nimport { Light } from \"../../Lights/light\";\nimport { SceneComponentConstants } from \"../../sceneComponent\";\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\nimport { AbstractScene } from \"../../abstractScene\";\nimport { AssetContainer } from \"../../assetContainer\";\nimport { ActionManager } from \"../../Actions/actionManager\";\nimport { Skeleton } from \"../../Bones/skeleton\";\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager\";\nimport { CannonJSPlugin } from \"../../Physics/Plugins/cannonJSPlugin\";\nimport { OimoJSPlugin } from \"../../Physics/Plugins/oimoJSPlugin\";\nimport { AmmoJSPlugin } from \"../../Physics/Plugins/ammoJSPlugin\";\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe\";\nimport { _TypeStore } from '../../Misc/typeStore';\nimport { Tools } from '../../Misc/tools';\nimport { StringTools } from '../../Misc/stringTools';\nimport { PostProcess } from '../../PostProcesses/postProcess';\n/** @hidden */\n\nexport var _BabylonLoaderRegistered = true;\n/**\r\n * Helps setting up some configuration for the babylon file loader.\r\n */\n\nvar BabylonFileLoaderConfiguration =\n/** @class */\nfunction () {\n  function BabylonFileLoaderConfiguration() {}\n  /**\r\n   * The loader does not allow injecting custom physix engine into the plugins.\r\n   * Unfortunately in ES6, we need to manually inject them into the plugin.\r\n   * So you could set this variable to your engine import to make it work.\r\n   */\n\n\n  BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine = undefined;\n  return BabylonFileLoaderConfiguration;\n}();\n\nexport { BabylonFileLoaderConfiguration };\n\nvar parseMaterialById = function parseMaterialById(id, parsedData, scene, rootUrl) {\n  for (var index = 0, cache = parsedData.materials.length; index < cache; index++) {\n    var parsedMaterial = parsedData.materials[index];\n\n    if (parsedMaterial.id === id) {\n      return Material.Parse(parsedMaterial, scene, rootUrl);\n    }\n  }\n\n  return null;\n};\n\nvar isDescendantOf = function isDescendantOf(mesh, names, hierarchyIds) {\n  for (var i in names) {\n    if (mesh.name === names[i]) {\n      hierarchyIds.push(mesh.id);\n      return true;\n    }\n  }\n\n  if (mesh.parentId && hierarchyIds.indexOf(mesh.parentId) !== -1) {\n    hierarchyIds.push(mesh.id);\n    return true;\n  }\n\n  return false;\n};\n\nvar logOperation = function logOperation(operation, producer) {\n  return operation + \" of \" + (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\");\n};\n\nvar loadDetailLevels = function loadDetailLevels(scene, mesh) {\n  var mastermesh = mesh; // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\n  // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\n\n  if (mesh._waitingData.lods) {\n    if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\n      var lodmeshes = mesh._waitingData.lods.ids;\n      var wasenabled = mastermesh.isEnabled(false);\n\n      if (mesh._waitingData.lods.distances) {\n        var distances = mesh._waitingData.lods.distances;\n\n        if (distances.length >= lodmeshes.length) {\n          var culling = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\n          mastermesh.setEnabled(false);\n\n          for (var index = 0; index < lodmeshes.length; index++) {\n            var lodid = lodmeshes[index];\n            var lodmesh = scene.getMeshByID(lodid);\n\n            if (lodmesh != null) {\n              mastermesh.addLODLevel(distances[index], lodmesh);\n            }\n          }\n\n          if (culling > 0) {\n            mastermesh.addLODLevel(culling, null);\n          }\n\n          if (wasenabled === true) {\n            mastermesh.setEnabled(true);\n          }\n        } else {\n          Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\n        }\n      }\n    }\n\n    mesh._waitingData.lods = null;\n  }\n};\n\nvar _loadAssetContainer = function loadAssetContainer(scene, data, rootUrl, onError, addToScene) {\n  if (addToScene === void 0) {\n    addToScene = false;\n  }\n\n  var container = new AssetContainer(scene); // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n  // when SceneLoader.debugLogging = true (default), or exception encountered.\n  // Everything stored in var log instead of writing separate lines to support only writing in exception,\n  // and avoid problems with multiple concurrent .babylon loads.\n\n  var log = \"importScene has failed JSON parse\";\n\n  try {\n    var parsedData = JSON.parse(data);\n    log = \"\";\n    var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n    var index;\n    var cache; // Environment texture\n\n    if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\n      // PBR needed for both HDR texture (gamma space) & a sky box\n      var isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\n\n      if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\n        var hdrSize = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\n        var hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR);\n\n        if (parsedData.environmentTextureRotationY) {\n          hdrTexture.rotationY = parsedData.environmentTextureRotationY;\n        }\n\n        scene.environmentTexture = hdrTexture;\n      } else {\n        if (StringTools.EndsWith(parsedData.environmentTexture, \".env\")) {\n          var compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene);\n\n          if (parsedData.environmentTextureRotationY) {\n            compressedTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n\n          scene.environmentTexture = compressedTexture;\n        } else {\n          var cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene);\n\n          if (parsedData.environmentTextureRotationY) {\n            cubeTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n\n          scene.environmentTexture = cubeTexture;\n        }\n      }\n\n      if (parsedData.createDefaultSkybox === true) {\n        var skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\n        var skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\n        scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\n      }\n\n      container.environmentTexture = scene.environmentTexture;\n    } // Environment Intensity\n\n\n    if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\n      scene.environmentIntensity = parsedData.environmentIntensity;\n    } // Lights\n\n\n    if (parsedData.lights !== undefined && parsedData.lights !== null) {\n      for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\n        var parsedLight = parsedData.lights[index];\n        var light = Light.Parse(parsedLight, scene);\n\n        if (light) {\n          container.lights.push(light);\n          log += index === 0 ? \"\\n\\tLights:\" : \"\";\n          log += \"\\n\\t\\t\" + light.toString(fullDetails);\n        }\n      }\n    } // Reflection probes\n\n\n    if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\n      for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\n        var parsedReflectionProbe = parsedData.reflectionProbes[index];\n        var reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\n\n        if (reflectionProbe) {\n          container.reflectionProbes.push(reflectionProbe);\n          log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\n          log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\n        }\n      }\n    } // Animations\n\n\n    if (parsedData.animations !== undefined && parsedData.animations !== null) {\n      for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\n        var parsedAnimation = parsedData.animations[index];\n\n        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          var animation = internalClass.Parse(parsedAnimation);\n          scene.animations.push(animation);\n          container.animations.push(animation);\n          log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\n          log += \"\\n\\t\\t\" + animation.toString(fullDetails);\n        }\n      }\n    } // Materials\n\n\n    if (parsedData.materials !== undefined && parsedData.materials !== null) {\n      for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\n        var parsedMaterial = parsedData.materials[index];\n        var mat = Material.Parse(parsedMaterial, scene, rootUrl);\n\n        if (mat) {\n          container.materials.push(mat);\n          log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\n          log += \"\\n\\t\\t\" + mat.toString(fullDetails); // Textures\n\n          var textures = mat.getActiveTextures();\n          textures.forEach(function (t) {\n            if (container.textures.indexOf(t) == -1) {\n              container.textures.push(t);\n            }\n          });\n        }\n      }\n    }\n\n    if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n      for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\n        var parsedMultiMaterial = parsedData.multiMaterials[index];\n        var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n        container.multiMaterials.push(mmat);\n        log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\n        log += \"\\n\\t\\t\" + mmat.toString(fullDetails); // Textures\n\n        var textures = mmat.getActiveTextures();\n        textures.forEach(function (t) {\n          if (container.textures.indexOf(t) == -1) {\n            container.textures.push(t);\n          }\n        });\n      }\n    } // Morph targets\n\n\n    if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n      for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {\n        var managerData = _a[_i];\n        container.morphTargetManagers.push(MorphTargetManager.Parse(managerData, scene));\n      }\n    } // Skeletons\n\n\n    if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n      for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\n        var parsedSkeleton = parsedData.skeletons[index];\n        var skeleton = Skeleton.Parse(parsedSkeleton, scene);\n        container.skeletons.push(skeleton);\n        log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\n        log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\n      }\n    } // Geometries\n\n\n    var geometries = parsedData.geometries;\n\n    if (geometries !== undefined && geometries !== null) {\n      var addedGeometry = new Array(); // VertexData\n\n      var vertexData = geometries.vertexData;\n\n      if (vertexData !== undefined && vertexData !== null) {\n        for (index = 0, cache = vertexData.length; index < cache; index++) {\n          var parsedVertexData = vertexData[index];\n          addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\n        }\n      }\n\n      addedGeometry.forEach(function (g) {\n        if (g) {\n          container.geometries.push(g);\n        }\n      });\n    } // Transform nodes\n\n\n    if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n      for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n        var parsedTransformNode = parsedData.transformNodes[index];\n        var node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\n        container.transformNodes.push(node);\n      }\n    } // Meshes\n\n\n    if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n      for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n        var parsedMesh = parsedData.meshes[index];\n        var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n        container.meshes.push(mesh);\n\n        if (mesh.hasInstances) {\n          for (var _b = 0, _c = mesh.instances; _b < _c.length; _b++) {\n            var instance = _c[_b];\n            container.meshes.push(instance);\n          }\n        }\n\n        log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\n        log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\n      }\n    } // Cameras\n\n\n    if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\n      for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\n        var parsedCamera = parsedData.cameras[index];\n        var camera = Camera.Parse(parsedCamera, scene);\n        container.cameras.push(camera);\n        log += index === 0 ? \"\\n\\tCameras:\" : \"\";\n        log += \"\\n\\t\\t\" + camera.toString(fullDetails);\n      }\n    } // Postprocesses\n\n\n    if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\n      for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\n        var parsedPostProcess = parsedData.postProcesses[index];\n        var postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\n\n        if (postProcess) {\n          container.postProcesses.push(postProcess);\n          log += index === 0 ? \"\\n\\Postprocesses:\" : \"\";\n          log += \"\\n\\t\\t\" + postProcess.toString();\n        }\n      }\n    } // Animation Groups\n\n\n    if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\n      for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\n        var parsedAnimationGroup = parsedData.animationGroups[index];\n        var animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\n        container.animationGroups.push(animationGroup);\n        log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\n        log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\n      }\n    } // Browsing all the graph to connect the dots\n\n\n    for (index = 0, cache = scene.cameras.length; index < cache; index++) {\n      var camera = scene.cameras[index];\n\n      if (camera._waitingParentId) {\n        camera.parent = scene.getLastEntryByID(camera._waitingParentId);\n        camera._waitingParentId = null;\n      }\n    }\n\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      var light_1 = scene.lights[index];\n\n      if (light_1 && light_1._waitingParentId) {\n        light_1.parent = scene.getLastEntryByID(light_1._waitingParentId);\n        light_1._waitingParentId = null;\n      }\n    } // Connect parents & children and parse actions and lods\n\n\n    for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n      var transformNode = scene.transformNodes[index];\n\n      if (transformNode._waitingParentId) {\n        transformNode.parent = scene.getLastEntryByID(transformNode._waitingParentId);\n        transformNode._waitingParentId = null;\n      }\n    }\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var mesh = scene.meshes[index];\n\n      if (mesh._waitingParentId) {\n        mesh.parent = scene.getLastEntryByID(mesh._waitingParentId);\n        mesh._waitingParentId = null;\n      }\n\n      if (mesh._waitingData.lods) {\n        loadDetailLevels(scene, mesh);\n      }\n    } // link skeleton transform nodes\n\n\n    for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\n      var skeleton = scene.skeletons[index];\n\n      if (skeleton._hasWaitingData) {\n        if (skeleton.bones != null) {\n          skeleton.bones.forEach(function (bone) {\n            if (bone._waitingTransformNodeId) {\n              var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId);\n\n              if (linkTransformNode) {\n                bone.linkTransformNode(linkTransformNode);\n              }\n\n              bone._waitingTransformNodeId = null;\n            }\n          });\n        }\n\n        if (skeleton._waitingOverrideMeshId) {\n          skeleton.overrideMesh = scene.getMeshByID(skeleton._waitingOverrideMeshId);\n          skeleton._waitingOverrideMeshId = null;\n        }\n\n        skeleton._hasWaitingData = null;\n      }\n    } // freeze world matrix application\n\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var currentMesh = scene.meshes[index];\n\n      if (currentMesh._waitingData.freezeWorldMatrix) {\n        currentMesh.freezeWorldMatrix();\n        currentMesh._waitingData.freezeWorldMatrix = null;\n      } else {\n        currentMesh.computeWorldMatrix(true);\n      }\n    } // Lights exclusions / inclusions\n\n\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      var light_2 = scene.lights[index]; // Excluded check\n\n      if (light_2._excludedMeshesIds.length > 0) {\n        for (var excludedIndex = 0; excludedIndex < light_2._excludedMeshesIds.length; excludedIndex++) {\n          var excludedMesh = scene.getMeshByID(light_2._excludedMeshesIds[excludedIndex]);\n\n          if (excludedMesh) {\n            light_2.excludedMeshes.push(excludedMesh);\n          }\n        }\n\n        light_2._excludedMeshesIds = [];\n      } // Included check\n\n\n      if (light_2._includedOnlyMeshesIds.length > 0) {\n        for (var includedOnlyIndex = 0; includedOnlyIndex < light_2._includedOnlyMeshesIds.length; includedOnlyIndex++) {\n          var includedOnlyMesh = scene.getMeshByID(light_2._includedOnlyMeshesIds[includedOnlyIndex]);\n\n          if (includedOnlyMesh) {\n            light_2.includedOnlyMeshes.push(includedOnlyMesh);\n          }\n        }\n\n        light_2._includedOnlyMeshesIds = [];\n      }\n    }\n\n    AbstractScene.Parse(parsedData, scene, container, rootUrl); // Actions (scene) Done last as it can access other objects.\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var mesh = scene.meshes[index];\n\n      if (mesh._waitingData.actions) {\n        ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\n        mesh._waitingData.actions = null;\n      }\n    }\n\n    if (parsedData.actions !== undefined && parsedData.actions !== null) {\n      ActionManager.Parse(parsedData.actions, null, scene);\n    }\n  } catch (err) {\n    var msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n    if (onError) {\n      onError(msg, err);\n    } else {\n      Logger.Log(msg);\n      throw err;\n    }\n  } finally {\n    if (!addToScene) {\n      container.removeAllFromScene();\n    }\n\n    if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n      Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n    }\n  }\n\n  return container;\n};\n\nSceneLoader.RegisterPlugin({\n  name: \"babylon.js\",\n  extensions: \".babylon\",\n  canDirectLoad: function canDirectLoad(data) {\n    if (data.indexOf(\"babylon\") !== -1) {\n      // We consider that the producer string is filled\n      return true;\n    }\n\n    return false;\n  },\n  importMesh: function importMesh(meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) {\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    var log = \"importMesh has failed JSON parse\";\n\n    try {\n      var parsedData = JSON.parse(data);\n      log = \"\";\n      var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n\n      if (!meshesNames) {\n        meshesNames = null;\n      } else if (!Array.isArray(meshesNames)) {\n        meshesNames = [meshesNames];\n      }\n\n      var hierarchyIds = new Array();\n\n      if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n        var loadedSkeletonsIds = [];\n        var loadedMaterialsIds = [];\n        var index;\n        var cache;\n\n        for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n          var parsedMesh = parsedData.meshes[index];\n\n          if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\n            if (meshesNames !== null) {\n              // Remove found mesh name from list.\n              delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\n            } //Geometry?\n\n\n            if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\n              //does the file contain geometries?\n              if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\n                //find the correct geometry and add it to the scene\n                var found = false;\n                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach(function (geometryType) {\n                  if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\n                    return;\n                  } else {\n                    parsedData.geometries[geometryType].forEach(function (parsedGeometryData) {\n                      if (parsedGeometryData.id === parsedMesh.geometryId) {\n                        switch (geometryType) {\n                          case \"vertexData\":\n                            Geometry.Parse(parsedGeometryData, scene, rootUrl);\n                            break;\n                        }\n\n                        found = true;\n                      }\n                    });\n                  }\n                });\n\n                if (found === false) {\n                  Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\n                }\n              }\n            } // Material ?\n\n\n            if (parsedMesh.materialId) {\n              var materialFound = loadedMaterialsIds.indexOf(parsedMesh.materialId) !== -1;\n\n              if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n                for (var multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\n                  var parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\n\n                  if (parsedMultiMaterial.id === parsedMesh.materialId) {\n                    for (var matIndex = 0, matCache = parsedMultiMaterial.materials.length; matIndex < matCache; matIndex++) {\n                      var subMatId = parsedMultiMaterial.materials[matIndex];\n                      loadedMaterialsIds.push(subMatId);\n                      var mat = parseMaterialById(subMatId, parsedData, scene, rootUrl);\n\n                      if (mat) {\n                        log += \"\\n\\tMaterial \" + mat.toString(fullDetails);\n                      }\n                    }\n\n                    loadedMaterialsIds.push(parsedMultiMaterial.id);\n                    var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n\n                    if (mmat) {\n                      materialFound = true;\n                      log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\n                    }\n\n                    break;\n                  }\n                }\n              }\n\n              if (materialFound === false) {\n                loadedMaterialsIds.push(parsedMesh.materialId);\n                var mat = parseMaterialById(parsedMesh.materialId, parsedData, scene, rootUrl);\n\n                if (!mat) {\n                  Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\n                } else {\n                  log += \"\\n\\tMaterial \" + mat.toString(fullDetails);\n                }\n              }\n            } // Skeleton ?\n\n\n            if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n              var skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\n\n              if (skeletonAlreadyLoaded === false) {\n                for (var skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\n                  var parsedSkeleton = parsedData.skeletons[skeletonIndex];\n\n                  if (parsedSkeleton.id === parsedMesh.skeletonId) {\n                    var skeleton = Skeleton.Parse(parsedSkeleton, scene);\n                    skeletons.push(skeleton);\n                    loadedSkeletonsIds.push(parsedSkeleton.id);\n                    log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\n                  }\n                }\n              }\n            } // Morph targets ?\n\n\n            if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n              for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {\n                var managerData = _a[_i];\n                MorphTargetManager.Parse(managerData, scene);\n              }\n            }\n\n            var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n            meshes.push(mesh);\n            log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\n          }\n        } // Connecting parents and lods\n\n\n        var currentMesh;\n\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n\n          if (currentMesh._waitingParentId) {\n            currentMesh.parent = scene.getLastEntryByID(currentMesh._waitingParentId);\n            currentMesh._waitingParentId = null;\n          }\n\n          if (currentMesh._waitingData.lods) {\n            loadDetailLevels(scene, currentMesh);\n          }\n        } // link skeleton transform nodes\n\n\n        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\n          var skeleton = scene.skeletons[index];\n\n          if (skeleton._hasWaitingData) {\n            if (skeleton.bones != null) {\n              skeleton.bones.forEach(function (bone) {\n                if (bone._waitingTransformNodeId) {\n                  var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId);\n\n                  if (linkTransformNode) {\n                    bone.linkTransformNode(linkTransformNode);\n                  }\n\n                  bone._waitingTransformNodeId = null;\n                }\n              });\n            }\n\n            if (skeleton._waitingOverrideMeshId) {\n              skeleton.overrideMesh = scene.getMeshByID(skeleton._waitingOverrideMeshId);\n              skeleton._waitingOverrideMeshId = null;\n            }\n\n            skeleton._hasWaitingData = null;\n          }\n        } // freeze and compute world matrix application\n\n\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n\n          if (currentMesh._waitingData.freezeWorldMatrix) {\n            currentMesh.freezeWorldMatrix();\n            currentMesh._waitingData.freezeWorldMatrix = null;\n          } else {\n            currentMesh.computeWorldMatrix(true);\n          }\n        }\n      } // Particles\n\n\n      if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n        var parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n\n        if (parser) {\n          for (index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n            var parsedParticleSystem = parsedData.particleSystems[index];\n\n            if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\n              particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\n            }\n          }\n        }\n      }\n\n      return true;\n    } catch (err) {\n      var msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n\n    return false;\n  },\n  load: function load(scene, data, rootUrl, onError) {\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    var log = \"importScene has failed JSON parse\";\n\n    try {\n      var parsedData = JSON.parse(data);\n      log = \"\"; // Scene\n\n      if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\n        scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\n      }\n\n      if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\n        scene.autoClear = parsedData.autoClear;\n      }\n\n      if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\n        scene.clearColor = Color4.FromArray(parsedData.clearColor);\n      }\n\n      if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\n        scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\n      }\n\n      if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\n        scene.gravity = Vector3.FromArray(parsedData.gravity);\n      } // Fog\n\n\n      if (parsedData.fogMode && parsedData.fogMode !== 0) {\n        scene.fogMode = parsedData.fogMode;\n        scene.fogColor = Color3.FromArray(parsedData.fogColor);\n        scene.fogStart = parsedData.fogStart;\n        scene.fogEnd = parsedData.fogEnd;\n        scene.fogDensity = parsedData.fogDensity;\n        log += \"\\tFog mode for scene:  \";\n\n        switch (scene.fogMode) {\n          // getters not compiling, so using hardcoded\n          case 1:\n            log += \"exp\\n\";\n            break;\n\n          case 2:\n            log += \"exp2\\n\";\n            break;\n\n          case 3:\n            log += \"linear\\n\";\n            break;\n        }\n      } //Physics\n\n\n      if (parsedData.physicsEnabled) {\n        var physicsPlugin;\n\n        if (parsedData.physicsEngine === \"cannon\") {\n          physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"oimo\") {\n          physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"ammo\") {\n          physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\n        }\n\n        log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\"; //else - default engine, which is currently oimo\n\n        var physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\n        scene.enablePhysics(physicsGravity, physicsPlugin);\n      } // Metadata\n\n\n      if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\n        scene.metadata = parsedData.metadata;\n      } //collisions, if defined. otherwise, default is true\n\n\n      if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\n        scene.collisionsEnabled = parsedData.collisionsEnabled;\n      }\n\n      var container = _loadAssetContainer(scene, data, rootUrl, onError, true);\n\n      if (!container) {\n        return false;\n      }\n\n      if (parsedData.autoAnimate) {\n        scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\n      }\n\n      if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\n        scene.setActiveCameraByID(parsedData.activeCameraID);\n      } // Finish\n\n\n      return true;\n    } catch (err) {\n      var msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n\n    return false;\n  },\n  loadAssetContainer: function loadAssetContainer(scene, data, rootUrl, onError) {\n    var container = _loadAssetContainer(scene, data, rootUrl, onError);\n\n    return container;\n  }\n});","map":null,"metadata":{},"sourceType":"module"}