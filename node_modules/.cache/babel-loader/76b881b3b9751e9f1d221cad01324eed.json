{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { PostProcess } from \"./postProcess\";\nimport \"../Shaders/refraction.fragment\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { SerializationHelper, serialize } from '../Misc/decorators';\n/**\r\n * Post process which applies a refractin texture\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#refraction\r\n */\n\nvar RefractionPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(RefractionPostProcess, _super);\n  /**\r\n   * Initializes the RefractionPostProcess\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#refraction\r\n   * @param name The name of the effect.\r\n   * @param refractionTextureUrl Url of the refraction texture to use\r\n   * @param color the base color of the refraction (used to taint the rendering)\r\n   * @param depth simulated refraction depth\r\n   * @param colorLevel the coefficient of the base color (0 to remove base color tainting)\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass.\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   */\n\n\n  function RefractionPostProcess(name, refractionTextureUrl, color, depth, colorLevel, options, camera, samplingMode, engine, reusable) {\n    var _this = _super.call(this, name, \"refraction\", [\"baseColor\", \"depth\", \"colorLevel\"], [\"refractionSampler\"], options, camera, samplingMode, engine, reusable) || this;\n\n    _this._ownRefractionTexture = true;\n    _this.color = color;\n    _this.depth = depth;\n    _this.colorLevel = colorLevel;\n    _this.refractionTextureUrl = refractionTextureUrl;\n\n    _this.onActivateObservable.add(function (cam) {\n      _this._refTexture = _this._refTexture || new Texture(refractionTextureUrl, cam.getScene());\n    });\n\n    _this.onApplyObservable.add(function (effect) {\n      effect.setColor3(\"baseColor\", _this.color);\n      effect.setFloat(\"depth\", _this.depth);\n      effect.setFloat(\"colorLevel\", _this.colorLevel);\n      effect.setTexture(\"refractionSampler\", _this._refTexture);\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(RefractionPostProcess.prototype, \"refractionTexture\", {\n    /**\r\n     * Gets or sets the refraction texture\r\n     * Please note that you are responsible for disposing the texture if you set it manually\r\n     */\n    get: function get() {\n      return this._refTexture;\n    },\n    set: function set(value) {\n      if (this._refTexture && this._ownRefractionTexture) {\n        this._refTexture.dispose();\n      }\n\n      this._refTexture = value;\n      this._ownRefractionTexture = false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"RefractionPostProcess\" string\r\n   */\n\n  RefractionPostProcess.prototype.getClassName = function () {\n    return \"RefractionPostProcess\";\n  }; // Methods\n\n  /**\r\n   * Disposes of the post process\r\n   * @param camera Camera to dispose post process on\r\n   */\n\n\n  RefractionPostProcess.prototype.dispose = function (camera) {\n    if (this._refTexture && this._ownRefractionTexture) {\n      this._refTexture.dispose();\n\n      this._refTexture = null;\n    }\n\n    _super.prototype.dispose.call(this, camera);\n  };\n  /** @hidden */\n\n\n  RefractionPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new RefractionPostProcess(parsedPostProcess.name, parsedPostProcess.refractionTextureUrl, parsedPostProcess.color, parsedPostProcess.depth, parsedPostProcess.colorLevel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], RefractionPostProcess.prototype, \"color\", void 0);\n\n  __decorate([serialize()], RefractionPostProcess.prototype, \"depth\", void 0);\n\n  __decorate([serialize()], RefractionPostProcess.prototype, \"colorLevel\", void 0);\n\n  __decorate([serialize()], RefractionPostProcess.prototype, \"refractionTextureUrl\", void 0);\n\n  return RefractionPostProcess;\n}(PostProcess);\n\nexport { RefractionPostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.RefractionPostProcess\"] = RefractionPostProcess;","map":null,"metadata":{},"sourceType":"module"}