{"ast":null,"code":"\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.assertHash = exports.assertBytes = exports.assertBool = exports.assertNumber = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0; // The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\n\nvar crypto_1 = require(\"@noble/hashes/crypto\"); // Cast array to different type\n\n\nvar u8 = function u8(arr) {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n};\n\nexports.u8 = u8;\n\nvar u32 = function u32(arr) {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n};\n\nexports.u32 = u32; // Cast array to view\n\nvar createView = function createView(arr) {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n};\n\nexports.createView = createView; // The rotate right (circular right shift) operation for uint32\n\nvar rotr = function rotr(word, shift) {\n  return word << 32 - shift | word >>> shift;\n};\n\nexports.rotr = rotr;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44; // There is almost no big endian hardware, but js typed arrays uses platform specific endianess.\n// So, just to be sure not to corrupt anything.\n\nif (!exports.isLE) throw new Error('Non little-endian hardware is not supported');\nvar hexes = Array.from({\n  length: 256\n}, function (v, i) {\n  return i.toString(16).padStart(2, '0');\n});\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\n\nfunction bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  var hex = '';\n\n  for (var i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('deadbeef')\n */\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  var array = new Uint8Array(hex.length / 2);\n\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    var hexByte = hex.slice(j, j + 2);\n    var byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte)) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nexports.hexToBytes = hexToBytes; // Currently avoid insertion of polyfills with packers (browserify/webpack/etc)\n// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here\n\nexports.nextTick = function () {\n  var nodeRequire = typeof module !== 'undefined' && typeof module.require === 'function' && module.require.bind(module);\n\n  try {\n    if (nodeRequire) {\n      var _nodeRequire = nodeRequire('timers'),\n          setImmediate = _nodeRequire.setImmediate;\n\n      return function () {\n        return new Promise(function (resolve) {\n          return setImmediate(resolve);\n        });\n      };\n    }\n  } catch (e) {}\n\n  return function () {\n    return new Promise(function (resolve) {\n      return setTimeout(resolve, 0);\n    });\n  };\n}(); // Returns control to thread each 'tick' ms to avoid blocking\n\n\nfunction asyncLoop(_x, _x2, _x3) {\n  return _asyncLoop.apply(this, arguments);\n}\n\nfunction _asyncLoop() {\n  _asyncLoop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(iters, tick, cb) {\n    var ts, i, diff;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ts = Date.now();\n            i = 0;\n\n          case 2:\n            if (!(i < iters)) {\n              _context.next = 13;\n              break;\n            }\n\n            cb(i); // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n\n            diff = Date.now() - ts;\n\n            if (!(diff >= 0 && diff < tick)) {\n              _context.next = 7;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 10);\n\n          case 7:\n            _context.next = 9;\n            return (0, exports.nextTick)();\n\n          case 9:\n            ts += diff;\n\n          case 10:\n            i++;\n            _context.next = 2;\n            break;\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _asyncLoop.apply(this, arguments);\n}\n\nexports.asyncLoop = asyncLoop;\n\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(\"utf8ToBytes expected string, got \".concat(typeof str));\n  }\n\n  return new TextEncoder().encode(str);\n}\n\nexports.utf8ToBytes = utf8ToBytes;\n\nfunction toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(\"Expected input type is Uint8Array (got \".concat(typeof data, \")\"));\n  return data;\n}\n\nexports.toBytes = toBytes;\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(function (a) {\n    return a instanceof Uint8Array;\n  })) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nexports.concatBytes = concatBytes;\n\nfunction assertNumber(n) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"Wrong positive integer: \".concat(n));\n}\n\nexports.assertNumber = assertNumber;\n\nfunction assertBool(b) {\n  if (typeof b !== 'boolean') {\n    throw new Error(\"Expected boolean, not \".concat(b));\n  }\n}\n\nexports.assertBool = assertBool;\n\nfunction assertBytes(bytes) {\n  for (var _len2 = arguments.length, lengths = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    lengths[_key2 - 1] = arguments[_key2];\n  }\n\n  if (bytes instanceof Uint8Array && (!lengths.length || lengths.includes(bytes.length))) {\n    return;\n  }\n\n  throw new TypeError(\"Expected \".concat(lengths, \" bytes, not \").concat(typeof bytes, \" with length=\").concat(bytes.length));\n}\n\nexports.assertBytes = assertBytes;\n\nfunction assertHash(hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  assertNumber(hash.outputLen);\n  assertNumber(hash.blockLen);\n}\n\nexports.assertHash = assertHash; // For runtime check if class implements interface\n\nvar Hash = /*#__PURE__*/function () {\n  function Hash() {\n    _classCallCheck(this, Hash);\n  }\n\n  _createClass(Hash, [{\n    key: \"clone\",\n    // Safe version that clones internal state\n    value: function clone() {\n      return this._cloneInto();\n    }\n  }]);\n\n  return Hash;\n}();\n\nexports.Hash = Hash; // Check if object doens't have custom constructor (like Uint8Array/Array)\n\nvar isPlainObject = function isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n};\n\nfunction checkOpts(def, _opts) {\n  if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts))) throw new TypeError('Options should be object or undefined');\n  var opts = Object.assign(def, _opts);\n  return opts;\n}\n\nexports.checkOpts = checkOpts;\n\nfunction wrapConstructor(hashConstructor) {\n  var hashC = function hashC(message) {\n    return hashConstructor().update(toBytes(message)).digest();\n  };\n\n  var tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = function () {\n    return hashConstructor();\n  };\n\n  return hashC;\n}\n\nexports.wrapConstructor = wrapConstructor;\n\nfunction wrapConstructorWithOpts(hashCons) {\n  var hashC = function hashC(msg, opts) {\n    return hashCons(opts).update(toBytes(msg)).digest();\n  };\n\n  var tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = function (opts) {\n    return hashCons(opts);\n  };\n\n  return hashC;\n}\n\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\n/**\n * Secure PRNG\n */\n\nfunction randomBytes() {\n  var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n  if (crypto_1.crypto.web) {\n    return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n  } else if (crypto_1.crypto.node) {\n    return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);\n  } else {\n    throw new Error(\"The environment doesn't have randomBytes function\");\n  }\n}\n\nexports.randomBytes = randomBytes;","map":null,"metadata":{},"sourceType":"script"}