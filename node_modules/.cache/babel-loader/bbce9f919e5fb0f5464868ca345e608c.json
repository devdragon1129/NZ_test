{"ast":null,"code":"'use strict';\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar pull = require('pull-stream/pull');\n\nvar error = require('pull-stream/sources/error');\n\nvar filter = require('pull-stream/throughs/filter');\n\nvar flatten = require('pull-stream/throughs/flatten');\n\nvar map = require('pull-stream/throughs/map');\n\nvar paramap = require('pull-paramap');\n\nvar CID = require('cids');\n\nvar waterfall = require('async/waterfall');\n\nvar resolvers = {\n  directory: require('./dir-flat'),\n  'hamt-sharded-directory': require('./dir-hamt-sharded'),\n  file: require('./file'),\n  object: require('./object'),\n  raw: require('./raw')\n};\nmodule.exports = Object.assign({\n  createResolver: createResolver,\n  typeOf: typeOf\n}, resolvers);\n\nfunction createResolver(dag, options, depth, parent) {\n  if (!depth) {\n    depth = 0;\n  }\n\n  if (depth > options.maxDepth) {\n    return map(identity);\n  }\n\n  return pull(paramap(function (item, cb) {\n    if (typeof item.depth !== 'number') {\n      return error(new Error('no depth'));\n    }\n\n    if (item.object) {\n      return cb(null, resolveItem(null, item.object, item, options));\n    }\n\n    var cid = new CID(item.multihash);\n    waterfall([function (done) {\n      return dag.get(cid, done);\n    }, function (node, done) {\n      return done(null, resolveItem(cid, node.value, item, options));\n    }], cb);\n  }), flatten(), filter(Boolean), filter(function (node) {\n    return node.depth <= options.maxDepth;\n  }));\n\n  function resolveItem(cid, node, item, options) {\n    return resolve({\n      cid: cid,\n      node: node,\n      name: item.name,\n      path: item.path,\n      pathRest: item.pathRest,\n      size: item.size,\n      dag: dag,\n      parentNode: item.parent || parent,\n      depth: item.depth,\n      options: options\n    });\n  }\n\n  function resolve(_ref) {\n    var cid = _ref.cid,\n        node = _ref.node,\n        name = _ref.name,\n        path = _ref.path,\n        pathRest = _ref.pathRest,\n        size = _ref.size,\n        dag = _ref.dag,\n        parentNode = _ref.parentNode,\n        depth = _ref.depth,\n        options = _ref.options;\n    var type;\n\n    try {\n      type = typeOf(node);\n    } catch (err) {\n      return error(err);\n    }\n\n    var nodeResolver = resolvers[type];\n\n    if (!nodeResolver) {\n      return error(new Error('Unkown node type ' + type));\n    }\n\n    var resolveDeep = createResolver(dag, options, depth, node);\n    return nodeResolver(cid, node, name, path, pathRest, resolveDeep, size, dag, parentNode, depth, options);\n  }\n}\n\nfunction typeOf(node) {\n  if (Buffer.isBuffer(node)) {\n    return 'raw';\n  } else if (Buffer.isBuffer(node.data)) {\n    return UnixFS.unmarshal(node.data).type;\n  } else {\n    return 'object';\n  }\n}\n\nfunction identity(o) {\n  return o;\n}","map":null,"metadata":{},"sourceType":"script"}