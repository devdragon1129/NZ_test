{"ast":null,"code":"import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\nimport { Color4 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { Scene } from \"../../scene\";\nimport { Axis } from '../../Maths/math.axis';\n\nVertexData.CreateCylinder = function (options) {\n  var height = options.height || 2;\n  var diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\n  var diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\n  diameterTop = diameterTop || 0.00001; // Prevent broken normals\n\n  diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\n\n  var tessellation = options.tessellation || 24;\n  var subdivisions = options.subdivisions || 1;\n  var hasRings = options.hasRings ? true : false;\n  var enclose = options.enclose ? true : false;\n  var cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\n  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var faceUV = options.faceUV || new Array(3);\n  var faceColors = options.faceColors; // default face colors and UV if undefined\n\n  var quadNb = arc !== 1 && enclose ? 2 : 0;\n  var ringNb = hasRings ? subdivisions : 1;\n  var surfaceNb = 2 + (1 + quadNb) * ringNb;\n  var f;\n\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceUV && faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n  }\n\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var colors = new Array();\n  var angle_step = Math.PI * 2 * arc / tessellation;\n  var angle;\n  var h;\n  var radius;\n  var tan = (diameterBottom - diameterTop) / 2 / height;\n  var ringVertex = Vector3.Zero();\n  var ringNormal = Vector3.Zero();\n  var ringFirstVertex = Vector3.Zero();\n  var ringFirstNormal = Vector3.Zero();\n  var quadNormal = Vector3.Zero();\n  var Y = Axis.Y; // positions, normals, uvs\n\n  var i;\n  var j;\n  var r;\n  var ringIdx = 1;\n  var s = 1; // surface index\n\n  var cs = 0;\n  var v = 0;\n\n  for (i = 0; i <= subdivisions; i++) {\n    h = i / subdivisions;\n    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\n    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\n\n    for (r = 0; r < ringIdx; r++) {\n      if (hasRings) {\n        s += r;\n      }\n\n      if (enclose) {\n        s += 2 * r;\n      }\n\n      for (j = 0; j <= tessellation; j++) {\n        angle = j * angle_step; // position\n\n        ringVertex.x = Math.cos(-angle) * radius;\n        ringVertex.y = -height / 2 + h * height;\n        ringVertex.z = Math.sin(-angle) * radius; // normal\n\n        if (diameterTop === 0 && i === subdivisions) {\n          // if no top cap, reuse former normals\n          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\n          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\n          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\n        } else {\n          ringNormal.x = ringVertex.x;\n          ringNormal.z = ringVertex.z;\n          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\n          ringNormal.normalize();\n        } // keep first ring vertex values for enclose\n\n\n        if (j === 0) {\n          ringFirstVertex.copyFrom(ringVertex);\n          ringFirstNormal.copyFrom(ringNormal);\n        }\n\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s].y : faceUV[s].w;\n        } else {\n          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\n        }\n\n        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, v);\n\n        if (faceColors) {\n          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\n        }\n      } // if enclose, add four vertices and their dedicated normals\n\n\n      if (arc !== 1 && enclose) {\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\n        Vector3.CrossToRef(Y, ringNormal, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n        Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\n        } else {\n          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\n        }\n\n        uvs.push(faceUV[s + 1].x, v);\n        uvs.push(faceUV[s + 1].z, v);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\n        } else {\n          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\n        }\n\n        uvs.push(faceUV[s + 2].x, v);\n        uvs.push(faceUV[s + 2].z, v);\n\n        if (faceColors) {\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n        }\n      }\n\n      if (cs !== s) {\n        cs = s;\n      }\n    }\n  } // indices\n\n\n  var e = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\n\n  var s;\n  i = 0;\n\n  for (s = 0; s < subdivisions; s++) {\n    var i0 = 0;\n    var i1 = 0;\n    var i2 = 0;\n    var i3 = 0;\n\n    for (j = 0; j < tessellation; j++) {\n      i0 = i * (e + 1) + j;\n      i1 = (i + 1) * (e + 1) + j;\n      i2 = i * (e + 1) + (j + 1);\n      i3 = (i + 1) * (e + 1) + (j + 1);\n      indices.push(i0, i1, i2);\n      indices.push(i3, i2, i1);\n    }\n\n    if (arc !== 1 && enclose) {\n      // if enclose, add two quads\n      indices.push(i0 + 2, i1 + 2, i2 + 2);\n      indices.push(i3 + 2, i2 + 2, i1 + 2);\n      indices.push(i0 + 4, i1 + 4, i2 + 4);\n      indices.push(i3 + 4, i2 + 4, i1 + 4);\n    }\n\n    i = hasRings ? i + 2 : i + 1;\n  } // Caps\n\n\n  var createCylinderCap = function createCylinderCap(isTop) {\n    var radius = isTop ? diameterTop / 2 : diameterBottom / 2;\n\n    if (radius === 0) {\n      return;\n    } // Cap positions, normals & uvs\n\n\n    var angle;\n    var circleVector;\n    var i;\n    var u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\n    var c = null;\n\n    if (faceColors) {\n      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\n    } // cap center\n\n\n    var vbase = positions.length / 3;\n    var offset = isTop ? height / 2 : -height / 2;\n    var center = new Vector3(0, offset, 0);\n    positions.push(center.x, center.y, center.z);\n    normals.push(0, isTop ? 1 : -1, 0);\n    uvs.push(u.x + (u.z - u.x) * 0.5, u.y + (u.w - u.y) * 0.5);\n\n    if (c) {\n      colors.push(c.r, c.g, c.b, c.a);\n    }\n\n    var textureScale = new Vector2(0.5, 0.5);\n\n    for (i = 0; i <= tessellation; i++) {\n      angle = Math.PI * 2 * i * arc / tessellation;\n      var cos = Math.cos(-angle);\n      var sin = Math.sin(-angle);\n      circleVector = new Vector3(cos * radius, offset, sin * radius);\n      var textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\n      positions.push(circleVector.x, circleVector.y, circleVector.z);\n      normals.push(0, isTop ? 1 : -1, 0);\n      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, u.y + (u.w - u.y) * textureCoordinate.y);\n\n      if (c) {\n        colors.push(c.r, c.g, c.b, c.a);\n      }\n    } // Cap indices\n\n\n    for (i = 0; i < tessellation; i++) {\n      if (!isTop) {\n        indices.push(vbase);\n        indices.push(vbase + (i + 1));\n        indices.push(vbase + (i + 2));\n      } else {\n        indices.push(vbase);\n        indices.push(vbase + (i + 2));\n        indices.push(vbase + (i + 1));\n      }\n    }\n  }; // add caps to geometry based on cap parameter\n\n\n  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\n    createCylinderCap(false);\n  }\n\n  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\n    createCylinderCap(true);\n  } // Sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    vertexData.colors = colors;\n  }\n\n  return vertexData;\n};\n\nMesh.CreateCylinder = function (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {\n  if (scene === undefined || !(scene instanceof Scene)) {\n    if (scene !== undefined) {\n      sideOrientation = updatable || Mesh.DEFAULTSIDE;\n      updatable = scene;\n    }\n\n    scene = subdivisions;\n    subdivisions = 1;\n  }\n\n  var options = {\n    height: height,\n    diameterTop: diameterTop,\n    diameterBottom: diameterBottom,\n    tessellation: tessellation,\n    subdivisions: subdivisions,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CylinderBuilder.CreateCylinder(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar CylinderBuilder =\n/** @class */\nfunction () {\n  function CylinderBuilder() {}\n  /**\r\n   * Creates a cylinder or a cone mesh\r\n   * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n   * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n   * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n   * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n   * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n   * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n   * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n   * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n   * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n   * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n   * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n   * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n   * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n   * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n   * * If `enclose` is false, a ring surface is one element.\r\n   * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n   * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the cylinder mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone\r\n   */\n\n\n  CylinderBuilder.CreateCylinder = function (name, options, scene) {\n    var cylinder = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateCylinder(options);\n    vertexData.applyToMesh(cylinder, options.updatable);\n    return cylinder;\n  };\n\n  return CylinderBuilder;\n}();\n\nexport { CylinderBuilder };","map":null,"metadata":{},"sourceType":"module"}