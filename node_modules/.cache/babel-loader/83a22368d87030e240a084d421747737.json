{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { Material } from \"../Materials/material\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\nimport { EffectLayer } from \"./effectLayer\";\nimport { AbstractScene } from \"../abstractScene\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { Engine } from '../Engines/engine';\nimport { Color4 } from '../Maths/math.color';\nimport \"../Shaders/glowMapMerge.fragment\";\nimport \"../Shaders/glowMapMerge.vertex\";\nimport \"../Layers/effectLayerSceneComponent\";\n\nAbstractScene.prototype.getGlowLayerByName = function (name) {\n  for (var index = 0; index < this.effectLayers.length; index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n\n  return null;\n};\n/**\r\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\r\n *\r\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\r\n *\r\n * Documentation: https://doc.babylonjs.com/how_to/glow_layer\r\n */\n\n\nvar GlowLayer =\n/** @class */\nfunction (_super) {\n  __extends(GlowLayer, _super);\n  /**\r\n   * Instantiates a new glow Layer and references it to the scene.\r\n   * @param name The name of the layer\r\n   * @param scene The scene to use the layer in\r\n   * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n   */\n\n\n  function GlowLayer(name, scene, options) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._intensity = 1.0;\n    _this._includedOnlyMeshes = [];\n    _this._excludedMeshes = [];\n    _this._meshesUsingTheirOwnMaterials = [];\n    _this.neutralColor = new Color4(0, 0, 0, 1); // Adapt options\n\n    _this._options = __assign({\n      mainTextureRatio: GlowLayer.DefaultTextureRatio,\n      blurKernelSize: 32,\n      mainTextureFixedSize: undefined,\n      camera: null,\n      mainTextureSamples: 1,\n      renderingGroupId: -1\n    }, options); // Initialize the layer\n\n    _this._init({\n      alphaBlendingMode: 1,\n      camera: _this._options.camera,\n      mainTextureFixedSize: _this._options.mainTextureFixedSize,\n      mainTextureRatio: _this._options.mainTextureRatio,\n      renderingGroupId: _this._options.renderingGroupId\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(GlowLayer.prototype, \"blurKernelSize\", {\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\n    get: function get() {\n      return this._horizontalBlurPostprocess1.kernel;\n    },\n\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\n    set: function set(value) {\n      this._horizontalBlurPostprocess1.kernel = value;\n      this._verticalBlurPostprocess1.kernel = value;\n      this._horizontalBlurPostprocess2.kernel = value;\n      this._verticalBlurPostprocess2.kernel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlowLayer.prototype, \"intensity\", {\n    /**\r\n     * Gets the glow intensity.\r\n     */\n    get: function get() {\n      return this._intensity;\n    },\n\n    /**\r\n     * Sets the glow intensity.\r\n     */\n    set: function set(value) {\n      this._intensity = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the effect name of the layer.\r\n   * @return The effect name\r\n   */\n\n  GlowLayer.prototype.getEffectName = function () {\n    return GlowLayer.EffectName;\n  };\n  /**\r\n   * Create the merge effect. This is the shader use to blit the information back\r\n   * to the main canvas at the end of the scene rendering.\r\n   */\n\n\n  GlowLayer.prototype._createMergeEffect = function () {\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], \"#define EMISSIVE \\n\");\n  };\n  /**\r\n   * Creates the render target textures and post processes used in the glow layer.\r\n   */\n\n\n  GlowLayer.prototype._createTextureAndPostProcesses = function () {\n    var _this = this;\n\n    var blurTextureWidth = this._mainTextureDesiredSize.width;\n    var blurTextureHeight = this._mainTextureDesiredSize.height;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n\n    this._blurTexture1 = new RenderTargetTexture(\"GlowLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\n\n    this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._blurTexture1.renderParticles = false;\n    this._blurTexture1.ignoreCameraViewport = true;\n    var blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\n    var blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\n    this._blurTexture2 = new RenderTargetTexture(\"GlowLayerBlurRTT2\", {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, this._scene, false, true, textureType);\n    this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\n\n    this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._blurTexture2.renderParticles = false;\n    this._blurTexture2.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture1, this._blurTexture2];\n    this._horizontalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerHBP1\", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess1.width = blurTextureWidth;\n    this._horizontalBlurPostprocess1.height = blurTextureHeight;\n\n    this._horizontalBlurPostprocess1.onApplyObservable.add(function (effect) {\n      effect.setTexture(\"textureSampler\", _this._mainTexture);\n    });\n\n    this._verticalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerVBP1\", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerHBP2\", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2.width = blurTextureWidth2;\n    this._horizontalBlurPostprocess2.height = blurTextureHeight2;\n\n    this._horizontalBlurPostprocess2.onApplyObservable.add(function (effect) {\n      effect.setTexture(\"textureSampler\", _this._blurTexture1);\n    });\n\n    this._verticalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerVBP2\", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\n    this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._mainTexture.samples = this._options.mainTextureSamples;\n\n    this._mainTexture.onAfterUnbindObservable.add(function () {\n      var internalTexture = _this._blurTexture1.getInternalTexture();\n\n      if (internalTexture) {\n        _this._scene.postProcessManager.directRender(_this._postProcesses1, internalTexture, true);\n\n        var internalTexture2 = _this._blurTexture2.getInternalTexture();\n\n        if (internalTexture2) {\n          _this._scene.postProcessManager.directRender(_this._postProcesses2, internalTexture2, true);\n        }\n\n        _this._engine.unBindFramebuffer(internalTexture2 !== null && internalTexture2 !== void 0 ? internalTexture2 : internalTexture, true);\n      }\n    }); // Prevent autoClear.\n\n\n    this._postProcesses.map(function (pp) {\n      pp.autoClear = false;\n    });\n  };\n  /**\r\n   * Checks for the readiness of the element composing the layer.\r\n   * @param subMesh the mesh to check for\r\n   * @param useInstances specify wether or not to use instances to render the mesh\r\n   * @param emissiveTexture the associated emissive texture used to generate the glow\r\n   * @return true if ready otherwise, false\r\n   */\n\n\n  GlowLayer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n    var mesh = subMesh.getRenderingMesh();\n\n    if (!material || !mesh) {\n      return false;\n    }\n\n    var emissiveTexture = material.emissiveTexture;\n    return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);\n  };\n  /**\r\n   * Returns whether or nood the layer needs stencil enabled during the mesh rendering.\r\n   */\n\n\n  GlowLayer.prototype.needStencil = function () {\n    return false;\n  };\n  /**\r\n   * Returns true if the mesh can be rendered, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @param material The material used on the mesh\r\n   * @returns true if it can be rendered otherwise false\r\n   */\n\n\n  GlowLayer.prototype._canRenderMesh = function (mesh, material) {\n    return true;\n  };\n  /**\r\n   * Implementation specific of rendering the generating effect on the main canvas.\r\n   * @param effect The effect used to render through\r\n   */\n\n\n  GlowLayer.prototype._internalRender = function (effect) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture1);\n    effect.setTexture(\"textureSampler2\", this._blurTexture2);\n    effect.setFloat(\"offset\", this._intensity); // Cache\n\n    var engine = this._engine;\n    var previousStencilBuffer = engine.getStencilBuffer(); // Draw order\n\n    engine.setStencilBuffer(false);\n    engine.drawElementsType(Material.TriangleFillMode, 0, 6); // Draw order\n\n    engine.setStencilBuffer(previousStencilBuffer);\n  };\n  /**\r\n   * Sets the required values for both the emissive texture and and the main color.\r\n   */\n\n\n  GlowLayer.prototype._setEmissiveTextureAndColor = function (mesh, subMesh, material) {\n    var textureLevel = 1.0;\n\n    if (this.customEmissiveTextureSelector) {\n      this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\n    } else {\n      if (material) {\n        this._emissiveTextureAndColor.texture = material.emissiveTexture;\n\n        if (this._emissiveTextureAndColor.texture) {\n          textureLevel = this._emissiveTextureAndColor.texture.level;\n        }\n      } else {\n        this._emissiveTextureAndColor.texture = null;\n      }\n    }\n\n    if (this.customEmissiveColorSelector) {\n      this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\n    } else {\n      if (material.emissiveColor) {\n        this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);\n      } else {\n        this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n      }\n    }\n  };\n  /**\r\n   * Returns true if the mesh should render, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @returns true if it should render otherwise false\r\n   */\n\n\n  GlowLayer.prototype._shouldRenderMesh = function (mesh) {\n    return this.hasMesh(mesh);\n  };\n  /**\r\n   * Adds specific effects defines.\r\n   * @param defines The defines to add specifics to.\r\n   */\n\n\n  GlowLayer.prototype._addCustomEffectDefines = function (defines) {\n    defines.push(\"#define GLOW\");\n  };\n  /**\r\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n   * @param mesh The mesh to exclude from the glow layer\r\n   */\n\n\n  GlowLayer.prototype.addExcludedMesh = function (mesh) {\n    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._excludedMeshes.push(mesh.uniqueId);\n    }\n  };\n  /**\r\n    * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n    * @param mesh The mesh to remove\r\n    */\n\n\n  GlowLayer.prototype.removeExcludedMesh = function (mesh) {\n    var index = this._excludedMeshes.indexOf(mesh.uniqueId);\n\n    if (index !== -1) {\n      this._excludedMeshes.splice(index, 1);\n    }\n  };\n  /**\r\n   * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n   * @param mesh The mesh to include in the glow layer\r\n   */\n\n\n  GlowLayer.prototype.addIncludedOnlyMesh = function (mesh) {\n    if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._includedOnlyMeshes.push(mesh.uniqueId);\n    }\n  };\n  /**\r\n    * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n    * @param mesh The mesh to remove\r\n    */\n\n\n  GlowLayer.prototype.removeIncludedOnlyMesh = function (mesh) {\n    var index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\n\n    if (index !== -1) {\n      this._includedOnlyMeshes.splice(index, 1);\n    }\n  };\n  /**\r\n   * Determine if a given mesh will be used in the glow layer\r\n   * @param mesh The mesh to test\r\n   * @returns true if the mesh will be highlighted by the current glow layer\r\n   */\n\n\n  GlowLayer.prototype.hasMesh = function (mesh) {\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    } // Included Mesh\n\n\n    if (this._includedOnlyMeshes.length) {\n      return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\n    } // Excluded Mesh\n\n\n    if (this._excludedMeshes.length) {\n      return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\n    }\n\n    return true;\n  };\n  /**\r\n   * Defines whether the current material of the mesh should be use to render the effect.\r\n   * @param mesh defines the current mesh to render\r\n   */\n\n\n  GlowLayer.prototype._useMeshMaterial = function (mesh) {\n    if (this._meshesUsingTheirOwnMaterials.length == 0) {\n      return false;\n    }\n\n    return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\n  };\n  /**\r\n   * Add a mesh to be rendered through its own material and not with emissive only.\r\n   * @param mesh The mesh for which we need to use its material\r\n   */\n\n\n  GlowLayer.prototype.referenceMeshToUseItsOwnMaterial = function (mesh) {\n    this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\n  };\n  /**\r\n   * Remove a mesh from being rendered through its own material and not with emissive only.\r\n   * @param mesh The mesh for which we need to not use its material\r\n   */\n\n\n  GlowLayer.prototype.unReferenceMeshFromUsingItsOwnMaterial = function (mesh) {\n    var index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n\n    while (index >= 0) {\n      this._meshesUsingTheirOwnMaterials.splice(index, 1);\n\n      index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n    }\n  };\n  /**\r\n   * Free any resources and references associated to a mesh.\r\n   * Internal use\r\n   * @param mesh The mesh to free.\r\n   * @hidden\r\n   */\n\n\n  GlowLayer.prototype._disposeMesh = function (mesh) {\n    this.removeIncludedOnlyMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  };\n  /**\r\n    * Gets the class name of the effect layer\r\n    * @returns the string with the class name of the effect layer\r\n    */\n\n\n  GlowLayer.prototype.getClassName = function () {\n    return \"GlowLayer\";\n  };\n  /**\r\n   * Serializes this glow layer\r\n   * @returns a serialized glow layer object\r\n   */\n\n\n  GlowLayer.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.GlowLayer\";\n    var index; // Included meshes\n\n    serializationObject.includedMeshes = [];\n\n    if (this._includedOnlyMeshes.length) {\n      for (index = 0; index < this._includedOnlyMeshes.length; index++) {\n        var mesh = this._scene.getMeshByUniqueID(this._includedOnlyMeshes[index]);\n\n        if (mesh) {\n          serializationObject.includedMeshes.push(mesh.id);\n        }\n      }\n    } // Excluded meshes\n\n\n    serializationObject.excludedMeshes = [];\n\n    if (this._excludedMeshes.length) {\n      for (index = 0; index < this._excludedMeshes.length; index++) {\n        var mesh = this._scene.getMeshByUniqueID(this._excludedMeshes[index]);\n\n        if (mesh) {\n          serializationObject.excludedMeshes.push(mesh.id);\n        }\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Creates a Glow Layer from parsed glow layer data\r\n   * @param parsedGlowLayer defines glow layer data\r\n   * @param scene defines the current scene\r\n   * @param rootUrl defines the root URL containing the glow layer information\r\n   * @returns a parsed Glow Layer\r\n   */\n\n\n  GlowLayer.Parse = function (parsedGlowLayer, scene, rootUrl) {\n    var gl = SerializationHelper.Parse(function () {\n      return new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options);\n    }, parsedGlowLayer, scene, rootUrl);\n    var index; // Excluded meshes\n\n    for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\n      var mesh = scene.getMeshByID(parsedGlowLayer.excludedMeshes[index]);\n\n      if (mesh) {\n        gl.addExcludedMesh(mesh);\n      }\n    } // Included meshes\n\n\n    for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\n      var mesh = scene.getMeshByID(parsedGlowLayer.includedMeshes[index]);\n\n      if (mesh) {\n        gl.addIncludedOnlyMesh(mesh);\n      }\n    }\n\n    return gl;\n  };\n  /**\r\n   * Effect Name of the layer.\r\n   */\n\n\n  GlowLayer.EffectName = \"GlowLayer\";\n  /**\r\n   * The default blur kernel size used for the glow.\r\n   */\n\n  GlowLayer.DefaultBlurKernelSize = 32;\n  /**\r\n   * The default texture size ratio used for the glow.\r\n   */\n\n  GlowLayer.DefaultTextureRatio = 0.5;\n\n  __decorate([serialize()], GlowLayer.prototype, \"blurKernelSize\", null);\n\n  __decorate([serialize()], GlowLayer.prototype, \"intensity\", null);\n\n  __decorate([serialize(\"options\")], GlowLayer.prototype, \"_options\", void 0);\n\n  return GlowLayer;\n}(EffectLayer);\n\nexport { GlowLayer };\n_TypeStore.RegisteredTypes[\"BABYLON.GlowLayer\"] = GlowLayer;","map":null,"metadata":{},"sourceType":"module"}