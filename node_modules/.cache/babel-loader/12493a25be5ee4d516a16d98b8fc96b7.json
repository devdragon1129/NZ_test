{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport { Observable } from \"../Misc/observable\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { Scene } from \"../scene\";\nimport { PhysicsEngine } from \"./physicsEngine\";\nimport { PhysicsJoint } from \"./physicsJoint\";\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\n\nScene.prototype.getPhysicsEngine = function () {\n  return this._physicsEngine;\n};\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to OimoJS.\r\n * @return a boolean indicating if the physics engine was initialized\r\n */\n\n\nScene.prototype.enablePhysics = function (gravity, plugin) {\n  if (gravity === void 0) {\n    gravity = null;\n  }\n\n  if (this._physicsEngine) {\n    return true;\n  } // Register the component to the scene\n\n\n  var component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);\n\n  if (!component) {\n    component = new PhysicsEngineSceneComponent(this);\n\n    this._addComponent(component);\n  }\n\n  try {\n    this._physicsEngine = new PhysicsEngine(gravity, plugin);\n    this._physicsTimeAccumulator = 0;\n    return true;\n  } catch (e) {\n    Logger.Error(e.message);\n    return false;\n  }\n};\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\n\n\nScene.prototype.disablePhysicsEngine = function () {\n  if (!this._physicsEngine) {\n    return;\n  }\n\n  this._physicsEngine.dispose();\n\n  this._physicsEngine = null;\n};\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\n\n\nScene.prototype.isPhysicsEnabled = function () {\n  return this._physicsEngine !== undefined;\n};\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\n\n\nScene.prototype.deleteCompoundImpostor = function (compound) {\n  var mesh = compound.parts[0].mesh;\n\n  if (mesh.physicsImpostor) {\n    mesh.physicsImpostor.dispose();\n    mesh.physicsImpostor = null;\n  }\n};\n/** @hidden */\n\n\nScene.prototype._advancePhysicsEngineStep = function (step) {\n  if (this._physicsEngine) {\n    var subTime = this._physicsEngine.getSubTimeStep();\n\n    if (subTime > 0) {\n      this._physicsTimeAccumulator += step;\n\n      while (this._physicsTimeAccumulator > subTime) {\n        this.onBeforePhysicsObservable.notifyObservers(this);\n\n        this._physicsEngine._step(subTime / 1000);\n\n        this.onAfterPhysicsObservable.notifyObservers(this);\n        this._physicsTimeAccumulator -= subTime;\n      }\n    } else {\n      this.onBeforePhysicsObservable.notifyObservers(this);\n\n      this._physicsEngine._step(step / 1000);\n\n      this.onAfterPhysicsObservable.notifyObservers(this);\n    }\n  }\n};\n\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\n  get: function get() {\n    return this._physicsImpostor;\n  },\n  set: function set(value) {\n    var _this = this;\n\n    if (this._physicsImpostor === value) {\n      return;\n    }\n\n    if (this._disposePhysicsObserver) {\n      this.onDisposeObservable.remove(this._disposePhysicsObserver);\n    }\n\n    this._physicsImpostor = value;\n\n    if (value) {\n      this._disposePhysicsObserver = this.onDisposeObservable.add(function () {\n        // Physics\n        if (_this.physicsImpostor) {\n          _this.physicsImpostor.dispose();\n\n          _this.physicsImpostor = null;\n        }\n      });\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\r\n * Gets the current physics impostor\r\n * @see https://doc.babylonjs.com/features/physics_engine\r\n * @returns a physics impostor or null\r\n */\n\nAbstractMesh.prototype.getPhysicsImpostor = function () {\n  return this.physicsImpostor;\n};\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\n\n\nAbstractMesh.prototype.applyImpulse = function (force, contactPoint) {\n  if (!this.physicsImpostor) {\n    return this;\n  }\n\n  this.physicsImpostor.applyImpulse(force, contactPoint);\n  return this;\n};\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\n\n\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh, pivot1, pivot2, options) {\n  if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\n    return this;\n  }\n\n  this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\n    mainPivot: pivot1,\n    connectedPivot: pivot2,\n    nativeParams: options\n  });\n  return this;\n};\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\n\n\nvar PhysicsEngineSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function PhysicsEngineSceneComponent(scene) {\n    var _this = this;\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\n\n\n    this.name = SceneComponentConstants.NAME_PHYSICSENGINE;\n    this.scene = scene;\n    this.scene.onBeforePhysicsObservable = new Observable();\n    this.scene.onAfterPhysicsObservable = new Observable(); // Replace the function used to get the deterministic frame time\n\n    this.scene.getDeterministicFrameTime = function () {\n      if (_this.scene._physicsEngine) {\n        return _this.scene._physicsEngine.getTimeStep() * 1000;\n      }\n\n      return 1000.0 / 60.0;\n    };\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.register = function () {};\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.rebuild = function () {// Nothing to do for this component\n  };\n  /**\r\n   * Disposes the component and the associated ressources\r\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.dispose = function () {\n    this.scene.onBeforePhysicsObservable.clear();\n    this.scene.onAfterPhysicsObservable.clear();\n\n    if (this.scene._physicsEngine) {\n      this.scene.disablePhysicsEngine();\n    }\n  };\n\n  return PhysicsEngineSceneComponent;\n}();\n\nexport { PhysicsEngineSceneComponent };","map":null,"metadata":{},"sourceType":"module"}