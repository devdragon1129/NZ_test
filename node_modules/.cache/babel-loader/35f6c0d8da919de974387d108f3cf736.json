{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess\";\nimport { BlurPostProcess } from \"./blurPostProcess\";\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport { Texture } from \"../Materials/Textures/texture\";\n/**\r\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\r\n */\n\nvar BloomEffect =\n/** @class */\nfunction (_super) {\n  __extends(BloomEffect, _super);\n  /**\r\n   * Creates a new instance of @see BloomEffect\r\n   * @param scene The scene the effect belongs to.\r\n   * @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n   * @param bloomKernel The size of the kernel to be used when applying the blur.\r\n   * @param bloomWeight The the strength of bloom.\r\n   * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n   */\n\n\n  function BloomEffect(scene, bloomScale, bloomWeight, bloomKernel, pipelineTextureType, blockCompilation) {\n    if (pipelineTextureType === void 0) {\n      pipelineTextureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    var _this = _super.call(this, scene.getEngine(), \"bloom\", function () {\n      return _this._effects;\n    }, true) || this;\n\n    _this.bloomScale = bloomScale;\n    /**\r\n     * @hidden Internal\r\n     */\n\n    _this._effects = [];\n    _this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    _this._blurX = new BlurPostProcess(\"horizontal blur\", new Vector2(1.0, 0), 10.0, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    _this._blurX.alwaysForcePOT = true;\n    _this._blurX.autoClear = false;\n    _this._blurY = new BlurPostProcess(\"vertical blur\", new Vector2(0, 1.0), 10.0, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    _this._blurY.alwaysForcePOT = true;\n    _this._blurY.autoClear = false;\n    _this.kernel = bloomKernel;\n    _this._effects = [_this._downscale, _this._blurX, _this._blurY];\n    _this._merge = new BloomMergePostProcess(\"bloomMerge\", _this._downscale, _this._blurY, bloomWeight, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    _this._merge.autoClear = false;\n\n    _this._effects.push(_this._merge);\n\n    return _this;\n  }\n\n  Object.defineProperty(BloomEffect.prototype, \"threshold\", {\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\n    get: function get() {\n      return this._downscale.threshold;\n    },\n    set: function set(value) {\n      this._downscale.threshold = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BloomEffect.prototype, \"weight\", {\n    /**\r\n     * The strength of the bloom.\r\n     */\n    get: function get() {\n      return this._merge.weight;\n    },\n    set: function set(value) {\n      this._merge.weight = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BloomEffect.prototype, \"kernel\", {\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\n    get: function get() {\n      return this._blurX.kernel / this.bloomScale;\n    },\n    set: function set(value) {\n      this._blurX.kernel = value * this.bloomScale;\n      this._blurY.kernel = value * this.bloomScale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes each of the internal effects for a given camera.\r\n   * @param camera The camera to dispose the effect on.\r\n   */\n\n  BloomEffect.prototype.disposeEffects = function (camera) {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].dispose(camera);\n    }\n  };\n  /**\r\n   * @hidden Internal\r\n   */\n\n\n  BloomEffect.prototype._updateEffects = function () {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].updateEffect();\n    }\n  };\n  /**\r\n   * Internal\r\n   * @returns if all the contained post processes are ready.\r\n   * @hidden\r\n   */\n\n\n  BloomEffect.prototype._isReady = function () {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      if (!this._effects[effectIndex].isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return BloomEffect;\n}(PostProcessRenderEffect);\n\nexport { BloomEffect };","map":null,"metadata":{},"sourceType":"module"}