{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { Color3 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { GroundMesh } from \"../groundMesh\";\nimport { Tools } from \"../../Misc/tools\";\nimport { EngineStore } from '../../Engines/engineStore';\nimport { Epsilon } from '../../Maths/math.constants';\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\n\nVertexData.CreateGround = function (options) {\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var row, col;\n  var width = options.width || 1;\n  var height = options.height || 1;\n  var subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n  var subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n\n  for (row = 0; row <= subdivisionsY; row++) {\n    for (col = 0; col <= subdivisionsX; col++) {\n      var position = new Vector3(col * width / subdivisionsX - width / 2.0, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2.0);\n      var normal = new Vector3(0, 1.0, 0);\n      positions.push(position.x, position.y, position.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(col / subdivisionsX, 1.0 - row / subdivisionsY);\n    }\n  }\n\n  for (row = 0; row < subdivisionsY; row++) {\n    for (col = 0; col < subdivisionsX; col++) {\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + row * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n      indices.push(col + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nVertexData.CreateTiledGround = function (options) {\n  var xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\n  var zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\n  var xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\n  var zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\n  var subdivisions = options.subdivisions || {\n    w: 1,\n    h: 1\n  };\n  var precision = options.precision || {\n    w: 1,\n    h: 1\n  };\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var row, col, tileRow, tileCol;\n  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\n  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\n  precision.w = precision.w < 1 ? 1 : precision.w;\n  precision.h = precision.h < 1 ? 1 : precision.h;\n  var tileSize = {\n    'w': (xmax - xmin) / subdivisions.w,\n    'h': (zmax - zmin) / subdivisions.h\n  };\n\n  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\n    // Indices\n    var base = positions.length / 3;\n    var rowLength = precision.w + 1;\n\n    for (row = 0; row < precision.h; row++) {\n      for (col = 0; col < precision.w; col++) {\n        var square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\n        indices.push(square[1]);\n        indices.push(square[2]);\n        indices.push(square[3]);\n        indices.push(square[0]);\n        indices.push(square[1]);\n        indices.push(square[3]);\n      }\n    } // Position, normals and uvs\n\n\n    var position = Vector3.Zero();\n    var normal = new Vector3(0, 1.0, 0);\n\n    for (row = 0; row <= precision.h; row++) {\n      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;\n\n      for (col = 0; col <= precision.w; col++) {\n        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;\n        position.y = 0;\n        positions.push(position.x, position.y, position.z);\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(col / precision.w, row / precision.h);\n      }\n    }\n  }\n\n  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\n    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\n      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nVertexData.CreateGroundFromHeightMap = function (options) {\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var row, col;\n  var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n  var alphaFilter = options.alphaFilter || 0.0;\n  var invert = false;\n\n  if (options.minHeight > options.maxHeight) {\n    invert = true;\n    var temp = options.maxHeight;\n    options.maxHeight = options.minHeight;\n    options.minHeight = temp;\n  } // Vertices\n\n\n  for (row = 0; row <= options.subdivisions; row++) {\n    for (col = 0; col <= options.subdivisions; col++) {\n      var position = new Vector3(col * options.width / options.subdivisions - options.width / 2.0, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2.0); // Compute height\n\n      var heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;\n      var heightMapY = (1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;\n      var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\n      var r = options.buffer[pos] / 255.0;\n      var g = options.buffer[pos + 1] / 255.0;\n      var b = options.buffer[pos + 2] / 255.0;\n      var a = options.buffer[pos + 3] / 255.0;\n\n      if (invert) {\n        r = 1.0 - r;\n        g = 1.0 - g;\n        b = 1.0 - b;\n      }\n\n      var gradient = r * filter.r + g * filter.g + b * filter.b; // If our alpha channel is not within our filter then we will assign a 'special' height\n      // Then when building the indices, we will ignore any vertex that is using the special height\n\n      if (a >= alphaFilter) {\n        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\n      } else {\n        position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\n      } // Add  vertex\n\n\n      positions.push(position.x, position.y, position.z);\n      normals.push(0, 0, 0);\n      uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\n    }\n  } // Indices\n\n\n  for (row = 0; row < options.subdivisions; row++) {\n    for (col = 0; col < options.subdivisions; col++) {\n      // Calculate Indices\n      var idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\n      var idx2 = col + 1 + row * (options.subdivisions + 1);\n      var idx3 = col + row * (options.subdivisions + 1);\n      var idx4 = col + (row + 1) * (options.subdivisions + 1); // Check that all indices are visible (based on our special height)\n      // Only display the vertex if all Indices are visible\n      // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\n\n      var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\n      var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\n      var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\n\n      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\n        indices.push(idx1);\n        indices.push(idx2);\n        indices.push(idx3);\n      }\n\n      var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\n\n      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\n        indices.push(idx4);\n        indices.push(idx1);\n        indices.push(idx3);\n      }\n    }\n  } // Normals\n\n\n  VertexData.ComputeNormals(positions, indices, normals); // Result\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nMesh.CreateGround = function (name, width, height, subdivisions, scene, updatable) {\n  var options = {\n    width: width,\n    height: height,\n    subdivisions: subdivisions,\n    updatable: updatable\n  };\n  return GroundBuilder.CreateGround(name, options, scene);\n};\n\nMesh.CreateTiledGround = function (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {\n  var options = {\n    xmin: xmin,\n    zmin: zmin,\n    xmax: xmax,\n    zmax: zmax,\n    subdivisions: subdivisions,\n    precision: precision,\n    updatable: updatable\n  };\n  return GroundBuilder.CreateTiledGround(name, options, scene);\n};\n\nMesh.CreateGroundFromHeightMap = function (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {\n  var options = {\n    width: width,\n    height: height,\n    subdivisions: subdivisions,\n    minHeight: minHeight,\n    maxHeight: maxHeight,\n    updatable: updatable,\n    onReady: onReady,\n    alphaFilter: alphaFilter\n  };\n  return GroundBuilder.CreateGroundFromHeightMap(name, url, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar GroundBuilder =\n/** @class */\nfunction () {\n  function GroundBuilder() {}\n  /**\r\n   * Creates a ground mesh\r\n   * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n   * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the ground mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n   */\n\n\n  GroundBuilder.CreateGround = function (name, options, scene) {\n    var ground = new GroundMesh(name, scene);\n\n    ground._setReady(false);\n\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n    ground._width = options.width || 1;\n    ground._height = options.height || 1;\n    ground._maxX = ground._width / 2;\n    ground._maxZ = ground._height / 2;\n    ground._minX = -ground._maxX;\n    ground._minZ = -ground._maxZ;\n    var vertexData = VertexData.CreateGround(options);\n    vertexData.applyToMesh(ground, options.updatable);\n\n    ground._setReady(true);\n\n    return ground;\n  };\n  /**\r\n   * Creates a tiled ground mesh\r\n   * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n   * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n   * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n   * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the tiled ground mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n   */\n\n\n  GroundBuilder.CreateTiledGround = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var tiledGround = new Mesh(name, scene);\n    var vertexData = VertexData.CreateTiledGround(options);\n    vertexData.applyToMesh(tiledGround, options.updatable);\n    return tiledGround;\n  };\n  /**\r\n   * Creates a ground mesh from a height map\r\n   * * The parameter `url` sets the URL of the height map image resource.\r\n   * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n   * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n   * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n   * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n   * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n   * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n   * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param url defines the url to the height map\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the ground mesh\r\n   * @see https://doc.babylonjs.com/babylon101/height_map\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n   */\n\n\n  GroundBuilder.CreateGroundFromHeightMap = function (name, url, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var width = options.width || 10.0;\n    var height = options.height || 10.0;\n    var subdivisions = options.subdivisions || 1 | 0;\n    var minHeight = options.minHeight || 0.0;\n    var maxHeight = options.maxHeight || 1.0;\n    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n    var alphaFilter = options.alphaFilter || 0.0;\n    var updatable = options.updatable;\n    var onReady = options.onReady;\n    scene = scene || EngineStore.LastCreatedScene;\n    var ground = new GroundMesh(name, scene);\n    ground._subdivisionsX = subdivisions;\n    ground._subdivisionsY = subdivisions;\n    ground._width = width;\n    ground._height = height;\n    ground._maxX = ground._width / 2.0;\n    ground._maxZ = ground._height / 2.0;\n    ground._minX = -ground._maxX;\n    ground._minZ = -ground._maxZ;\n\n    ground._setReady(false);\n\n    var onload = function onload(img) {\n      var bufferWidth = img.width;\n      var bufferHeight = img.height; // Getting height map data\n\n      var canvas = CanvasGenerator.CreateCanvas(bufferWidth, bufferHeight);\n      var context = canvas.getContext(\"2d\");\n\n      if (!context) {\n        throw new Error(\"Unable to get 2d context for CreateGroundFromHeightMap\");\n      }\n\n      if (scene.isDisposed) {\n        return;\n      }\n\n      context.drawImage(img, 0, 0); // Create VertexData from map data\n      // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n\n      var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;\n      var vertexData = VertexData.CreateGroundFromHeightMap({\n        width: width,\n        height: height,\n        subdivisions: subdivisions,\n        minHeight: minHeight,\n        maxHeight: maxHeight,\n        colorFilter: filter,\n        buffer: buffer,\n        bufferWidth: bufferWidth,\n        bufferHeight: bufferHeight,\n        alphaFilter: alphaFilter\n      });\n      vertexData.applyToMesh(ground, updatable); //execute ready callback, if set\n\n      if (onReady) {\n        onReady(ground);\n      }\n\n      ground._setReady(true);\n    };\n\n    Tools.LoadImage(url, onload, function () {}, scene.offlineProvider);\n    return ground;\n  };\n\n  return GroundBuilder;\n}();\n\nexport { GroundBuilder };","map":null,"metadata":{},"sourceType":"module"}