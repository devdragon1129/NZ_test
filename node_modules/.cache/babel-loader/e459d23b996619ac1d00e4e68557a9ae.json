{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Material } from \"../Materials/material\";\nimport { Tags } from \"../Misc/tags\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n * separate meshes. This can be use to improve performances.\r\n * @see https://doc.babylonjs.com/how_to/multi_materials\r\n */\n\nvar MultiMaterial =\n/** @class */\nfunction (_super) {\n  __extends(MultiMaterial, _super);\n  /**\r\n   * Instantiates a new Multi Material\r\n   * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n   * separate meshes. This can be use to improve performances.\r\n   * @see https://doc.babylonjs.com/how_to/multi_materials\r\n   * @param name Define the name in the scene\r\n   * @param scene Define the scene the material belongs to\r\n   */\n\n\n  function MultiMaterial(name, scene) {\n    var _this = _super.call(this, name, scene, true) || this;\n\n    scene.multiMaterials.push(_this);\n    _this.subMaterials = new Array();\n    _this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\n\n    return _this;\n  }\n\n  Object.defineProperty(MultiMaterial.prototype, \"subMaterials\", {\n    /**\r\n     * Gets or Sets the list of Materials used within the multi material.\r\n     * They need to be ordered according to the submeshes order in the associated mesh\r\n     */\n    get: function get() {\n      return this._subMaterials;\n    },\n    set: function set(value) {\n      this._subMaterials = value;\n\n      this._hookArray(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Function used to align with Node.getChildren()\r\n   * @returns the list of Materials used within the multi material\r\n   */\n\n  MultiMaterial.prototype.getChildren = function () {\n    return this.subMaterials;\n  };\n\n  MultiMaterial.prototype._hookArray = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      _this._markAllSubMeshesAsTexturesDirty();\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      _this._markAllSubMeshesAsTexturesDirty();\n\n      return deleted;\n    };\n  };\n  /**\r\n   * Get one of the submaterial by its index in the submaterials array\r\n   * @param index The index to look the sub material at\r\n   * @returns The Material if the index has been defined\r\n   */\n\n\n  MultiMaterial.prototype.getSubMaterial = function (index) {\n    if (index < 0 || index >= this.subMaterials.length) {\n      return this.getScene().defaultMaterial;\n    }\n\n    return this.subMaterials[index];\n  };\n  /**\r\n   * Get the list of active textures for the whole sub materials list.\r\n   * @returns All the textures that will be used during the rendering\r\n   */\n\n\n  MultiMaterial.prototype.getActiveTextures = function () {\n    var _a;\n\n    return (_a = _super.prototype.getActiveTextures.call(this)).concat.apply(_a, this.subMaterials.map(function (subMaterial) {\n      if (subMaterial) {\n        return subMaterial.getActiveTextures();\n      } else {\n        return [];\n      }\n    }));\n  };\n  /**\r\n   * Specifies if any sub-materials of this multi-material use a given texture.\r\n   * @param texture Defines the texture to check against this multi-material's sub-materials.\r\n   * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\r\n   */\n\n\n  MultiMaterial.prototype.hasTexture = function (texture) {\n    var _a;\n\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    for (var i = 0; i < this.subMaterials.length; i++) {\n      if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Gets the current class name of the material e.g. \"MultiMaterial\"\r\n   * Mainly use in serialization.\r\n   * @returns the class name\r\n   */\n\n\n  MultiMaterial.prototype.getClassName = function () {\n    return \"MultiMaterial\";\n  };\n  /**\r\n   * Checks if the material is ready to render the requested sub mesh\r\n   * @param mesh Define the mesh the submesh belongs to\r\n   * @param subMesh Define the sub mesh to look readyness for\r\n   * @param useInstances Define whether or not the material is used with instances\r\n   * @returns true if ready, otherwise false\r\n   */\n\n\n  MultiMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    for (var index = 0; index < this.subMaterials.length; index++) {\n      var subMaterial = this.subMaterials[index];\n\n      if (subMaterial) {\n        if (subMaterial._storeEffectOnSubMeshes) {\n          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\n            return false;\n          }\n\n          continue;\n        }\n\n        if (!subMaterial.isReady(mesh)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Clones the current material and its related sub materials\r\n   * @param name Define the name of the newly cloned material\r\n   * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\r\n   * @returns the cloned material\r\n   */\n\n\n  MultiMaterial.prototype.clone = function (name, cloneChildren) {\n    var newMultiMaterial = new MultiMaterial(name, this.getScene());\n\n    for (var index = 0; index < this.subMaterials.length; index++) {\n      var subMaterial = null;\n      var current = this.subMaterials[index];\n\n      if (cloneChildren && current) {\n        subMaterial = current.clone(name + \"-\" + current.name);\n      } else {\n        subMaterial = this.subMaterials[index];\n      }\n\n      newMultiMaterial.subMaterials.push(subMaterial);\n    }\n\n    return newMultiMaterial;\n  };\n  /**\r\n   * Serializes the materials into a JSON representation.\r\n   * @returns the JSON representation\r\n   */\n\n\n  MultiMaterial.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n\n    if (Tags) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n\n    serializationObject.materials = [];\n\n    for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\n      var subMat = this.subMaterials[matIndex];\n\n      if (subMat) {\n        serializationObject.materials.push(subMat.id);\n      } else {\n        serializationObject.materials.push(null);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Dispose the material and release its associated resources\r\n   * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\r\n   * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\r\n   * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\r\n   */\n\n\n  MultiMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    if (forceDisposeChildren) {\n      for (var index = 0; index < this.subMaterials.length; index++) {\n        var subMaterial = this.subMaterials[index];\n\n        if (subMaterial) {\n          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\n        }\n      }\n    }\n\n    var index = scene.multiMaterials.indexOf(this);\n\n    if (index >= 0) {\n      scene.multiMaterials.splice(index, 1);\n    }\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\n  };\n  /**\r\n   * Creates a MultiMaterial from parsed MultiMaterial data.\r\n   * @param parsedMultiMaterial defines parsed MultiMaterial data.\r\n   * @param scene defines the hosting scene\r\n   * @returns a new MultiMaterial\r\n   */\n\n\n  MultiMaterial.ParseMultiMaterial = function (parsedMultiMaterial, scene) {\n    var multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\n    multiMaterial.id = parsedMultiMaterial.id;\n\n    if (Tags) {\n      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\n    }\n\n    for (var matIndex = 0; matIndex < parsedMultiMaterial.materials.length; matIndex++) {\n      var subMatId = parsedMultiMaterial.materials[matIndex];\n\n      if (subMatId) {\n        // If the same multimaterial is loaded twice, the 2nd multimaterial needs to reference the latest material by that id which\n        // is why this lookup should use getLastMaterialByID instead of getMaterialByID\n        multiMaterial.subMaterials.push(scene.getLastMaterialByID(subMatId));\n      } else {\n        multiMaterial.subMaterials.push(null);\n      }\n    }\n\n    return multiMaterial;\n  };\n\n  return MultiMaterial;\n}(Material);\n\nexport { MultiMaterial };\n_TypeStore.RegisteredTypes[\"BABYLON.MultiMaterial\"] = MultiMaterial;","map":null,"metadata":{},"sourceType":"module"}