{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color4 } from '../Maths/math.color';\nimport { Observable } from '../Misc/observable';\nimport { ThinSprite } from './thinSprite';\n/**\r\n * Class used to represent a sprite\r\n * @see https://doc.babylonjs.com/babylon101/sprites\r\n */\n\nvar Sprite =\n/** @class */\nfunction (_super) {\n  __extends(Sprite, _super);\n  /**\r\n   * Creates a new Sprite\r\n   * @param name defines the name\r\n   * @param manager defines the manager\r\n   */\n\n\n  function Sprite(\n  /** defines the name */\n  name, manager) {\n    var _this = _super.call(this) || this;\n\n    _this.name = name;\n    /** Gets the list of attached animations */\n\n    _this.animations = new Array();\n    /** Gets or sets a boolean indicating if the sprite can be picked */\n\n    _this.isPickable = false;\n    /** Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default) */\n\n    _this.useAlphaForPicking = false;\n    /**\r\n     * An event triggered when the control has been disposed\r\n     */\n\n    _this.onDisposeObservable = new Observable();\n    _this._onAnimationEnd = null;\n\n    _this._endAnimation = function () {\n      if (_this._onAnimationEnd) {\n        _this._onAnimationEnd();\n      }\n\n      if (_this.disposeWhenFinishedAnimating) {\n        _this.dispose();\n      }\n    };\n\n    _this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    _this.position = Vector3.Zero();\n    _this._manager = manager;\n\n    _this._manager.sprites.push(_this);\n\n    _this.uniqueId = _this._manager.scene.getUniqueId();\n    return _this;\n  }\n\n  Object.defineProperty(Sprite.prototype, \"size\", {\n    /**\r\n     * Gets or sets the sprite size\r\n     */\n    get: function get() {\n      return this.width;\n    },\n    set: function set(value) {\n      this.width = value;\n      this.height = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"manager\", {\n    /**\r\n     * Gets the manager of this sprite\r\n     */\n    get: function get() {\n      return this._manager;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"Sprite\"\r\n   * @returns \"Sprite\"\r\n   */\n\n  Sprite.prototype.getClassName = function () {\n    return \"Sprite\";\n  };\n\n  Object.defineProperty(Sprite.prototype, \"fromIndex\", {\n    /** Gets or sets the initial key for the animation (setting it will restart the animation)  */\n    get: function get() {\n      return this._fromIndex;\n    },\n    set: function set(value) {\n      this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"toIndex\", {\n    /** Gets or sets the end key for the animation (setting it will restart the animation)  */\n    get: function get() {\n      return this._toIndex;\n    },\n    set: function set(value) {\n      this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"loopAnimation\", {\n    /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\n    get: function get() {\n      return this._loopAnimation;\n    },\n    set: function set(value) {\n      this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"delay\", {\n    /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\n    get: function get() {\n      return Math.max(this._delay, 1);\n    },\n    set: function set(value) {\n      this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Starts an animation\r\n   * @param from defines the initial key\r\n   * @param to defines the end key\r\n   * @param loop defines if the animation must loop\r\n   * @param delay defines the start delay (in ms)\r\n   * @param onAnimationEnd defines a callback to call when animation ends\r\n   */\n\n  Sprite.prototype.playAnimation = function (from, to, loop, delay, onAnimationEnd) {\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    this._onAnimationEnd = onAnimationEnd;\n\n    _super.prototype.playAnimation.call(this, from, to, loop, delay, this._endAnimation);\n  };\n  /** Release associated resources */\n\n\n  Sprite.prototype.dispose = function () {\n    for (var i = 0; i < this._manager.sprites.length; i++) {\n      if (this._manager.sprites[i] == this) {\n        this._manager.sprites.splice(i, 1);\n      }\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  };\n  /**\r\n   * Serializes the sprite to a JSON object\r\n   * @returns the JSON object\r\n   */\n\n\n  Sprite.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.position = this.position.asArray();\n    serializationObject.color = this.color.asArray();\n    serializationObject.width = this.width;\n    serializationObject.height = this.height;\n    serializationObject.angle = this.angle;\n    serializationObject.cellIndex = this.cellIndex;\n    serializationObject.cellRef = this.cellRef;\n    serializationObject.invertU = this.invertU;\n    serializationObject.invertV = this.invertV;\n    serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;\n    serializationObject.isPickable = this.isPickable;\n    serializationObject.isVisible = this.isVisible;\n    serializationObject.useAlphaForPicking = this.useAlphaForPicking;\n    serializationObject.animationStarted = this.animationStarted;\n    serializationObject.fromIndex = this.fromIndex;\n    serializationObject.toIndex = this.toIndex;\n    serializationObject.loopAnimation = this.loopAnimation;\n    serializationObject.delay = this.delay;\n    return serializationObject;\n  };\n  /**\r\n   * Parses a JSON object to create a new sprite\r\n   * @param parsedSprite The JSON object to parse\r\n   * @param manager defines the hosting manager\r\n   * @returns the new sprite\r\n   */\n\n\n  Sprite.Parse = function (parsedSprite, manager) {\n    var sprite = new Sprite(parsedSprite.name, manager);\n    sprite.position = Vector3.FromArray(parsedSprite.position);\n    sprite.color = Color4.FromArray(parsedSprite.color);\n    sprite.width = parsedSprite.width;\n    sprite.height = parsedSprite.height;\n    sprite.angle = parsedSprite.angle;\n    sprite.cellIndex = parsedSprite.cellIndex;\n    sprite.cellRef = parsedSprite.cellRef;\n    sprite.invertU = parsedSprite.invertU;\n    sprite.invertV = parsedSprite.invertV;\n    sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;\n    sprite.isPickable = parsedSprite.isPickable;\n    sprite.isVisible = parsedSprite.isVisible;\n    sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;\n    sprite.fromIndex = parsedSprite.fromIndex;\n    sprite.toIndex = parsedSprite.toIndex;\n    sprite.loopAnimation = parsedSprite.loopAnimation;\n    sprite.delay = parsedSprite.delay;\n\n    if (parsedSprite.animationStarted) {\n      sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);\n    }\n\n    return sprite;\n  };\n\n  return Sprite;\n}(ThinSprite);\n\nexport { Sprite };","map":null,"metadata":{},"sourceType":"module"}