{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { Texture } from '../../../Textures/texture';\n/**\r\n * Base block used for the particle texture\r\n */\n\nvar ParticleTextureBlock =\n/** @class */\nfunction (_super) {\n  __extends(ParticleTextureBlock, _super);\n  /**\r\n   * Create a new ParticleTextureBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function ParticleTextureBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n\n    _this._samplerName = \"diffuseSampler\";\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\n\n    _this.convertToGammaSpace = false;\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\n\n    _this.convertToLinearSpace = false;\n    _this._isUnique = false;\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\n\n    _this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  ParticleTextureBlock.prototype.getClassName = function () {\n    return \"ParticleTextureBlock\";\n  };\n\n  Object.defineProperty(ParticleTextureBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the uv input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"rgba\", {\n    /**\r\n     * Gets the rgba output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"rgb\", {\n    /**\r\n     * Gets the rgb output component\r\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"r\", {\n    /**\r\n     * Gets the r output component\r\n     */\n    get: function get() {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"g\", {\n    /**\r\n     * Gets the g output component\r\n     */\n    get: function get() {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"b\", {\n    /**\r\n     * Gets the b output component\r\n     */\n    get: function get() {\n      return this._outputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"a\", {\n    /**\r\n     * Gets the a output component\r\n     */\n    get: function get() {\n      return this._outputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initialize the block and prepare the context for build\r\n   * @param state defines the state that will be used for the build\r\n   */\n\n  ParticleTextureBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"diffuseSampler\");\n  };\n\n  ParticleTextureBlock.prototype.autoConfigure = function (material) {\n    if (!this.uv.isConnected) {\n      var uvInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"particle_uv\";\n      });\n\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"particle_uv\");\n      }\n\n      uvInput.output.connectTo(this.uv);\n    }\n  };\n\n  ParticleTextureBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\n  };\n\n  ParticleTextureBlock.prototype.isReady = function () {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ParticleTextureBlock.prototype._writeOutput = function (state, output, swizzle) {\n    state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n    state.compilationString += \"#ifdef \" + this._linearDefineName + \"\\r\\n\";\n    state.compilationString += output.associatedVariableName + \" = toGammaSpace(\" + output.associatedVariableName + \");\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef \" + this._gammaDefineName + \"\\r\\n\";\n    state.compilationString += output.associatedVariableName + \" = toLinearSpace(\" + output.associatedVariableName + \");\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n  };\n\n  ParticleTextureBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (state.target === NodeMaterialBlockTargets.Vertex) {\n      return;\n    }\n\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n\n    state._emit2DSampler(this._samplerName);\n\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    var comments = \"//\" + this.name;\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + this.uv.associatedVariableName + \");\\r\\n\";\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n\n    return this;\n  };\n\n  ParticleTextureBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n\n    if (this.texture) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  ParticleTextureBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  };\n\n  return ParticleTextureBlock;\n}(NodeMaterialBlock);\n\nexport { ParticleTextureBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.ParticleTextureBlock\"] = ParticleTextureBlock;","map":null,"metadata":{},"sourceType":"module"}