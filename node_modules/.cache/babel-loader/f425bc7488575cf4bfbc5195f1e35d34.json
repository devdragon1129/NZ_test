{"ast":null,"code":"import _regeneratorRuntime from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nexport function stackHandle(handleFunction, mergeFunction) {\n  var identifyFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return '';\n  };\n  var stack = new Map();\n  return /*#__PURE__*/_regeneratorRuntime.mark(function selfHandle(action) {\n    var id, _ref, _ref2, _currentAction, _nextAction, _ref3, _ref4, nextAction;\n\n    return _regeneratorRuntime.wrap(function selfHandle$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            id = identifyFunction(action);\n\n            if (!stack.has(id)) {\n              _context.next = 7;\n              break;\n            }\n\n            _ref = stack.get(id), _ref2 = _slicedToArray(_ref, 2), _currentAction = _ref2[0], _nextAction = _ref2[1];\n            stack.set(id, [_currentAction, mergeFunction(_currentAction, _nextAction, action)]);\n            return _context.abrupt(\"return\");\n\n          case 7:\n            stack.set(id, [action, null]);\n\n          case 8:\n            return _context.delegateYield(handleFunction(action), \"t0\", 9);\n\n          case 9:\n            _ref3 = stack.get(id), _ref4 = _slicedToArray(_ref3, 2), nextAction = _ref4[1];\n            stack.delete(id);\n\n            if (!nextAction) {\n              _context.next = 13;\n              break;\n            }\n\n            return _context.delegateYield(selfHandle(nextAction), \"t1\", 13);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, selfHandle);\n  });\n}\nexport function getPagination(page, recordsPerPage) {\n  page = !Number.isFinite(page) || page <= 0 ? 1 : page;\n  recordsPerPage = !Number.isFinite(page) || page <= 0 ? 1 : recordsPerPage;\n  return {\n    limit: recordsPerPage,\n    offset: page * recordsPerPage - recordsPerPage\n  };\n}","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/pool/utils.ts"],"names":["stackHandle","handleFunction","mergeFunction","identifyFunction","stack","Map","selfHandle","action","id","has","get","currentAction","nextAction","set","delete","getPagination","page","recordsPerPage","Number","isFinite","limit","offset"],"mappings":";;AACA,OAAO,SAASA,WAAT,CACLC,cADK,EAELC,aAFK,EAIL;AAAA,MADAC,gBACA,uEAD0C;AAAA,WAAM,EAAN;AAAA,GAC1C;AAEA,MAAMC,KAAK,GAAG,IAAIC,GAAJ,EAAd;AACA,+CAAO,SAAUC,UAAV,CAAqBC,MAArB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAECC,YAAAA,EAFD,GAEML,gBAAgB,CAACI,MAAD,CAFtB;;AAAA,iBAGDH,KAAK,CAACK,GAAN,CAAUD,EAAV,CAHC;AAAA;AAAA;AAAA;;AAAA,mBAIiCJ,KAAK,CAACM,GAAN,CAAUF,EAAV,CAJjC,mCAIIG,cAJJ,aAImBC,WAJnB;AAKHR,YAAAA,KAAK,CAACS,GAAN,CAAUL,EAAV,EAAc,CAACG,cAAD,EAAgBT,aAAa,CAACS,cAAD,EAAgBC,WAAhB,EAA4BL,MAA5B,CAA7B,CAAd;AALG;;AAAA;AAQHH,YAAAA,KAAK,CAACS,GAAN,CAAUL,EAAV,EAAc,CAACD,MAAD,EAAS,IAAT,CAAd;;AARG;AAWL,0CAAON,cAAc,CAACM,MAAD,CAArB;;AAXK;AAAA,oBAYkBH,KAAK,CAACM,GAAN,CAAUF,EAAV,CAZlB,oCAYII,UAZJ;AAaLR,YAAAA,KAAK,CAACU,MAAN,CAAaN,EAAb;;AAbK,iBAcDI,UAdC;AAAA;AAAA;AAAA;;AAeH,0CAAON,UAAU,CAACM,UAAD,CAAjB;;AAfG;AAAA;AAAA;AAAA;AAAA;AAAA,OAAUN,UAAV;AAAA,GAAP;AAkBD;AAED,OAAO,SAASS,aAAT,CAAuBC,IAAvB,EAAqCC,cAArC,EAA6D;AAClED,EAAAA,IAAI,GAAG,CAACE,MAAM,CAACC,QAAP,CAAgBH,IAAhB,CAAD,IAA0BA,IAAI,IAAI,CAAlC,GAAsC,CAAtC,GAA0CA,IAAjD;AACAC,EAAAA,cAAc,GAAG,CAACC,MAAM,CAACC,QAAP,CAAgBH,IAAhB,CAAD,IAA0BA,IAAI,IAAI,CAAlC,GAAsC,CAAtC,GAA0CC,cAA3D;AAEA,SAAO;AAAEG,IAAAA,KAAK,EAAEH,cAAT;AAAyBI,IAAAA,MAAM,EAAGL,IAAI,GAAGC,cAAR,GAA0BA;AAA3D,GAAP;AACD","sourcesContent":["\nexport function stackHandle<A, T>(\n  handleFunction: (action: A) => IterableIterator<T>,\n  mergeFunction: (currentAction: A, nextAction: A | null, newAction: A) => A | null,\n  identifyFunction: (action: A) => string = () => ''\n) {\n\n  const stack = new Map<string, [A, A | null]>()\n  return function* selfHandle(action: A): IterableIterator<T> {\n\n    const id = identifyFunction(action)\n    if (stack.has(id)) {\n      const [currentAction, nextAction] = stack.get(id) as [A, A | null]\n      stack.set(id, [currentAction, mergeFunction(currentAction, nextAction, action)])\n      return\n    } else {\n      stack.set(id, [action, null])\n    }\n\n    yield* handleFunction(action)\n    const [, nextAction] = stack.get(id) as [A, A | null]\n    stack.delete(id)\n    if (nextAction) {\n      yield* selfHandle(nextAction)\n    }\n  }\n}\n\nexport function getPagination(page: number, recordsPerPage: number) {\n  page = !Number.isFinite(page) || page <= 0 ? 1 : page\n  recordsPerPage = !Number.isFinite(page) || page <= 0 ? 1 : recordsPerPage\n\n  return { limit: recordsPerPage, offset: (page * recordsPerPage) - recordsPerPage }\n}\n"]},"metadata":{},"sourceType":"module"}