{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from \"../Maths/math.color\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nNode.AddNodeConstructor(\"Light_Type_3\", function (name, scene) {\n  return function () {\n    return new HemisphericLight(name, Vector3.Zero(), scene);\n  };\n});\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\n\nvar HemisphericLight =\n/** @class */\nfunction (_super) {\n  __extends(HemisphericLight, _super);\n  /**\r\n   * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n   * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n   * The HemisphericLight can't cast shadows.\r\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n   * @param name The friendly name of the light\r\n   * @param direction The direction of the light reflection\r\n   * @param scene The scene the light belongs to\r\n   */\n\n\n  function HemisphericLight(name, direction, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\n\n\n    _this.groundColor = new Color3(0.0, 0.0, 0.0);\n    _this.direction = direction || Vector3.Up();\n    return _this;\n  }\n\n  HemisphericLight.prototype._buildUniformLayout = function () {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightGround\", 3);\n\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n\n    this._uniformBuffer.create();\n  };\n  /**\r\n   * Returns the string \"HemisphericLight\".\r\n   * @return The class name\r\n   */\n\n\n  HemisphericLight.prototype.getClassName = function () {\n    return \"HemisphericLight\";\n  };\n  /**\r\n   * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n   * Returns the updated direction.\r\n   * @param target The target the direction should point to\r\n   * @return The computed direction\r\n   */\n\n\n  HemisphericLight.prototype.setDirectionToTarget = function (target) {\n    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\n    return this.direction;\n  };\n  /**\r\n   * Returns the shadow generator associated to the light.\r\n   * @returns Always null for hemispheric lights because it does not support shadows.\r\n   */\n\n\n  HemisphericLight.prototype.getShadowGenerator = function () {\n    return null;\n  };\n  /**\r\n   * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n   * @param effect The effect to update\r\n   * @param lightIndex The index of the light in the effect to update\r\n   * @returns The hemispheric light\r\n   */\n\n\n  HemisphericLight.prototype.transferToEffect = function (effect, lightIndex) {\n    var normalizeDirection = Vector3.Normalize(this.direction);\n\n    this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\n\n    this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\n\n    return this;\n  };\n\n  HemisphericLight.prototype.transferToNodeMaterialEffect = function (effect, lightDataUniformName) {\n    var normalizeDirection = Vector3.Normalize(this.direction);\n    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n    return this;\n  };\n  /**\r\n   * Computes the world matrix of the node\r\n   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n   * @param useWasUpdatedFlag defines a reserved property\r\n   * @returns the world matrix\r\n   */\n\n\n  HemisphericLight.prototype.computeWorldMatrix = function () {\n    if (!this._worldMatrix) {\n      this._worldMatrix = Matrix.Identity();\n    }\n\n    return this._worldMatrix;\n  };\n  /**\r\n   * Returns the integer 3.\r\n   * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n   */\n\n\n  HemisphericLight.prototype.getTypeID = function () {\n    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n  };\n  /**\r\n   * Prepares the list of defines specific to the light type.\r\n   * @param defines the list of defines\r\n   * @param lightIndex defines the index of the light for the effect\r\n   */\n\n\n  HemisphericLight.prototype.prepareLightSpecificDefines = function (defines, lightIndex) {\n    defines[\"HEMILIGHT\" + lightIndex] = true;\n  };\n\n  __decorate([serializeAsColor3()], HemisphericLight.prototype, \"groundColor\", void 0);\n\n  __decorate([serializeAsVector3()], HemisphericLight.prototype, \"direction\", void 0);\n\n  return HemisphericLight;\n}(Light);\n\nexport { HemisphericLight };","map":null,"metadata":{},"sourceType":"module"}