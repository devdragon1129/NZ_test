{"ast":null,"code":"import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\n/**\r\n * @hidden\r\n */\n\nvar FaceDirectionInfo =\n/** @class */\nfunction () {\n  function FaceDirectionInfo(direction, rotatedDirection, diff, ignore) {\n    if (rotatedDirection === void 0) {\n      rotatedDirection = new Vector3();\n    }\n\n    if (diff === void 0) {\n      diff = 0;\n    }\n\n    if (ignore === void 0) {\n      ignore = false;\n    }\n\n    this.direction = direction;\n    this.rotatedDirection = rotatedDirection;\n    this.diff = diff;\n    this.ignore = ignore;\n  }\n\n  return FaceDirectionInfo;\n}();\n/**\r\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\r\n */\n\n\nvar AttachToBoxBehavior =\n/** @class */\nfunction () {\n  /**\r\n   * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\r\n   * @param ui The transform node that should be attched to the mesh\r\n   */\n  function AttachToBoxBehavior(ui) {\n    this.ui = ui;\n    /**\r\n     *  The name of the behavior\r\n     */\n\n    this.name = \"AttachToBoxBehavior\";\n    /**\r\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\r\n     */\n\n    this.distanceAwayFromFace = 0.15;\n    /**\r\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\r\n     */\n\n    this.distanceAwayFromBottomOfFace = 0.15;\n    this._faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];\n    this._tmpMatrix = new Matrix();\n    this._tmpVector = new Vector3();\n    this._zeroVector = Vector3.Zero();\n    this._lookAtTmpMatrix = new Matrix();\n    /* Does nothing */\n  }\n  /**\r\n   *  Initializes the behavior\r\n   */\n\n\n  AttachToBoxBehavior.prototype.init = function () {\n    /* Does nothing */\n  };\n\n  AttachToBoxBehavior.prototype._closestFace = function (targetDirection) {\n    var _this = this; // Go over each face and calculate the angle between the face's normal and targetDirection\n\n\n    this._faceVectors.forEach(function (v) {\n      if (!_this._target.rotationQuaternion) {\n        _this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._target.rotation.y, _this._target.rotation.x, _this._target.rotation.z);\n      }\n\n      _this._target.rotationQuaternion.toRotationMatrix(_this._tmpMatrix);\n\n      Vector3.TransformCoordinatesToRef(v.direction, _this._tmpMatrix, v.rotatedDirection);\n      v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\n    }); // Return the face information of the one with the normal closeset to target direction\n\n\n    return this._faceVectors.reduce(function (min, p) {\n      if (min.ignore) {\n        return p;\n      } else if (p.ignore) {\n        return min;\n      } else {\n        return min.diff < p.diff ? min : p;\n      }\n    }, this._faceVectors[0]);\n  };\n\n  AttachToBoxBehavior.prototype._lookAtToRef = function (pos, up, ref) {\n    if (up === void 0) {\n      up = new Vector3(0, 1, 0);\n    }\n\n    Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\n\n    this._lookAtTmpMatrix.invert();\n\n    Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\n  };\n  /**\r\n   * Attaches the AttachToBoxBehavior to the passed in mesh\r\n   * @param target The mesh that the specified node will be attached to\r\n   */\n\n\n  AttachToBoxBehavior.prototype.attach = function (target) {\n    var _this = this;\n\n    this._target = target;\n    this._scene = this._target.getScene(); // Every frame, update the app bars position\n\n    this._onRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n      if (!_this._scene.activeCamera) {\n        return;\n      } // Find the face closest to the cameras position\n\n\n      var cameraPos = _this._scene.activeCamera.position;\n\n      if (_this._scene.activeCamera.devicePosition) {\n        cameraPos = _this._scene.activeCamera.devicePosition;\n      }\n\n      var facing = _this._closestFace(cameraPos.subtract(target.position));\n\n      if (_this._scene.activeCamera.leftCamera) {\n        _this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);\n      } else {\n        _this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);\n      } // Get camera up direction\n\n\n      Vector3.TransformCoordinatesToRef(Vector3.Up(), _this._tmpMatrix, _this._tmpVector); // Ignore faces to not select a parrelel face for the up vector of the UI\n\n      _this._faceVectors.forEach(function (v) {\n        if (facing.direction.x && v.direction.x) {\n          v.ignore = true;\n        }\n\n        if (facing.direction.y && v.direction.y) {\n          v.ignore = true;\n        }\n\n        if (facing.direction.z && v.direction.z) {\n          v.ignore = true;\n        }\n      });\n\n      var facingUp = _this._closestFace(_this._tmpVector); // Unignore faces\n\n\n      _this._faceVectors.forEach(function (v) {\n        v.ignore = false;\n      }); // Position the app bar on that face\n\n\n      _this.ui.position.copyFrom(target.position);\n\n      if (facing.direction.x) {\n        facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this.ui.position.addInPlace(_this._tmpVector);\n      }\n\n      if (facing.direction.y) {\n        facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this.ui.position.addInPlace(_this._tmpVector);\n      }\n\n      if (facing.direction.z) {\n        facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this.ui.position.addInPlace(_this._tmpVector);\n      } // Rotate to be oriented properly to the camera\n\n\n      if (!_this.ui.rotationQuaternion) {\n        _this.ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.ui.rotation.y, _this.ui.rotation.x, _this.ui.rotation.z);\n      }\n\n      facing.rotatedDirection.scaleToRef(-1, _this._tmpVector);\n\n      _this._lookAtToRef(_this._tmpVector, facingUp.rotatedDirection, _this.ui.rotationQuaternion); // Place ui the correct distance from the bottom of the mesh\n\n\n      if (facingUp.direction.x) {\n        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.x / 2, _this._tmpVector);\n      }\n\n      if (facingUp.direction.y) {\n        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.y / 2, _this._tmpVector);\n      }\n\n      if (facingUp.direction.z) {\n        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.z / 2, _this._tmpVector);\n      }\n\n      _this.ui.position.addInPlace(_this._tmpVector);\n    });\n  };\n  /**\r\n   *  Detaches the behavior from the mesh\r\n   */\n\n\n  AttachToBoxBehavior.prototype.detach = function () {\n    this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\n  };\n\n  return AttachToBoxBehavior;\n}();\n\nexport { AttachToBoxBehavior };","map":null,"metadata":{},"sourceType":"module"}