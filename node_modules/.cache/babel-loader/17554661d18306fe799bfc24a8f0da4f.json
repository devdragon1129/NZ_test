{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from '../Materials/standardMaterial';\nimport { HemisphericLight } from '../Lights/hemisphericLight';\nimport { DirectionalLight } from '../Lights/directionalLight';\nimport { SphereBuilder } from '../Meshes/Builders/sphereBuilder';\nimport { HemisphereBuilder } from '../Meshes/Builders/hemisphereBuilder';\nimport { SpotLight } from '../Lights/spotLight';\nimport { TransformNode } from '../Meshes/transformNode';\nimport { PointerEventTypes } from '../Events/pointerEvents';\nimport { Observable } from \"../Misc/observable\";\n/**\r\n * Gizmo that enables viewing a light\r\n */\n\nvar LightGizmo =\n/** @class */\nfunction (_super) {\n  __extends(LightGizmo, _super);\n  /**\r\n   * Creates a LightGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   */\n\n\n  function LightGizmo(gizmoLayer) {\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._cachedPosition = new Vector3();\n    _this._cachedForward = new Vector3(0, 0, 1);\n    _this._pointerObserver = null;\n    /**\r\n     * Event that fires each time the gizmo is clicked\r\n     */\n\n    _this.onClickedObservable = new Observable();\n    _this._light = null;\n    _this.attachedMesh = new AbstractMesh(\"\", _this.gizmoLayer.utilityLayerScene);\n    _this._attachedMeshParent = new TransformNode(\"parent\", _this.gizmoLayer.utilityLayerScene);\n    _this.attachedMesh.parent = _this._attachedMeshParent;\n    _this._material = new StandardMaterial(\"light\", _this.gizmoLayer.utilityLayerScene);\n    _this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\n    _this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      if (!_this._light) {\n        return;\n      }\n\n      _this._isHovered = !!(pointerInfo.pickInfo && _this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n\n      if (_this._isHovered && pointerInfo.event.button === 0) {\n        _this.onClickedObservable.notifyObservers(_this._light);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n    return _this;\n  }\n\n  Object.defineProperty(LightGizmo.prototype, \"light\", {\n    get: function get() {\n      return this._light;\n    },\n\n    /**\r\n     * The light that the gizmo is attached to\r\n     */\n    set: function set(light) {\n      var _this = this;\n\n      this._light = light;\n\n      if (light) {\n        // Create the mesh for the given light type\n        if (this._lightMesh) {\n          this._lightMesh.dispose();\n        }\n\n        if (light instanceof HemisphericLight) {\n          this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else if (light instanceof DirectionalLight) {\n          this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else if (light instanceof SpotLight) {\n          this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else {\n          this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\n        }\n\n        this._lightMesh.getChildMeshes(false).forEach(function (m) {\n          m.material = _this._material;\n        });\n\n        this._lightMesh.parent = this._rootMesh; // Add lighting to the light gizmo\n\n        var gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n\n        gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\n        this._lightMesh.rotationQuaternion = new Quaternion();\n\n        if (!this.attachedMesh.reservedDataStore) {\n          this.attachedMesh.reservedDataStore = {};\n        }\n\n        this.attachedMesh.reservedDataStore.lightGizmo = this;\n\n        if (light.parent) {\n          this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\n        } // Get update position and direction if the light has it\n\n\n        if (light.position) {\n          this.attachedMesh.position.copyFrom(light.position);\n          this.attachedMesh.computeWorldMatrix(true);\n\n          this._cachedPosition.copyFrom(this.attachedMesh.position);\n        }\n\n        if (light.direction) {\n          this.attachedMesh.setDirection(light.direction);\n          this.attachedMesh.computeWorldMatrix(true);\n\n          this._cachedForward.copyFrom(this.attachedMesh.forward);\n        }\n\n        this._update();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightGizmo.prototype, \"material\", {\n    /**\r\n     * Gets the material used to render the light gizmo\r\n     */\n    get: function get() {\n      return this._material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @hidden\r\n   * Updates the gizmo to match the attached mesh's position/rotation\r\n   */\n\n  LightGizmo.prototype._update = function () {\n    _super.prototype._update.call(this);\n\n    if (!this._light) {\n      return;\n    }\n\n    if (this._light.parent) {\n      this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\n    }\n\n    if (this._light.position) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (!this.attachedMesh.position.equals(this._cachedPosition)) {\n        // update light to match gizmo\n        this._light.position.copyFrom(this.attachedMesh.position);\n\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      } else {\n        // update gizmo to match light\n        this.attachedMesh.position.copyFrom(this._light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n    }\n\n    if (this._light.direction) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (Vector3.DistanceSquared(this.attachedMesh.forward, this._cachedForward) > 0.0001) {\n        // update light to match gizmo\n        this._light.direction.copyFrom(this.attachedMesh.forward);\n\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      } else if (Vector3.DistanceSquared(this.attachedMesh.forward, this._light.direction) > 0.0001) {\n        // update gizmo to match light\n        this.attachedMesh.setDirection(this._light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      }\n    }\n  };\n  /**\r\n   * Disposes of the light gizmo\r\n   */\n\n\n  LightGizmo.prototype.dispose = function () {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n\n    this._material.dispose();\n\n    _super.prototype.dispose.call(this);\n\n    this._attachedMeshParent.dispose();\n  };\n\n  LightGizmo._CreateHemisphericLightMesh = function (scene) {\n    var root = new Mesh(\"hemisphereLight\", scene);\n    var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    hemisphere.position.z = -0.15;\n    hemisphere.rotation.x = Math.PI / 2;\n    hemisphere.parent = root;\n\n    var lines = this._CreateLightLines(3, scene);\n\n    lines.parent = root;\n    lines.position.z - 0.15;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreatePointLightMesh = function (scene) {\n    var root = new Mesh(\"pointLight\", scene);\n    var sphere = SphereBuilder.CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.rotation.x = Math.PI / 2;\n    sphere.parent = root;\n\n    var lines = this._CreateLightLines(5, scene);\n\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreateSpotLightMesh = function (scene) {\n    var root = new Mesh(\"spotLight\", scene);\n    var sphere = SphereBuilder.CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.parent = root;\n    var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 2\n    }, scene);\n    hemisphere.parent = root;\n    hemisphere.rotation.x = -Math.PI / 2;\n\n    var lines = this._CreateLightLines(2, scene);\n\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreateDirectionalLightMesh = function (scene) {\n    var root = new Mesh(\"directionalLight\", scene);\n    var mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    var sphere = SphereBuilder.CreateSphere(root.name, {\n      diameter: 1.2,\n      segments: 10\n    }, scene);\n    sphere.parent = mesh;\n    var line = Mesh.CreateCylinder(root.name, 6, 0.3, 0.3, 6, 1, scene);\n    line.parent = mesh;\n    var left = line.clone(root.name);\n    left.scaling.y = 0.5;\n    left.position.x += 1.25;\n    var right = line.clone(root.name);\n    right.scaling.y = 0.5;\n    right.position.x += -1.25;\n    var arrowHead = Mesh.CreateCylinder(root.name, 1, 0, 0.6, 6, 1, scene);\n    arrowHead.position.y += 3;\n    arrowHead.parent = mesh;\n    var left = arrowHead.clone(root.name);\n    left.position.y = 1.5;\n    left.position.x += 1.25;\n    var right = arrowHead.clone(root.name);\n    right.position.y = 1.5;\n    right.position.x += -1.25;\n    mesh.scaling.scaleInPlace(LightGizmo._Scale);\n    mesh.rotation.z = Math.PI / 2;\n    mesh.rotation.y = Math.PI / 2;\n    return root;\n  }; // Static helper methods\n\n\n  LightGizmo._Scale = 0.007;\n  /**\r\n   * Creates the lines for a light mesh\r\n   */\n\n  LightGizmo._CreateLightLines = function (levels, scene) {\n    var distFromSphere = 1.2;\n    var root = new Mesh(\"root\", scene);\n    root.rotation.x = Math.PI / 2; // Create the top line, this will be cloned for all other lines\n\n    var linePivot = new Mesh(\"linePivot\", scene);\n    linePivot.parent = root;\n    var line = Mesh.CreateCylinder(\"line\", 2, 0.2, 0.3, 6, 1, scene);\n    line.position.y = line.scaling.y / 2 + distFromSphere;\n    line.parent = linePivot;\n\n    if (levels < 2) {\n      return linePivot;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l = linePivot.clone(\"lineParentClone\");\n      l.rotation.z = Math.PI / 4;\n      l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n      l.getChildMeshes()[0].scaling.y = 0.5;\n      l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n      l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n    }\n\n    if (levels < 3) {\n      return root;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l = linePivot.clone(\"linePivotClone\");\n      l.rotation.z = Math.PI / 2;\n      l.rotation.y = Math.PI / 2 * i;\n    }\n\n    if (levels < 4) {\n      return root;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l = linePivot.clone(\"linePivotClone\");\n      l.rotation.z = Math.PI + Math.PI / 4;\n      l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n      l.getChildMeshes()[0].scaling.y = 0.5;\n      l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n      l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n    }\n\n    if (levels < 5) {\n      return root;\n    }\n\n    var l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI;\n    return root;\n  };\n\n  return LightGizmo;\n}(Gizmo);\n\nexport { LightGizmo };","map":null,"metadata":{},"sourceType":"module"}