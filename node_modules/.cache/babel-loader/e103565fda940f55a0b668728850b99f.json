{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\nimport { Logger } from '../../Misc/logger';\nimport { Tools } from '../../Misc/tools';\nimport { ThinEngine } from '../thinEngine';\n\nThinEngine.prototype.updateRawTexture = function (texture, data, format, invertY, compression, type) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (type === void 0) {\n    type = 0;\n  }\n\n  if (!texture) {\n    return;\n  } // Babylon's internalSizedFomat but gl's texImage2D internalFormat\n\n\n  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format); // Babylon's internalFormat but gl's texImage2D format\n\n\n  var internalFormat = this._getInternalFormat(format);\n\n  var textureType = this._getWebGLTextureType(type);\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n    texture.format = format;\n    texture.type = type;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n\n  if (texture.width % 4 !== 0) {\n    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n  }\n\n  if (compression && data) {\n    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);\n  } else {\n    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\n  }\n\n  if (texture.generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null); //  this.resetTextureCache();\n\n\n  texture.isReady = true;\n};\n\nThinEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (type === void 0) {\n    type = 0;\n  }\n\n  var texture = new InternalTexture(this, InternalTextureSource.Raw);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.width = width;\n  texture.height = height;\n  texture.format = format;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture.type = type;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n\n  this.updateRawTexture(texture, data, format, invertY, compression, type);\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true); // Filters\n\n\n  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\n\n  if (generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};\n\nThinEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  var gl = this._gl;\n  var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\n  texture.isCube = true;\n  texture.format = format;\n  texture.type = type;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferViewArray = data;\n  }\n\n  var textureType = this._getWebGLTextureType(type);\n\n  var internalFormat = this._getInternalFormat(format);\n\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n  } // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\n\n\n  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\n  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\n  }\n\n  var width = size;\n  var height = width;\n  texture.width = width;\n  texture.height = height; // Double check on POT to generate Mips.\n\n  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);\n\n  if (!isPot) {\n    generateMipMaps = false;\n  } // Upload data if needed. The texture won't be ready until then.\n\n\n  if (data) {\n    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true); // Filters\n\n\n  if (data && generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n\n  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n\n  texture.generateMipMaps = generateMipMaps;\n  return texture;\n};\n\nThinEngine.prototype.updateRawCubeTexture = function (texture, data, format, type, invertY, compression, level) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (level === void 0) {\n    level = 0;\n  }\n\n  texture._bufferViewArray = data;\n  texture.format = format;\n  texture.type = type;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  var gl = this._gl;\n\n  var textureType = this._getWebGLTextureType(type);\n\n  var internalFormat = this._getInternalFormat(format);\n\n  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n\n  var needConversion = false;\n\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n    needConversion = true;\n  }\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n  if (texture.width % 4 !== 0) {\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n  } // Data are known to be in +X +Y +Z -X -Y -Z\n\n\n  for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n    var faceData = data[faceIndex];\n\n    if (compression) {\n      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);\n    } else {\n      if (needConversion) {\n        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\n      }\n\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\n    }\n  }\n\n  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);\n\n  if (isPot && texture.generateMipMaps && level === 0) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null); // this.resetTextureCache();\n\n\n  texture.isReady = true;\n};\n\nThinEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad, onError, samplingMode, invertY) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (samplingMode === void 0) {\n    samplingMode = 3;\n  }\n\n  if (invertY === void 0) {\n    invertY = false;\n  }\n\n  var gl = this._gl;\n  var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\n  scene === null || scene === void 0 ? void 0 : scene._addPendingData(texture);\n  texture.url = url;\n\n  this._internalTexturesCache.push(texture);\n\n  var onerror = function onerror(request, exception) {\n    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);\n\n    if (onError && request) {\n      onError(request.status + \" \" + request.statusText, exception);\n    }\n  };\n\n  var internalCallback = function internalCallback(data) {\n    var width = texture.width;\n    var faceDataArrays = callback(data);\n\n    if (!faceDataArrays) {\n      return;\n    }\n\n    if (mipmapGenerator) {\n      var textureType = _this._getWebGLTextureType(type);\n\n      var internalFormat = _this._getInternalFormat(format);\n\n      var internalSizedFomat = _this._getRGBABufferInternalSizedFormat(type);\n\n      var needConversion = false;\n\n      if (internalFormat === gl.RGB) {\n        internalFormat = gl.RGBA;\n        needConversion = true;\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n      _this._unpackFlipY(false);\n\n      var mipData = mipmapGenerator(faceDataArrays);\n\n      for (var level = 0; level < mipData.length; level++) {\n        var mipSize = width >> level;\n\n        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n          var mipFaceData = mipData[level][faceIndex];\n\n          if (needConversion) {\n            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n          }\n\n          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\n        }\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n    } else {\n      _this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\n    }\n\n    texture.isReady = true; // this.resetTextureCache();\n\n    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);\n\n    if (onLoad) {\n      onLoad();\n    }\n  };\n\n  this._loadFile(url, function (data) {\n    internalCallback(data);\n  }, undefined, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);\n\n  return texture;\n};\n/** @hidden */\n\n\nfunction _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {\n  // Create new RGBA data container.\n  var rgbaData;\n\n  if (textureType === 1) {\n    rgbaData = new Float32Array(width * height * 4);\n  } else {\n    rgbaData = new Uint32Array(width * height * 4);\n  } // Convert each pixel.\n\n\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      var index = (y * width + x) * 3;\n      var newIndex = (y * width + x) * 4; // Map Old Value to new value.\n\n      rgbaData[newIndex + 0] = rgbData[index + 0];\n      rgbaData[newIndex + 1] = rgbData[index + 1];\n      rgbaData[newIndex + 2] = rgbData[index + 2]; // Add fully opaque alpha channel.\n\n      rgbaData[newIndex + 3] = 1;\n    }\n  }\n\n  return rgbaData;\n}\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\n\n\nfunction _makeCreateRawTextureFunction(is3D) {\n  return function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n    var source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\n    var texture = new InternalTexture(this, source);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.baseDepth = depth;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = depth;\n    texture.format = format;\n    texture.type = textureType;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n\n    if (is3D) {\n      texture.is3D = true;\n    } else {\n      texture.is2DArray = true;\n    }\n\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n    }\n\n    if (is3D) {\n      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\n    } else {\n      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\n    }\n\n    this._bindTextureDirectly(target, texture, true); // Filters\n\n\n    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n\n    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\n\n    if (generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n\n    this._bindTextureDirectly(target, null);\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n}\n\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\n\nfunction _makeUpdateRawTextureFunction(is3D) {\n  return function (texture, data, format, invertY, compression, textureType) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n\n    var internalType = this._getWebGLTextureType(textureType);\n\n    var internalFormat = this._getInternalFormat(format);\n\n    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\n\n    this._bindTextureDirectly(target, texture, true);\n\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n      texture.format = format;\n      texture.invertY = invertY;\n      texture._compression = compression;\n    }\n\n    if (texture.width % 4 !== 0) {\n      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n    }\n\n    if (compression && data) {\n      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);\n    } else {\n      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\n    }\n\n    if (texture.generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n\n    this._bindTextureDirectly(target, null); // this.resetTextureCache();\n\n\n    texture.isReady = true;\n  };\n}\n\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);","map":null,"metadata":{},"sourceType":"module"}