{"ast":null,"code":"import { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { Animation } from \"./animation\";\nimport { Size } from '../Maths/math.size'; // Static values to help the garbage collector\n// Quaternion\n\nvar _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0)); // Vector3\n\n\nvar _staticOffsetValueVector3 = Object.freeze(Vector3.Zero()); // Vector2\n\n\nvar _staticOffsetValueVector2 = Object.freeze(Vector2.Zero()); // Size\n\n\nvar _staticOffsetValueSize = Object.freeze(Size.Zero()); // Color3\n\n\nvar _staticOffsetValueColor3 = Object.freeze(Color3.Black());\n/**\r\n * Defines a runtime animation\r\n */\n\n\nvar RuntimeAnimation =\n/** @class */\nfunction () {\n  /**\r\n   * Create a new RuntimeAnimation object\r\n   * @param target defines the target of the animation\r\n   * @param animation defines the source animation object\r\n   * @param scene defines the hosting scene\r\n   * @param host defines the initiating Animatable\r\n   */\n  function RuntimeAnimation(target, animation, scene, host) {\n    var _this = this;\n\n    this._events = new Array();\n    /**\r\n     * The current frame of the runtime animation\r\n     */\n\n    this._currentFrame = 0;\n    /**\r\n     * The original value of the runtime animation\r\n     */\n\n    this._originalValue = new Array();\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\n\n    this._originalBlendValue = null;\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\n\n    this._offsetsCache = {};\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\n\n    this._highLimitsCache = {};\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\n\n    this._stopped = false;\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\n\n    this._blendingFactor = 0;\n    /**\r\n     * The current value of the runtime animation\r\n     */\n\n    this._currentValue = null;\n    this._currentActiveTarget = null;\n    this._directTarget = null;\n    /**\r\n     * The target path of the runtime animation\r\n     */\n\n    this._targetPath = \"\";\n    /**\r\n     * The weight of the runtime animation\r\n     */\n\n    this._weight = 1.0;\n    /**\r\n     * The ratio offset of the runtime animation\r\n     */\n\n    this._ratioOffset = 0;\n    /**\r\n     * The previous delay of the runtime animation\r\n     */\n\n    this._previousDelay = 0;\n    /**\r\n     * The previous ratio of the runtime animation\r\n     */\n\n    this._previousRatio = 0;\n    this._targetIsArray = false;\n    this._animation = animation;\n    this._target = target;\n    this._scene = scene;\n    this._host = host;\n    this._activeTargets = [];\n\n    animation._runtimeAnimations.push(this); // State\n\n\n    this._animationState = {\n      key: 0,\n      repeatCount: 0,\n      loopMode: this._getCorrectLoopMode()\n    };\n\n    if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      this._animationState.workValue = Matrix.Zero();\n    } // Limits\n\n\n    this._keys = this._animation.getKeys();\n    this._minFrame = this._keys[0].frame;\n    this._maxFrame = this._keys[this._keys.length - 1].frame;\n    this._minValue = this._keys[0].value;\n    this._maxValue = this._keys[this._keys.length - 1].value; // Add a start key at frame 0 if missing\n\n    if (this._minFrame !== 0) {\n      var newKey = {\n        frame: 0,\n        value: this._minValue\n      };\n\n      this._keys.splice(0, 0, newKey);\n    } // Check data\n\n\n    if (this._target instanceof Array) {\n      var index = 0;\n\n      for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\n        var target_1 = _a[_i];\n\n        this._preparePath(target_1, index);\n\n        this._getOriginalValues(index);\n\n        index++;\n      }\n\n      this._targetIsArray = true;\n    } else {\n      this._preparePath(this._target);\n\n      this._getOriginalValues();\n\n      this._targetIsArray = false;\n      this._directTarget = this._activeTargets[0];\n    } // Cloning events locally\n\n\n    var events = animation.getEvents();\n\n    if (events && events.length > 0) {\n      events.forEach(function (e) {\n        _this._events.push(e._clone());\n      });\n    }\n\n    this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n  }\n\n  Object.defineProperty(RuntimeAnimation.prototype, \"currentFrame\", {\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\n    get: function get() {\n      return this._currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"weight\", {\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\n    get: function get() {\n      return this._weight;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"currentValue\", {\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\n    get: function get() {\n      return this._currentValue;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"targetPath\", {\n    /**\r\n     * Gets the target path of the runtime animation\r\n     */\n    get: function get() {\n      return this._targetPath;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"target\", {\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\n    get: function get() {\n      return this._currentActiveTarget;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"isAdditive\", {\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\n    get: function get() {\n      return this._host && this._host.isAdditive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RuntimeAnimation.prototype._preparePath = function (target, targetIndex) {\n    if (targetIndex === void 0) {\n      targetIndex = 0;\n    }\n\n    var targetPropertyPath = this._animation.targetPropertyPath;\n\n    if (targetPropertyPath.length > 1) {\n      var property = target[targetPropertyPath[0]];\n\n      for (var index = 1; index < targetPropertyPath.length - 1; index++) {\n        property = property[targetPropertyPath[index]];\n      }\n\n      this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n      this._activeTargets[targetIndex] = property;\n    } else {\n      this._targetPath = targetPropertyPath[0];\n      this._activeTargets[targetIndex] = target;\n    }\n  };\n\n  Object.defineProperty(RuntimeAnimation.prototype, \"animation\", {\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\n    get: function get() {\n      return this._animation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets the runtime animation to the beginning\r\n   * @param restoreOriginal defines whether to restore the target property to the original value\r\n   */\n\n  RuntimeAnimation.prototype.reset = function (restoreOriginal) {\n    if (restoreOriginal === void 0) {\n      restoreOriginal = false;\n    }\n\n    if (restoreOriginal) {\n      if (this._target instanceof Array) {\n        var index = 0;\n\n        for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\n          var target = _a[_i];\n\n          if (this._originalValue[index] !== undefined) {\n            this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n          }\n\n          index++;\n        }\n      } else {\n        if (this._originalValue[0] !== undefined) {\n          this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n        }\n      }\n    }\n\n    this._offsetsCache = {};\n    this._highLimitsCache = {};\n    this._currentFrame = 0;\n    this._blendingFactor = 0; // Events\n\n    for (var index = 0; index < this._events.length; index++) {\n      this._events[index].isDone = false;\n    }\n  };\n  /**\r\n   * Specifies if the runtime animation is stopped\r\n   * @returns Boolean specifying if the runtime animation is stopped\r\n   */\n\n\n  RuntimeAnimation.prototype.isStopped = function () {\n    return this._stopped;\n  };\n  /**\r\n   * Disposes of the runtime animation\r\n   */\n\n\n  RuntimeAnimation.prototype.dispose = function () {\n    var index = this._animation.runtimeAnimations.indexOf(this);\n\n    if (index > -1) {\n      this._animation.runtimeAnimations.splice(index, 1);\n    }\n  };\n  /**\r\n   * Apply the interpolated value to the target\r\n   * @param currentValue defines the value computed by the animation\r\n   * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n   */\n\n\n  RuntimeAnimation.prototype.setValue = function (currentValue, weight) {\n    if (this._targetIsArray) {\n      for (var index = 0; index < this._target.length; index++) {\n        var target = this._target[index];\n\n        this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n      }\n\n      return;\n    }\n\n    this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n  };\n\n  RuntimeAnimation.prototype._getOriginalValues = function (targetIndex) {\n    if (targetIndex === void 0) {\n      targetIndex = 0;\n    }\n\n    var originalValue;\n    var target = this._activeTargets[targetIndex];\n\n    if (target.getRestPose && this._targetPath === \"_matrix\") {\n      // For bones\n      originalValue = target.getRestPose();\n    } else {\n      originalValue = target[this._targetPath];\n    }\n\n    if (originalValue && originalValue.clone) {\n      this._originalValue[targetIndex] = originalValue.clone();\n    } else {\n      this._originalValue[targetIndex] = originalValue;\n    }\n  };\n\n  RuntimeAnimation.prototype._setValue = function (target, destination, currentValue, weight, targetIndex) {\n    // Set value\n    this._currentActiveTarget = destination;\n    this._weight = weight;\n\n    if (this._enableBlending && this._blendingFactor <= 1.0) {\n      if (!this._originalBlendValue) {\n        var originalValue = destination[this._targetPath];\n\n        if (originalValue.clone) {\n          this._originalBlendValue = originalValue.clone();\n        } else {\n          this._originalBlendValue = originalValue;\n        }\n      }\n\n      if (this._originalBlendValue.m) {\n        // Matrix\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\n          if (this._currentValue) {\n            Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        } else {\n          if (this._currentValue) {\n            Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        }\n      } else {\n        this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n      }\n\n      var blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n      this._blendingFactor += blendingSpeed;\n    } else {\n      this._currentValue = currentValue;\n    }\n\n    if (weight !== -1.0) {\n      this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n    } else {\n      destination[this._targetPath] = this._currentValue;\n    }\n\n    if (target.markAsDirty) {\n      target.markAsDirty(this._animation.targetProperty);\n    }\n  };\n  /**\r\n   * Gets the loop pmode of the runtime animation\r\n   * @returns Loop Mode\r\n   */\n\n\n  RuntimeAnimation.prototype._getCorrectLoopMode = function () {\n    if (this._target && this._target.animationPropertiesOverride) {\n      return this._target.animationPropertiesOverride.loopMode;\n    }\n\n    return this._animation.loopMode;\n  };\n  /**\r\n   * Move the current animation to a given frame\r\n   * @param frame defines the frame to move to\r\n   */\n\n\n  RuntimeAnimation.prototype.goToFrame = function (frame) {\n    var keys = this._animation.getKeys();\n\n    if (frame < keys[0].frame) {\n      frame = keys[0].frame;\n    } else if (frame > keys[keys.length - 1].frame) {\n      frame = keys[keys.length - 1].frame;\n    } // Need to reset animation events\n\n\n    var events = this._events;\n\n    if (events.length) {\n      for (var index = 0; index < events.length; index++) {\n        if (!events[index].onlyOnce) {\n          // reset events in the future\n          events[index].isDone = events[index].frame < frame;\n        }\n      }\n    }\n\n    this._currentFrame = frame;\n\n    var currentValue = this._animation._interpolate(frame, this._animationState);\n\n    this.setValue(currentValue, -1);\n  };\n  /**\r\n   * @hidden Internal use only\r\n   */\n\n\n  RuntimeAnimation.prototype._prepareForSpeedRatioChange = function (newSpeedRatio) {\n    var newRatio = this._previousDelay * (this._animation.framePerSecond * newSpeedRatio) / 1000.0;\n    this._ratioOffset = this._previousRatio - newRatio;\n  };\n  /**\r\n   * Execute the current animation\r\n   * @param delay defines the delay to add to the current frame\r\n   * @param from defines the lower bound of the animation range\r\n   * @param to defines the upper bound of the animation range\r\n   * @param loop defines if the current animation must loop\r\n   * @param speedRatio defines the current speed ratio\r\n   * @param weight defines the weight of the animation (default is -1 so no weight)\r\n   * @param onLoop optional callback called when animation loops\r\n   * @returns a boolean indicating if the animation is running\r\n   */\n\n\n  RuntimeAnimation.prototype.animate = function (delay, from, to, loop, speedRatio, weight) {\n    if (weight === void 0) {\n      weight = -1.0;\n    }\n\n    var animation = this._animation;\n    var targetPropertyPath = animation.targetPropertyPath;\n\n    if (!targetPropertyPath || targetPropertyPath.length < 1) {\n      this._stopped = true;\n      return false;\n    }\n\n    var returnValue = true; // Check limits\n\n    if (from < this._minFrame || from > this._maxFrame) {\n      from = this._minFrame;\n    }\n\n    if (to < this._minFrame || to > this._maxFrame) {\n      to = this._maxFrame;\n    }\n\n    var range = to - from;\n    var offsetValue; // Compute ratio which represents the frame delta between from and to\n\n    var ratio = delay * (animation.framePerSecond * speedRatio) / 1000.0 + this._ratioOffset;\n    var highLimitValue = 0;\n    this._previousDelay = delay;\n    this._previousRatio = ratio;\n\n    if (!loop && to >= from && ratio >= range) {\n      // If we are out of range and not looping get back to caller\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._maxValue);\n    } else if (!loop && from >= to && ratio <= range) {\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._minValue);\n    } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n      var keyOffset = to.toString() + from.toString();\n\n      if (!this._offsetsCache[keyOffset]) {\n        this._animationState.repeatCount = 0;\n        this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\n\n        var fromValue = animation._interpolate(from, this._animationState);\n\n        var toValue = animation._interpolate(to, this._animationState);\n\n        this._animationState.loopMode = this._getCorrectLoopMode();\n\n        switch (animation.dataType) {\n          // Float\n          case Animation.ANIMATIONTYPE_FLOAT:\n            this._offsetsCache[keyOffset] = toValue - fromValue;\n            break;\n          // Quaternion\n\n          case Animation.ANIMATIONTYPE_QUATERNION:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Vector3\n\n          case Animation.ANIMATIONTYPE_VECTOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n          // Vector2\n\n          case Animation.ANIMATIONTYPE_VECTOR2:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n          // Size\n\n          case Animation.ANIMATIONTYPE_SIZE:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n          // Color3\n\n          case Animation.ANIMATIONTYPE_COLOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n\n          default:\n            break;\n        }\n\n        this._highLimitsCache[keyOffset] = toValue;\n      }\n\n      highLimitValue = this._highLimitsCache[keyOffset];\n      offsetValue = this._offsetsCache[keyOffset];\n    }\n\n    if (offsetValue === undefined) {\n      switch (animation.dataType) {\n        // Float\n        case Animation.ANIMATIONTYPE_FLOAT:\n          offsetValue = 0;\n          break;\n        // Quaternion\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          offsetValue = _staticOffsetValueQuaternion;\n          break;\n        // Vector3\n\n        case Animation.ANIMATIONTYPE_VECTOR3:\n          offsetValue = _staticOffsetValueVector3;\n          break;\n        // Vector2\n\n        case Animation.ANIMATIONTYPE_VECTOR2:\n          offsetValue = _staticOffsetValueVector2;\n          break;\n        // Size\n\n        case Animation.ANIMATIONTYPE_SIZE:\n          offsetValue = _staticOffsetValueSize;\n          break;\n        // Color3\n\n        case Animation.ANIMATIONTYPE_COLOR3:\n          offsetValue = _staticOffsetValueColor3;\n      }\n    } // Compute value\n\n\n    var currentFrame;\n\n    if (this._host && this._host.syncRoot) {\n      var syncRoot = this._host.syncRoot;\n      var hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n      currentFrame = from + (to - from) * hostNormalizedFrame;\n    } else {\n      currentFrame = returnValue && range !== 0 ? from + ratio % range : to;\n    } // Reset events if looping\n\n\n    var events = this._events;\n\n    if (range > 0 && this.currentFrame > currentFrame || range < 0 && this.currentFrame < currentFrame) {\n      this._onLoop(); // Need to reset animation events\n\n\n      if (events.length) {\n        for (var index = 0; index < events.length; index++) {\n          if (!events[index].onlyOnce) {\n            // reset event, the animation is looping\n            events[index].isDone = false;\n          }\n        }\n      }\n    }\n\n    this._currentFrame = currentFrame;\n    this._animationState.repeatCount = range === 0 ? 0 : ratio / range >> 0;\n    this._animationState.highLimitValue = highLimitValue;\n    this._animationState.offsetValue = offsetValue;\n\n    var currentValue = animation._interpolate(currentFrame, this._animationState); // Set value\n\n\n    this.setValue(currentValue, weight); // Check events\n\n    if (events.length) {\n      for (var index = 0; index < events.length; index++) {\n        // Make sure current frame has passed event frame and that event frame is within the current range\n        // Also, handle both forward and reverse animations\n        if (range > 0 && currentFrame >= events[index].frame && events[index].frame >= from || range < 0 && currentFrame <= events[index].frame && events[index].frame <= from) {\n          var event = events[index];\n\n          if (!event.isDone) {\n            // If event should be done only once, remove it.\n            if (event.onlyOnce) {\n              events.splice(index, 1);\n              index--;\n            }\n\n            event.isDone = true;\n            event.action(currentFrame);\n          } // Don't do anything if the event has already be done.\n\n        }\n      }\n    }\n\n    if (!returnValue) {\n      this._stopped = true;\n    }\n\n    return returnValue;\n  };\n\n  return RuntimeAnimation;\n}();\n\nexport { RuntimeAnimation };","map":null,"metadata":{},"sourceType":"module"}