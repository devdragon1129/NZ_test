{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\n\nvar util_1 = require(\"./util\");\n\nvar equal = require(\"fast-deep-equal\");\n\nvar traverse = require(\"json-schema-traverse\"); // TODO refactor to use keyword definitions\n\n\nvar SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\n\nfunction inlineRef(schema) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\n\nexports.inlineRef = inlineRef;\nvar REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\n\nfunction hasRef(schema) {\n  for (var key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    var sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n\n  return false;\n}\n\nfunction countKeys(schema) {\n  var count = 0;\n\n  for (var key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n\n    if (typeof schema[key] == \"object\") {\n      (0, util_1.eachItem)(schema[key], function (sch) {\n        return count += countKeys(sch);\n      });\n    }\n\n    if (count === Infinity) return Infinity;\n  }\n\n  return count;\n}\n\nfunction getFullPath(resolver) {\n  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var normalize = arguments.length > 2 ? arguments[2] : undefined;\n  if (normalize !== false) id = normalizeId(id);\n  var p = resolver.parse(id);\n  return _getFullPath(resolver, p);\n}\n\nexports.getFullPath = getFullPath;\n\nfunction _getFullPath(resolver, p) {\n  var serialized = resolver.serialize(p);\n  return serialized.split(\"#\")[0] + \"#\";\n}\n\nexports._getFullPath = _getFullPath;\nvar TRAILING_SLASH_HASH = /#\\/?$/;\n\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\n\nexports.normalizeId = normalizeId;\n\nfunction resolveUrl(resolver, baseId, id) {\n  id = normalizeId(id);\n  return resolver.resolve(baseId, id);\n}\n\nexports.resolveUrl = resolveUrl;\nvar ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\n\nfunction getSchemaRefs(schema, baseId) {\n  var _this = this;\n\n  if (typeof schema == \"boolean\") return {};\n  var _this$opts = this.opts,\n      schemaId = _this$opts.schemaId,\n      uriResolver = _this$opts.uriResolver;\n  var schId = normalizeId(schema[schemaId] || baseId);\n  var baseIds = {\n    \"\": schId\n  };\n  var pathPrefix = getFullPath(uriResolver, schId, false);\n  var localRefs = {};\n  var schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, function (sch, jsonPtr, _, parentJsonPtr) {\n    if (parentJsonPtr === undefined) return;\n    var fullPath = pathPrefix + jsonPtr;\n    var baseId = baseIds[parentJsonPtr];\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(_this, sch[schemaId]);\n    addAnchor.call(_this, sch.$anchor);\n    addAnchor.call(_this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n\n    function addRef(ref) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      var _resolve = this.opts.uriResolver.resolve;\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      var schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n\n      return ref;\n    }\n\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(\"invalid anchor \\\"\".concat(anchor, \"\\\"\"));\n        addRef.call(this, \"#\".concat(anchor));\n      }\n    }\n  });\n  return localRefs;\n\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n\n  function ambiguos(ref) {\n    return new Error(\"reference \\\"\".concat(ref, \"\\\" resolves to more than one schema\"));\n  }\n}\n\nexports.getSchemaRefs = getSchemaRefs;","map":null,"metadata":{},"sourceType":"script"}