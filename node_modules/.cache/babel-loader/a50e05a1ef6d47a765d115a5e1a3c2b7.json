{"ast":null,"code":"import { EngineStore } from './engineStore';\nimport { Effect } from '../Materials/effect';\nimport { _DevTools } from '../Misc/devTools';\nimport { Observable } from '../Misc/observable';\nimport { DepthCullingState } from '../States/depthCullingState';\nimport { StencilState } from '../States/stencilState';\nimport { AlphaState } from '../States/alphaCullingState';\nimport { InternalTexture, InternalTextureSource } from '../Materials/Textures/internalTexture';\nimport { Logger } from '../Misc/logger';\nimport { DomManagement } from '../Misc/domManagement';\nimport { WebGLShaderProcessor } from './WebGL/webGLShaderProcessors';\nimport { WebGL2ShaderProcessor } from './WebGL/webGL2ShaderProcessors';\nimport { WebGLDataBuffer } from '../Meshes/WebGL/webGLDataBuffer';\nimport { WebGLPipelineContext } from './WebGL/webGLPipelineContext';\nimport { CanvasGenerator } from '../Misc/canvasGenerator';\nimport { PerformanceConfigurator } from './performanceConfigurator';\n/**\r\n * Keeps track of all the buffer info used in engine.\r\n */\n\nvar BufferPointer =\n/** @class */\nfunction () {\n  function BufferPointer() {}\n\n  return BufferPointer;\n}();\n/**\r\n * The base engine class (root of all engines)\r\n */\n\n\nvar ThinEngine =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new engine\r\n   * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which alreay used the WebGL context\r\n   * @param antialias defines enable antialiasing (default: false)\r\n   * @param options defines further options to be sent to the getContext() function\r\n   * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)\r\n   */\n  function ThinEngine(canvasOrContext, antialias, options, adaptToDeviceRatio) {\n    var _this = this;\n\n    if (adaptToDeviceRatio === void 0) {\n      adaptToDeviceRatio = false;\n    }\n    /**\r\n     * Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required\r\n     */\n\n\n    this.forcePOTTextures = false;\n    /**\r\n     * Gets a boolean indicating if the engine is currently rendering in fullscreen mode\r\n     */\n\n    this.isFullscreen = false;\n    /**\r\n     * Gets or sets a boolean indicating if back faces must be culled (true by default)\r\n     */\n\n    this.cullBackFaces = true;\n    /**\r\n     * Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foregroun\r\n     */\n\n    this.renderEvenInBackground = true;\n    /**\r\n     * Gets or sets a boolean indicating that cache can be kept between frames\r\n     */\n\n    this.preventCacheWipeBetweenFrames = false;\n    /** Gets or sets a boolean indicating if the engine should validate programs after compilation */\n\n    this.validateShaderPrograms = false;\n    /**\r\n     * Gets or sets a boolean indicating if depth buffer should be reverse, going from far to near.\r\n     * This can provide greater z depth for distant objects.\r\n     */\n\n    this.useReverseDepthBuffer = false; // Uniform buffers list\n\n    /**\r\n     * Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported\r\n     */\n\n    this.disableUniformBuffers = false;\n    /** @hidden */\n\n    this._uniformBuffers = new Array();\n    /** @hidden */\n\n    this._webGLVersion = 1.0;\n    this._windowIsBackground = false;\n    this._highPrecisionShadersAllowed = true;\n    /** @hidden */\n\n    this._badOS = false;\n    /** @hidden */\n\n    this._badDesktopOS = false;\n    this._renderingQueueLaunched = false;\n    this._activeRenderLoops = new Array(); // Lost context\n\n    /**\r\n     * Observable signaled when a context lost event is raised\r\n     */\n\n    this.onContextLostObservable = new Observable();\n    /**\r\n     * Observable signaled when a context restored event is raised\r\n     */\n\n    this.onContextRestoredObservable = new Observable();\n    this._contextWasLost = false;\n    /** @hidden */\n\n    this._doNotHandleContextLost = false;\n    /**\r\n     * Gets or sets a boolean indicating that vertex array object must be disabled even if they are supported\r\n     */\n\n    this.disableVertexArrayObjects = false; // States\n\n    /** @hidden */\n\n    this._colorWrite = true;\n    /** @hidden */\n\n    this._colorWriteChanged = true;\n    /** @hidden */\n\n    this._depthCullingState = new DepthCullingState();\n    /** @hidden */\n\n    this._stencilState = new StencilState();\n    /** @hidden */\n\n    this._alphaState = new AlphaState();\n    /** @hidden */\n\n    this._alphaMode = 1;\n    /** @hidden */\n\n    this._alphaEquation = 0; // Cache\n\n    /** @hidden */\n\n    this._internalTexturesCache = new Array();\n    /** @hidden */\n\n    this._activeChannel = 0;\n    this._currentTextureChannel = -1;\n    /** @hidden */\n\n    this._boundTexturesCache = {};\n    this._compiledEffects = {};\n    this._vertexAttribArraysEnabled = [];\n    this._uintIndicesCurrentlySet = false;\n    this._currentBoundBuffer = new Array();\n    /** @hidden */\n\n    this._currentFramebuffer = null;\n    /** @hidden */\n\n    this._dummyFramebuffer = null;\n    this._currentBufferPointers = new Array();\n    this._currentInstanceLocations = new Array();\n    this._currentInstanceBuffers = new Array();\n    this._vaoRecordInProgress = false;\n    this._mustWipeVertexAttributes = false;\n    this._nextFreeTextureSlots = new Array();\n    this._maxSimultaneousTextures = 0;\n    this._activeRequests = new Array();\n    /** @hidden */\n\n    this._transformTextureUrl = null;\n    /**\r\n     * Gets information about the current host\r\n     */\n\n    this.hostInformation = {\n      isMobile: false\n    };\n    /**\r\n     * Defines whether the engine has been created with the premultipliedAlpha option on or not.\r\n     */\n\n    this.premultipliedAlpha = true;\n    /**\r\n     * Observable event triggered before each texture is initialized\r\n     */\n\n    this.onBeforeTextureInitObservable = new Observable();\n    this._viewportCached = {\n      x: 0,\n      y: 0,\n      z: 0,\n      w: 0\n    };\n    this._unpackFlipYCached = null;\n    /**\r\n     * In case you are sharing the context with other applications, it might\r\n     * be interested to not cache the unpack flip y state to ensure a consistent\r\n     * value would be set.\r\n     */\n\n    this.enableUnpackFlipYCached = true;\n\n    this._getDepthStencilBuffer = function (width, height, samples, internalFormat, msInternalFormat, attachment) {\n      var gl = _this._gl;\n      var depthStencilBuffer = gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\n\n      if (samples > 1 && gl.renderbufferStorageMultisample) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);\n      }\n\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthStencilBuffer);\n      gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n      return depthStencilBuffer;\n    };\n\n    this._boundUniforms = {};\n    var canvas = null;\n\n    if (!canvasOrContext) {\n      return;\n    }\n\n    options = options || {};\n    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\n\n    if (canvasOrContext.getContext) {\n      canvas = canvasOrContext;\n      this._renderingCanvas = canvas;\n\n      if (antialias != null) {\n        options.antialias = antialias;\n      }\n\n      if (options.deterministicLockstep === undefined) {\n        options.deterministicLockstep = false;\n      }\n\n      if (options.lockstepMaxSteps === undefined) {\n        options.lockstepMaxSteps = 4;\n      }\n\n      if (options.timeStep === undefined) {\n        options.timeStep = 1 / 60;\n      }\n\n      if (options.preserveDrawingBuffer === undefined) {\n        options.preserveDrawingBuffer = false;\n      }\n\n      if (options.audioEngine === undefined) {\n        options.audioEngine = true;\n      }\n\n      if (options.stencil === undefined) {\n        options.stencil = true;\n      }\n\n      if (options.premultipliedAlpha === false) {\n        this.premultipliedAlpha = false;\n      }\n\n      if (options.xrCompatible === undefined) {\n        options.xrCompatible = true;\n      }\n\n      this._doNotHandleContextLost = options.doNotHandleContextLost ? true : false; // Exceptions\n\n      if (navigator && navigator.userAgent) {\n        var ua = navigator.userAgent;\n        this.hostInformation.isMobile = ua.indexOf(\"Mobile\") !== -1;\n\n        for (var _i = 0, _a = ThinEngine.ExceptionList; _i < _a.length; _i++) {\n          var exception = _a[_i];\n          var key = exception.key;\n          var targets = exception.targets;\n          var check = new RegExp(key);\n\n          if (check.test(ua)) {\n            if (exception.capture && exception.captureConstraint) {\n              var capture = exception.capture;\n              var constraint = exception.captureConstraint;\n              var regex = new RegExp(capture);\n              var matches = regex.exec(ua);\n\n              if (matches && matches.length > 0) {\n                var capturedValue = parseInt(matches[matches.length - 1]);\n\n                if (capturedValue >= constraint) {\n                  continue;\n                }\n              }\n            }\n\n            for (var _b = 0, targets_1 = targets; _b < targets_1.length; _b++) {\n              var target = targets_1[_b];\n\n              switch (target) {\n                case \"uniformBuffer\":\n                  this.disableUniformBuffers = true;\n                  break;\n\n                case \"vao\":\n                  this.disableVertexArrayObjects = true;\n                  break;\n              }\n            }\n          }\n        }\n      } // Context lost\n\n\n      if (!this._doNotHandleContextLost) {\n        this._onContextLost = function (evt) {\n          evt.preventDefault();\n          _this._contextWasLost = true;\n          Logger.Warn(\"WebGL context lost.\");\n\n          _this.onContextLostObservable.notifyObservers(_this);\n        };\n\n        this._onContextRestored = function () {\n          // Adding a timeout to avoid race condition at browser level\n          setTimeout(function () {\n            // Rebuild gl context\n            _this._initGLContext(); // Rebuild effects\n\n\n            _this._rebuildEffects(); // Rebuild textures\n\n\n            _this._rebuildInternalTextures(); // Rebuild buffers\n\n\n            _this._rebuildBuffers(); // Cache\n\n\n            _this.wipeCaches(true);\n\n            Logger.Warn(\"WebGL context successfully restored.\");\n\n            _this.onContextRestoredObservable.notifyObservers(_this);\n\n            _this._contextWasLost = false;\n          }, 0);\n        };\n\n        canvas.addEventListener(\"webglcontextlost\", this._onContextLost, false);\n        canvas.addEventListener(\"webglcontextrestored\", this._onContextRestored, false);\n        options.powerPreference = \"high-performance\";\n      } // GL\n\n\n      if (!options.disableWebGL2Support) {\n        try {\n          this._gl = canvas.getContext(\"webgl2\", options) || canvas.getContext(\"experimental-webgl2\", options);\n\n          if (this._gl) {\n            this._webGLVersion = 2.0; // Prevent weird browsers to lie (yeah that happens!)\n\n            if (!this._gl.deleteQuery) {\n              this._webGLVersion = 1.0;\n            }\n          }\n        } catch (e) {// Do nothing\n        }\n      }\n\n      if (!this._gl) {\n        if (!canvas) {\n          throw new Error(\"The provided canvas is null or undefined.\");\n        }\n\n        try {\n          this._gl = canvas.getContext(\"webgl\", options) || canvas.getContext(\"experimental-webgl\", options);\n        } catch (e) {\n          throw new Error(\"WebGL not supported\");\n        }\n      }\n\n      if (!this._gl) {\n        throw new Error(\"WebGL not supported\");\n      }\n    } else {\n      this._gl = canvasOrContext;\n      this._renderingCanvas = this._gl.canvas;\n\n      if (this._gl.renderbufferStorageMultisample) {\n        this._webGLVersion = 2.0;\n      }\n\n      var attributes = this._gl.getContextAttributes();\n\n      if (attributes) {\n        options.stencil = attributes.stencil;\n      }\n    } // Ensures a consistent color space unpacking of textures cross browser.\n\n\n    this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);\n\n    if (options.useHighPrecisionFloats !== undefined) {\n      this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;\n    } // Viewport\n\n\n    var devicePixelRatio = DomManagement.IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\n    var limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;\n    this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, devicePixelRatio) : 1.0;\n    this.resize();\n    this._isStencilEnable = options.stencil ? true : false;\n\n    this._initGLContext(); // Prepare buffer pointers\n\n\n    for (var i = 0; i < this._caps.maxVertexAttribs; i++) {\n      this._currentBufferPointers[i] = new BufferPointer();\n    } // Shader processor\n\n\n    if (this.webGLVersion > 1) {\n      this._shaderProcessor = new WebGL2ShaderProcessor();\n    } else {\n      this._shaderProcessor = new WebGLShaderProcessor();\n    } // Detect if we are running on a faulty buggy OS.\n\n\n    this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent); // Starting with iOS 14, we can trust the browser\n    // let matches = navigator.userAgent.match(/Version\\/(\\d+)/);\n    // if (matches && matches.length === 2) {\n    //     if (parseInt(matches[1]) >= 14) {\n    //         this._badOS = false;\n    //     }\n    // }\n    // Detect if we are running on a faulty buggy desktop OS.\n\n    this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    this._creationOptions = options;\n    console.log(\"Babylon.js v\" + ThinEngine.Version + \" - \" + this.description);\n  }\n\n  Object.defineProperty(ThinEngine, \"NpmPackage\", {\n    /**\r\n     * Returns the current npm package of the sdk\r\n     */\n    // Not mixed with Version for tooling purpose.\n    get: function get() {\n      return \"babylonjs@4.2.0\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine, \"Version\", {\n    /**\r\n     * Returns the current version of the framework\r\n     */\n    get: function get() {\n      return \"4.2.0\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"description\", {\n    /**\r\n     * Returns a string describing the current engine\r\n     */\n    get: function get() {\n      var description = \"WebGL\" + this.webGLVersion;\n\n      if (this._caps.parallelShaderCompile) {\n        description += \" - Parallel shader compilation\";\n      }\n\n      return description;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine, \"ShadersRepository\", {\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\n    get: function get() {\n      return Effect.ShadersRepository;\n    },\n    set: function set(value) {\n      Effect.ShadersRepository = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"supportsUniformBuffers\", {\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     * @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets\r\n     */\n    get: function get() {\n      return this.webGLVersion > 1 && !this.disableUniformBuffers;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"_shouldUseHighPrecisionShader\", {\n    /** @hidden */\n    get: function get() {\n      return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"needPOTTextures\", {\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\n    get: function get() {\n      return this._webGLVersion < 2 || this.forcePOTTextures;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"doNotHandleContextLost\", {\n    /**\r\n     * Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#handling-webgl-context-lost\r\n     */\n    get: function get() {\n      return this._doNotHandleContextLost;\n    },\n    set: function set(value) {\n      this._doNotHandleContextLost = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"_supportsHardwareTextureRescaling\", {\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"framebufferDimensionsObject\", {\n    /**\r\n     * sets the object from which width and height will be taken from when getting render width and height\r\n     * Will fallback to the gl object\r\n     * @param dimensions the framebuffer width and height that will be used.\r\n     */\n    set: function set(dimensions) {\n      this._framebufferDimensionsObject = dimensions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"currentViewport\", {\n    /**\r\n     * Gets the current viewport\r\n     */\n    get: function get() {\n      return this._cachedViewport;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"emptyTexture\", {\n    /**\r\n     * Gets the default empty texture\r\n     */\n    get: function get() {\n      if (!this._emptyTexture) {\n        this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, false, false, 1);\n      }\n\n      return this._emptyTexture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"emptyTexture3D\", {\n    /**\r\n     * Gets the default empty 3D texture\r\n     */\n    get: function get() {\n      if (!this._emptyTexture3D) {\n        this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);\n      }\n\n      return this._emptyTexture3D;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"emptyTexture2DArray\", {\n    /**\r\n     * Gets the default empty 2D array texture\r\n     */\n    get: function get() {\n      if (!this._emptyTexture2DArray) {\n        this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);\n      }\n\n      return this._emptyTexture2DArray;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"emptyCubeTexture\", {\n    /**\r\n     * Gets the default empty cube texture\r\n     */\n    get: function get() {\n      if (!this._emptyCubeTexture) {\n        var faceData = new Uint8Array(4);\n        var cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];\n        this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, 5, 0, false, false, 1);\n      }\n\n      return this._emptyCubeTexture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ThinEngine.prototype._rebuildInternalTextures = function () {\n    var currentState = this._internalTexturesCache.slice(); // Do a copy because the rebuild will add proxies\n\n\n    for (var _i = 0, currentState_1 = currentState; _i < currentState_1.length; _i++) {\n      var internalTexture = currentState_1[_i];\n\n      internalTexture._rebuild();\n    }\n  };\n\n  ThinEngine.prototype._rebuildEffects = function () {\n    for (var key in this._compiledEffects) {\n      var effect = this._compiledEffects[key];\n\n      effect._prepareEffect();\n    }\n\n    Effect.ResetCache();\n  };\n  /**\r\n   * Gets a boolean indicating if all created effects are ready\r\n   * @returns true if all effects are ready\r\n   */\n\n\n  ThinEngine.prototype.areAllEffectsReady = function () {\n    for (var key in this._compiledEffects) {\n      var effect = this._compiledEffects[key];\n\n      if (!effect.isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ThinEngine.prototype._rebuildBuffers = function () {\n    // Uniforms\n    for (var _i = 0, _a = this._uniformBuffers; _i < _a.length; _i++) {\n      var uniformBuffer = _a[_i];\n\n      uniformBuffer._rebuild();\n    }\n  };\n\n  ThinEngine.prototype._initGLContext = function () {\n    // Caps\n    this._caps = {\n      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),\n      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),\n      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),\n      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),\n      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,\n      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),\n      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),\n      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),\n      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),\n      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),\n      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),\n      parallelShaderCompile: this._gl.getExtension('KHR_parallel_shader_compile'),\n      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension('OES_standard_derivatives') !== null,\n      maxAnisotropy: 1,\n      astc: this._gl.getExtension('WEBGL_compressed_texture_astc') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_astc'),\n      bptc: this._gl.getExtension('EXT_texture_compression_bptc') || this._gl.getExtension('WEBKIT_EXT_texture_compression_bptc'),\n      s3tc: this._gl.getExtension('WEBGL_compressed_texture_s3tc') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc'),\n      pvrtc: this._gl.getExtension('WEBGL_compressed_texture_pvrtc') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n      etc1: this._gl.getExtension('WEBGL_compressed_texture_etc1') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_etc1'),\n      etc2: this._gl.getExtension('WEBGL_compressed_texture_etc') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_etc') || this._gl.getExtension('WEBGL_compressed_texture_es3_0'),\n      textureAnisotropicFilterExtension: this._gl.getExtension('EXT_texture_filter_anisotropic') || this._gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') || this._gl.getExtension('MOZ_EXT_texture_filter_anisotropic'),\n      uintIndices: this._webGLVersion > 1 || this._gl.getExtension('OES_element_index_uint') !== null,\n      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension('EXT_frag_depth') !== null,\n      highPrecisionShaderSupported: false,\n      timerQuery: this._gl.getExtension('EXT_disjoint_timer_query_webgl2') || this._gl.getExtension(\"EXT_disjoint_timer_query\"),\n      canUseTimestampForTimerQuery: false,\n      drawBuffersExtension: false,\n      maxMSAASamples: 1,\n      colorBufferFloat: this._webGLVersion > 1 && this._gl.getExtension('EXT_color_buffer_float'),\n      textureFloat: this._webGLVersion > 1 || this._gl.getExtension('OES_texture_float') ? true : false,\n      textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension('OES_texture_half_float') ? true : false,\n      textureHalfFloatRender: false,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: false,\n      textureHalfFloatLinearFiltering: false,\n      vertexArrayObject: false,\n      instancedArrays: false,\n      textureLOD: this._webGLVersion > 1 || this._gl.getExtension('EXT_shader_texture_lod') ? true : false,\n      blendMinMax: false,\n      multiview: this._gl.getExtension('OVR_multiview2'),\n      oculusMultiview: this._gl.getExtension('OCULUS_multiview'),\n      depthTextureExtension: false\n    }; // Infos\n\n    this._glVersion = this._gl.getParameter(this._gl.VERSION);\n\n    var rendererInfo = this._gl.getExtension(\"WEBGL_debug_renderer_info\");\n\n    if (rendererInfo != null) {\n      this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);\n      this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);\n    }\n\n    if (!this._glVendor) {\n      this._glVendor = \"Unknown vendor\";\n    }\n\n    if (!this._glRenderer) {\n      this._glRenderer = \"Unknown renderer\";\n    } // Constants\n\n\n    if (this._gl.HALF_FLOAT_OES !== 0x8D61) {\n      this._gl.HALF_FLOAT_OES = 0x8D61; // Half floating-point type (16-bit).\n    }\n\n    if (this._gl.RGBA16F !== 0x881A) {\n      this._gl.RGBA16F = 0x881A; // RGBA 16-bit floating-point color-renderable internal sized format.\n    }\n\n    if (this._gl.RGBA32F !== 0x8814) {\n      this._gl.RGBA32F = 0x8814; // RGBA 32-bit floating-point color-renderable internal sized format.\n    }\n\n    if (this._gl.DEPTH24_STENCIL8 !== 35056) {\n      this._gl.DEPTH24_STENCIL8 = 35056;\n    } // Extensions\n\n\n    if (this._caps.timerQuery) {\n      if (this._webGLVersion === 1) {\n        this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);\n      }\n\n      this._caps.canUseTimestampForTimerQuery = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) > 0;\n    }\n\n    this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;\n    this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension('OES_texture_float_linear') ? true : false;\n    this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;\n    this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension('OES_texture_half_float_linear') ? true : false; // Checks if some of the format renders first to allow the use of webgl inspector.\n\n    if (this._webGLVersion > 1) {\n      if (this._gl.HALF_FLOAT_OES !== 0x140B) {\n        this._gl.HALF_FLOAT_OES = 0x140B;\n      }\n    }\n\n    this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer(); // Draw buffers\n\n    if (this._webGLVersion > 1) {\n      this._caps.drawBuffersExtension = true;\n      this._caps.maxMSAASamples = this._gl.getParameter(this._gl.MAX_SAMPLES);\n    } else {\n      var drawBuffersExtension = this._gl.getExtension('WEBGL_draw_buffers');\n\n      if (drawBuffersExtension !== null) {\n        this._caps.drawBuffersExtension = true;\n        this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);\n        this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;\n\n        for (var i = 0; i < 16; i++) {\n          this._gl[\"COLOR_ATTACHMENT\" + i + \"_WEBGL\"] = drawBuffersExtension[\"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n        }\n      }\n    } // Depth Texture\n\n\n    if (this._webGLVersion > 1) {\n      this._caps.depthTextureExtension = true;\n    } else {\n      var depthTextureExtension = this._gl.getExtension('WEBGL_depth_texture');\n\n      if (depthTextureExtension != null) {\n        this._caps.depthTextureExtension = true;\n        this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;\n      }\n    } // Vertex array object\n\n\n    if (this.disableVertexArrayObjects) {\n      this._caps.vertexArrayObject = false;\n    } else if (this._webGLVersion > 1) {\n      this._caps.vertexArrayObject = true;\n    } else {\n      var vertexArrayObjectExtension = this._gl.getExtension('OES_vertex_array_object');\n\n      if (vertexArrayObjectExtension != null) {\n        this._caps.vertexArrayObject = true;\n        this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);\n        this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);\n        this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);\n      }\n    } // Instances count\n\n\n    if (this._webGLVersion > 1) {\n      this._caps.instancedArrays = true;\n    } else {\n      var instanceExtension = this._gl.getExtension('ANGLE_instanced_arrays');\n\n      if (instanceExtension != null) {\n        this._caps.instancedArrays = true;\n        this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);\n        this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);\n        this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);\n      } else {\n        this._caps.instancedArrays = false;\n      }\n    }\n\n    if (this._gl.getShaderPrecisionFormat) {\n      var vertex_highp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);\n\n      var fragment_highp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);\n\n      if (vertex_highp && fragment_highp) {\n        this._caps.highPrecisionShaderSupported = vertex_highp.precision !== 0 && fragment_highp.precision !== 0;\n      }\n    }\n\n    if (this._webGLVersion > 1) {\n      this._caps.blendMinMax = true;\n    } else {\n      var blendMinMaxExtension = this._gl.getExtension('EXT_blend_minmax');\n\n      if (blendMinMaxExtension != null) {\n        this._caps.blendMinMax = true;\n        this._gl.MAX = blendMinMaxExtension.MAX_EXT;\n        this._gl.MIN = blendMinMaxExtension.MIN_EXT;\n      }\n    } // Depth buffer\n\n\n    this._depthCullingState.depthTest = true;\n    this._depthCullingState.depthFunc = this._gl.LEQUAL;\n    this._depthCullingState.depthMask = true; // Texture maps\n\n    this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;\n\n    for (var slot = 0; slot < this._maxSimultaneousTextures; slot++) {\n      this._nextFreeTextureSlots.push(slot);\n    }\n  };\n\n  Object.defineProperty(ThinEngine.prototype, \"webGLVersion\", {\n    /**\r\n     * Gets version of the current webGL context\r\n     */\n    get: function get() {\n      return this._webGLVersion;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"Engine\" string\r\n   */\n\n  ThinEngine.prototype.getClassName = function () {\n    return \"ThinEngine\";\n  };\n\n  Object.defineProperty(ThinEngine.prototype, \"isStencilEnable\", {\n    /**\r\n     * Returns true if the stencil buffer has been enabled through the creation option of the context.\r\n     */\n    get: function get() {\n      return this._isStencilEnable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  ThinEngine.prototype._prepareWorkingCanvas = function () {\n    if (this._workingCanvas) {\n      return;\n    }\n\n    this._workingCanvas = CanvasGenerator.CreateCanvas(1, 1);\n\n    var context = this._workingCanvas.getContext(\"2d\");\n\n    if (context) {\n      this._workingContext = context;\n    }\n  };\n  /**\r\n   * Reset the texture cache to empty state\r\n   */\n\n\n  ThinEngine.prototype.resetTextureCache = function () {\n    for (var key in this._boundTexturesCache) {\n      if (!this._boundTexturesCache.hasOwnProperty(key)) {\n        continue;\n      }\n\n      this._boundTexturesCache[key] = null;\n    }\n\n    this._currentTextureChannel = -1;\n  };\n  /**\r\n   * Gets an object containing information about the current webGL context\r\n   * @returns an object containing the vender, the renderer and the version of the current webGL context\r\n   */\n\n\n  ThinEngine.prototype.getGlInfo = function () {\n    return {\n      vendor: this._glVendor,\n      renderer: this._glRenderer,\n      version: this._glVersion\n    };\n  };\n  /**\r\n   * Defines the hardware scaling level.\r\n   * By default the hardware scaling level is computed from the window device ratio.\r\n   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n   * @param level defines the level to use\r\n   */\n\n\n  ThinEngine.prototype.setHardwareScalingLevel = function (level) {\n    this._hardwareScalingLevel = level;\n    this.resize();\n  };\n  /**\r\n   * Gets the current hardware scaling level.\r\n   * By default the hardware scaling level is computed from the window device ratio.\r\n   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n   * @returns a number indicating the current hardware scaling level\r\n   */\n\n\n  ThinEngine.prototype.getHardwareScalingLevel = function () {\n    return this._hardwareScalingLevel;\n  };\n  /**\r\n   * Gets the list of loaded textures\r\n   * @returns an array containing all loaded textures\r\n   */\n\n\n  ThinEngine.prototype.getLoadedTexturesCache = function () {\n    return this._internalTexturesCache;\n  };\n  /**\r\n   * Gets the object containing all engine capabilities\r\n   * @returns the EngineCapabilities object\r\n   */\n\n\n  ThinEngine.prototype.getCaps = function () {\n    return this._caps;\n  };\n  /**\r\n   * stop executing a render loop function and remove it from the execution array\r\n   * @param renderFunction defines the function to be removed. If not provided all functions will be removed.\r\n   */\n\n\n  ThinEngine.prototype.stopRenderLoop = function (renderFunction) {\n    if (!renderFunction) {\n      this._activeRenderLoops = [];\n      return;\n    }\n\n    var index = this._activeRenderLoops.indexOf(renderFunction);\n\n    if (index >= 0) {\n      this._activeRenderLoops.splice(index, 1);\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._renderLoop = function () {\n    if (!this._contextWasLost) {\n      var shouldRender = true;\n\n      if (!this.renderEvenInBackground && this._windowIsBackground) {\n        shouldRender = false;\n      }\n\n      if (shouldRender) {\n        // Start new frame\n        this.beginFrame();\n\n        for (var index = 0; index < this._activeRenderLoops.length; index++) {\n          var renderFunction = this._activeRenderLoops[index];\n          renderFunction();\n        } // Present\n\n\n        this.endFrame();\n      }\n    }\n\n    if (this._activeRenderLoops.length > 0) {\n      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\n    } else {\n      this._renderingQueueLaunched = false;\n    }\n  };\n  /**\r\n   * Gets the HTML canvas attached with the current webGL context\r\n   * @returns a HTML canvas\r\n   */\n\n\n  ThinEngine.prototype.getRenderingCanvas = function () {\n    return this._renderingCanvas;\n  };\n  /**\r\n   * Gets host window\r\n   * @returns the host window object\r\n   */\n\n\n  ThinEngine.prototype.getHostWindow = function () {\n    if (!DomManagement.IsWindowObjectExist()) {\n      return null;\n    }\n\n    if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {\n      return this._renderingCanvas.ownerDocument.defaultView;\n    }\n\n    return window;\n  };\n  /**\r\n   * Gets the current render width\r\n   * @param useScreen defines if screen size must be used (or the current render target if any)\r\n   * @returns a number defining the current render width\r\n   */\n\n\n  ThinEngine.prototype.getRenderWidth = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n\n    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;\n  };\n  /**\r\n   * Gets the current render height\r\n   * @param useScreen defines if screen size must be used (or the current render target if any)\r\n   * @returns a number defining the current render height\r\n   */\n\n\n  ThinEngine.prototype.getRenderHeight = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n\n    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;\n  };\n  /**\r\n   * Can be used to override the current requestAnimationFrame requester.\r\n   * @hidden\r\n   */\n\n\n  ThinEngine.prototype._queueNewFrame = function (bindedRenderFunction, requester) {\n    return ThinEngine.QueueNewFrame(bindedRenderFunction, requester);\n  };\n  /**\r\n   * Register and execute a render loop. The engine can have more than one render function\r\n   * @param renderFunction defines the function to continuously execute\r\n   */\n\n\n  ThinEngine.prototype.runRenderLoop = function (renderFunction) {\n    if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {\n      return;\n    }\n\n    this._activeRenderLoops.push(renderFunction);\n\n    if (!this._renderingQueueLaunched) {\n      this._renderingQueueLaunched = true;\n      this._boundRenderFunction = this._renderLoop.bind(this);\n      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\n    }\n  };\n  /**\r\n   * Clear the current render buffer or the current render target (if any is set up)\r\n   * @param color defines the color to use\r\n   * @param backBuffer defines if the back buffer must be cleared\r\n   * @param depth defines if the depth buffer must be cleared\r\n   * @param stencil defines if the stencil buffer must be cleared\r\n   */\n\n\n  ThinEngine.prototype.clear = function (color, backBuffer, depth, stencil) {\n    if (stencil === void 0) {\n      stencil = false;\n    }\n\n    this.applyStates();\n    var mode = 0;\n\n    if (backBuffer && color) {\n      this._gl.clearColor(color.r, color.g, color.b, color.a !== undefined ? color.a : 1.0);\n\n      mode |= this._gl.COLOR_BUFFER_BIT;\n    }\n\n    if (depth) {\n      if (this.useReverseDepthBuffer) {\n        this._depthCullingState.depthFunc = this._gl.GREATER;\n\n        this._gl.clearDepth(0.0);\n      } else {\n        this._gl.clearDepth(1.0);\n      }\n\n      mode |= this._gl.DEPTH_BUFFER_BIT;\n    }\n\n    if (stencil) {\n      this._gl.clearStencil(0);\n\n      mode |= this._gl.STENCIL_BUFFER_BIT;\n    }\n\n    this._gl.clear(mode);\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._viewport = function (x, y, width, height) {\n    if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {\n      this._viewportCached.x = x;\n      this._viewportCached.y = y;\n      this._viewportCached.z = width;\n      this._viewportCached.w = height;\n\n      this._gl.viewport(x, y, width, height);\n    }\n  };\n  /**\r\n   * Set the WebGL's viewport\r\n   * @param viewport defines the viewport element to be used\r\n   * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n   * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n   */\n\n\n  ThinEngine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {\n    var width = requiredWidth || this.getRenderWidth();\n    var height = requiredHeight || this.getRenderHeight();\n    var x = viewport.x || 0;\n    var y = viewport.y || 0;\n    this._cachedViewport = viewport;\n\n    this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);\n  };\n  /**\r\n   * Begin a new frame\r\n   */\n\n\n  ThinEngine.prototype.beginFrame = function () {};\n  /**\r\n   * Enf the current frame\r\n   */\n\n\n  ThinEngine.prototype.endFrame = function () {\n    // Force a flush in case we are using a bad OS.\n    if (this._badOS) {\n      this.flushFramebuffer();\n    }\n  };\n  /**\r\n   * Resize the view according to the canvas' size\r\n   */\n\n\n  ThinEngine.prototype.resize = function () {\n    var width;\n    var height;\n\n    if (DomManagement.IsWindowObjectExist()) {\n      width = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth;\n      height = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight;\n    } else {\n      width = this._renderingCanvas ? this._renderingCanvas.width : 100;\n      height = this._renderingCanvas ? this._renderingCanvas.height : 100;\n    }\n\n    this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel);\n  };\n  /**\r\n   * Force a specific size of the canvas\r\n   * @param width defines the new canvas' width\r\n   * @param height defines the new canvas' height\r\n   * @returns true if the size was changed\r\n   */\n\n\n  ThinEngine.prototype.setSize = function (width, height) {\n    if (!this._renderingCanvas) {\n      return false;\n    }\n\n    width = width | 0;\n    height = height | 0;\n\n    if (this._renderingCanvas.width === width && this._renderingCanvas.height === height) {\n      return false;\n    }\n\n    this._renderingCanvas.width = width;\n    this._renderingCanvas.height = height;\n    return true;\n  };\n  /**\r\n   * Binds the frame buffer to the specified texture.\r\n   * @param texture The texture to render to or null for the default canvas\r\n   * @param faceIndex The face of the texture to render to in case of cube texture\r\n   * @param requiredWidth The width of the target to render to\r\n   * @param requiredHeight The height of the target to render to\r\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n   * @param lodLevel defines the lod level to bind to the frame buffer\r\n   * @param layer defines the 2d array index to bind to frame buffer to\r\n   */\n\n\n  ThinEngine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel, layer) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lodLevel === void 0) {\n      lodLevel = 0;\n    }\n\n    if (layer === void 0) {\n      layer = 0;\n    }\n\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n\n    this._currentRenderTarget = texture;\n\n    this._bindUnboundFramebuffer(texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer);\n\n    var gl = this._gl;\n\n    if (texture.is2DArray) {\n      gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, texture._webGLTexture, lodLevel, layer);\n    } else if (texture.isCube) {\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture._webGLTexture, lodLevel);\n    }\n\n    var depthStencilTexture = texture._depthStencilTexture;\n\n    if (depthStencilTexture) {\n      var attachment = depthStencilTexture._generateStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\n      if (texture.is2DArray) {\n        gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, depthStencilTexture._webGLTexture, lodLevel, layer);\n      } else if (texture.isCube) {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthStencilTexture._webGLTexture, lodLevel);\n      } else {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, depthStencilTexture._webGLTexture, lodLevel);\n      }\n    }\n\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    } else {\n      if (!requiredWidth) {\n        requiredWidth = texture.width;\n\n        if (lodLevel) {\n          requiredWidth = requiredWidth / Math.pow(2, lodLevel);\n        }\n      }\n\n      if (!requiredHeight) {\n        requiredHeight = texture.height;\n\n        if (lodLevel) {\n          requiredHeight = requiredHeight / Math.pow(2, lodLevel);\n        }\n      }\n\n      this._viewport(0, 0, requiredWidth, requiredHeight);\n    }\n\n    this.wipeCaches();\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._bindUnboundFramebuffer = function (framebuffer) {\n    if (this._currentFramebuffer !== framebuffer) {\n      this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);\n\n      this._currentFramebuffer = framebuffer;\n    }\n  };\n  /**\r\n   * Unbind the current render target texture from the webGL context\r\n   * @param texture defines the render target texture to unbind\r\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n   */\n\n\n  ThinEngine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {\n    if (disableGenerateMipMaps === void 0) {\n      disableGenerateMipMaps = false;\n    }\n\n    this._currentRenderTarget = null; // If MSAA, we need to bitblt back to main texture\n\n    var gl = this._gl;\n\n    if (texture._MSAAFramebuffer) {\n      if (texture._textureArray) {\n        // This texture is part of a MRT texture, we need to treat all attachments\n        this.unBindMultiColorAttachmentFramebuffer(texture._textureArray, disableGenerateMipMaps, onBeforeUnbind);\n        return;\n      }\n\n      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, texture._MSAAFramebuffer);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, texture._framebuffer);\n      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n    }\n\n    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\n\n      gl.generateMipmap(gl.TEXTURE_2D);\n\n      this._bindTextureDirectly(gl.TEXTURE_2D, null);\n    }\n\n    if (onBeforeUnbind) {\n      if (texture._MSAAFramebuffer) {\n        // Bind the correct framebuffer\n        this._bindUnboundFramebuffer(texture._framebuffer);\n      }\n\n      onBeforeUnbind();\n    }\n\n    this._bindUnboundFramebuffer(null);\n  };\n  /**\r\n   * Force a webGL flush (ie. a flush of all waiting webGL commands)\r\n   */\n\n\n  ThinEngine.prototype.flushFramebuffer = function () {\n    this._gl.flush();\n  };\n  /**\r\n   * Unbind the current render target and bind the default framebuffer\r\n   */\n\n\n  ThinEngine.prototype.restoreDefaultFramebuffer = function () {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    } else {\n      this._bindUnboundFramebuffer(null);\n    }\n\n    if (this._cachedViewport) {\n      this.setViewport(this._cachedViewport);\n    }\n\n    this.wipeCaches();\n  }; // VBOs\n\n  /** @hidden */\n\n\n  ThinEngine.prototype._resetVertexBufferBinding = function () {\n    this.bindArrayBuffer(null);\n    this._cachedVertexBuffers = null;\n  };\n  /**\r\n   * Creates a vertex buffer\r\n   * @param data the data for the vertex buffer\r\n   * @returns the new WebGL static buffer\r\n   */\n\n\n  ThinEngine.prototype.createVertexBuffer = function (data) {\n    return this._createVertexBuffer(data, this._gl.STATIC_DRAW);\n  };\n\n  ThinEngine.prototype._createVertexBuffer = function (data, usage) {\n    var vbo = this._gl.createBuffer();\n\n    if (!vbo) {\n      throw new Error(\"Unable to create vertex buffer\");\n    }\n\n    var dataBuffer = new WebGLDataBuffer(vbo);\n    this.bindArrayBuffer(dataBuffer);\n\n    if (data instanceof Array) {\n      this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), this._gl.STATIC_DRAW);\n    } else {\n      this._gl.bufferData(this._gl.ARRAY_BUFFER, data, this._gl.STATIC_DRAW);\n    }\n\n    this._resetVertexBufferBinding();\n\n    dataBuffer.references = 1;\n    return dataBuffer;\n  };\n  /**\r\n   * Creates a dynamic vertex buffer\r\n   * @param data the data for the dynamic vertex buffer\r\n   * @returns the new WebGL dynamic buffer\r\n   */\n\n\n  ThinEngine.prototype.createDynamicVertexBuffer = function (data) {\n    return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);\n  };\n\n  ThinEngine.prototype._resetIndexBufferBinding = function () {\n    this.bindIndexBuffer(null);\n    this._cachedIndexBuffer = null;\n  };\n  /**\r\n   * Creates a new index buffer\r\n   * @param indices defines the content of the index buffer\r\n   * @param updatable defines if the index buffer must be updatable\r\n   * @returns a new webGL buffer\r\n   */\n\n\n  ThinEngine.prototype.createIndexBuffer = function (indices, updatable) {\n    var vbo = this._gl.createBuffer();\n\n    var dataBuffer = new WebGLDataBuffer(vbo);\n\n    if (!vbo) {\n      throw new Error(\"Unable to create index buffer\");\n    }\n\n    this.bindIndexBuffer(dataBuffer);\n\n    var data = this._normalizeIndexData(indices);\n\n    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);\n\n    this._resetIndexBufferBinding();\n\n    dataBuffer.references = 1;\n    dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n    return dataBuffer;\n  };\n\n  ThinEngine.prototype._normalizeIndexData = function (indices) {\n    if (indices instanceof Uint16Array) {\n      return indices;\n    } // Check 32 bit support\n\n\n    if (this._caps.uintIndices) {\n      if (indices instanceof Uint32Array) {\n        return indices;\n      } else {\n        // number[] or Int32Array, check if 32 bit is necessary\n        for (var index = 0; index < indices.length; index++) {\n          if (indices[index] >= 65535) {\n            return new Uint32Array(indices);\n          }\n        }\n\n        return new Uint16Array(indices);\n      }\n    } // No 32 bit support, force conversion to 16 bit (values greater 16 bit are lost)\n\n\n    return new Uint16Array(indices);\n  };\n  /**\r\n   * Bind a webGL buffer to the webGL context\r\n   * @param buffer defines the buffer to bind\r\n   */\n\n\n  ThinEngine.prototype.bindArrayBuffer = function (buffer) {\n    if (!this._vaoRecordInProgress) {\n      this._unbindVertexArrayObject();\n    }\n\n    this.bindBuffer(buffer, this._gl.ARRAY_BUFFER);\n  };\n  /**\r\n   * Bind a specific block at a given index in a specific shader program\r\n   * @param pipelineContext defines the pipeline context to use\r\n   * @param blockName defines the block name\r\n   * @param index defines the index where to bind the block\r\n   */\n\n\n  ThinEngine.prototype.bindUniformBlock = function (pipelineContext, blockName, index) {\n    var program = pipelineContext.program;\n\n    var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);\n\n    this._gl.uniformBlockBinding(program, uniformLocation, index);\n  };\n\n  ThinEngine.prototype.bindIndexBuffer = function (buffer) {\n    if (!this._vaoRecordInProgress) {\n      this._unbindVertexArrayObject();\n    }\n\n    this.bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);\n  };\n\n  ThinEngine.prototype.bindBuffer = function (buffer, target) {\n    if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {\n      this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);\n\n      this._currentBoundBuffer[target] = buffer;\n    }\n  };\n  /**\r\n   * update the bound buffer with the given data\r\n   * @param data defines the data to update\r\n   */\n\n\n  ThinEngine.prototype.updateArrayBuffer = function (data) {\n    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);\n  };\n\n  ThinEngine.prototype._vertexAttribPointer = function (buffer, indx, size, type, normalized, stride, offset) {\n    var pointer = this._currentBufferPointers[indx];\n\n    if (!pointer) {\n      return;\n    }\n\n    var changed = false;\n\n    if (!pointer.active) {\n      changed = true;\n      pointer.active = true;\n      pointer.index = indx;\n      pointer.size = size;\n      pointer.type = type;\n      pointer.normalized = normalized;\n      pointer.stride = stride;\n      pointer.offset = offset;\n      pointer.buffer = buffer;\n    } else {\n      if (pointer.buffer !== buffer) {\n        pointer.buffer = buffer;\n        changed = true;\n      }\n\n      if (pointer.size !== size) {\n        pointer.size = size;\n        changed = true;\n      }\n\n      if (pointer.type !== type) {\n        pointer.type = type;\n        changed = true;\n      }\n\n      if (pointer.normalized !== normalized) {\n        pointer.normalized = normalized;\n        changed = true;\n      }\n\n      if (pointer.stride !== stride) {\n        pointer.stride = stride;\n        changed = true;\n      }\n\n      if (pointer.offset !== offset) {\n        pointer.offset = offset;\n        changed = true;\n      }\n    }\n\n    if (changed || this._vaoRecordInProgress) {\n      this.bindArrayBuffer(buffer);\n\n      this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._bindIndexBufferWithCache = function (indexBuffer) {\n    if (indexBuffer == null) {\n      return;\n    }\n\n    if (this._cachedIndexBuffer !== indexBuffer) {\n      this._cachedIndexBuffer = indexBuffer;\n      this.bindIndexBuffer(indexBuffer);\n      this._uintIndicesCurrentlySet = indexBuffer.is32Bits;\n    }\n  };\n\n  ThinEngine.prototype._bindVertexBuffersAttributes = function (vertexBuffers, effect) {\n    var attributes = effect.getAttributesNames();\n\n    if (!this._vaoRecordInProgress) {\n      this._unbindVertexArrayObject();\n    }\n\n    this.unbindAllAttributes();\n\n    for (var index = 0; index < attributes.length; index++) {\n      var order = effect.getAttributeLocation(index);\n\n      if (order >= 0) {\n        var vertexBuffer = vertexBuffers[attributes[index]];\n\n        if (!vertexBuffer) {\n          continue;\n        }\n\n        this._gl.enableVertexAttribArray(order);\n\n        if (!this._vaoRecordInProgress) {\n          this._vertexAttribArraysEnabled[order] = true;\n        }\n\n        var buffer = vertexBuffer.getBuffer();\n\n        if (buffer) {\n          this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);\n\n          if (vertexBuffer.getIsInstanced()) {\n            this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());\n\n            if (!this._vaoRecordInProgress) {\n              this._currentInstanceLocations.push(order);\n\n              this._currentInstanceBuffers.push(buffer);\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Records a vertex array object\r\n   * @see https://doc.babylonjs.com/features/webgl2#vertex-array-objects\r\n   * @param vertexBuffers defines the list of vertex buffers to store\r\n   * @param indexBuffer defines the index buffer to store\r\n   * @param effect defines the effect to store\r\n   * @returns the new vertex array object\r\n   */\n\n\n  ThinEngine.prototype.recordVertexArrayObject = function (vertexBuffers, indexBuffer, effect) {\n    var vao = this._gl.createVertexArray();\n\n    this._vaoRecordInProgress = true;\n\n    this._gl.bindVertexArray(vao);\n\n    this._mustWipeVertexAttributes = true;\n\n    this._bindVertexBuffersAttributes(vertexBuffers, effect);\n\n    this.bindIndexBuffer(indexBuffer);\n    this._vaoRecordInProgress = false;\n\n    this._gl.bindVertexArray(null);\n\n    return vao;\n  };\n  /**\r\n   * Bind a specific vertex array object\r\n   * @see https://doc.babylonjs.com/features/webgl2#vertex-array-objects\r\n   * @param vertexArrayObject defines the vertex array object to bind\r\n   * @param indexBuffer defines the index buffer to bind\r\n   */\n\n\n  ThinEngine.prototype.bindVertexArrayObject = function (vertexArrayObject, indexBuffer) {\n    if (this._cachedVertexArrayObject !== vertexArrayObject) {\n      this._cachedVertexArrayObject = vertexArrayObject;\n\n      this._gl.bindVertexArray(vertexArrayObject);\n\n      this._cachedVertexBuffers = null;\n      this._cachedIndexBuffer = null;\n      this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;\n      this._mustWipeVertexAttributes = true;\n    }\n  };\n  /**\r\n   * Bind webGl buffers directly to the webGL context\r\n   * @param vertexBuffer defines the vertex buffer to bind\r\n   * @param indexBuffer defines the index buffer to bind\r\n   * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer\r\n   * @param vertexStrideSize defines the vertex stride of the vertex buffer\r\n   * @param effect defines the effect associated with the vertex buffer\r\n   */\n\n\n  ThinEngine.prototype.bindBuffersDirectly = function (vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {\n    if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {\n      this._cachedVertexBuffers = vertexBuffer;\n      this._cachedEffectForVertexBuffers = effect;\n      var attributesCount = effect.getAttributesCount();\n\n      this._unbindVertexArrayObject();\n\n      this.unbindAllAttributes();\n      var offset = 0;\n\n      for (var index = 0; index < attributesCount; index++) {\n        if (index < vertexDeclaration.length) {\n          var order = effect.getAttributeLocation(index);\n\n          if (order >= 0) {\n            this._gl.enableVertexAttribArray(order);\n\n            this._vertexAttribArraysEnabled[order] = true;\n\n            this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);\n          }\n\n          offset += vertexDeclaration[index] * 4;\n        }\n      }\n    }\n\n    this._bindIndexBufferWithCache(indexBuffer);\n  };\n\n  ThinEngine.prototype._unbindVertexArrayObject = function () {\n    if (!this._cachedVertexArrayObject) {\n      return;\n    }\n\n    this._cachedVertexArrayObject = null;\n\n    this._gl.bindVertexArray(null);\n  };\n  /**\r\n   * Bind a list of vertex buffers to the webGL context\r\n   * @param vertexBuffers defines the list of vertex buffers to bind\r\n   * @param indexBuffer defines the index buffer to bind\r\n   * @param effect defines the effect associated with the vertex buffers\r\n   */\n\n\n  ThinEngine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect) {\n    if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {\n      this._cachedVertexBuffers = vertexBuffers;\n      this._cachedEffectForVertexBuffers = effect;\n\n      this._bindVertexBuffersAttributes(vertexBuffers, effect);\n    }\n\n    this._bindIndexBufferWithCache(indexBuffer);\n  };\n  /**\r\n   * Unbind all instance attributes\r\n   */\n\n\n  ThinEngine.prototype.unbindInstanceAttributes = function () {\n    var boundBuffer;\n\n    for (var i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {\n      var instancesBuffer = this._currentInstanceBuffers[i];\n\n      if (boundBuffer != instancesBuffer && instancesBuffer.references) {\n        boundBuffer = instancesBuffer;\n        this.bindArrayBuffer(instancesBuffer);\n      }\n\n      var offsetLocation = this._currentInstanceLocations[i];\n\n      this._gl.vertexAttribDivisor(offsetLocation, 0);\n    }\n\n    this._currentInstanceBuffers.length = 0;\n    this._currentInstanceLocations.length = 0;\n  };\n  /**\r\n   * Release and free the memory of a vertex array object\r\n   * @param vao defines the vertex array object to delete\r\n   */\n\n\n  ThinEngine.prototype.releaseVertexArrayObject = function (vao) {\n    this._gl.deleteVertexArray(vao);\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._releaseBuffer = function (buffer) {\n    buffer.references--;\n\n    if (buffer.references === 0) {\n      this._deleteBuffer(buffer);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  ThinEngine.prototype._deleteBuffer = function (buffer) {\n    this._gl.deleteBuffer(buffer.underlyingResource);\n  };\n  /**\r\n   * Update the content of a webGL buffer used with instanciation and bind it to the webGL context\r\n   * @param instancesBuffer defines the webGL buffer to update and bind\r\n   * @param data defines the data to store in the buffer\r\n   * @param offsetLocations defines the offsets or attributes information used to determine where data must be stored in the buffer\r\n   */\n\n\n  ThinEngine.prototype.updateAndBindInstancesBuffer = function (instancesBuffer, data, offsetLocations) {\n    this.bindArrayBuffer(instancesBuffer);\n\n    if (data) {\n      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);\n    }\n\n    if (offsetLocations[0].index !== undefined) {\n      this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);\n    } else {\n      for (var index = 0; index < 4; index++) {\n        var offsetLocation = offsetLocations[index];\n\n        if (!this._vertexAttribArraysEnabled[offsetLocation]) {\n          this._gl.enableVertexAttribArray(offsetLocation);\n\n          this._vertexAttribArraysEnabled[offsetLocation] = true;\n        }\n\n        this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);\n\n        this._gl.vertexAttribDivisor(offsetLocation, 1);\n\n        this._currentInstanceLocations.push(offsetLocation);\n\n        this._currentInstanceBuffers.push(instancesBuffer);\n      }\n    }\n  };\n  /**\r\n   * Bind the content of a webGL buffer used with instantiation\r\n   * @param instancesBuffer defines the webGL buffer to bind\r\n   * @param attributesInfo defines the offsets or attributes information used to determine where data must be stored in the buffer\r\n   * @param computeStride defines Whether to compute the strides from the info or use the default 0\r\n   */\n\n\n  ThinEngine.prototype.bindInstancesBuffer = function (instancesBuffer, attributesInfo, computeStride) {\n    if (computeStride === void 0) {\n      computeStride = true;\n    }\n\n    this.bindArrayBuffer(instancesBuffer);\n    var stride = 0;\n\n    if (computeStride) {\n      for (var i = 0; i < attributesInfo.length; i++) {\n        var ai = attributesInfo[i];\n        stride += ai.attributeSize * 4;\n      }\n    }\n\n    for (var i = 0; i < attributesInfo.length; i++) {\n      var ai = attributesInfo[i];\n\n      if (ai.index === undefined) {\n        ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);\n      }\n\n      if (ai.index < 0) {\n        continue;\n      }\n\n      if (!this._vertexAttribArraysEnabled[ai.index]) {\n        this._gl.enableVertexAttribArray(ai.index);\n\n        this._vertexAttribArraysEnabled[ai.index] = true;\n      }\n\n      this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);\n\n      this._gl.vertexAttribDivisor(ai.index, ai.divisor === undefined ? 1 : ai.divisor);\n\n      this._currentInstanceLocations.push(ai.index);\n\n      this._currentInstanceBuffers.push(instancesBuffer);\n    }\n  };\n  /**\r\n   * Disable the instance attribute corresponding to the name in parameter\r\n   * @param name defines the name of the attribute to disable\r\n   */\n\n\n  ThinEngine.prototype.disableInstanceAttributeByName = function (name) {\n    if (!this._currentEffect) {\n      return;\n    }\n\n    var attributeLocation = this._currentEffect.getAttributeLocationByName(name);\n\n    this.disableInstanceAttribute(attributeLocation);\n  };\n  /**\r\n   * Disable the instance attribute corresponding to the location in parameter\r\n   * @param attributeLocation defines the attribute location of the attribute to disable\r\n   */\n\n\n  ThinEngine.prototype.disableInstanceAttribute = function (attributeLocation) {\n    var shouldClean = false;\n    var index;\n\n    while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {\n      this._currentInstanceLocations.splice(index, 1);\n\n      this._currentInstanceBuffers.splice(index, 1);\n\n      shouldClean = true;\n      index = this._currentInstanceLocations.indexOf(attributeLocation);\n    }\n\n    if (shouldClean) {\n      this._gl.vertexAttribDivisor(attributeLocation, 0);\n\n      this.disableAttributeByIndex(attributeLocation);\n    }\n  };\n  /**\r\n   * Disable the attribute corresponding to the location in parameter\r\n   * @param attributeLocation defines the attribute location of the attribute to disable\r\n   */\n\n\n  ThinEngine.prototype.disableAttributeByIndex = function (attributeLocation) {\n    this._gl.disableVertexAttribArray(attributeLocation);\n\n    this._vertexAttribArraysEnabled[attributeLocation] = false;\n    this._currentBufferPointers[attributeLocation].active = false;\n  };\n  /**\r\n   * Send a draw order\r\n   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n   * @param indexStart defines the starting index\r\n   * @param indexCount defines the number of index to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  ThinEngine.prototype.draw = function (useTriangles, indexStart, indexCount, instancesCount) {\n    this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);\n  };\n  /**\r\n   * Draw a list of points\r\n   * @param verticesStart defines the index of first vertex to draw\r\n   * @param verticesCount defines the count of vertices to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  ThinEngine.prototype.drawPointClouds = function (verticesStart, verticesCount, instancesCount) {\n    this.drawArraysType(2, verticesStart, verticesCount, instancesCount);\n  };\n  /**\r\n   * Draw a list of unindexed primitives\r\n   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n   * @param verticesStart defines the index of first vertex to draw\r\n   * @param verticesCount defines the count of vertices to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  ThinEngine.prototype.drawUnIndexed = function (useTriangles, verticesStart, verticesCount, instancesCount) {\n    this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);\n  };\n  /**\r\n   * Draw a list of indexed primitives\r\n   * @param fillMode defines the primitive to use\r\n   * @param indexStart defines the starting index\r\n   * @param indexCount defines the number of index to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  ThinEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {\n    // Apply states\n    this.applyStates();\n\n    this._reportDrawCall(); // Render\n\n\n    var drawMode = this._drawMode(fillMode);\n\n    var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;\n    var mult = this._uintIndicesCurrentlySet ? 4 : 2;\n\n    if (instancesCount) {\n      this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);\n    } else {\n      this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);\n    }\n  };\n  /**\r\n   * Draw a list of unindexed primitives\r\n   * @param fillMode defines the primitive to use\r\n   * @param verticesStart defines the index of first vertex to draw\r\n   * @param verticesCount defines the count of vertices to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  ThinEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {\n    // Apply states\n    this.applyStates();\n\n    this._reportDrawCall();\n\n    var drawMode = this._drawMode(fillMode);\n\n    if (instancesCount) {\n      this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);\n    } else {\n      this._gl.drawArrays(drawMode, verticesStart, verticesCount);\n    }\n  };\n\n  ThinEngine.prototype._drawMode = function (fillMode) {\n    switch (fillMode) {\n      // Triangle views\n      case 0:\n        return this._gl.TRIANGLES;\n\n      case 2:\n        return this._gl.POINTS;\n\n      case 1:\n        return this._gl.LINES;\n      // Draw modes\n\n      case 3:\n        return this._gl.POINTS;\n\n      case 4:\n        return this._gl.LINES;\n\n      case 5:\n        return this._gl.LINE_LOOP;\n\n      case 6:\n        return this._gl.LINE_STRIP;\n\n      case 7:\n        return this._gl.TRIANGLE_STRIP;\n\n      case 8:\n        return this._gl.TRIANGLE_FAN;\n\n      default:\n        return this._gl.TRIANGLES;\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._reportDrawCall = function () {// Will be implemented by children\n  }; // Shaders\n\n  /** @hidden */\n\n\n  ThinEngine.prototype._releaseEffect = function (effect) {\n    if (this._compiledEffects[effect._key]) {\n      delete this._compiledEffects[effect._key];\n\n      this._deletePipelineContext(effect.getPipelineContext());\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._deletePipelineContext = function (pipelineContext) {\n    var webGLPipelineContext = pipelineContext;\n\n    if (webGLPipelineContext && webGLPipelineContext.program) {\n      webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;\n\n      this._gl.deleteProgram(webGLPipelineContext.program);\n    }\n  };\n  /**\r\n   * Create a new effect (used to store vertex/fragment shaders)\r\n   * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n   * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n   * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n   * @param samplers defines an array of string used to represent textures\r\n   * @param defines defines the string containing the defines to use to compile the shaders\r\n   * @param fallbacks defines the list of potential fallbacks to use if shader conmpilation fails\r\n   * @param onCompiled defines a function to call when the effect creation is successful\r\n   * @param onError defines a function to call when the effect creation has failed\r\n   * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n   * @returns the new Effect\r\n   */\n\n\n  ThinEngine.prototype.createEffect = function (baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters) {\n    var vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;\n    var fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;\n    var name = vertex + \"+\" + fragment + \"@\" + (defines ? defines : attributesNamesOrOptions.defines);\n\n    if (this._compiledEffects[name]) {\n      var compiledEffect = this._compiledEffects[name];\n\n      if (onCompiled && compiledEffect.isReady()) {\n        onCompiled(compiledEffect);\n      }\n\n      return compiledEffect;\n    }\n\n    var effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters);\n    effect._key = name;\n    this._compiledEffects[name] = effect;\n    return effect;\n  };\n\n  ThinEngine._ConcatenateShader = function (source, defines, shaderVersion) {\n    if (shaderVersion === void 0) {\n      shaderVersion = \"\";\n    }\n\n    return shaderVersion + (defines ? defines + \"\\n\" : \"\") + source;\n  };\n\n  ThinEngine.prototype._compileShader = function (source, type, defines, shaderVersion) {\n    return this._compileRawShader(ThinEngine._ConcatenateShader(source, defines, shaderVersion), type);\n  };\n\n  ThinEngine.prototype._compileRawShader = function (source, type) {\n    var gl = this._gl;\n    var shader = gl.createShader(type === \"vertex\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\n\n    if (!shader) {\n      throw new Error(\"Something went wrong while compile the shader.\");\n    }\n\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._getShaderSource = function (shader) {\n    return this._gl.getShaderSource(shader);\n  };\n  /**\r\n   * Directly creates a webGL program\r\n   * @param pipelineContext  defines the pipeline context to attach to\r\n   * @param vertexCode defines the vertex shader code to use\r\n   * @param fragmentCode defines the fragment shader code to use\r\n   * @param context defines the webGL context to use (if not set, the current one will be used)\r\n   * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n   * @returns the new webGL program\r\n   */\n\n\n  ThinEngine.prototype.createRawShaderProgram = function (pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings) {\n    if (transformFeedbackVaryings === void 0) {\n      transformFeedbackVaryings = null;\n    }\n\n    context = context || this._gl;\n\n    var vertexShader = this._compileRawShader(vertexCode, \"vertex\");\n\n    var fragmentShader = this._compileRawShader(fragmentCode, \"fragment\");\n\n    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);\n  };\n  /**\r\n   * Creates a webGL program\r\n   * @param pipelineContext  defines the pipeline context to attach to\r\n   * @param vertexCode  defines the vertex shader code to use\r\n   * @param fragmentCode defines the fragment shader code to use\r\n   * @param defines defines the string containing the defines to use to compile the shaders\r\n   * @param context defines the webGL context to use (if not set, the current one will be used)\r\n   * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n   * @returns the new webGL program\r\n   */\n\n\n  ThinEngine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {\n    if (transformFeedbackVaryings === void 0) {\n      transformFeedbackVaryings = null;\n    }\n\n    context = context || this._gl;\n    var shaderVersion = this._webGLVersion > 1 ? \"#version 300 es\\n#define WEBGL2 \\n\" : \"\";\n\n    var vertexShader = this._compileShader(vertexCode, \"vertex\", defines, shaderVersion);\n\n    var fragmentShader = this._compileShader(fragmentCode, \"fragment\", defines, shaderVersion);\n\n    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);\n  };\n  /**\r\n   * Creates a new pipeline context\r\n   * @returns the new pipeline\r\n   */\n\n\n  ThinEngine.prototype.createPipelineContext = function () {\n    var pipelineContext = new WebGLPipelineContext();\n    pipelineContext.engine = this;\n\n    if (this._caps.parallelShaderCompile) {\n      pipelineContext.isParallelCompiled = true;\n    }\n\n    return pipelineContext;\n  };\n\n  ThinEngine.prototype._createShaderProgram = function (pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {\n    if (transformFeedbackVaryings === void 0) {\n      transformFeedbackVaryings = null;\n    }\n\n    var shaderProgram = context.createProgram();\n    pipelineContext.program = shaderProgram;\n\n    if (!shaderProgram) {\n      throw new Error(\"Unable to create program\");\n    }\n\n    context.attachShader(shaderProgram, vertexShader);\n    context.attachShader(shaderProgram, fragmentShader);\n    context.linkProgram(shaderProgram);\n    pipelineContext.context = context;\n    pipelineContext.vertexShader = vertexShader;\n    pipelineContext.fragmentShader = fragmentShader;\n\n    if (!pipelineContext.isParallelCompiled) {\n      this._finalizePipelineContext(pipelineContext);\n    }\n\n    return shaderProgram;\n  };\n\n  ThinEngine.prototype._finalizePipelineContext = function (pipelineContext) {\n    var context = pipelineContext.context;\n    var vertexShader = pipelineContext.vertexShader;\n    var fragmentShader = pipelineContext.fragmentShader;\n    var program = pipelineContext.program;\n    var linked = context.getProgramParameter(program, context.LINK_STATUS);\n\n    if (!linked) {\n      // Get more info\n      // Vertex\n      if (!this._gl.getShaderParameter(vertexShader, this._gl.COMPILE_STATUS)) {\n        var log = this._gl.getShaderInfoLog(vertexShader);\n\n        if (log) {\n          pipelineContext.vertexCompilationError = log;\n          throw new Error(\"VERTEX SHADER \" + log);\n        }\n      } // Fragment\n\n\n      if (!this._gl.getShaderParameter(fragmentShader, this._gl.COMPILE_STATUS)) {\n        var log = this._gl.getShaderInfoLog(fragmentShader);\n\n        if (log) {\n          pipelineContext.fragmentCompilationError = log;\n          throw new Error(\"FRAGMENT SHADER \" + log);\n        }\n      }\n\n      var error = context.getProgramInfoLog(program);\n\n      if (error) {\n        pipelineContext.programLinkError = error;\n        throw new Error(error);\n      }\n    }\n\n    if (this.validateShaderPrograms) {\n      context.validateProgram(program);\n      var validated = context.getProgramParameter(program, context.VALIDATE_STATUS);\n\n      if (!validated) {\n        var error = context.getProgramInfoLog(program);\n\n        if (error) {\n          pipelineContext.programValidationError = error;\n          throw new Error(error);\n        }\n      }\n    }\n\n    context.deleteShader(vertexShader);\n    context.deleteShader(fragmentShader);\n    pipelineContext.vertexShader = undefined;\n    pipelineContext.fragmentShader = undefined;\n\n    if (pipelineContext.onCompiled) {\n      pipelineContext.onCompiled();\n      pipelineContext.onCompiled = undefined;\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._preparePipelineContext = function (pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rebuildRebind, defines, transformFeedbackVaryings) {\n    var webGLRenderingState = pipelineContext;\n\n    if (createAsRaw) {\n      webGLRenderingState.program = this.createRawShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, undefined, transformFeedbackVaryings);\n    } else {\n      webGLRenderingState.program = this.createShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, defines, undefined, transformFeedbackVaryings);\n    }\n\n    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._isRenderingStateCompiled = function (pipelineContext) {\n    var webGLPipelineContext = pipelineContext;\n\n    if (this._gl.getProgramParameter(webGLPipelineContext.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)) {\n      this._finalizePipelineContext(webGLPipelineContext);\n\n      return true;\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._executeWhenRenderingStateIsCompiled = function (pipelineContext, action) {\n    var webGLPipelineContext = pipelineContext;\n\n    if (!webGLPipelineContext.isParallelCompiled) {\n      action();\n      return;\n    }\n\n    var oldHandler = webGLPipelineContext.onCompiled;\n\n    if (oldHandler) {\n      webGLPipelineContext.onCompiled = function () {\n        oldHandler();\n        action();\n      };\n    } else {\n      webGLPipelineContext.onCompiled = action;\n    }\n  };\n  /**\r\n   * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\r\n   * @param pipelineContext defines the pipeline context to use\r\n   * @param uniformsNames defines the list of uniform names\r\n   * @returns an array of webGL uniform locations\r\n   */\n\n\n  ThinEngine.prototype.getUniforms = function (pipelineContext, uniformsNames) {\n    var results = new Array();\n    var webGLPipelineContext = pipelineContext;\n\n    for (var index = 0; index < uniformsNames.length; index++) {\n      results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));\n    }\n\n    return results;\n  };\n  /**\r\n   * Gets the lsit of active attributes for a given webGL program\r\n   * @param pipelineContext defines the pipeline context to use\r\n   * @param attributesNames defines the list of attribute names to get\r\n   * @returns an array of indices indicating the offset of each attribute\r\n   */\n\n\n  ThinEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {\n    var results = [];\n    var webGLPipelineContext = pipelineContext;\n\n    for (var index = 0; index < attributesNames.length; index++) {\n      try {\n        results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));\n      } catch (e) {\n        results.push(-1);\n      }\n    }\n\n    return results;\n  };\n  /**\r\n   * Activates an effect, mkaing it the current one (ie. the one used for rendering)\r\n   * @param effect defines the effect to activate\r\n   */\n\n\n  ThinEngine.prototype.enableEffect = function (effect) {\n    if (!effect || effect === this._currentEffect) {\n      return;\n    } // Use program\n\n\n    this.bindSamplers(effect);\n    this._currentEffect = effect;\n\n    if (effect.onBind) {\n      effect.onBind(effect);\n    }\n\n    if (effect._onBindObservable) {\n      effect._onBindObservable.notifyObservers(effect);\n    }\n  };\n  /**\r\n   * Set the value of an uniform to a number (int)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param value defines the int number to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setInt = function (uniform, value) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniform1i(uniform, value);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setIntArray = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniform1iv(uniform, array);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setIntArray2 = function (uniform, array) {\n    if (!uniform || array.length % 2 !== 0) {\n      return false;\n    }\n\n    this._gl.uniform2iv(uniform, array);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setIntArray3 = function (uniform, array) {\n    if (!uniform || array.length % 3 !== 0) {\n      return false;\n    }\n\n    this._gl.uniform3iv(uniform, array);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec4)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setIntArray4 = function (uniform, array) {\n    if (!uniform || array.length % 4 !== 0) {\n      return false;\n    }\n\n    this._gl.uniform4iv(uniform, array);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setArray = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniform1fv(uniform, array);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setArray2 = function (uniform, array) {\n    if (!uniform || array.length % 2 !== 0) {\n      return false;\n    }\n\n    this._gl.uniform2fv(uniform, array);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setArray3 = function (uniform, array) {\n    if (!uniform || array.length % 3 !== 0) {\n      return false;\n    }\n\n    this._gl.uniform3fv(uniform, array);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec4)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setArray4 = function (uniform, array) {\n    if (!uniform || array.length % 4 !== 0) {\n      return false;\n    }\n\n    this._gl.uniform4fv(uniform, array);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as matrices)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrices defines the array of float32 to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setMatrices = function (uniform, matrices) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniformMatrix4fv(uniform, false, matrices);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a matrix (3x3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrix defines the Float32Array representing the 3x3 matrix to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setMatrix3x3 = function (uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniformMatrix3fv(uniform, false, matrix);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a matrix (2x2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrix defines the Float32Array representing the 2x2 matrix to store\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setMatrix2x2 = function (uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniformMatrix2fv(uniform, false, matrix);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a number (float)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param value defines the float number to store\r\n   * @returns true if the value was transfered\r\n   */\n\n\n  ThinEngine.prototype.setFloat = function (uniform, value) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniform1f(uniform, value);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec2\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setFloat2 = function (uniform, x, y) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniform2f(uniform, x, y);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec3\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @param z defines the 3rd component of the value\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setFloat3 = function (uniform, x, y, z) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniform3f(uniform, x, y, z);\n\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec4\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @param z defines the 3rd component of the value\r\n   * @param w defines the 4th component of the value\r\n   * @returns true if the value was set\r\n   */\n\n\n  ThinEngine.prototype.setFloat4 = function (uniform, x, y, z, w) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._gl.uniform4f(uniform, x, y, z, w);\n\n    return true;\n  }; // States\n\n  /**\r\n   * Apply all cached states (depth, culling, stencil and alpha)\r\n   */\n\n\n  ThinEngine.prototype.applyStates = function () {\n    this._depthCullingState.apply(this._gl);\n\n    this._stencilState.apply(this._gl);\n\n    this._alphaState.apply(this._gl);\n\n    if (this._colorWriteChanged) {\n      this._colorWriteChanged = false;\n      var enable = this._colorWrite;\n\n      this._gl.colorMask(enable, enable, enable, enable);\n    }\n  };\n  /**\r\n   * Enable or disable color writing\r\n   * @param enable defines the state to set\r\n   */\n\n\n  ThinEngine.prototype.setColorWrite = function (enable) {\n    if (enable !== this._colorWrite) {\n      this._colorWriteChanged = true;\n      this._colorWrite = enable;\n    }\n  };\n  /**\r\n   * Gets a boolean indicating if color writing is enabled\r\n   * @returns the current color writing state\r\n   */\n\n\n  ThinEngine.prototype.getColorWrite = function () {\n    return this._colorWrite;\n  };\n\n  Object.defineProperty(ThinEngine.prototype, \"depthCullingState\", {\n    /**\r\n     * Gets the depth culling state manager\r\n     */\n    get: function get() {\n      return this._depthCullingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"alphaState\", {\n    /**\r\n     * Gets the alpha state manager\r\n     */\n    get: function get() {\n      return this._alphaState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinEngine.prototype, \"stencilState\", {\n    /**\r\n     * Gets the stencil state manager\r\n     */\n    get: function get() {\n      return this._stencilState;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Textures\n\n  /**\r\n   * Clears the list of texture accessible through engine.\r\n   * This can help preventing texture load conflict due to name collision.\r\n   */\n\n  ThinEngine.prototype.clearInternalTexturesCache = function () {\n    this._internalTexturesCache = [];\n  };\n  /**\r\n   * Force the entire cache to be cleared\r\n   * You should not have to use this function unless your engine needs to share the webGL context with another engine\r\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n   */\n\n\n  ThinEngine.prototype.wipeCaches = function (bruteForce) {\n    if (this.preventCacheWipeBetweenFrames && !bruteForce) {\n      return;\n    }\n\n    this._currentEffect = null;\n    this._viewportCached.x = 0;\n    this._viewportCached.y = 0;\n    this._viewportCached.z = 0;\n    this._viewportCached.w = 0; // Done before in case we clean the attributes\n\n    this._unbindVertexArrayObject();\n\n    if (bruteForce) {\n      this._currentProgram = null;\n      this.resetTextureCache();\n\n      this._stencilState.reset();\n\n      this._depthCullingState.reset();\n\n      this._depthCullingState.depthFunc = this._gl.LEQUAL;\n\n      this._alphaState.reset();\n\n      this._alphaMode = 1;\n      this._alphaEquation = 0;\n      this._colorWrite = true;\n      this._colorWriteChanged = true;\n      this._unpackFlipYCached = null;\n\n      this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);\n\n      this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\n\n      this._mustWipeVertexAttributes = true;\n      this.unbindAllAttributes();\n    }\n\n    this._resetVertexBufferBinding();\n\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n    this.bindIndexBuffer(null);\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._getSamplingParameters = function (samplingMode, generateMipMaps) {\n    var gl = this._gl;\n    var magFilter = gl.NEAREST;\n    var minFilter = gl.NEAREST;\n\n    switch (samplingMode) {\n      case 11:\n        magFilter = gl.LINEAR;\n\n        if (generateMipMaps) {\n          minFilter = gl.LINEAR_MIPMAP_NEAREST;\n        } else {\n          minFilter = gl.LINEAR;\n        }\n\n        break;\n\n      case 3:\n        magFilter = gl.LINEAR;\n\n        if (generateMipMaps) {\n          minFilter = gl.LINEAR_MIPMAP_LINEAR;\n        } else {\n          minFilter = gl.LINEAR;\n        }\n\n        break;\n\n      case 8:\n        magFilter = gl.NEAREST;\n\n        if (generateMipMaps) {\n          minFilter = gl.NEAREST_MIPMAP_LINEAR;\n        } else {\n          minFilter = gl.NEAREST;\n        }\n\n        break;\n\n      case 4:\n        magFilter = gl.NEAREST;\n\n        if (generateMipMaps) {\n          minFilter = gl.NEAREST_MIPMAP_NEAREST;\n        } else {\n          minFilter = gl.NEAREST;\n        }\n\n        break;\n\n      case 5:\n        magFilter = gl.NEAREST;\n\n        if (generateMipMaps) {\n          minFilter = gl.LINEAR_MIPMAP_NEAREST;\n        } else {\n          minFilter = gl.LINEAR;\n        }\n\n        break;\n\n      case 6:\n        magFilter = gl.NEAREST;\n\n        if (generateMipMaps) {\n          minFilter = gl.LINEAR_MIPMAP_LINEAR;\n        } else {\n          minFilter = gl.LINEAR;\n        }\n\n        break;\n\n      case 7:\n        magFilter = gl.NEAREST;\n        minFilter = gl.LINEAR;\n        break;\n\n      case 1:\n        magFilter = gl.NEAREST;\n        minFilter = gl.NEAREST;\n        break;\n\n      case 9:\n        magFilter = gl.LINEAR;\n\n        if (generateMipMaps) {\n          minFilter = gl.NEAREST_MIPMAP_NEAREST;\n        } else {\n          minFilter = gl.NEAREST;\n        }\n\n        break;\n\n      case 10:\n        magFilter = gl.LINEAR;\n\n        if (generateMipMaps) {\n          minFilter = gl.NEAREST_MIPMAP_LINEAR;\n        } else {\n          minFilter = gl.NEAREST;\n        }\n\n        break;\n\n      case 2:\n        magFilter = gl.LINEAR;\n        minFilter = gl.LINEAR;\n        break;\n\n      case 12:\n        magFilter = gl.LINEAR;\n        minFilter = gl.NEAREST;\n        break;\n    }\n\n    return {\n      min: minFilter,\n      mag: magFilter\n    };\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._createTexture = function () {\n    var texture = this._gl.createTexture();\n\n    if (!texture) {\n      throw new Error(\"Unable to create texture\");\n    }\n\n    return texture;\n  };\n  /**\r\n   * Usually called from Texture.ts.\r\n   * Passed information to create a WebGLTexture\r\n   * @param url defines a value which contains one of the following:\r\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n   * @param scene needed for loading to the correct scene\r\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n   * @param onLoad optional callback to be called upon successful completion\r\n   * @param onError optional callback to be called upon failure\r\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n   * @param forcedExtension defines the extension to use to pick the right loader\r\n   * @param mimeType defines an optional mime type\r\n   * @param loaderOptions options to be passed to the loader\r\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n   */\n\n\n  ThinEngine.prototype.createTexture = function (url, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType, loaderOptions) {\n    var _this = this;\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (fallback === void 0) {\n      fallback = null;\n    }\n\n    if (format === void 0) {\n      format = null;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    url = url || \"\";\n    var fromData = url.substr(0, 5) === \"data:\";\n    var fromBlob = url.substr(0, 5) === \"blob:\";\n    var isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\n    var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\n    var originalUrl = url;\n\n    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\n      url = this._transformTextureUrl(url);\n    }\n\n    if (originalUrl !== url) {\n      texture._originalUrl = originalUrl;\n    } // establish the file extension, if possible\n\n\n    var lastDot = url.lastIndexOf('.');\n    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n    var loader = null; // Remove query string\n\n    var queryStringIndex = extension.indexOf(\"?\");\n\n    if (queryStringIndex > -1) {\n      extension = extension.split(\"?\")[0];\n    }\n\n    for (var _i = 0, _a = ThinEngine._TextureLoaders; _i < _a.length; _i++) {\n      var availableLoader = _a[_i];\n\n      if (availableLoader.canLoad(extension, mimeType)) {\n        loader = availableLoader;\n        break;\n      }\n    }\n\n    if (scene) {\n      scene._addPendingData(texture);\n    }\n\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n\n    if (!this._doNotHandleContextLost) {\n      // Keep a link to the buffer only if we plan to handle context lost\n      texture._buffer = buffer;\n    }\n\n    var onLoadObserver = null;\n\n    if (onLoad && !fallback) {\n      onLoadObserver = texture.onLoadedObservable.add(onLoad);\n    }\n\n    if (!fallback) {\n      this._internalTexturesCache.push(texture);\n    }\n\n    var onInternalError = function onInternalError(message, exception) {\n      if (scene) {\n        scene._removePendingData(texture);\n      }\n\n      if (url === originalUrl) {\n        if (onLoadObserver) {\n          texture.onLoadedObservable.remove(onLoadObserver);\n        }\n\n        if (EngineStore.UseFallbackTexture) {\n          _this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);\n        }\n\n        if (onError) {\n          onError((message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\"), exception);\n        }\n      } else {\n        // fall back to the original url if the transformed url fails to load\n        Logger.Warn(\"Failed to load \" + url + \", falling back to \" + originalUrl);\n\n        _this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);\n      }\n    }; // processing for non-image formats\n\n\n    if (loader) {\n      var callback_1 = function callback_1(data) {\n        loader.loadData(data, texture, function (width, height, loadMipmap, isCompressed, done, loadFailed) {\n          if (loadFailed) {\n            onInternalError(\"TextureLoader failed to load data\");\n          } else {\n            _this._prepareWebGLTexture(texture, scene, width, height, texture.invertY, !loadMipmap, isCompressed, function () {\n              done();\n              return false;\n            }, samplingMode);\n          }\n        }, loaderOptions);\n      };\n\n      if (!buffer) {\n        this._loadFile(url, function (data) {\n          return callback_1(new Uint8Array(data));\n        }, undefined, scene ? scene.offlineProvider : undefined, true, function (request, exception) {\n          onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\n        });\n      } else {\n        if (buffer instanceof ArrayBuffer) {\n          callback_1(new Uint8Array(buffer));\n        } else if (ArrayBuffer.isView(buffer)) {\n          callback_1(buffer);\n        } else {\n          if (onError) {\n            onError(\"Unable to load: only ArrayBuffer or ArrayBufferView is supported\", null);\n          }\n        }\n      }\n    } else {\n      var onload_1 = function onload_1(img) {\n        if (fromBlob && !_this._doNotHandleContextLost) {\n          // We need to store the image if we need to rebuild the texture\n          // in case of a webgl context lost\n          texture._buffer = img;\n        }\n\n        _this._prepareWebGLTexture(texture, scene, img.width, img.height, texture.invertY, noMipmap, false, function (potWidth, potHeight, continuationCallback) {\n          var gl = _this._gl;\n          var isPot = img.width === potWidth && img.height === potHeight;\n          var internalFormat = format ? _this._getInternalFormat(format) : extension === \".jpg\" ? gl.RGB : gl.RGBA;\n\n          if (isPot) {\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, img);\n            return false;\n          }\n\n          var maxTextureSize = _this._caps.maxTextureSize;\n\n          if (img.width > maxTextureSize || img.height > maxTextureSize || !_this._supportsHardwareTextureRescaling) {\n            _this._prepareWorkingCanvas();\n\n            if (!_this._workingCanvas || !_this._workingContext) {\n              return false;\n            }\n\n            _this._workingCanvas.width = potWidth;\n            _this._workingCanvas.height = potHeight;\n\n            _this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);\n\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);\n            texture.width = potWidth;\n            texture.height = potHeight;\n            return false;\n          } else {\n            // Using shaders when possible to rescale because canvas.drawImage is lossy\n            var source_1 = new InternalTexture(_this, InternalTextureSource.Temp);\n\n            _this._bindTextureDirectly(gl.TEXTURE_2D, source_1, true);\n\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, img);\n\n            _this._rescaleTexture(source_1, texture, scene, internalFormat, function () {\n              _this._releaseTexture(source_1);\n\n              _this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\n\n              continuationCallback();\n            });\n          }\n\n          return true;\n        }, samplingMode);\n      };\n\n      if (!fromData || isBase64) {\n        if (buffer && (buffer.decoding || buffer.close)) {\n          onload_1(buffer);\n        } else {\n          ThinEngine._FileToolsLoadImage(url, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType);\n        }\n      } else if (typeof buffer === \"string\" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {\n        ThinEngine._FileToolsLoadImage(buffer, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType);\n      } else if (buffer) {\n        onload_1(buffer);\n      }\n    }\n\n    return texture;\n  };\n  /**\r\n   * Loads an image as an HTMLImageElement.\r\n   * @param input url string, ArrayBuffer, or Blob to load\r\n   * @param onLoad callback called when the image successfully loads\r\n   * @param onError callback called when the image fails to load\r\n   * @param offlineProvider offline provider for caching\r\n   * @param mimeType optional mime type\r\n   * @returns the HTMLImageElement of the loaded image\r\n   * @hidden\r\n   */\n\n\n  ThinEngine._FileToolsLoadImage = function (input, onLoad, onError, offlineProvider, mimeType) {\n    throw _DevTools.WarnImport(\"FileTools\");\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  ThinEngine.prototype._rescaleTexture = function (source, destination, scene, internalFormat, onComplete) {};\n  /**\r\n   * Creates a raw texture\r\n   * @param data defines the data to store in the texture\r\n   * @param width defines the width of the texture\r\n   * @param height defines the height of the texture\r\n   * @param format defines the format of the data\r\n   * @param generateMipMaps defines if the engine should generate the mip levels\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n   * @param compression defines the compression used (null by default)\r\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n   * @returns the raw texture inside an InternalTexture\r\n   */\n\n\n  ThinEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    throw _DevTools.WarnImport(\"Engine.RawTexture\");\n  };\n  /**\r\n   * Creates a new raw cube texture\r\n   * @param data defines the array of data to use to create each face\r\n   * @param size defines the size of the textures\r\n   * @param format defines the format of the data\r\n   * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n   * @param generateMipMaps  defines if the engine should generate the mip levels\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n   * @param compression defines the compression used (null by default)\r\n   * @returns the cube texture as an InternalTexture\r\n   */\n\n\n  ThinEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    throw _DevTools.WarnImport(\"Engine.RawTexture\");\n  };\n  /**\r\n   * Creates a new raw 3D texture\r\n   * @param data defines the data used to create the texture\r\n   * @param width defines the width of the texture\r\n   * @param height defines the height of the texture\r\n   * @param depth defines the depth of the texture\r\n   * @param format defines the format of the texture\r\n   * @param generateMipMaps defines if the engine must generate mip levels\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n   * @param compression defines the compressed used (can be null)\r\n   * @param textureType defines the compressed used (can be null)\r\n   * @returns a new raw 3D texture (stored in an InternalTexture)\r\n   */\n\n\n  ThinEngine.prototype.createRawTexture3D = function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    throw _DevTools.WarnImport(\"Engine.RawTexture\");\n  };\n  /**\r\n   * Creates a new raw 2D array texture\r\n   * @param data defines the data used to create the texture\r\n   * @param width defines the width of the texture\r\n   * @param height defines the height of the texture\r\n   * @param depth defines the number of layers of the texture\r\n   * @param format defines the format of the texture\r\n   * @param generateMipMaps defines if the engine must generate mip levels\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n   * @param compression defines the compressed used (can be null)\r\n   * @param textureType defines the compressed used (can be null)\r\n   * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n   */\n\n\n  ThinEngine.prototype.createRawTexture2DArray = function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    throw _DevTools.WarnImport(\"Engine.RawTexture\");\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._unpackFlipY = function (value) {\n    if (this._unpackFlipYCached !== value) {\n      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);\n\n      if (this.enableUnpackFlipYCached) {\n        this._unpackFlipYCached = value;\n      }\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._getUnpackAlignement = function () {\n    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);\n  };\n\n  ThinEngine.prototype._getTextureTarget = function (texture) {\n    if (texture.isCube) {\n      return this._gl.TEXTURE_CUBE_MAP;\n    } else if (texture.is3D) {\n      return this._gl.TEXTURE_3D;\n    } else if (texture.is2DArray || texture.isMultiview) {\n      return this._gl.TEXTURE_2D_ARRAY;\n    }\n\n    return this._gl.TEXTURE_2D;\n  };\n  /**\r\n   * Update the sampling mode of a given texture\r\n   * @param samplingMode defines the required sampling mode\r\n   * @param texture defines the texture to update\r\n   * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n   */\n\n\n  ThinEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture, generateMipMaps) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    var target = this._getTextureTarget(texture);\n\n    var filters = this._getSamplingParameters(samplingMode, texture.generateMipMaps || generateMipMaps);\n\n    this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);\n\n    this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\n\n    if (generateMipMaps) {\n      texture.generateMipMaps = true;\n\n      this._gl.generateMipmap(target);\n    }\n\n    this._bindTextureDirectly(target, null);\n\n    texture.samplingMode = samplingMode;\n  };\n  /**\r\n   * Update the sampling mode of a given texture\r\n   * @param texture defines the texture to update\r\n   * @param wrapU defines the texture wrap mode of the u coordinates\r\n   * @param wrapV defines the texture wrap mode of the v coordinates\r\n   * @param wrapR defines the texture wrap mode of the r coordinates\r\n   */\n\n\n  ThinEngine.prototype.updateTextureWrappingMode = function (texture, wrapU, wrapV, wrapR) {\n    if (wrapV === void 0) {\n      wrapV = null;\n    }\n\n    if (wrapR === void 0) {\n      wrapR = null;\n    }\n\n    var target = this._getTextureTarget(texture);\n\n    if (wrapU !== null) {\n      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);\n\n      texture._cachedWrapU = wrapU;\n    }\n\n    if (wrapV !== null) {\n      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);\n\n      texture._cachedWrapV = wrapV;\n    }\n\n    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\n      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);\n\n      texture._cachedWrapR = wrapR;\n    }\n\n    this._bindTextureDirectly(target, null);\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._setupDepthStencilTexture = function (internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction) {\n    var width = size.width || size;\n    var height = size.height || size;\n    var layers = size.layers || 0;\n    internalTexture.baseWidth = width;\n    internalTexture.baseHeight = height;\n    internalTexture.width = width;\n    internalTexture.height = height;\n    internalTexture.is2DArray = layers > 0;\n    internalTexture.depth = layers;\n    internalTexture.isReady = true;\n    internalTexture.samples = 1;\n    internalTexture.generateMipMaps = false;\n    internalTexture._generateDepthBuffer = true;\n    internalTexture._generateStencilBuffer = generateStencil;\n    internalTexture.samplingMode = bilinearFiltering ? 2 : 1;\n    internalTexture.type = 0;\n    internalTexture._comparisonFunction = comparisonFunction;\n    var gl = this._gl;\n\n    var target = this._getTextureTarget(internalTexture);\n\n    var samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);\n\n    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);\n    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);\n    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    if (comparisonFunction === 0) {\n      gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);\n      gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);\n    } else {\n      gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);\n      gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, data, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    var gl = this._gl;\n    var target = gl.TEXTURE_2D;\n\n    if (texture.isCube) {\n      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\n    }\n\n    this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod, babylonInternalFormat, useTextureWidthAndHeight) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    if (useTextureWidthAndHeight === void 0) {\n      useTextureWidthAndHeight = false;\n    }\n\n    var gl = this._gl;\n\n    var textureType = this._getWebGLTextureType(texture.type);\n\n    var format = this._getInternalFormat(texture.format);\n\n    var internalFormat = babylonInternalFormat === undefined ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format) : this._getInternalFormat(babylonInternalFormat);\n\n    this._unpackFlipY(texture.invertY);\n\n    var target = gl.TEXTURE_2D;\n\n    if (texture.isCube) {\n      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\n    }\n\n    var lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\n    var lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\n    var width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\n    var height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\n    gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);\n  };\n  /**\r\n   * Update a portion of an internal texture\r\n   * @param texture defines the texture to update\r\n   * @param imageData defines the data to store into the texture\r\n   * @param xOffset defines the x coordinates of the update rectangle\r\n   * @param yOffset defines the y coordinates of the update rectangle\r\n   * @param width defines the width of the update rectangle\r\n   * @param height defines the height of the update rectangle\r\n   * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n   * @param lod defines the lod level to update (0 by default)\r\n   */\n\n\n  ThinEngine.prototype.updateTextureData = function (texture, imageData, xOffset, yOffset, width, height, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    var gl = this._gl;\n\n    var textureType = this._getWebGLTextureType(texture.type);\n\n    var format = this._getInternalFormat(texture.format);\n\n    this._unpackFlipY(texture.invertY);\n\n    var target = gl.TEXTURE_2D;\n\n    if (texture.isCube) {\n      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\n    }\n\n    gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    var gl = this._gl;\n    var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\n\n    this._bindTextureDirectly(bindTarget, texture, true);\n\n    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\n\n    this._bindTextureDirectly(bindTarget, null, true);\n  };\n\n  ThinEngine.prototype._prepareWebGLTextureContinuation = function (texture, scene, noMipmap, isCompressed, samplingMode) {\n    var gl = this._gl;\n\n    if (!gl) {\n      return;\n    }\n\n    var filters = this._getSamplingParameters(samplingMode, !noMipmap);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);\n\n    if (!noMipmap && !isCompressed) {\n      gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    this._bindTextureDirectly(gl.TEXTURE_2D, null); // this.resetTextureCache();\n\n\n    if (scene) {\n      scene._removePendingData(texture);\n    }\n\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n  };\n\n  ThinEngine.prototype._prepareWebGLTexture = function (texture, scene, width, height, invertY, noMipmap, isCompressed, processFunction, samplingMode) {\n    var _this = this;\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    var maxTextureSize = this.getCaps().maxTextureSize;\n    var potWidth = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, maxTextureSize) : width);\n    var potHeight = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, maxTextureSize) : height);\n    var gl = this._gl;\n\n    if (!gl) {\n      return;\n    }\n\n    if (!texture._webGLTexture) {\n      //  this.resetTextureCache();\n      if (scene) {\n        scene._removePendingData(texture);\n      }\n\n      return;\n    }\n\n    this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\n\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = potWidth;\n    texture.height = potHeight;\n    texture.isReady = true;\n\n    if (processFunction(potWidth, potHeight, function () {\n      _this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);\n    })) {\n      // Returning as texture needs extra async steps\n      return;\n    }\n\n    this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._setupFramebufferDepthAttachments = function (generateStencilBuffer, generateDepthBuffer, width, height, samples) {\n    if (samples === void 0) {\n      samples = 1;\n    }\n\n    var gl = this._gl; // Create the depth/stencil buffer\n\n    if (generateStencilBuffer && generateDepthBuffer) {\n      return this._getDepthStencilBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);\n    }\n\n    if (generateDepthBuffer) {\n      var depthFormat = gl.DEPTH_COMPONENT16;\n\n      if (this._webGLVersion > 1) {\n        depthFormat = gl.DEPTH_COMPONENT32F;\n      }\n\n      return this._getDepthStencilBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);\n    }\n\n    if (generateStencilBuffer) {\n      return this._getDepthStencilBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);\n    }\n\n    return null;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._releaseFramebufferObjects = function (texture) {\n    var gl = this._gl;\n\n    if (texture._framebuffer) {\n      gl.deleteFramebuffer(texture._framebuffer);\n      texture._framebuffer = null;\n    }\n\n    if (texture._depthStencilBuffer) {\n      gl.deleteRenderbuffer(texture._depthStencilBuffer);\n      texture._depthStencilBuffer = null;\n    }\n\n    if (texture._MSAAFramebuffer) {\n      gl.deleteFramebuffer(texture._MSAAFramebuffer);\n      texture._MSAAFramebuffer = null;\n    }\n\n    if (texture._MSAARenderBuffer) {\n      gl.deleteRenderbuffer(texture._MSAARenderBuffer);\n      texture._MSAARenderBuffer = null;\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._releaseTexture = function (texture) {\n    this._releaseFramebufferObjects(texture);\n\n    this._deleteTexture(texture._webGLTexture); // Unbind channels\n\n\n    this.unbindAllTextures();\n\n    var index = this._internalTexturesCache.indexOf(texture);\n\n    if (index !== -1) {\n      this._internalTexturesCache.splice(index, 1);\n    } // Integrated fixed lod samplers.\n\n\n    if (texture._lodTextureHigh) {\n      texture._lodTextureHigh.dispose();\n    }\n\n    if (texture._lodTextureMid) {\n      texture._lodTextureMid.dispose();\n    }\n\n    if (texture._lodTextureLow) {\n      texture._lodTextureLow.dispose();\n    } // Integrated irradiance map.\n\n\n    if (texture._irradianceTexture) {\n      texture._irradianceTexture.dispose();\n    }\n  };\n\n  ThinEngine.prototype._deleteTexture = function (texture) {\n    this._gl.deleteTexture(texture);\n  };\n\n  ThinEngine.prototype._setProgram = function (program) {\n    if (this._currentProgram !== program) {\n      this._gl.useProgram(program);\n\n      this._currentProgram = program;\n    }\n  };\n  /**\r\n   * Binds an effect to the webGL context\r\n   * @param effect defines the effect to bind\r\n   */\n\n\n  ThinEngine.prototype.bindSamplers = function (effect) {\n    var webGLPipelineContext = effect.getPipelineContext();\n\n    this._setProgram(webGLPipelineContext.program);\n\n    var samplers = effect.getSamplers();\n\n    for (var index = 0; index < samplers.length; index++) {\n      var uniform = effect.getUniform(samplers[index]);\n\n      if (uniform) {\n        this._boundUniforms[index] = uniform;\n      }\n    }\n\n    this._currentEffect = null;\n  };\n\n  ThinEngine.prototype._activateCurrentTexture = function () {\n    if (this._currentTextureChannel !== this._activeChannel) {\n      this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);\n\n      this._currentTextureChannel = this._activeChannel;\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._bindTextureDirectly = function (target, texture, forTextureDataUpdate, force) {\n    if (forTextureDataUpdate === void 0) {\n      forTextureDataUpdate = false;\n    }\n\n    if (force === void 0) {\n      force = false;\n    }\n\n    var wasPreviouslyBound = false;\n    var isTextureForRendering = texture && texture._associatedChannel > -1;\n\n    if (forTextureDataUpdate && isTextureForRendering) {\n      this._activeChannel = texture._associatedChannel;\n    }\n\n    var currentTextureBound = this._boundTexturesCache[this._activeChannel];\n\n    if (currentTextureBound !== texture || force) {\n      this._activateCurrentTexture();\n\n      if (texture && texture.isMultiview) {\n        this._gl.bindTexture(target, texture ? texture._colorTextureArray : null);\n      } else {\n        this._gl.bindTexture(target, texture ? texture._webGLTexture : null);\n      }\n\n      this._boundTexturesCache[this._activeChannel] = texture;\n\n      if (texture) {\n        texture._associatedChannel = this._activeChannel;\n      }\n    } else if (forTextureDataUpdate) {\n      wasPreviouslyBound = true;\n\n      this._activateCurrentTexture();\n    }\n\n    if (isTextureForRendering && !forTextureDataUpdate) {\n      this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);\n    }\n\n    return wasPreviouslyBound;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._bindTexture = function (channel, texture) {\n    if (channel === undefined) {\n      return;\n    }\n\n    if (texture) {\n      texture._associatedChannel = channel;\n    }\n\n    this._activeChannel = channel;\n    var target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;\n\n    this._bindTextureDirectly(target, texture);\n  };\n  /**\r\n   * Unbind all textures from the webGL context\r\n   */\n\n\n  ThinEngine.prototype.unbindAllTextures = function () {\n    for (var channel = 0; channel < this._maxSimultaneousTextures; channel++) {\n      this._activeChannel = channel;\n\n      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n\n      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n\n      if (this.webGLVersion > 1) {\n        this._bindTextureDirectly(this._gl.TEXTURE_3D, null);\n\n        this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);\n      }\n    }\n  };\n  /**\r\n   * Sets a texture to the according uniform.\r\n   * @param channel The texture channel\r\n   * @param uniform The uniform to set\r\n   * @param texture The texture to apply\r\n   */\n\n\n  ThinEngine.prototype.setTexture = function (channel, uniform, texture) {\n    if (channel === undefined) {\n      return;\n    }\n\n    if (uniform) {\n      this._boundUniforms[channel] = uniform;\n    }\n\n    this._setTexture(channel, texture);\n  };\n\n  ThinEngine.prototype._bindSamplerUniformToChannel = function (sourceSlot, destination) {\n    var uniform = this._boundUniforms[sourceSlot];\n\n    if (!uniform || uniform._currentState === destination) {\n      return;\n    }\n\n    this._gl.uniform1i(uniform, destination);\n\n    uniform._currentState = destination;\n  };\n\n  ThinEngine.prototype._getTextureWrapMode = function (mode) {\n    switch (mode) {\n      case 1:\n        return this._gl.REPEAT;\n\n      case 0:\n        return this._gl.CLAMP_TO_EDGE;\n\n      case 2:\n        return this._gl.MIRRORED_REPEAT;\n    }\n\n    return this._gl.REPEAT;\n  };\n\n  ThinEngine.prototype._setTexture = function (channel, texture, isPartOfTextureArray, depthStencilTexture) {\n    if (isPartOfTextureArray === void 0) {\n      isPartOfTextureArray = false;\n    }\n\n    if (depthStencilTexture === void 0) {\n      depthStencilTexture = false;\n    } // Not ready?\n\n\n    if (!texture) {\n      if (this._boundTexturesCache[channel] != null) {\n        this._activeChannel = channel;\n\n        this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n\n        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n\n        if (this.webGLVersion > 1) {\n          this._bindTextureDirectly(this._gl.TEXTURE_3D, null);\n\n          this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);\n        }\n      }\n\n      return false;\n    } // Video\n\n\n    if (texture.video) {\n      this._activeChannel = channel;\n      texture.update();\n    } else if (texture.delayLoadState === 4) {\n      // Delay loading\n      texture.delayLoad();\n      return false;\n    }\n\n    var internalTexture;\n\n    if (depthStencilTexture) {\n      internalTexture = texture.depthStencilTexture;\n    } else if (texture.isReady()) {\n      internalTexture = texture.getInternalTexture();\n    } else if (texture.isCube) {\n      internalTexture = this.emptyCubeTexture;\n    } else if (texture.is3D) {\n      internalTexture = this.emptyTexture3D;\n    } else if (texture.is2DArray) {\n      internalTexture = this.emptyTexture2DArray;\n    } else {\n      internalTexture = this.emptyTexture;\n    }\n\n    if (!isPartOfTextureArray && internalTexture) {\n      internalTexture._associatedChannel = channel;\n    }\n\n    var needToBind = true;\n\n    if (this._boundTexturesCache[channel] === internalTexture) {\n      if (!isPartOfTextureArray) {\n        this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);\n      }\n\n      needToBind = false;\n    }\n\n    this._activeChannel = channel;\n\n    var target = this._getTextureTarget(internalTexture);\n\n    if (needToBind) {\n      this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);\n    }\n\n    if (internalTexture && !internalTexture.isMultiview) {\n      // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\n      if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\n        internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\n        var textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;\n        texture.wrapU = textureWrapMode;\n        texture.wrapV = textureWrapMode;\n      }\n\n      if (internalTexture._cachedWrapU !== texture.wrapU) {\n        internalTexture._cachedWrapU = texture.wrapU;\n\n        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);\n      }\n\n      if (internalTexture._cachedWrapV !== texture.wrapV) {\n        internalTexture._cachedWrapV = texture.wrapV;\n\n        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);\n      }\n\n      if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {\n        internalTexture._cachedWrapR = texture.wrapR;\n\n        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);\n      }\n\n      this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);\n    }\n\n    return true;\n  };\n  /**\r\n   * Sets an array of texture to the webGL context\r\n   * @param channel defines the channel where the texture array must be set\r\n   * @param uniform defines the associated uniform location\r\n   * @param textures defines the array of textures to bind\r\n   */\n\n\n  ThinEngine.prototype.setTextureArray = function (channel, uniform, textures) {\n    if (channel === undefined || !uniform) {\n      return;\n    }\n\n    if (!this._textureUnits || this._textureUnits.length !== textures.length) {\n      this._textureUnits = new Int32Array(textures.length);\n    }\n\n    for (var i = 0; i < textures.length; i++) {\n      var texture = textures[i].getInternalTexture();\n\n      if (texture) {\n        this._textureUnits[i] = channel + i;\n        texture._associatedChannel = channel + i;\n      } else {\n        this._textureUnits[i] = -1;\n      }\n    }\n\n    this._gl.uniform1iv(uniform, this._textureUnits);\n\n    for (var index = 0; index < textures.length; index++) {\n      this._setTexture(this._textureUnits[index], textures[index], true);\n    }\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._setAnisotropicLevel = function (target, internalTexture, anisotropicFilteringLevel) {\n    var anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;\n\n    if (internalTexture.samplingMode !== 11 && internalTexture.samplingMode !== 3 && internalTexture.samplingMode !== 2) {\n      anisotropicFilteringLevel = 1; // Forcing the anisotropic to 1 because else webgl will force filters to linear\n    }\n\n    if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\n      this._setTextureParameterFloat(target, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);\n\n      internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;\n    }\n  };\n\n  ThinEngine.prototype._setTextureParameterFloat = function (target, parameter, value, texture) {\n    this._bindTextureDirectly(target, texture, true, true);\n\n    this._gl.texParameterf(target, parameter, value);\n  };\n\n  ThinEngine.prototype._setTextureParameterInteger = function (target, parameter, value, texture) {\n    if (texture) {\n      this._bindTextureDirectly(target, texture, true, true);\n    }\n\n    this._gl.texParameteri(target, parameter, value);\n  };\n  /**\r\n   * Unbind all vertex attributes from the webGL context\r\n   */\n\n\n  ThinEngine.prototype.unbindAllAttributes = function () {\n    if (this._mustWipeVertexAttributes) {\n      this._mustWipeVertexAttributes = false;\n\n      for (var i = 0; i < this._caps.maxVertexAttribs; i++) {\n        this.disableAttributeByIndex(i);\n      }\n\n      return;\n    }\n\n    for (var i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {\n      if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {\n        continue;\n      }\n\n      this.disableAttributeByIndex(i);\n    }\n  };\n  /**\r\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n   */\n\n\n  ThinEngine.prototype.releaseEffects = function () {\n    for (var name in this._compiledEffects) {\n      var webGLPipelineContext = this._compiledEffects[name].getPipelineContext();\n\n      this._deletePipelineContext(webGLPipelineContext);\n    }\n\n    this._compiledEffects = {};\n  };\n  /**\r\n   * Dispose and release all associated resources\r\n   */\n\n\n  ThinEngine.prototype.dispose = function () {\n    this.stopRenderLoop(); // Clear observables\n\n    if (this.onBeforeTextureInitObservable) {\n      this.onBeforeTextureInitObservable.clear();\n    } // Empty texture\n\n\n    if (this._emptyTexture) {\n      this._releaseTexture(this._emptyTexture);\n\n      this._emptyTexture = null;\n    }\n\n    if (this._emptyCubeTexture) {\n      this._releaseTexture(this._emptyCubeTexture);\n\n      this._emptyCubeTexture = null;\n    }\n\n    if (this._dummyFramebuffer) {\n      this._gl.deleteFramebuffer(this._dummyFramebuffer);\n    } // Release effects\n\n\n    this.releaseEffects(); // Unbind\n\n    this.unbindAllAttributes();\n    this._boundUniforms = []; // Events\n\n    if (DomManagement.IsWindowObjectExist()) {\n      if (this._renderingCanvas) {\n        if (!this._doNotHandleContextLost) {\n          this._renderingCanvas.removeEventListener(\"webglcontextlost\", this._onContextLost);\n\n          this._renderingCanvas.removeEventListener(\"webglcontextrestored\", this._onContextRestored);\n        }\n      }\n    }\n\n    this._workingCanvas = null;\n    this._workingContext = null;\n    this._currentBufferPointers = [];\n    this._renderingCanvas = null;\n    this._currentProgram = null;\n    this._boundRenderFunction = null;\n    Effect.ResetCache(); // Abort active requests\n\n    for (var _i = 0, _a = this._activeRequests; _i < _a.length; _i++) {\n      var request = _a[_i];\n      request.abort();\n    }\n  };\n  /**\r\n   * Attach a new callback raised when context lost event is fired\r\n   * @param callback defines the callback to call\r\n   */\n\n\n  ThinEngine.prototype.attachContextLostEvent = function (callback) {\n    if (this._renderingCanvas) {\n      this._renderingCanvas.addEventListener(\"webglcontextlost\", callback, false);\n    }\n  };\n  /**\r\n   * Attach a new callback raised when context restored event is fired\r\n   * @param callback defines the callback to call\r\n   */\n\n\n  ThinEngine.prototype.attachContextRestoredEvent = function (callback) {\n    if (this._renderingCanvas) {\n      this._renderingCanvas.addEventListener(\"webglcontextrestored\", callback, false);\n    }\n  };\n  /**\r\n   * Get the current error code of the webGL context\r\n   * @returns the error code\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\r\n   */\n\n\n  ThinEngine.prototype.getError = function () {\n    return this._gl.getError();\n  };\n\n  ThinEngine.prototype._canRenderToFloatFramebuffer = function () {\n    if (this._webGLVersion > 1) {\n      return this._caps.colorBufferFloat;\n    }\n\n    return this._canRenderToFramebuffer(1);\n  };\n\n  ThinEngine.prototype._canRenderToHalfFloatFramebuffer = function () {\n    if (this._webGLVersion > 1) {\n      return this._caps.colorBufferFloat;\n    }\n\n    return this._canRenderToFramebuffer(2);\n  }; // Thank you : http://stackoverflow.com/questions/28827511/webgl-ios-render-to-floating-point-texture\n\n\n  ThinEngine.prototype._canRenderToFramebuffer = function (type) {\n    var gl = this._gl; //clear existing errors\n\n    while (gl.getError() !== gl.NO_ERROR) {}\n\n    var successful = true;\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    var fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    successful = successful && status === gl.FRAMEBUFFER_COMPLETE;\n    successful = successful && gl.getError() === gl.NO_ERROR; //try render by clearing frame buffer's color buffer\n\n    if (successful) {\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      successful = successful && gl.getError() === gl.NO_ERROR;\n    } //try reading from frame to ensure render occurs (just creating the FBO is not sufficient to determine if rendering is supported)\n\n\n    if (successful) {\n      //in practice it's sufficient to just read from the backbuffer rather than handle potentially issues reading from the texture\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      var readFormat = gl.RGBA;\n      var readType = gl.UNSIGNED_BYTE;\n      var buffer = new Uint8Array(4);\n      gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);\n      successful = successful && gl.getError() === gl.NO_ERROR;\n    } //clean up\n\n\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(fb);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null); //clear accumulated errors\n\n    while (!successful && gl.getError() !== gl.NO_ERROR) {}\n\n    return successful;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._getWebGLTextureType = function (type) {\n    if (this._webGLVersion === 1) {\n      switch (type) {\n        case 1:\n          return this._gl.FLOAT;\n\n        case 2:\n          return this._gl.HALF_FLOAT_OES;\n\n        case 0:\n          return this._gl.UNSIGNED_BYTE;\n\n        case 8:\n          return this._gl.UNSIGNED_SHORT_4_4_4_4;\n\n        case 9:\n          return this._gl.UNSIGNED_SHORT_5_5_5_1;\n\n        case 10:\n          return this._gl.UNSIGNED_SHORT_5_6_5;\n      }\n\n      return this._gl.UNSIGNED_BYTE;\n    }\n\n    switch (type) {\n      case 3:\n        return this._gl.BYTE;\n\n      case 0:\n        return this._gl.UNSIGNED_BYTE;\n\n      case 4:\n        return this._gl.SHORT;\n\n      case 5:\n        return this._gl.UNSIGNED_SHORT;\n\n      case 6:\n        return this._gl.INT;\n\n      case 7:\n        // Refers to UNSIGNED_INT\n        return this._gl.UNSIGNED_INT;\n\n      case 1:\n        return this._gl.FLOAT;\n\n      case 2:\n        return this._gl.HALF_FLOAT;\n\n      case 8:\n        return this._gl.UNSIGNED_SHORT_4_4_4_4;\n\n      case 9:\n        return this._gl.UNSIGNED_SHORT_5_5_5_1;\n\n      case 10:\n        return this._gl.UNSIGNED_SHORT_5_6_5;\n\n      case 11:\n        return this._gl.UNSIGNED_INT_2_10_10_10_REV;\n\n      case 12:\n        return this._gl.UNSIGNED_INT_24_8;\n\n      case 13:\n        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;\n\n      case 14:\n        return this._gl.UNSIGNED_INT_5_9_9_9_REV;\n\n      case 15:\n        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\n    }\n\n    return this._gl.UNSIGNED_BYTE;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._getInternalFormat = function (format) {\n    var internalFormat = this._gl.RGBA;\n\n    switch (format) {\n      case 0:\n        internalFormat = this._gl.ALPHA;\n        break;\n\n      case 1:\n        internalFormat = this._gl.LUMINANCE;\n        break;\n\n      case 2:\n        internalFormat = this._gl.LUMINANCE_ALPHA;\n        break;\n\n      case 6:\n        internalFormat = this._gl.RED;\n        break;\n\n      case 7:\n        internalFormat = this._gl.RG;\n        break;\n\n      case 4:\n        internalFormat = this._gl.RGB;\n        break;\n\n      case 5:\n        internalFormat = this._gl.RGBA;\n        break;\n    }\n\n    if (this._webGLVersion > 1) {\n      switch (format) {\n        case 8:\n          internalFormat = this._gl.RED_INTEGER;\n          break;\n\n        case 9:\n          internalFormat = this._gl.RG_INTEGER;\n          break;\n\n        case 10:\n          internalFormat = this._gl.RGB_INTEGER;\n          break;\n\n        case 11:\n          internalFormat = this._gl.RGBA_INTEGER;\n          break;\n      }\n    }\n\n    return internalFormat;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._getRGBABufferInternalSizedFormat = function (type, format) {\n    if (this._webGLVersion === 1) {\n      if (format !== undefined) {\n        switch (format) {\n          case 0:\n            return this._gl.ALPHA;\n\n          case 1:\n            return this._gl.LUMINANCE;\n\n          case 2:\n            return this._gl.LUMINANCE_ALPHA;\n\n          case 4:\n            return this._gl.RGB;\n        }\n      }\n\n      return this._gl.RGBA;\n    }\n\n    switch (type) {\n      case 3:\n        switch (format) {\n          case 6:\n            return this._gl.R8_SNORM;\n\n          case 7:\n            return this._gl.RG8_SNORM;\n\n          case 4:\n            return this._gl.RGB8_SNORM;\n\n          case 8:\n            return this._gl.R8I;\n\n          case 9:\n            return this._gl.RG8I;\n\n          case 10:\n            return this._gl.RGB8I;\n\n          case 11:\n            return this._gl.RGBA8I;\n\n          default:\n            return this._gl.RGBA8_SNORM;\n        }\n\n      case 0:\n        switch (format) {\n          case 6:\n            return this._gl.R8;\n\n          case 7:\n            return this._gl.RG8;\n\n          case 4:\n            return this._gl.RGB8;\n          // By default. Other possibilities are RGB565, SRGB8.\n\n          case 5:\n            return this._gl.RGBA8;\n          // By default. Other possibilities are RGB5_A1, RGBA4, SRGB8_ALPHA8.\n\n          case 8:\n            return this._gl.R8UI;\n\n          case 9:\n            return this._gl.RG8UI;\n\n          case 10:\n            return this._gl.RGB8UI;\n\n          case 11:\n            return this._gl.RGBA8UI;\n\n          case 0:\n            return this._gl.ALPHA;\n\n          case 1:\n            return this._gl.LUMINANCE;\n\n          case 2:\n            return this._gl.LUMINANCE_ALPHA;\n\n          default:\n            return this._gl.RGBA8;\n        }\n\n      case 4:\n        switch (format) {\n          case 8:\n            return this._gl.R16I;\n\n          case 9:\n            return this._gl.RG16I;\n\n          case 10:\n            return this._gl.RGB16I;\n\n          case 11:\n            return this._gl.RGBA16I;\n\n          default:\n            return this._gl.RGBA16I;\n        }\n\n      case 5:\n        switch (format) {\n          case 8:\n            return this._gl.R16UI;\n\n          case 9:\n            return this._gl.RG16UI;\n\n          case 10:\n            return this._gl.RGB16UI;\n\n          case 11:\n            return this._gl.RGBA16UI;\n\n          default:\n            return this._gl.RGBA16UI;\n        }\n\n      case 6:\n        switch (format) {\n          case 8:\n            return this._gl.R32I;\n\n          case 9:\n            return this._gl.RG32I;\n\n          case 10:\n            return this._gl.RGB32I;\n\n          case 11:\n            return this._gl.RGBA32I;\n\n          default:\n            return this._gl.RGBA32I;\n        }\n\n      case 7:\n        // Refers to UNSIGNED_INT\n        switch (format) {\n          case 8:\n            return this._gl.R32UI;\n\n          case 9:\n            return this._gl.RG32UI;\n\n          case 10:\n            return this._gl.RGB32UI;\n\n          case 11:\n            return this._gl.RGBA32UI;\n\n          default:\n            return this._gl.RGBA32UI;\n        }\n\n      case 1:\n        switch (format) {\n          case 6:\n            return this._gl.R32F;\n          // By default. Other possibility is R16F.\n\n          case 7:\n            return this._gl.RG32F;\n          // By default. Other possibility is RG16F.\n\n          case 4:\n            return this._gl.RGB32F;\n          // By default. Other possibilities are RGB16F, R11F_G11F_B10F, RGB9_E5.\n\n          case 5:\n            return this._gl.RGBA32F;\n          // By default. Other possibility is RGBA16F.\n\n          default:\n            return this._gl.RGBA32F;\n        }\n\n      case 2:\n        switch (format) {\n          case 6:\n            return this._gl.R16F;\n\n          case 7:\n            return this._gl.RG16F;\n\n          case 4:\n            return this._gl.RGB16F;\n          // By default. Other possibilities are R11F_G11F_B10F, RGB9_E5.\n\n          case 5:\n            return this._gl.RGBA16F;\n\n          default:\n            return this._gl.RGBA16F;\n        }\n\n      case 10:\n        return this._gl.RGB565;\n\n      case 13:\n        return this._gl.R11F_G11F_B10F;\n\n      case 14:\n        return this._gl.RGB9_E5;\n\n      case 8:\n        return this._gl.RGBA4;\n\n      case 9:\n        return this._gl.RGB5_A1;\n\n      case 11:\n        switch (format) {\n          case 5:\n            return this._gl.RGB10_A2;\n          // By default. Other possibility is RGB5_A1.\n\n          case 11:\n            return this._gl.RGB10_A2UI;\n\n          default:\n            return this._gl.RGB10_A2;\n        }\n\n    }\n\n    return this._gl.RGBA8;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._getRGBAMultiSampleBufferFormat = function (type) {\n    if (type === 1) {\n      return this._gl.RGBA32F;\n    } else if (type === 2) {\n      return this._gl.RGBA16F;\n    }\n\n    return this._gl.RGBA8;\n  };\n  /** @hidden */\n\n\n  ThinEngine.prototype._loadFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    var _this = this;\n\n    var request = ThinEngine._FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /**\r\n   * Loads a file from a url\r\n   * @param url url to load\r\n   * @param onSuccess callback called when the file successfully loads\r\n   * @param onProgress callback called while file is loading (if the server supports this mode)\r\n   * @param offlineProvider defines the offline provider for caching\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @param onError callback called when the file fails to load\r\n   * @returns a file request object\r\n   * @hidden\r\n   */\n\n\n  ThinEngine._FileToolsLoadFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    throw _DevTools.WarnImport(\"FileTools\");\n  };\n  /**\r\n   * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n   * @param x defines the x coordinate of the rectangle where pixels must be read\r\n   * @param y defines the y coordinate of the rectangle where pixels must be read\r\n   * @param width defines the width of the rectangle where pixels must be read\r\n   * @param height defines the height of the rectangle where pixels must be read\r\n   * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n   * @returns a Uint8Array containing RGBA colors\r\n   */\n\n\n  ThinEngine.prototype.readPixels = function (x, y, width, height, hasAlpha) {\n    if (hasAlpha === void 0) {\n      hasAlpha = true;\n    }\n\n    var numChannels = hasAlpha ? 4 : 3;\n    var format = hasAlpha ? this._gl.RGBA : this._gl.RGB;\n    var data = new Uint8Array(height * width * numChannels);\n\n    this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);\n\n    return data;\n  };\n\n  Object.defineProperty(ThinEngine, \"IsSupported\", {\n    /**\r\n     * Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)\r\n     */\n    get: function get() {\n      return this.isSupported(); // Backward compat\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)\r\n   * @returns true if the engine can be created\r\n   * @ignorenaming\r\n   */\n\n  ThinEngine.isSupported = function () {\n    if (this._HasMajorPerformanceCaveat !== null) {\n      return !this._HasMajorPerformanceCaveat; // We know it is performant so WebGL is supported\n    }\n\n    if (this._IsSupported === null) {\n      try {\n        var tempcanvas = CanvasGenerator.CreateCanvas(1, 1);\n        var gl = tempcanvas.getContext(\"webgl\") || tempcanvas.getContext(\"experimental-webgl\");\n        this._IsSupported = gl != null && !!window.WebGLRenderingContext;\n      } catch (e) {\n        this._IsSupported = false;\n      }\n    }\n\n    return this._IsSupported;\n  };\n\n  Object.defineProperty(ThinEngine, \"HasMajorPerformanceCaveat\", {\n    /**\r\n     * Gets a boolean indicating if the engine can be instanciated on a performant device (ie. if a webGL context can be found and it does not use a slow implementation)\r\n     */\n    get: function get() {\n      if (this._HasMajorPerformanceCaveat === null) {\n        try {\n          var tempcanvas = CanvasGenerator.CreateCanvas(1, 1);\n          var gl = tempcanvas.getContext(\"webgl\", {\n            failIfMajorPerformanceCaveat: true\n          }) || tempcanvas.getContext(\"experimental-webgl\", {\n            failIfMajorPerformanceCaveat: true\n          });\n          this._HasMajorPerformanceCaveat = !gl;\n        } catch (e) {\n          this._HasMajorPerformanceCaveat = false;\n        }\n      }\n\n      return this._HasMajorPerformanceCaveat;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Find the next highest power of two.\r\n   * @param x Number to start search from.\r\n   * @return Next highest power of two.\r\n   */\n\n  ThinEngine.CeilingPOT = function (x) {\n    x--;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    x++;\n    return x;\n  };\n  /**\r\n   * Find the next lowest power of two.\r\n   * @param x Number to start search from.\r\n   * @return Next lowest power of two.\r\n   */\n\n\n  ThinEngine.FloorPOT = function (x) {\n    x = x | x >> 1;\n    x = x | x >> 2;\n    x = x | x >> 4;\n    x = x | x >> 8;\n    x = x | x >> 16;\n    return x - (x >> 1);\n  };\n  /**\r\n   * Find the nearest power of two.\r\n   * @param x Number to start search from.\r\n   * @return Next nearest power of two.\r\n   */\n\n\n  ThinEngine.NearestPOT = function (x) {\n    var c = ThinEngine.CeilingPOT(x);\n    var f = ThinEngine.FloorPOT(x);\n    return c - x > x - f ? f : c;\n  };\n  /**\r\n   * Get the closest exponent of two\r\n   * @param value defines the value to approximate\r\n   * @param max defines the maximum value to return\r\n   * @param mode defines how to define the closest value\r\n   * @returns closest exponent of two of the given value\r\n   */\n\n\n  ThinEngine.GetExponentOfTwo = function (value, max, mode) {\n    if (mode === void 0) {\n      mode = 2;\n    }\n\n    var pot;\n\n    switch (mode) {\n      case 1:\n        pot = ThinEngine.FloorPOT(value);\n        break;\n\n      case 2:\n        pot = ThinEngine.NearestPOT(value);\n        break;\n\n      case 3:\n      default:\n        pot = ThinEngine.CeilingPOT(value);\n        break;\n    }\n\n    return Math.min(pot, max);\n  };\n  /**\r\n   * Queue a new function into the requested animation frame pool (ie. this function will be executed byt the browser for the next frame)\r\n   * @param func - the function to be called\r\n   * @param requester - the object that will request the next frame. Falls back to window.\r\n   * @returns frame number\r\n   */\n\n\n  ThinEngine.QueueNewFrame = function (func, requester) {\n    if (!DomManagement.IsWindowObjectExist()) {\n      if (typeof requestAnimationFrame !== \"undefined\") {\n        return requestAnimationFrame(func);\n      }\n\n      return setTimeout(func, 16);\n    }\n\n    if (!requester) {\n      requester = window;\n    }\n\n    if (requester.requestPostAnimationFrame) {\n      return requester.requestPostAnimationFrame(func);\n    } else if (requester.requestAnimationFrame) {\n      return requester.requestAnimationFrame(func);\n    } else if (requester.msRequestAnimationFrame) {\n      return requester.msRequestAnimationFrame(func);\n    } else if (requester.webkitRequestAnimationFrame) {\n      return requester.webkitRequestAnimationFrame(func);\n    } else if (requester.mozRequestAnimationFrame) {\n      return requester.mozRequestAnimationFrame(func);\n    } else if (requester.oRequestAnimationFrame) {\n      return requester.oRequestAnimationFrame(func);\n    } else {\n      return window.setTimeout(func, 16);\n    }\n  };\n  /**\r\n   * Gets host document\r\n   * @returns the host document object\r\n   */\n\n\n  ThinEngine.prototype.getHostDocument = function () {\n    if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {\n      return this._renderingCanvas.ownerDocument;\n    }\n\n    return document;\n  };\n  /** Use this array to turn off some WebGL2 features on known buggy browsers version */\n\n\n  ThinEngine.ExceptionList = [{\n    key: \"Chrome\\/63\\.0\",\n    capture: \"63\\\\.0\\\\.3239\\\\.(\\\\d+)\",\n    captureConstraint: 108,\n    targets: [\"uniformBuffer\"]\n  }, {\n    key: \"Firefox\\/58\",\n    capture: null,\n    captureConstraint: null,\n    targets: [\"uniformBuffer\"]\n  }, {\n    key: \"Firefox\\/59\",\n    capture: null,\n    captureConstraint: null,\n    targets: [\"uniformBuffer\"]\n  }, {\n    key: \"Chrome\\/72.+?Mobile\",\n    capture: null,\n    captureConstraint: null,\n    targets: [\"vao\"]\n  }, {\n    key: \"Chrome\\/73.+?Mobile\",\n    capture: null,\n    captureConstraint: null,\n    targets: [\"vao\"]\n  }, {\n    key: \"Chrome\\/74.+?Mobile\",\n    capture: null,\n    captureConstraint: null,\n    targets: [\"vao\"]\n  }, {\n    key: \"Mac OS.+Chrome\\/71\",\n    capture: null,\n    captureConstraint: null,\n    targets: [\"vao\"]\n  }, {\n    key: \"Mac OS.+Chrome\\/72\",\n    capture: null,\n    captureConstraint: null,\n    targets: [\"vao\"]\n  }];\n  /** @hidden */\n\n  ThinEngine._TextureLoaders = []; // Updatable statics so stick with vars here\n\n  /**\r\n   * Gets or sets the epsilon value used by collision engine\r\n   */\n\n  ThinEngine.CollisionsEpsilon = 0.001; // Statics\n\n  ThinEngine._IsSupported = null;\n  ThinEngine._HasMajorPerformanceCaveat = null;\n  return ThinEngine;\n}();\n\nexport { ThinEngine };","map":null,"metadata":{},"sourceType":"module"}