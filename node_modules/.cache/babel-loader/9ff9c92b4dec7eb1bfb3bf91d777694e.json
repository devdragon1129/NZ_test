{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh\";\nimport { VertexBuffer, Buffer } from './buffer';\nimport { Matrix, Vector3, TmpVectors } from '../Maths/math.vector';\n\nMesh.prototype.thinInstanceAdd = function (matrix, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\n\n  var index = this._thinInstanceDataStorage.instancesCount;\n\n  if (Array.isArray(matrix)) {\n    for (var i = 0; i < matrix.length; ++i) {\n      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\n    }\n  } else {\n    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\n  }\n\n  return index;\n};\n\nMesh.prototype.thinInstanceAddSelf = function (refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\n};\n\nMesh.prototype.thinInstanceRegisterAttribute = function (kind, stride) {\n  this.removeVerticesData(kind);\n\n  this._thinInstanceInitializeUserStorage();\n\n  this._userThinInstanceBuffersStorage.strides[kind] = stride;\n  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\n\n  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\n  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\n  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n};\n\nMesh.prototype.thinInstanceSetMatrixAt = function (index, matrix, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n  matrix.copyToArray(matrixData, index * 16);\n\n  if (this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices[index] = matrix;\n  }\n\n  if (refresh) {\n    this.thinInstanceBufferUpdated(\"matrix\");\n\n    if (!this.doNotSyncBoundingInfo) {\n      this.thinInstanceRefreshBoundingInfo(false);\n    }\n  }\n\n  return true;\n};\n\nMesh.prototype.thinInstanceSetAttributeAt = function (kind, index, value, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n\n  this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\n\n\n  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\n\n  if (refresh) {\n    this.thinInstanceBufferUpdated(kind);\n  }\n\n  return true;\n};\n\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\n  get: function get() {\n    return this._thinInstanceDataStorage.instancesCount;\n  },\n  set: function set(value) {\n    var _a, _b;\n\n    var numMaxInstances = ((_b = (_a = this._thinInstanceDataStorage.matrixData) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) / 16;\n\n    if (value <= numMaxInstances) {\n      this._thinInstanceDataStorage.instancesCount = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nMesh.prototype.thinInstanceSetBuffer = function (kind, buffer, stride, staticBuffer) {\n  var _a, _b;\n\n  if (stride === void 0) {\n    stride = 0;\n  }\n\n  if (staticBuffer === void 0) {\n    staticBuffer = false;\n  }\n\n  stride = stride || 16;\n\n  if (kind === \"matrix\") {\n    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._thinInstanceDataStorage.matrixBuffer = null;\n    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\n    this._thinInstanceDataStorage.matrixData = buffer;\n    this._thinInstanceDataStorage.worldMatrices = null;\n\n    if (buffer !== null) {\n      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\n      var matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, stride, false, true);\n      this._thinInstanceDataStorage.matrixBuffer = matrixBuffer;\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world0\", 0, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world1\", 4, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world2\", 8, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world3\", 12, 4));\n\n      if (!this.doNotSyncBoundingInfo) {\n        this.thinInstanceRefreshBoundingInfo(false);\n      }\n    } else {\n      this._thinInstanceDataStorage.instancesCount = 0;\n\n      if (!this.doNotSyncBoundingInfo) {\n        // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\n        this.refreshBoundingInfo(true);\n      }\n    }\n  } else {\n    if (buffer === null) {\n      if ((_b = this._userThinInstanceBuffersStorage) === null || _b === void 0 ? void 0 : _b.data[kind]) {\n        this.removeVerticesData(kind);\n        delete this._userThinInstanceBuffersStorage.data[kind];\n        delete this._userThinInstanceBuffersStorage.strides[kind];\n        delete this._userThinInstanceBuffersStorage.sizes[kind];\n        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\n      }\n    } else {\n      this._thinInstanceInitializeUserStorage();\n\n      this._userThinInstanceBuffersStorage.data[kind] = buffer;\n      this._userThinInstanceBuffersStorage.strides[kind] = stride;\n      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\n\nMesh.prototype.thinInstanceBufferUpdated = function (kind) {\n  var _a;\n\n  if (kind === \"matrix\") {\n    if (this._thinInstanceDataStorage.matrixBuffer) {\n      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);\n    }\n  } else if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\n  }\n};\n\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind, data, offset) {\n  var _a;\n\n  if (kind === \"matrix\") {\n    if (this._thinInstanceDataStorage.matrixBuffer) {\n      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\n    }\n  } else if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);\n  }\n};\n\nMesh.prototype.thinInstanceGetWorldMatrices = function () {\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return [];\n  }\n\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n\n  if (!this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices = new Array();\n\n    for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\n    }\n  }\n\n  return this._thinInstanceDataStorage.worldMatrices;\n};\n\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo) {\n  if (forceRefreshParentInfo === void 0) {\n    forceRefreshParentInfo = false;\n  }\n\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return;\n  }\n\n  var vectors = this._thinInstanceDataStorage.boundingVectors;\n\n  if (forceRefreshParentInfo) {\n    vectors.length = 0;\n    this.refreshBoundingInfo(true);\n  }\n\n  var boundingInfo = this.getBoundingInfo();\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n\n  if (vectors.length === 0) {\n    for (var v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\n      vectors.push(boundingInfo.boundingBox.vectors[v].clone());\n    }\n  }\n\n  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\n\n  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\n\n  for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\n\n    for (var v = 0; v < vectors.length; ++v) {\n      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\n    }\n  }\n\n  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\n\n  this._updateBoundingInfo();\n};\n\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind, numInstances) {\n  var _a, _b;\n\n  if (numInstances === void 0) {\n    numInstances = 1;\n  }\n\n  var kindIsMatrix = kind === \"matrix\";\n\n  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\n    return;\n  }\n\n  var stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\n  var currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\n  var data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\n  var bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\n  var newSize = currentSize;\n\n  while (newSize < bufferSize) {\n    newSize *= 2;\n  }\n\n  if (!data || currentSize != newSize) {\n    if (!data) {\n      data = new Float32Array(newSize);\n    } else {\n      var newData = new Float32Array(newSize);\n      newData.set(data, 0);\n      data = newData;\n    }\n\n    if (kindIsMatrix) {\n      (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n      var matrixBuffer = new Buffer(this.getEngine(), data, true, stride, false, true);\n      this._thinInstanceDataStorage.matrixBuffer = matrixBuffer;\n      this._thinInstanceDataStorage.matrixData = data;\n      this._thinInstanceDataStorage.matrixBufferSize = newSize;\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world0\", 0, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world1\", 4, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world2\", 8, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world3\", 12, 4));\n    } else {\n      (_b = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();\n      this._userThinInstanceBuffersStorage.data[kind] = data;\n      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\n\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\n  if (!this._userThinInstanceBuffersStorage) {\n    this._userThinInstanceBuffersStorage = {\n      data: {},\n      sizes: {},\n      vertexBuffers: {},\n      strides: {}\n    };\n  }\n};\n\nMesh.prototype._disposeThinInstanceSpecificData = function () {\n  var _a;\n\n  if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {\n    this._thinInstanceDataStorage.matrixBuffer.dispose();\n\n    this._thinInstanceDataStorage.matrixBuffer = null;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}