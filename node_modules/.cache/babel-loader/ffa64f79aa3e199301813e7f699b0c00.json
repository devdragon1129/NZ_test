{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Material } from \"../Materials/material\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { PostProcess } from \"../PostProcesses/postProcess\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\nimport { EffectLayer } from \"./effectLayer\";\nimport { AbstractScene } from \"../abstractScene\";\nimport { Logger } from \"../Misc/logger\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { Color4, Color3 } from '../Maths/math.color';\nimport \"../Shaders/glowMapMerge.fragment\";\nimport \"../Shaders/glowMapMerge.vertex\";\nimport \"../Shaders/glowBlurPostProcess.fragment\";\n\nAbstractScene.prototype.getHighlightLayerByName = function (name) {\n  for (var index = 0; index < this.effectLayers.length; index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n\n  return null;\n};\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n */\n\n\nvar GlowBlurPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(GlowBlurPostProcess, _super);\n\n  function GlowBlurPostProcess(name, direction, kernel, options, camera, samplingMode, engine, reusable) {\n    if (samplingMode === void 0) {\n      samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    }\n\n    var _this = _super.call(this, name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable) || this;\n\n    _this.direction = direction;\n    _this.kernel = kernel;\n\n    _this.onApplyObservable.add(function (effect) {\n      effect.setFloat2(\"screenSize\", _this.width, _this.height);\n      effect.setVector2(\"direction\", _this.direction);\n      effect.setFloat(\"blurWidth\", _this.kernel);\n    });\n\n    return _this;\n  }\n\n  return GlowBlurPostProcess;\n}(PostProcess);\n/**\r\n * The highlight layer Helps adding a glow effect around a mesh.\r\n *\r\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\r\n * glowy meshes to your scene.\r\n *\r\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\r\n */\n\n\nvar HighlightLayer =\n/** @class */\nfunction (_super) {\n  __extends(HighlightLayer, _super);\n  /**\r\n   * Instantiates a new highlight Layer and references it to the scene..\r\n   * @param name The name of the layer\r\n   * @param scene The scene to use the layer in\r\n   * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n   */\n\n\n  function HighlightLayer(name, scene, options) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this.name = name;\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\n\n    _this.innerGlow = true;\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\n\n    _this.outerGlow = true;\n    /**\r\n     * An event triggered when the highlight layer is being blurred.\r\n     */\n\n    _this.onBeforeBlurObservable = new Observable();\n    /**\r\n     * An event triggered when the highlight layer has been blurred.\r\n     */\n\n    _this.onAfterBlurObservable = new Observable();\n    _this._instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\n    _this._meshes = {};\n    _this._excludedMeshes = {};\n    _this.neutralColor = HighlightLayer.NeutralColor; // Warn on stencil\n\n    if (!_this._engine.isStencilEnable) {\n      Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\n    } // Adapt options\n\n\n    _this._options = __assign({\n      mainTextureRatio: 0.5,\n      blurTextureSizeRatio: 0.5,\n      blurHorizontalSize: 1.0,\n      blurVerticalSize: 1.0,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1\n    }, options); // Initialize the layer\n\n    _this._init({\n      alphaBlendingMode: _this._options.alphaBlendingMode,\n      camera: _this._options.camera,\n      mainTextureFixedSize: _this._options.mainTextureFixedSize,\n      mainTextureRatio: _this._options.mainTextureRatio,\n      renderingGroupId: _this._options.renderingGroupId\n    }); // Do not render as long as no meshes have been added\n\n\n    _this._shouldRender = false;\n    return _this;\n  }\n\n  Object.defineProperty(HighlightLayer.prototype, \"blurHorizontalSize\", {\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\n    get: function get() {\n      return this._horizontalBlurPostprocess.kernel;\n    },\n\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\n    set: function set(value) {\n      this._horizontalBlurPostprocess.kernel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HighlightLayer.prototype, \"blurVerticalSize\", {\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\n    get: function get() {\n      return this._verticalBlurPostprocess.kernel;\n    },\n\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\n    set: function set(value) {\n      this._verticalBlurPostprocess.kernel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the effect name of the layer.\r\n   * @return The effect name\r\n   */\n\n  HighlightLayer.prototype.getEffectName = function () {\n    return HighlightLayer.EffectName;\n  };\n  /**\r\n   * Create the merge effect. This is the shader use to blit the information back\r\n   * to the main canvas at the end of the scene rendering.\r\n   */\n\n\n  HighlightLayer.prototype._createMergeEffect = function () {\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], this._options.isStroke ? \"#define STROKE \\n\" : undefined);\n  };\n  /**\r\n   * Creates the render target textures and post processes used in the highlight layer.\r\n   */\n\n\n  HighlightLayer.prototype._createTextureAndPostProcesses = function () {\n    var _this = this;\n\n    var blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\n    var blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n\n    this._blurTexture = new RenderTargetTexture(\"HighlightLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.anisotropicFilteringLevel = 16;\n\n    this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\n\n    this._blurTexture.renderParticles = false;\n    this._blurTexture.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture];\n\n    if (this._options.alphaBlendingMode === 2) {\n      this._downSamplePostprocess = new PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n\n      this._downSamplePostprocess.onApplyObservable.add(function (effect) {\n        effect.setTexture(\"textureSampler\", _this._mainTexture);\n      });\n\n      this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n\n      this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n\n      this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n\n      this._verticalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n\n      this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    } else {\n      this._horizontalBlurPostprocess = new BlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._horizontalBlurPostprocess.width = blurTextureWidth;\n      this._horizontalBlurPostprocess.height = blurTextureHeight;\n\n      this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setTexture(\"textureSampler\", _this._mainTexture);\n      });\n\n      this._verticalBlurPostprocess = new BlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    }\n\n    this._mainTexture.onAfterUnbindObservable.add(function () {\n      _this.onBeforeBlurObservable.notifyObservers(_this);\n\n      var internalTexture = _this._blurTexture.getInternalTexture();\n\n      if (internalTexture) {\n        _this._scene.postProcessManager.directRender(_this._postProcesses, internalTexture, true);\n\n        _this._engine.unBindFramebuffer(internalTexture, true);\n      }\n\n      _this.onAfterBlurObservable.notifyObservers(_this);\n    }); // Prevent autoClear.\n\n\n    this._postProcesses.map(function (pp) {\n      pp.autoClear = false;\n    });\n  };\n  /**\r\n   * Returns wether or nood the layer needs stencil enabled during the mesh rendering.\r\n   */\n\n\n  HighlightLayer.prototype.needStencil = function () {\n    return true;\n  };\n  /**\r\n   * Checks for the readiness of the element composing the layer.\r\n   * @param subMesh the mesh to check for\r\n   * @param useInstances specify wether or not to use instances to render the mesh\r\n   * @param emissiveTexture the associated emissive texture used to generate the glow\r\n   * @return true if ready otherwise, false\r\n   */\n\n\n  HighlightLayer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n    var mesh = subMesh.getRenderingMesh();\n\n    if (!material || !mesh || !this._meshes) {\n      return false;\n    }\n\n    var emissiveTexture = null;\n    var highlightLayerMesh = this._meshes[mesh.uniqueId];\n\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      emissiveTexture = material.emissiveTexture;\n    }\n\n    return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);\n  };\n  /**\r\n   * Implementation specific of rendering the generating effect on the main canvas.\r\n   * @param effect The effect used to render through\r\n   */\n\n\n  HighlightLayer.prototype._internalRender = function (effect) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture); // Cache\n\n    var engine = this._engine;\n    engine.cacheStencilState(); // Stencil operations\n\n    engine.setStencilOperationPass(7681);\n    engine.setStencilOperationFail(7680);\n    engine.setStencilOperationDepthFail(7680); // Draw order\n\n    engine.setStencilMask(0x00);\n    engine.setStencilBuffer(true);\n    engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference); // 2 passes inner outer\n\n    if (this.outerGlow) {\n      effect.setFloat(\"offset\", 0);\n      engine.setStencilFunction(517);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n\n    if (this.innerGlow) {\n      effect.setFloat(\"offset\", 1);\n      engine.setStencilFunction(514);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    } // Restore Cache\n\n\n    engine.restoreStencilState();\n  };\n  /**\r\n   * Returns true if the layer contains information to display, otherwise false.\r\n   */\n\n\n  HighlightLayer.prototype.shouldRender = function () {\n    if (_super.prototype.shouldRender.call(this)) {\n      return this._meshes ? true : false;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns true if the mesh should render, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @returns true if it should render otherwise false\r\n   */\n\n\n  HighlightLayer.prototype._shouldRenderMesh = function (mesh) {\n    // Excluded Mesh\n    if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\n      return false;\n    }\n\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Returns true if the mesh can be rendered, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @param material The material used on the mesh\r\n   * @returns true if it can be rendered otherwise false\r\n   */\n\n\n  HighlightLayer.prototype._canRenderMesh = function (mesh, material) {\n    // all meshes can be rendered in the highlight layer, even transparent ones\n    return true;\n  };\n  /**\r\n   * Adds specific effects defines.\r\n   * @param defines The defines to add specifics to.\r\n   */\n\n\n  HighlightLayer.prototype._addCustomEffectDefines = function (defines) {\n    defines.push(\"#define HIGHLIGHT\");\n  };\n  /**\r\n   * Sets the required values for both the emissive texture and and the main color.\r\n   */\n\n\n  HighlightLayer.prototype._setEmissiveTextureAndColor = function (mesh, subMesh, material) {\n    var highlightLayerMesh = this._meshes[mesh.uniqueId];\n\n    if (highlightLayerMesh) {\n      this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\n    } else {\n      this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n    }\n\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      this._emissiveTextureAndColor.texture = material.emissiveTexture;\n\n      this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._emissiveTextureAndColor.texture = null;\n    }\n  };\n  /**\r\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n   * @param mesh The mesh to exclude from the highlight layer\r\n   */\n\n\n  HighlightLayer.prototype.addExcludedMesh = function (mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n\n    var meshExcluded = this._excludedMeshes[mesh.uniqueId];\n\n    if (!meshExcluded) {\n      this._excludedMeshes[mesh.uniqueId] = {\n        mesh: mesh,\n        beforeBind: mesh.onBeforeBindObservable.add(function (mesh) {\n          mesh.getEngine().setStencilBuffer(false);\n        }),\n        afterRender: mesh.onAfterRenderObservable.add(function (mesh) {\n          mesh.getEngine().setStencilBuffer(true);\n        })\n      };\n    }\n  };\n  /**\r\n    * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n    * @param mesh The mesh to highlight\r\n    */\n\n\n  HighlightLayer.prototype.removeExcludedMesh = function (mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n\n    var meshExcluded = this._excludedMeshes[mesh.uniqueId];\n\n    if (meshExcluded) {\n      if (meshExcluded.beforeBind) {\n        mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\n      }\n\n      if (meshExcluded.afterRender) {\n        mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\n      }\n    }\n\n    this._excludedMeshes[mesh.uniqueId] = null;\n  };\n  /**\r\n   * Determine if a given mesh will be highlighted by the current HighlightLayer\r\n   * @param mesh mesh to test\r\n   * @returns true if the mesh will be highlighted by the current HighlightLayer\r\n   */\n\n\n  HighlightLayer.prototype.hasMesh = function (mesh) {\n    if (!this._meshes) {\n      return false;\n    }\n\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    }\n\n    return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\n  };\n  /**\r\n   * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n   * @param mesh The mesh to highlight\r\n   * @param color The color of the highlight\r\n   * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n   */\n\n\n  HighlightLayer.prototype.addMesh = function (mesh, color, glowEmissiveOnly) {\n    var _this = this;\n\n    if (glowEmissiveOnly === void 0) {\n      glowEmissiveOnly = false;\n    }\n\n    if (!this._meshes) {\n      return;\n    }\n\n    var meshHighlight = this._meshes[mesh.uniqueId];\n\n    if (meshHighlight) {\n      meshHighlight.color = color;\n    } else {\n      this._meshes[mesh.uniqueId] = {\n        mesh: mesh,\n        color: color,\n        // Lambda required for capture due to Observable this context\n        observerHighlight: mesh.onBeforeBindObservable.add(function (mesh) {\n          if (_this.isEnabled) {\n            if (_this._excludedMeshes && _this._excludedMeshes[mesh.uniqueId]) {\n              _this._defaultStencilReference(mesh);\n            } else {\n              mesh.getScene().getEngine().setStencilFunctionReference(_this._instanceGlowingMeshStencilReference);\n            }\n          }\n        }),\n        observerDefault: mesh.onAfterRenderObservable.add(function (mesh) {\n          if (_this.isEnabled) {\n            _this._defaultStencilReference(mesh);\n          }\n        }),\n        glowEmissiveOnly: glowEmissiveOnly\n      };\n      mesh.onDisposeObservable.add(function () {\n        _this._disposeMesh(mesh);\n      });\n    }\n\n    this._shouldRender = true;\n  };\n  /**\r\n   * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n   * @param mesh The mesh to highlight\r\n   */\n\n\n  HighlightLayer.prototype.removeMesh = function (mesh) {\n    if (!this._meshes) {\n      return;\n    }\n\n    var meshHighlight = this._meshes[mesh.uniqueId];\n\n    if (meshHighlight) {\n      if (meshHighlight.observerHighlight) {\n        mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n      }\n\n      if (meshHighlight.observerDefault) {\n        mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n      }\n\n      delete this._meshes[mesh.uniqueId];\n    }\n\n    this._shouldRender = false;\n\n    for (var meshHighlightToCheck in this._meshes) {\n      if (this._meshes[meshHighlightToCheck]) {\n        this._shouldRender = true;\n        break;\n      }\n    }\n  };\n  /**\r\n   * Remove all the meshes currently referenced in the highlight layer\r\n   */\n\n\n  HighlightLayer.prototype.removeAllMeshes = function () {\n    if (!this._meshes) {\n      return;\n    }\n\n    for (var uniqueId in this._meshes) {\n      if (this._meshes.hasOwnProperty(uniqueId)) {\n        var mesh = this._meshes[uniqueId];\n\n        if (mesh) {\n          this.removeMesh(mesh.mesh);\n        }\n      }\n    }\n  };\n  /**\r\n   * Force the stencil to the normal expected value for none glowing parts\r\n   */\n\n\n  HighlightLayer.prototype._defaultStencilReference = function (mesh) {\n    mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\n  };\n  /**\r\n   * Free any resources and references associated to a mesh.\r\n   * Internal use\r\n   * @param mesh The mesh to free.\r\n   * @hidden\r\n   */\n\n\n  HighlightLayer.prototype._disposeMesh = function (mesh) {\n    this.removeMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  };\n  /**\r\n   * Dispose the highlight layer and free resources.\r\n   */\n\n\n  HighlightLayer.prototype.dispose = function () {\n    if (this._meshes) {\n      // Clean mesh references\n      for (var id in this._meshes) {\n        var meshHighlight = this._meshes[id];\n\n        if (meshHighlight && meshHighlight.mesh) {\n          if (meshHighlight.observerHighlight) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n          }\n\n          if (meshHighlight.observerDefault) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n          }\n        }\n      }\n\n      this._meshes = null;\n    }\n\n    if (this._excludedMeshes) {\n      for (var id in this._excludedMeshes) {\n        var meshHighlight = this._excludedMeshes[id];\n\n        if (meshHighlight) {\n          if (meshHighlight.beforeBind) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\n          }\n\n          if (meshHighlight.afterRender) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\n          }\n        }\n      }\n\n      this._excludedMeshes = null;\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n    * Gets the class name of the effect layer\r\n    * @returns the string with the class name of the effect layer\r\n    */\n\n\n  HighlightLayer.prototype.getClassName = function () {\n    return \"HighlightLayer\";\n  };\n  /**\r\n   * Serializes this Highlight layer\r\n   * @returns a serialized Highlight layer object\r\n   */\n\n\n  HighlightLayer.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.HighlightLayer\"; // Highlighted meshes\n\n    serializationObject.meshes = [];\n\n    if (this._meshes) {\n      for (var m in this._meshes) {\n        var mesh = this._meshes[m];\n\n        if (mesh) {\n          serializationObject.meshes.push({\n            glowEmissiveOnly: mesh.glowEmissiveOnly,\n            color: mesh.color.asArray(),\n            meshId: mesh.mesh.id\n          });\n        }\n      }\n    } // Excluded meshes\n\n\n    serializationObject.excludedMeshes = [];\n\n    if (this._excludedMeshes) {\n      for (var e in this._excludedMeshes) {\n        var excludedMesh = this._excludedMeshes[e];\n\n        if (excludedMesh) {\n          serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\n        }\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Creates a Highlight layer from parsed Highlight layer data\r\n   * @param parsedHightlightLayer defines the Highlight layer data\r\n   * @param scene defines the current scene\r\n   * @param rootUrl defines the root URL containing the Highlight layer information\r\n   * @returns a parsed Highlight layer\r\n   */\n\n\n  HighlightLayer.Parse = function (parsedHightlightLayer, scene, rootUrl) {\n    var hl = SerializationHelper.Parse(function () {\n      return new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options);\n    }, parsedHightlightLayer, scene, rootUrl);\n    var index; // Excluded meshes\n\n    for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\n      var mesh = scene.getMeshByID(parsedHightlightLayer.excludedMeshes[index]);\n\n      if (mesh) {\n        hl.addExcludedMesh(mesh);\n      }\n    } // Included meshes\n\n\n    for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\n      var highlightedMesh = parsedHightlightLayer.meshes[index];\n      var mesh = scene.getMeshByID(highlightedMesh.meshId);\n\n      if (mesh) {\n        hl.addMesh(mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\n      }\n    }\n\n    return hl;\n  };\n  /**\r\n   * Effect Name of the highlight layer.\r\n   */\n\n\n  HighlightLayer.EffectName = \"HighlightLayer\";\n  /**\r\n   * The neutral color used during the preparation of the glow effect.\r\n   * This is black by default as the blend operation is a blend operation.\r\n   */\n\n  HighlightLayer.NeutralColor = new Color4(0, 0, 0, 0);\n  /**\r\n   * Stencil value used for glowing meshes.\r\n   */\n\n  HighlightLayer.GlowingMeshStencilReference = 0x02;\n  /**\r\n   * Stencil value used for the other meshes in the scene.\r\n   */\n\n  HighlightLayer.NormalMeshStencilReference = 0x01;\n\n  __decorate([serialize()], HighlightLayer.prototype, \"innerGlow\", void 0);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"outerGlow\", void 0);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"blurHorizontalSize\", null);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"blurVerticalSize\", null);\n\n  __decorate([serialize(\"options\")], HighlightLayer.prototype, \"_options\", void 0);\n\n  return HighlightLayer;\n}(EffectLayer);\n\nexport { HighlightLayer };\n_TypeStore.RegisteredTypes[\"BABYLON.HighlightLayer\"] = HighlightLayer;","map":null,"metadata":{},"sourceType":"module"}