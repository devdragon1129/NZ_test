{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _slicedToArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\n\nvar u64 = __importStar(require(\"./_u64.js\"));\n\nvar utils_js_1 = require(\"./utils.js\"); // Various per round constants calculations\n\n\nvar SHA3_PI = [],\n    SHA3_ROTL = [],\n    _SHA3_IOTA = [];\n\nvar _0n = BigInt(0);\n\nvar _1n = BigInt(1);\n\nvar _2n = BigInt(2);\n\nvar _7n = BigInt(7);\n\nvar _256n = BigInt(256);\n\nvar _0x71n = BigInt(0x71);\n\nfor (var round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  var _ref = [y, (2 * x + 3 * y) % 5];\n  x = _ref[0];\n  y = _ref[1];\n  SHA3_PI.push(2 * (5 * y + x)); // Rotational\n\n  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64); // Iota\n\n  var t = _0n;\n\n  for (var j = 0; j < 7; j++) {\n    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n    if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;\n  }\n\n  _SHA3_IOTA.push(t);\n}\n\nvar _u64$split = u64.split(_SHA3_IOTA, true),\n    _u64$split2 = _slicedToArray(_u64$split, 2),\n    SHA3_IOTA_H = _u64$split2[0],\n    SHA3_IOTA_L = _u64$split2[1]; // Left rotation (without 0, 32, 64)\n\n\nvar rotlH = function rotlH(h, l, s) {\n  return s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\n};\n\nvar rotlL = function rotlL(h, l, s) {\n  return s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);\n}; // Same as keccakf1600, but allows to skip some rounds\n\n\nfunction keccakP(s) {\n  var rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;\n  var B = new Uint32Array(5 * 2); // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n\n  for (var _round = 24 - rounds; _round < 24; _round++) {\n    // Theta θ\n    for (var _x = 0; _x < 10; _x++) {\n      B[_x] = s[_x] ^ s[_x + 10] ^ s[_x + 20] ^ s[_x + 30] ^ s[_x + 40];\n    }\n\n    for (var _x2 = 0; _x2 < 10; _x2 += 2) {\n      var idx1 = (_x2 + 8) % 10;\n      var idx0 = (_x2 + 2) % 10;\n      var B0 = B[idx0];\n      var B1 = B[idx0 + 1];\n      var Th = rotlH(B0, B1, 1) ^ B[idx1];\n      var Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n\n      for (var _y = 0; _y < 50; _y += 10) {\n        s[_x2 + _y] ^= Th;\n        s[_x2 + _y + 1] ^= Tl;\n      }\n    } // Rho (ρ) and Pi (π)\n\n\n    var curH = s[2];\n    var curL = s[3];\n\n    for (var _t = 0; _t < 24; _t++) {\n      var shift = SHA3_ROTL[_t];\n\n      var _Th = rotlH(curH, curL, shift);\n\n      var _Tl = rotlL(curH, curL, shift);\n\n      var PI = SHA3_PI[_t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = _Th;\n      s[PI + 1] = _Tl;\n    } // Chi (χ)\n\n\n    for (var _y2 = 0; _y2 < 50; _y2 += 10) {\n      for (var _x3 = 0; _x3 < 10; _x3++) {\n        B[_x3] = s[_y2 + _x3];\n      }\n\n      for (var _x4 = 0; _x4 < 10; _x4++) {\n        s[_y2 + _x4] ^= ~B[(_x4 + 2) % 10] & B[(_x4 + 4) % 10];\n      }\n    } // Iota (ι)\n\n\n    s[0] ^= SHA3_IOTA_H[_round];\n    s[1] ^= SHA3_IOTA_L[_round];\n  }\n\n  B.fill(0);\n}\n\nexports.keccakP = keccakP;\n\nvar Keccak = /*#__PURE__*/function (_utils_js_1$Hash) {\n  _inherits(Keccak, _utils_js_1$Hash);\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  function Keccak(blockLen, suffix, outputLen) {\n    var _this;\n\n    var enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;\n\n    _classCallCheck(this, Keccak);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Keccak).call(this));\n    _this.blockLen = blockLen;\n    _this.suffix = suffix;\n    _this.outputLen = outputLen;\n    _this.enableXOF = enableXOF;\n    _this.rounds = rounds;\n    _this.pos = 0;\n    _this.posOut = 0;\n    _this.finished = false;\n    _this.destroyed = false; // Can be passed from user as dkLen\n\n    (0, utils_js_1.assertNumber)(outputLen); // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n\n    if (0 >= _this.blockLen || _this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');\n    _this.state = new Uint8Array(200);\n    _this.state32 = (0, utils_js_1.u32)(_this.state);\n    return _this;\n  }\n\n  _createClass(Keccak, [{\n    key: \"keccak\",\n    value: function keccak() {\n      keccakP(this.state32, this.rounds);\n      this.posOut = 0;\n      this.pos = 0;\n    }\n  }, {\n    key: \"update\",\n    value: function update(data) {\n      if (this.destroyed) throw new Error('instance is destroyed');\n      if (this.finished) throw new Error('digest() was already called');\n      var blockLen = this.blockLen,\n          state = this.state;\n      data = (0, utils_js_1.toBytes)(data);\n      var len = data.length;\n\n      for (var pos = 0; pos < len;) {\n        var take = Math.min(blockLen - this.pos, len - pos);\n\n        for (var i = 0; i < take; i++) {\n          state[this.pos++] ^= data[pos++];\n        }\n\n        if (this.pos === blockLen) this.keccak();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      if (this.finished) return;\n      this.finished = true;\n      var state = this.state,\n          suffix = this.suffix,\n          pos = this.pos,\n          blockLen = this.blockLen; // Do the padding\n\n      state[pos] ^= suffix;\n      if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n      state[blockLen - 1] ^= 0x80;\n      this.keccak();\n    }\n  }, {\n    key: \"writeInto\",\n    value: function writeInto(out) {\n      if (this.destroyed) throw new Error('instance is destroyed');\n      if (!(out instanceof Uint8Array)) throw new Error('Keccak: invalid output buffer');\n      this.finish();\n\n      for (var pos = 0, len = out.length; pos < len;) {\n        if (this.posOut >= this.blockLen) this.keccak();\n        var take = Math.min(this.blockLen - this.posOut, len - pos);\n        out.set(this.state.subarray(this.posOut, this.posOut + take), pos);\n        this.posOut += take;\n        pos += take;\n      }\n\n      return out;\n    }\n  }, {\n    key: \"xofInto\",\n    value: function xofInto(out) {\n      // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n      if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n      return this.writeInto(out);\n    }\n  }, {\n    key: \"xof\",\n    value: function xof(bytes) {\n      (0, utils_js_1.assertNumber)(bytes);\n      return this.xofInto(new Uint8Array(bytes));\n    }\n  }, {\n    key: \"digestInto\",\n    value: function digestInto(out) {\n      if (out.length < this.outputLen) throw new Error('Keccak: invalid output buffer');\n      if (this.finished) throw new Error('digest() was already called');\n      this.finish();\n      this.writeInto(out);\n      this.destroy();\n      return out;\n    }\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      return this.digestInto(new Uint8Array(this.outputLen));\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.destroyed = true;\n      this.state.fill(0);\n    }\n  }, {\n    key: \"_cloneInto\",\n    value: function _cloneInto(to) {\n      var blockLen = this.blockLen,\n          suffix = this.suffix,\n          outputLen = this.outputLen,\n          rounds = this.rounds,\n          enableXOF = this.enableXOF;\n      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n      to.state32.set(this.state32);\n      to.pos = this.pos;\n      to.posOut = this.posOut;\n      to.finished = this.finished;\n      to.rounds = rounds; // Suffix can change in cSHAKE\n\n      to.suffix = suffix;\n      to.outputLen = outputLen;\n      to.enableXOF = enableXOF;\n      to.destroyed = this.destroyed;\n      return to;\n    }\n  }]);\n\n  return Keccak;\n}(utils_js_1.Hash);\n\nexports.Keccak = Keccak;\n\nvar gen = function gen(suffix, blockLen, outputLen) {\n  return (0, utils_js_1.wrapConstructor)(function () {\n    return new Keccak(blockLen, suffix, outputLen);\n  });\n};\n\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\n\nexports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\n\nexports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\n\nvar genShake = function genShake(suffix, blockLen, outputLen) {\n  return (0, utils_js_1.wrapConstructorWithOpts)(function () {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Keccak(blockLen, suffix, opts.dkLen !== undefined ? opts.dkLen : outputLen, true);\n  });\n};\n\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8);","map":null,"metadata":{},"sourceType":"script"}