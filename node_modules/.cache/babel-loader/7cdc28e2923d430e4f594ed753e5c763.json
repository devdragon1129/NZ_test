{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\n/**\r\n * COnfiguration object for WebXR output canvas\r\n */\n\nvar WebXRManagedOutputCanvasOptions =\n/** @class */\nfunction () {\n  function WebXRManagedOutputCanvasOptions() {}\n  /**\r\n   * Get the default values of the configuration object\r\n   * @param engine defines the engine to use (can be null)\r\n   * @returns default values of this configuration object\r\n   */\n\n\n  WebXRManagedOutputCanvasOptions.GetDefaults = function (engine) {\n    var defaults = new WebXRManagedOutputCanvasOptions();\n    defaults.canvasOptions = {\n      antialias: true,\n      depth: true,\n      stencil: engine ? engine.isStencilEnable : true,\n      alpha: true,\n      multiview: false,\n      framebufferScaleFactor: 1\n    };\n    defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\n    return defaults;\n  };\n\n  return WebXRManagedOutputCanvasOptions;\n}();\n\nexport { WebXRManagedOutputCanvasOptions };\n/**\r\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\r\n */\n\nvar WebXRManagedOutputCanvas =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the canvas to be added/removed upon entering/exiting xr\r\n   * @param _xrSessionManager The XR Session manager\r\n   * @param _options optional configuration for this canvas output. defaults will be used if not provided\r\n   */\n  function WebXRManagedOutputCanvas(_xrSessionManager, _options) {\n    var _this = this;\n\n    if (_options === void 0) {\n      _options = WebXRManagedOutputCanvasOptions.GetDefaults();\n    }\n\n    this._options = _options;\n    this._canvas = null;\n    /**\r\n     * xr layer for the canvas\r\n     */\n\n    this.xrLayer = null;\n    /**\r\n     * Obseervers registered here will be triggered when the xr layer was initialized\r\n     */\n\n    this.onXRLayerInitObservable = new Observable();\n    this._engine = _xrSessionManager.scene.getEngine();\n\n    if (!_options.canvasElement) {\n      var canvas = document.createElement(\"canvas\");\n      canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\n\n      this._setManagedOutputCanvas(canvas);\n    } else {\n      this._setManagedOutputCanvas(_options.canvasElement);\n    }\n\n    _xrSessionManager.onXRSessionInit.add(function () {\n      _this._addCanvas();\n    });\n\n    _xrSessionManager.onXRSessionEnded.add(function () {\n      _this._removeCanvas();\n    });\n  }\n  /**\r\n   * Disposes of the object\r\n   */\n\n\n  WebXRManagedOutputCanvas.prototype.dispose = function () {\n    this._removeCanvas();\n\n    this._setManagedOutputCanvas(null);\n  };\n  /**\r\n   * Initializes the xr layer for the session\r\n   * @param xrSession xr session\r\n   * @returns a promise that will resolve once the XR Layer has been created\r\n   */\n\n\n  WebXRManagedOutputCanvas.prototype.initializeXRLayerAsync = function (xrSession) {\n    var _this = this;\n\n    var createLayer = function createLayer() {\n      var layer = new XRWebGLLayer(xrSession, _this.canvasContext, _this._options.canvasOptions);\n\n      _this.onXRLayerInitObservable.notifyObservers(layer);\n\n      return layer;\n    }; // support canvases without makeXRCompatible\n\n\n    if (!this.canvasContext.makeXRCompatible) {\n      this.xrLayer = createLayer();\n      return Promise.resolve(this.xrLayer);\n    }\n\n    return this.canvasContext.makeXRCompatible().then(function () {\n      _this.xrLayer = createLayer();\n      return _this.xrLayer;\n    });\n  };\n\n  WebXRManagedOutputCanvas.prototype._addCanvas = function () {\n    var _this = this;\n\n    if (this._canvas && this._canvas !== this._engine.getRenderingCanvas()) {\n      document.body.appendChild(this._canvas);\n    }\n\n    if (this.xrLayer) {\n      this._setCanvasSize(true);\n    } else {\n      this.onXRLayerInitObservable.addOnce(function (layer) {\n        _this._setCanvasSize(true, layer);\n      });\n    }\n  };\n\n  WebXRManagedOutputCanvas.prototype._removeCanvas = function () {\n    if (this._canvas && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\n      document.body.removeChild(this._canvas);\n    }\n\n    this._setCanvasSize(false);\n  };\n\n  WebXRManagedOutputCanvas.prototype._setCanvasSize = function (init, xrLayer) {\n    if (init === void 0) {\n      init = true;\n    }\n\n    if (xrLayer === void 0) {\n      xrLayer = this.xrLayer;\n    }\n\n    if (!this._canvas) {\n      return;\n    }\n\n    if (init) {\n      if (xrLayer) {\n        if (this._canvas !== this._engine.getRenderingCanvas()) {\n          this._canvas.style.width = xrLayer.framebufferWidth + \"px\";\n          this._canvas.style.height = xrLayer.framebufferHeight + \"px\";\n        } else {\n          this._engine.setSize(xrLayer.framebufferWidth, xrLayer.framebufferHeight);\n        }\n      }\n    } else {\n      if (this._originalCanvasSize) {\n        if (this._canvas !== this._engine.getRenderingCanvas()) {\n          this._canvas.style.width = this._originalCanvasSize.width + \"px\";\n          this._canvas.style.height = this._originalCanvasSize.height + \"px\";\n        } else {\n          this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\n        }\n      }\n    }\n  };\n\n  WebXRManagedOutputCanvas.prototype._setManagedOutputCanvas = function (canvas) {\n    this._removeCanvas();\n\n    if (!canvas) {\n      this._canvas = null;\n      this.canvasContext = null;\n    } else {\n      this._originalCanvasSize = {\n        width: canvas.offsetWidth,\n        height: canvas.offsetHeight\n      };\n      this._canvas = canvas;\n      this.canvasContext = this._canvas.getContext(\"webgl2\");\n\n      if (!this.canvasContext) {\n        this.canvasContext = this._canvas.getContext(\"webgl\");\n      }\n    }\n  };\n\n  return WebXRManagedOutputCanvas;\n}();\n\nexport { WebXRManagedOutputCanvas };","map":null,"metadata":{},"sourceType":"module"}