{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix } from \"../Maths/math.vector\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { BoxBuilder } from \"../Meshes/Builders/boxBuilder\";\nimport { CylinderBuilder } from \"../Meshes/Builders/cylinderBuilder\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { Color3 } from '../Maths/math.color';\n/**\r\n * Single axis scale gizmo\r\n */\n\nvar AxisScaleGizmo =\n/** @class */\nfunction (_super) {\n  __extends(AxisScaleGizmo, _super);\n  /**\r\n   * Creates an AxisScaleGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param dragAxis The axis which the gizmo will be able to scale on\r\n   * @param color The color of the gizmo\r\n   * @param thickness display gizmo axis thickness\r\n   */\n\n\n  function AxisScaleGizmo(dragAxis, color, gizmoLayer, parent, thickness) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._pointerObserver = null;\n    /**\r\n     * Scale distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\n\n    _this.snapDistance = 0;\n    /**\r\n     * Event that fires each time the gizmo snaps to a new location.\r\n     * * snapDistance is the the change in distance\r\n     */\n\n    _this.onSnapObservable = new Observable();\n    /**\r\n     * If the scaling operation should be done on all axis (default: false)\r\n     */\n\n    _this.uniformScaling = false;\n    /**\r\n     * Custom sensitivity value for the drag strength\r\n     */\n\n    _this.sensitivity = 1;\n    _this._isEnabled = true;\n    _this._parent = null;\n    _this._dragging = false;\n    _this._tmpVector = new Vector3();\n    _this._tmpMatrix = new Matrix();\n    _this._tmpMatrix2 = new Matrix();\n    _this._parent = parent; // Create Material\n\n    _this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._coloredMaterial.diffuseColor = color;\n    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    _this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._hoverMaterial.diffuseColor = Color3.Yellow();\n    _this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._disableMaterial.diffuseColor = Color3.Gray();\n    _this._disableMaterial.alpha = 0.4; // Build mesh + Collider\n\n    _this._gizmoMesh = new Mesh(\"axis\", gizmoLayer.utilityLayerScene);\n\n    var _h = _this._createGizmoMesh(_this._gizmoMesh, thickness),\n        arrowMesh = _h.arrowMesh,\n        arrowTail = _h.arrowTail;\n\n    var collider = _this._createGizmoMesh(_this._gizmoMesh, thickness + 4, true);\n\n    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(dragAxis));\n\n    _this._rootMesh.addChild(_this._gizmoMesh);\n\n    _this._gizmoMesh.scaling.scaleInPlace(1 / 3); // Closure of inital prop values for resetting\n\n\n    var nodePosition = arrowMesh.position.clone();\n    var linePosition = arrowTail.position.clone();\n    var lineScale = arrowTail.scaling.clone();\n\n    var increaseGizmoMesh = function increaseGizmoMesh(dragDistance) {\n      var dragStrength = dragDistance * (3 / _this._rootMesh.scaling.length()) * 6;\n      arrowMesh.position.z += dragStrength / 3.5;\n      arrowTail.scaling.y += dragStrength;\n      arrowTail.position.z = arrowMesh.position.z / 2;\n    };\n\n    var resetGizmoMesh = function resetGizmoMesh() {\n      arrowMesh.position.set(nodePosition.x, nodePosition.y, nodePosition.z);\n      arrowTail.position.set(linePosition.x, linePosition.y, linePosition.z);\n      arrowTail.scaling.set(lineScale.x, lineScale.y, lineScale.z);\n      _this._dragging = false;\n    }; // Add drag behavior to handle events when the gizmo is dragged\n\n\n    _this.dragBehavior = new PointerDragBehavior({\n      dragAxis: dragAxis\n    });\n    _this.dragBehavior.moveAttached = false;\n\n    _this._rootMesh.addBehavior(_this.dragBehavior);\n\n    var currentSnapDragDistance = 0;\n    var tmpVector = new Vector3();\n    var tmpSnapEvent = {\n      snapDistance: 0\n    };\n\n    _this.dragBehavior.onDragObservable.add(function (event) {\n      if (_this.attachedNode) {\n        // Drag strength is modified by the scale of the gizmo (eg. for small objects like boombox the strength will be increased to match the behavior of larger objects)\n        var dragStrength = _this.sensitivity * event.dragDistance * (_this.scaleRatio * 3 / _this._rootMesh.scaling.length()); // Snapping logic\n\n\n        var snapped = false;\n        var dragSteps = 0;\n\n        if (_this.uniformScaling) {\n          _this.attachedNode.getWorldMatrix().decompose(tmpVector);\n\n          tmpVector.normalize();\n\n          if (tmpVector.y < 0) {\n            tmpVector.scaleInPlace(-1);\n          }\n        } else {\n          tmpVector.copyFrom(dragAxis);\n        }\n\n        if (_this.snapDistance == 0) {\n          tmpVector.scaleToRef(dragStrength, tmpVector);\n        } else {\n          currentSnapDragDistance += dragStrength;\n\n          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {\n            dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);\n\n            if (currentSnapDragDistance < 0) {\n              dragSteps *= -1;\n            }\n\n            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;\n            tmpVector.scaleToRef(_this.snapDistance * dragSteps, tmpVector);\n            snapped = true;\n          } else {\n            tmpVector.scaleInPlace(0);\n          }\n        }\n\n        Matrix.ScalingToRef(1 + tmpVector.x, 1 + tmpVector.y, 1 + tmpVector.z, _this._tmpMatrix2);\n\n        _this._tmpMatrix2.multiplyToRef(_this.attachedNode.getWorldMatrix(), _this._tmpMatrix);\n\n        _this._tmpMatrix.decompose(_this._tmpVector);\n\n        var maxScale = 100000;\n\n        if (Math.abs(_this._tmpVector.x) < maxScale && Math.abs(_this._tmpVector.y) < maxScale && Math.abs(_this._tmpVector.z) < maxScale) {\n          _this.attachedNode.getWorldMatrix().copyFrom(_this._tmpMatrix);\n        }\n\n        if (snapped) {\n          tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;\n\n          _this.onSnapObservable.notifyObservers(tmpSnapEvent);\n        }\n\n        _this._matrixChanged();\n      }\n    }); // On Drag Listener: to move gizmo mesh with user action\n\n\n    _this.dragBehavior.onDragStartObservable.add(function () {\n      _this._dragging = true;\n    });\n\n    _this.dragBehavior.onDragObservable.add(function (e) {\n      return increaseGizmoMesh(e.dragDistance);\n    });\n\n    _this.dragBehavior.onDragEndObservable.add(resetGizmoMesh); // Listeners for Universal Scalar\n\n\n    (_c = (_b = (_a = parent === null || parent === void 0 ? void 0 : parent.uniformScaleGizmo) === null || _a === void 0 ? void 0 : _a.dragBehavior) === null || _b === void 0 ? void 0 : _b.onDragObservable) === null || _c === void 0 ? void 0 : _c.add(function (e) {\n      return increaseGizmoMesh(e.delta.y);\n    });\n    (_f = (_e = (_d = parent === null || parent === void 0 ? void 0 : parent.uniformScaleGizmo) === null || _d === void 0 ? void 0 : _d.dragBehavior) === null || _e === void 0 ? void 0 : _e.onDragEndObservable) === null || _f === void 0 ? void 0 : _f.add(resetGizmoMesh);\n    var cache = {\n      gizmoMeshes: [arrowMesh, arrowTail],\n      colliderMeshes: [collider.arrowMesh, collider.arrowTail],\n      material: _this._coloredMaterial,\n      hoverMaterial: _this._hoverMaterial,\n      disableMaterial: _this._disableMaterial,\n      active: false\n    };\n    (_g = _this._parent) === null || _g === void 0 ? void 0 : _g.addToAxisCache(_this._gizmoMesh, cache);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a;\n\n      if (_this._customMeshSet) {\n        return;\n      }\n\n      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) != -1);\n\n      if (!_this._parent) {\n        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;\n        cache.gizmoMeshes.forEach(function (m) {\n          m.material = material;\n\n          if (m.color) {\n            m.color = material.diffuseColor;\n          }\n        });\n      }\n    });\n\n    var light = gizmoLayer._getSharedGizmoLight();\n\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes());\n    return _this;\n  }\n  /** Create Geometry for Gizmo */\n\n\n  AxisScaleGizmo.prototype._createGizmoMesh = function (parentMesh, thickness, isCollider) {\n    if (isCollider === void 0) {\n      isCollider = false;\n    }\n\n    var arrowMesh = BoxBuilder.CreateBox(\"yPosMesh\", {\n      size: 0.4 * (1 + (thickness - 1) / 4)\n    }, this.gizmoLayer.utilityLayerScene);\n    var arrowTail = CylinderBuilder.CreateCylinder(\"cylinder\", {\n      diameterTop: 0.005 * thickness,\n      height: 0.275,\n      diameterBottom: 0.005 * thickness,\n      tessellation: 96\n    }, this.gizmoLayer.utilityLayerScene); // Position arrow pointing in its drag axis\n\n    arrowMesh.scaling.scaleInPlace(0.1);\n    arrowMesh.material = this._coloredMaterial;\n    arrowMesh.rotation.x = Math.PI / 2;\n    arrowMesh.position.z += 0.3;\n    arrowTail.material = this._coloredMaterial;\n    arrowTail.position.z += 0.275 / 2;\n    arrowTail.rotation.x = Math.PI / 2;\n\n    if (isCollider) {\n      arrowMesh.visibility = 0;\n      arrowTail.visibility = 0;\n    }\n\n    parentMesh.addChild(arrowMesh);\n    parentMesh.addChild(arrowTail);\n    return {\n      arrowMesh: arrowMesh,\n      arrowTail: arrowTail\n    };\n  };\n\n  AxisScaleGizmo.prototype._attachedNodeChanged = function (value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  };\n\n  Object.defineProperty(AxisScaleGizmo.prototype, \"isEnabled\", {\n    get: function get() {\n      return this._isEnabled;\n    },\n\n    /**\r\n     * If the gizmo is enabled\r\n     */\n    set: function set(value) {\n      this._isEnabled = value;\n\n      if (!value) {\n        this.attachedMesh = null;\n        this.attachedNode = null;\n      } else {\n        if (this._parent) {\n          this.attachedMesh = this._parent.attachedMesh;\n          this.attachedNode = this._parent.attachedNode;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n  AxisScaleGizmo.prototype.dispose = function () {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function (matl) {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n   * @param mesh The mesh to replace the default mesh of the gizmo\r\n   * @param useGizmoMaterial If the gizmo's default material should be used (default: false)\r\n   */\n\n\n  AxisScaleGizmo.prototype.setCustomMesh = function (mesh, useGizmoMaterial) {\n    var _this = this;\n\n    if (useGizmoMaterial === void 0) {\n      useGizmoMaterial = false;\n    }\n\n    _super.prototype.setCustomMesh.call(this, mesh);\n\n    if (useGizmoMaterial) {\n      this._rootMesh.getChildMeshes().forEach(function (m) {\n        m.material = _this._coloredMaterial;\n\n        if (m.color) {\n          m.color = _this._coloredMaterial.diffuseColor;\n        }\n      });\n\n      this._customMeshSet = false;\n    }\n  };\n\n  return AxisScaleGizmo;\n}(Gizmo);\n\nexport { AxisScaleGizmo };","map":null,"metadata":{},"sourceType":"module"}