{"ast":null,"code":"import { Logger } from \"../../Misc/logger\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../../Meshes/mesh\";\nimport { Epsilon, Vector3 } from '../../Maths/math';\nimport { VertexBuffer } from \"../../Meshes/buffer\";\n/**\r\n * RecastJS navigation plugin\r\n */\n\nvar RecastJSPlugin =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the recastJS plugin\r\n   * @param recastInjection can be used to inject your own recast reference\r\n   */\n  function RecastJSPlugin(recastInjection) {\n    if (recastInjection === void 0) {\n      recastInjection = Recast;\n    }\n    /**\r\n     * Reference to the Recast library\r\n     */\n\n\n    this.bjsRECAST = {};\n    /**\r\n     * plugin name\r\n     */\n\n    this.name = \"RecastJSPlugin\";\n    this._maximumSubStepCount = 10;\n    this._timeStep = 1 / 60;\n\n    if (typeof recastInjection === \"function\") {\n      recastInjection(this.bjsRECAST);\n    } else {\n      this.bjsRECAST = recastInjection;\n    }\n\n    if (!this.isSupported()) {\n      Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n\n    this.setTimeStep();\n  }\n  /**\r\n   * Set the time step of the navigation tick update.\r\n   * Default is 1/60.\r\n   * A value of 0 will disable fixed time update\r\n   * @param newTimeStep the new timestep to apply to this world.\r\n   */\n\n\n  RecastJSPlugin.prototype.setTimeStep = function (newTimeStep) {\n    if (newTimeStep === void 0) {\n      newTimeStep = 1 / 60;\n    }\n\n    this._timeStep = newTimeStep;\n  };\n  /**\r\n   * Get the time step of the navigation tick update.\r\n   * @returns the current time step\r\n   */\n\n\n  RecastJSPlugin.prototype.getTimeStep = function () {\n    return this._timeStep;\n  };\n  /**\r\n   * If delta time in navigation tick update is greater than the time step\r\n   * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n   * they will be discarded.\r\n   * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n   * @param newStepCount the maximum number of iterations\r\n   */\n\n\n  RecastJSPlugin.prototype.setMaximumSubStepCount = function (newStepCount) {\n    if (newStepCount === void 0) {\n      newStepCount = 10;\n    }\n\n    this._maximumSubStepCount = newStepCount;\n  };\n  /**\r\n   * Get the maximum number of iterations per navigation tick update\r\n   * @returns the maximum number of iterations\r\n   */\n\n\n  RecastJSPlugin.prototype.getMaximumSubStepCount = function () {\n    return this._maximumSubStepCount;\n  };\n  /**\r\n   * Creates a navigation mesh\r\n   * @param meshes array of all the geometry used to compute the navigatio mesh\r\n   * @param parameters bunch of parameters used to filter geometry\r\n   */\n\n\n  RecastJSPlugin.prototype.createNavMesh = function (meshes, parameters) {\n    var rc = new this.bjsRECAST.rcConfig();\n    rc.cs = parameters.cs;\n    rc.ch = parameters.ch;\n    rc.borderSize = 0;\n    rc.tileSize = 0;\n    rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\n    rc.walkableHeight = parameters.walkableHeight;\n    rc.walkableClimb = parameters.walkableClimb;\n    rc.walkableRadius = parameters.walkableRadius;\n    rc.maxEdgeLen = parameters.maxEdgeLen;\n    rc.maxSimplificationError = parameters.maxSimplificationError;\n    rc.minRegionArea = parameters.minRegionArea;\n    rc.mergeRegionArea = parameters.mergeRegionArea;\n    rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\n    rc.detailSampleDist = parameters.detailSampleDist;\n    rc.detailSampleMaxError = parameters.detailSampleMaxError;\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    var index;\n    var tri;\n    var pt;\n    var indices = [];\n    var positions = [];\n    var offset = 0;\n\n    for (index = 0; index < meshes.length; index++) {\n      if (meshes[index]) {\n        var mesh = meshes[index];\n        var meshIndices = mesh.getIndices();\n\n        if (!meshIndices) {\n          continue;\n        }\n\n        var meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n\n        if (!meshPositions) {\n          continue;\n        }\n\n        var wm = mesh.computeWorldMatrix(true);\n\n        for (tri = 0; tri < meshIndices.length; tri++) {\n          indices.push(meshIndices[tri] + offset);\n        }\n\n        var transformed = Vector3.Zero();\n        var position = Vector3.Zero();\n\n        for (pt = 0; pt < meshPositions.length; pt += 3) {\n          Vector3.FromArrayToRef(meshPositions, pt, position);\n          Vector3.TransformCoordinatesToRef(position, wm, transformed);\n          positions.push(transformed.x, transformed.y, transformed.z);\n        }\n\n        offset += meshPositions.length / 3;\n      }\n    }\n\n    this.navMesh.build(positions, offset, indices, indices.length, rc);\n  };\n  /**\r\n   * Create a navigation mesh debug mesh\r\n   * @param scene is where the mesh will be added\r\n   * @returns debug display mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.createDebugNavMesh = function (scene) {\n    var tri;\n    var pt;\n    var debugNavMesh = this.navMesh.getDebugNavMesh();\n    var triangleCount = debugNavMesh.getTriangleCount();\n    var indices = [];\n    var positions = [];\n\n    for (tri = 0; tri < triangleCount * 3; tri++) {\n      indices.push(tri);\n    }\n\n    for (tri = 0; tri < triangleCount; tri++) {\n      for (pt = 0; pt < 3; pt++) {\n        var point = debugNavMesh.getTriangle(tri).getPoint(pt);\n        positions.push(point.x, point.y, point.z);\n      }\n    }\n\n    var mesh = new Mesh(\"NavMeshDebug\", scene);\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.applyToMesh(mesh, false);\n    return mesh;\n  };\n  /**\r\n   * Get a navigation mesh constrained position, closest to the parameter position\r\n   * @param position world position\r\n   * @returns the closest point to position constrained by the navigation mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.getClosestPoint = function (position) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var ret = this.navMesh.getClosestPoint(p);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\r\n   * Get a navigation mesh constrained position, closest to the parameter position\r\n   * @param position world position\r\n   * @param result output the closest point to position constrained by the navigation mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.getClosestPointToRef = function (position, result) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var ret = this.navMesh.getClosestPoint(p);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\r\n   * Get a navigation mesh constrained position, within a particular radius\r\n   * @param position world position\r\n   * @param maxRadius the maximum distance to the constrained world position\r\n   * @returns the closest point to position constrained by the navigation mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.getRandomPointAround = function (position, maxRadius) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var ret = this.navMesh.getRandomPointAround(p, maxRadius);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\r\n   * Get a navigation mesh constrained position, within a particular radius\r\n   * @param position world position\r\n   * @param maxRadius the maximum distance to the constrained world position\r\n   * @param result output the closest point to position constrained by the navigation mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.getRandomPointAroundToRef = function (position, maxRadius, result) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var ret = this.navMesh.getRandomPointAround(p, maxRadius);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\r\n   * Compute the final position from a segment made of destination-position\r\n   * @param position world position\r\n   * @param destination world position\r\n   * @returns the resulting point along the navmesh\r\n   */\n\n\n  RecastJSPlugin.prototype.moveAlong = function (position, destination) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);\n    var ret = this.navMesh.moveAlong(p, d);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\r\n   * Compute the final position from a segment made of destination-position\r\n   * @param position world position\r\n   * @param destination world position\r\n   * @param result output the resulting point along the navmesh\r\n   */\n\n\n  RecastJSPlugin.prototype.moveAlongToRef = function (position, destination, result) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);\n    var ret = this.navMesh.moveAlong(p, d);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\r\n   * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n   * @param start world position\r\n   * @param end world position\r\n   * @returns array containing world position composing the path\r\n   */\n\n\n  RecastJSPlugin.prototype.computePath = function (start, end) {\n    var pt;\n    var startPos = new this.bjsRECAST.Vec3(start.x, start.y, start.z);\n    var endPos = new this.bjsRECAST.Vec3(end.x, end.y, end.z);\n    var navPath = this.navMesh.computePath(startPos, endPos);\n    var pointCount = navPath.getPointCount();\n    var positions = [];\n\n    for (pt = 0; pt < pointCount; pt++) {\n      var p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n\n    return positions;\n  };\n  /**\r\n   * Create a new Crowd so you can add agents\r\n   * @param maxAgents the maximum agent count in the crowd\r\n   * @param maxAgentRadius the maximum radius an agent can have\r\n   * @param scene to attach the crowd to\r\n   * @returns the crowd you can add agents to\r\n   */\n\n\n  RecastJSPlugin.prototype.createCrowd = function (maxAgents, maxAgentRadius, scene) {\n    var crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n    return crowd;\n  };\n  /**\r\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n   * The queries will try to find a solution within those bounds\r\n   * default is (1,1,1)\r\n   * @param extent x,y,z value that define the extent around the queries point of reference\r\n   */\n\n\n  RecastJSPlugin.prototype.setDefaultQueryExtent = function (extent) {\n    var ext = new this.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n    this.navMesh.setDefaultQueryExtent(ext);\n  };\n  /**\r\n   * Get the Bounding box extent specified by setDefaultQueryExtent\r\n   * @returns the box extent values\r\n   */\n\n\n  RecastJSPlugin.prototype.getDefaultQueryExtent = function () {\n    var p = this.navMesh.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  };\n  /**\r\n   * build the navmesh from a previously saved state using getNavmeshData\r\n   * @param data the Uint8Array returned by getNavmeshData\r\n   */\n\n\n  RecastJSPlugin.prototype.buildFromNavmeshData = function (data) {\n    var nDataBytes = data.length * data.BYTES_PER_ELEMENT;\n\n    var dataPtr = this.bjsRECAST._malloc(nDataBytes);\n\n    var dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\n    dataHeap.set(data);\n    var buf = new this.bjsRECAST.NavmeshData();\n    buf.dataPointer = dataHeap.byteOffset;\n    buf.size = data.length;\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    this.navMesh.buildFromNavmeshData(buf); // Free memory\n\n    this.bjsRECAST._free(dataHeap.byteOffset);\n  };\n  /**\r\n   * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n   * @returns data the Uint8Array that can be saved and reused\r\n   */\n\n\n  RecastJSPlugin.prototype.getNavmeshData = function () {\n    var navmeshData = this.navMesh.getNavmeshData();\n    var arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\n    var ret = new Uint8Array(navmeshData.size);\n    ret.set(arrView);\n    this.navMesh.freeNavmeshData(navmeshData);\n    return ret;\n  };\n  /**\r\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n   * @param result output the box extent values\r\n   */\n\n\n  RecastJSPlugin.prototype.getDefaultQueryExtentToRef = function (result) {\n    var p = this.navMesh.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  };\n  /**\r\n   * Disposes\r\n   */\n\n\n  RecastJSPlugin.prototype.dispose = function () {};\n  /**\r\n   * If this plugin is supported\r\n   * @returns true if plugin is supported\r\n   */\n\n\n  RecastJSPlugin.prototype.isSupported = function () {\n    return this.bjsRECAST !== undefined;\n  };\n\n  return RecastJSPlugin;\n}();\n\nexport { RecastJSPlugin };\n/**\r\n * Recast detour crowd implementation\r\n */\n\nvar RecastJSCrowd =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   * @param plugin recastJS plugin\r\n   * @param maxAgents the maximum agent count in the crowd\r\n   * @param maxAgentRadius the maximum radius an agent can have\r\n   * @param scene to attach the crowd to\r\n   * @returns the crowd you can add agents to\r\n   */\n  function RecastJSCrowd(plugin, maxAgents, maxAgentRadius, scene) {\n    var _this = this;\n    /**\r\n     * Link to the detour crowd\r\n     */\n\n\n    this.recastCrowd = {};\n    /**\r\n     * One transform per agent\r\n     */\n\n    this.transforms = new Array();\n    /**\r\n     * All agents created\r\n     */\n\n    this.agents = new Array();\n    /**\r\n     * Observer for crowd updates\r\n     */\n\n    this._onBeforeAnimationsObserver = null;\n    this.bjsRECASTPlugin = plugin;\n    this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\n    this._scene = scene;\n    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(function () {\n      _this.update(scene.getEngine().getDeltaTime() * 0.001);\n    });\n  }\n  /**\r\n   * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n   * You can attach anything to that node. The node position is updated in the scene update tick.\r\n   * @param pos world position that will be constrained by the navigation mesh\r\n   * @param parameters agent parameters\r\n   * @param transform hooked to the agent that will be update by the scene\r\n   * @returns agent index\r\n   */\n\n\n  RecastJSCrowd.prototype.addAgent = function (pos, parameters, transform) {\n    var agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\n    agentParams.radius = parameters.radius;\n    agentParams.height = parameters.height;\n    agentParams.maxAcceleration = parameters.maxAcceleration;\n    agentParams.maxSpeed = parameters.maxSpeed;\n    agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    agentParams.separationWeight = parameters.separationWeight;\n    agentParams.updateFlags = 7;\n    agentParams.obstacleAvoidanceType = 0;\n    agentParams.queryFilterType = 0;\n    agentParams.userData = 0;\n    var agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\n    this.transforms.push(transform);\n    this.agents.push(agentIndex);\n    return agentIndex;\n  };\n  /**\r\n   * Returns the agent position in world space\r\n   * @param index agent index returned by addAgent\r\n   * @returns world space position\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentPosition = function (index) {\n    var agentPos = this.recastCrowd.getAgentPosition(index);\n    return new Vector3(agentPos.x, agentPos.y, agentPos.z);\n  };\n  /**\r\n   * Returns the agent position result in world space\r\n   * @param index agent index returned by addAgent\r\n   * @param result output world space position\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentPositionToRef = function (index, result) {\n    var agentPos = this.recastCrowd.getAgentPosition(index);\n    result.set(agentPos.x, agentPos.y, agentPos.z);\n  };\n  /**\r\n   * Returns the agent velocity in world space\r\n   * @param index agent index returned by addAgent\r\n   * @returns world space velocity\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentVelocity = function (index) {\n    var agentVel = this.recastCrowd.getAgentVelocity(index);\n    return new Vector3(agentVel.x, agentVel.y, agentVel.z);\n  };\n  /**\r\n   * Returns the agent velocity result in world space\r\n   * @param index agent index returned by addAgent\r\n   * @param result output world space velocity\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentVelocityToRef = function (index, result) {\n    var agentVel = this.recastCrowd.getAgentVelocity(index);\n    result.set(agentVel.x, agentVel.y, agentVel.z);\n  };\n  /**\r\n   * Returns the agent next target point on the path\r\n   * @param index agent index returned by addAgent\r\n   * @returns world space position\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentNextTargetPath = function (index) {\n    var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  };\n  /**\r\n   * Returns the agent next target point on the path\r\n   * @param index agent index returned by addAgent\r\n   * @param result output world space position\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentNextTargetPathToRef = function (index, result) {\n    var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  };\n  /**\r\n   * Gets the agent state\r\n   * @param index agent index returned by addAgent\r\n   * @returns agent state\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentState = function (index) {\n    return this.recastCrowd.getAgentState(index);\n  };\n  /**\r\n   * returns true if the agent in over an off mesh link connection\r\n   * @param index agent index returned by addAgent\r\n   * @returns true if over an off mesh link connection\r\n   */\n\n\n  RecastJSCrowd.prototype.overOffmeshConnection = function (index) {\n    return this.recastCrowd.overOffmeshConnection(index);\n  };\n  /**\r\n   * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n   * @param index agent index returned by addAgent\r\n   * @param destination targeted world position\r\n   */\n\n\n  RecastJSCrowd.prototype.agentGoto = function (index, destination) {\n    this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n  };\n  /**\r\n   * Teleport the agent to a new position\r\n   * @param index agent index returned by addAgent\r\n   * @param destination targeted world position\r\n   */\n\n\n  RecastJSCrowd.prototype.agentTeleport = function (index, destination) {\n    this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n  };\n  /**\r\n   * Update agent parameters\r\n   * @param index agent index returned by addAgent\r\n   * @param parameters agent parameters\r\n   */\n\n\n  RecastJSCrowd.prototype.updateAgentParameters = function (index, parameters) {\n    var agentParams = this.recastCrowd.getAgentParameters(index);\n\n    if (parameters.radius !== undefined) {\n      agentParams.radius = parameters.radius;\n    }\n\n    if (parameters.height !== undefined) {\n      agentParams.height = parameters.height;\n    }\n\n    if (parameters.maxAcceleration !== undefined) {\n      agentParams.maxAcceleration = parameters.maxAcceleration;\n    }\n\n    if (parameters.maxSpeed !== undefined) {\n      agentParams.maxSpeed = parameters.maxSpeed;\n    }\n\n    if (parameters.collisionQueryRange !== undefined) {\n      agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    }\n\n    if (parameters.pathOptimizationRange !== undefined) {\n      agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    }\n\n    if (parameters.separationWeight !== undefined) {\n      agentParams.separationWeight = parameters.separationWeight;\n    }\n\n    this.recastCrowd.setAgentParameters(index, agentParams);\n  };\n  /**\r\n   * remove a particular agent previously created\r\n   * @param index agent index returned by addAgent\r\n   */\n\n\n  RecastJSCrowd.prototype.removeAgent = function (index) {\n    this.recastCrowd.removeAgent(index);\n    var item = this.agents.indexOf(index);\n\n    if (item > -1) {\n      this.agents.splice(item, 1);\n      this.transforms.splice(item, 1);\n    }\n  };\n  /**\r\n   * get the list of all agents attached to this crowd\r\n   * @returns list of agent indices\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgents = function () {\n    return this.agents;\n  };\n  /**\r\n   * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n   * @param deltaTime in seconds\r\n   */\n\n\n  RecastJSCrowd.prototype.update = function (deltaTime) {\n    // update crowd\n    var timeStep = this.bjsRECASTPlugin.getTimeStep();\n    var maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\n\n    if (timeStep <= Epsilon) {\n      this.recastCrowd.update(deltaTime);\n    } else {\n      var iterationCount = deltaTime / timeStep;\n\n      if (maxStepCount && iterationCount > maxStepCount) {\n        iterationCount = maxStepCount;\n      }\n\n      if (iterationCount < 1) {\n        iterationCount = 1;\n      }\n\n      for (var i = 0; i < iterationCount; i++) {\n        this.recastCrowd.update(timeStep);\n      }\n    } // update transforms\n\n\n    for (var index = 0; index < this.agents.length; index++) {\n      this.transforms[index].position = this.getAgentPosition(this.agents[index]);\n    }\n  };\n  /**\r\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n   * The queries will try to find a solution within those bounds\r\n   * default is (1,1,1)\r\n   * @param extent x,y,z value that define the extent around the queries point of reference\r\n   */\n\n\n  RecastJSCrowd.prototype.setDefaultQueryExtent = function (extent) {\n    var ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n    this.recastCrowd.setDefaultQueryExtent(ext);\n  };\n  /**\r\n   * Get the Bounding box extent specified by setDefaultQueryExtent\r\n   * @returns the box extent values\r\n   */\n\n\n  RecastJSCrowd.prototype.getDefaultQueryExtent = function () {\n    var p = this.recastCrowd.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  };\n  /**\r\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n   * @param result output the box extent values\r\n   */\n\n\n  RecastJSCrowd.prototype.getDefaultQueryExtentToRef = function (result) {\n    var p = this.recastCrowd.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  };\n  /**\r\n   * Release all resources\r\n   */\n\n\n  RecastJSCrowd.prototype.dispose = function () {\n    this.recastCrowd.destroy();\n\n    this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n\n    this._onBeforeAnimationsObserver = null;\n  };\n\n  return RecastJSCrowd;\n}();\n\nexport { RecastJSCrowd };","map":null,"metadata":{},"sourceType":"module"}