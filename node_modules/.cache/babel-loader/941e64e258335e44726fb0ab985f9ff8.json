{"ast":null,"code":"import { PrecisionDate } from \"./precisionDate\";\n/**\r\n * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window\r\n */\n\nvar PerformanceMonitor =\n/** @class */\nfunction () {\n  /**\r\n   * constructor\r\n   * @param frameSampleSize The number of samples required to saturate the sliding window\r\n   */\n  function PerformanceMonitor(frameSampleSize) {\n    if (frameSampleSize === void 0) {\n      frameSampleSize = 30;\n    }\n\n    this._enabled = true;\n    this._rollingFrameTime = new RollingAverage(frameSampleSize);\n  }\n  /**\r\n   * Samples current frame\r\n   * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames\r\n   */\n\n\n  PerformanceMonitor.prototype.sampleFrame = function (timeMs) {\n    if (timeMs === void 0) {\n      timeMs = PrecisionDate.Now;\n    }\n\n    if (!this._enabled) {\n      return;\n    }\n\n    if (this._lastFrameTimeMs != null) {\n      var dt = timeMs - this._lastFrameTimeMs;\n\n      this._rollingFrameTime.add(dt);\n    }\n\n    this._lastFrameTimeMs = timeMs;\n  };\n\n  Object.defineProperty(PerformanceMonitor.prototype, \"averageFrameTime\", {\n    /**\r\n     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\r\n     */\n    get: function get() {\n      return this._rollingFrameTime.average;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"averageFrameTimeVariance\", {\n    /**\r\n     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\r\n     */\n    get: function get() {\n      return this._rollingFrameTime.variance;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"instantaneousFrameTime\", {\n    /**\r\n     * Returns the frame time of the most recent frame\r\n     */\n    get: function get() {\n      return this._rollingFrameTime.history(0);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"averageFPS\", {\n    /**\r\n     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)\r\n     */\n    get: function get() {\n      return 1000.0 / this._rollingFrameTime.average;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"instantaneousFPS\", {\n    /**\r\n     * Returns the average framerate in frames per second using the most recent frame time\r\n     */\n    get: function get() {\n      var history = this._rollingFrameTime.history(0);\n\n      if (history === 0) {\n        return 0;\n      }\n\n      return 1000.0 / history;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"isSaturated\", {\n    /**\r\n     * Returns true if enough samples have been taken to completely fill the sliding window\r\n     */\n    get: function get() {\n      return this._rollingFrameTime.isSaturated();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Enables contributions to the sliding window sample set\r\n   */\n\n  PerformanceMonitor.prototype.enable = function () {\n    this._enabled = true;\n  };\n  /**\r\n   * Disables contributions to the sliding window sample set\r\n   * Samples will not be interpolated over the disabled period\r\n   */\n\n\n  PerformanceMonitor.prototype.disable = function () {\n    this._enabled = false; //clear last sample to avoid interpolating over the disabled period when next enabled\n\n    this._lastFrameTimeMs = null;\n  };\n\n  Object.defineProperty(PerformanceMonitor.prototype, \"isEnabled\", {\n    /**\r\n     * Returns true if sampling is enabled\r\n     */\n    get: function get() {\n      return this._enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets performance monitor\r\n   */\n\n  PerformanceMonitor.prototype.reset = function () {\n    //clear last sample to avoid interpolating over the disabled period when next enabled\n    this._lastFrameTimeMs = null; //wipe record\n\n    this._rollingFrameTime.reset();\n  };\n\n  return PerformanceMonitor;\n}();\n\nexport { PerformanceMonitor };\n/**\r\n * RollingAverage\r\n *\r\n * Utility to efficiently compute the rolling average and variance over a sliding window of samples\r\n */\n\nvar RollingAverage =\n/** @class */\nfunction () {\n  /**\r\n   * constructor\r\n   * @param length The number of samples required to saturate the sliding window\r\n   */\n  function RollingAverage(length) {\n    this._samples = new Array(length);\n    this.reset();\n  }\n  /**\r\n   * Adds a sample to the sample set\r\n   * @param v The sample value\r\n   */\n\n\n  RollingAverage.prototype.add = function (v) {\n    //http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n    var delta; //we need to check if we've already wrapped round\n\n    if (this.isSaturated()) {\n      //remove bottom of stack from mean\n      var bottomValue = this._samples[this._pos];\n      delta = bottomValue - this.average;\n      this.average -= delta / (this._sampleCount - 1);\n      this._m2 -= delta * (bottomValue - this.average);\n    } else {\n      this._sampleCount++;\n    } //add new value to mean\n\n\n    delta = v - this.average;\n    this.average += delta / this._sampleCount;\n    this._m2 += delta * (v - this.average); //set the new variance\n\n    this.variance = this._m2 / (this._sampleCount - 1);\n    this._samples[this._pos] = v;\n    this._pos++;\n    this._pos %= this._samples.length; //positive wrap around\n  };\n  /**\r\n   * Returns previously added values or null if outside of history or outside the sliding window domain\r\n   * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that\r\n   * @return Value previously recorded with add() or null if outside of range\r\n   */\n\n\n  RollingAverage.prototype.history = function (i) {\n    if (i >= this._sampleCount || i >= this._samples.length) {\n      return 0;\n    }\n\n    var i0 = this._wrapPosition(this._pos - 1.0);\n\n    return this._samples[this._wrapPosition(i0 - i)];\n  };\n  /**\r\n   * Returns true if enough samples have been taken to completely fill the sliding window\r\n   * @return true if sample-set saturated\r\n   */\n\n\n  RollingAverage.prototype.isSaturated = function () {\n    return this._sampleCount >= this._samples.length;\n  };\n  /**\r\n   * Resets the rolling average (equivalent to 0 samples taken so far)\r\n   */\n\n\n  RollingAverage.prototype.reset = function () {\n    this.average = 0;\n    this.variance = 0;\n    this._sampleCount = 0;\n    this._pos = 0;\n    this._m2 = 0;\n  };\n  /**\r\n   * Wraps a value around the sample range boundaries\r\n   * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.\r\n   * @return Wrapped position in sample range\r\n   */\n\n\n  RollingAverage.prototype._wrapPosition = function (i) {\n    var max = this._samples.length;\n    return (i % max + max) % max;\n  };\n\n  return RollingAverage;\n}();\n\nexport { RollingAverage };","map":null,"metadata":{},"sourceType":"module"}