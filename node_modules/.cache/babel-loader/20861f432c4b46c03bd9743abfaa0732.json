{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { Scene } from \"../scene\";\nimport { Ray } from \"../Culling/ray\";\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { ActionEvent } from \"../Actions/actionEvent\";\n\nScene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfo = null;\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  if (this.spriteManagers.length > 0) {\n    for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      var spriteManager = this.spriteManagers[spriteIndex];\n\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n\n      var result = spriteManager.intersects(ray, camera, predicate, fastCheck);\n\n      if (!result || !result.hit) {\n        continue;\n      }\n\n      if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n        continue;\n      }\n\n      pickingInfo = result;\n\n      if (fastCheck) {\n        break;\n      }\n    }\n  }\n\n  return pickingInfo || new PickingInfo();\n};\n\nScene.prototype._internalMultiPickSprites = function (ray, predicate, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfos = new Array();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  if (this.spriteManagers.length > 0) {\n    for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      var spriteManager = this.spriteManagers[spriteIndex];\n\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n\n      var results = spriteManager.multiIntersects(ray, camera, predicate);\n\n      if (results !== null) {\n        pickingInfos = pickingInfos.concat(results);\n      }\n    }\n  }\n\n  return pickingInfos;\n};\n\nScene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n};\n\nScene.prototype.pickSpriteWithRay = function (ray, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n};\n\nScene.prototype.multiPickSprite = function (x, y, predicate, camera) {\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\n\nScene.prototype.multiPickSpriteWithRay = function (ray, predicate, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\n\nScene.prototype.setPointerOverSprite = function (sprite) {\n  if (this._pointerOverSprite === sprite) {\n    return;\n  }\n\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n\n  this._pointerOverSprite = sprite;\n\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n};\n\nScene.prototype.getPointerOverSprite = function () {\n  return this._pointerOverSprite;\n};\n/**\r\n * Defines the sprite scene component responsible to manage sprites\r\n * in a given scene.\r\n */\n\n\nvar SpriteSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function SpriteSceneComponent(scene) {\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_SPRITE;\n    this.scene = scene;\n    this.scene.spriteManagers = new Array();\n    this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\n    this.scene.onBeforeSpritesRenderingObservable = new Observable();\n    this.scene.onAfterSpritesRenderingObservable = new Observable();\n\n    this._spritePredicate = function (sprite) {\n      if (!sprite.actionManager) {\n        return false;\n      }\n\n      return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\n    };\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  SpriteSceneComponent.prototype.register = function () {\n    this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\n\n    this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\n\n    this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  SpriteSceneComponent.prototype.rebuild = function () {\n    /** Nothing to do for sprites */\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  SpriteSceneComponent.prototype.dispose = function () {\n    this.scene.onBeforeSpritesRenderingObservable.clear();\n    this.scene.onAfterSpritesRenderingObservable.clear();\n    var spriteManagers = this.scene.spriteManagers;\n\n    while (spriteManagers.length) {\n      spriteManagers[0].dispose();\n    }\n  };\n\n  SpriteSceneComponent.prototype._pickSpriteButKeepRay = function (originalPointerInfo, x, y, fastCheck, camera) {\n    var result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\n\n    if (result) {\n      result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\n    }\n\n    return result;\n  };\n\n  SpriteSceneComponent.prototype._pointerMove = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {\n    var scene = this.scene;\n\n    if (isMeshPicked) {\n      scene.setPointerOverSprite(null);\n    } else {\n      pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\n\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        scene.setPointerOverSprite(pickResult.pickedSprite);\n\n        if (!scene.doNotHandleCursors) {\n          if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\n            element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\n          } else {\n            element.style.cursor = scene.hoverCursor;\n          }\n        }\n      } else {\n        scene.setPointerOverSprite(null);\n      }\n    }\n\n    return pickResult;\n  };\n\n  SpriteSceneComponent.prototype._pointerDown = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n    var scene = this.scene;\n    scene._pickedDownSprite = null;\n\n    if (scene.spriteManagers.length > 0) {\n      pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        if (pickResult.pickedSprite.actionManager) {\n          scene._pickedDownSprite = pickResult.pickedSprite;\n\n          switch (evt.button) {\n            case 0:\n              pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n\n            case 1:\n              pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n\n            case 2:\n              pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n          }\n\n          if (pickResult.pickedSprite.actionManager) {\n            pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n          }\n        }\n      }\n    }\n\n    return pickResult;\n  };\n\n  SpriteSceneComponent.prototype._pointerUp = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n    var scene = this.scene;\n\n    if (scene.spriteManagers.length > 0) {\n      var spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n\n      if (spritePickResult) {\n        if (spritePickResult.hit && spritePickResult.pickedSprite) {\n          if (spritePickResult.pickedSprite.actionManager) {\n            spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n\n            if (spritePickResult.pickedSprite.actionManager) {\n              if (!this.scene._inputManager._isPointerSwiping()) {\n                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n              }\n            }\n          }\n        }\n\n        if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\n          scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\n        }\n      }\n    }\n\n    return pickResult;\n  };\n\n  return SpriteSceneComponent;\n}();\n\nexport { SpriteSceneComponent };","map":null,"metadata":{},"sourceType":"module"}