{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager\";\nimport { RenderingManager } from \"../../Rendering/renderingManager\";\nimport \"../../Engines/Extensions/engine.renderTarget\";\nimport \"../../Engines/Extensions/engine.renderTargetCube\";\nimport { Engine } from '../../Engines/engine';\n/**\r\n * This Helps creating a texture that will be created from a camera in your scene.\r\n * It is basically a dynamic texture that could be used to create special effects for instance.\r\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\r\n */\n\nvar RenderTargetTexture =\n/** @class */\nfunction (_super) {\n  __extends(RenderTargetTexture, _super);\n  /**\r\n   * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse\r\n   * or used a shadow, depth texture...\r\n   * @param name The friendly name of the texture\r\n   * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n   * @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.\r\n   * @param generateMipMaps True if mip maps need to be generated after render.\r\n   * @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT\r\n   * @param type The type of the buffer in the RTT (int, half float, float...)\r\n   * @param isCube True if a cube texture needs to be created\r\n   * @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)\r\n   * @param generateDepthBuffer True to generate a depth buffer\r\n   * @param generateStencilBuffer True to generate a stencil buffer\r\n   * @param isMulti True if multiple textures need to be created (Draw Buffers)\r\n   * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)\r\n   * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n   */\n\n\n  function RenderTargetTexture(name, size, scene, generateMipMaps, doNotChangeAspectRatio, type, isCube, samplingMode, generateDepthBuffer, generateStencilBuffer, isMulti, format, delayAllocation) {\n    if (doNotChangeAspectRatio === void 0) {\n      doNotChangeAspectRatio = true;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (isCube === void 0) {\n      isCube = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (generateDepthBuffer === void 0) {\n      generateDepthBuffer = true;\n    }\n\n    if (generateStencilBuffer === void 0) {\n      generateStencilBuffer = false;\n    }\n\n    if (isMulti === void 0) {\n      isMulti = false;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (delayAllocation === void 0) {\n      delayAllocation = false;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps) || this;\n    /**\r\n     * Define if particles should be rendered in your texture.\r\n     */\n\n\n    _this.renderParticles = true;\n    /**\r\n     * Define if sprites should be rendered in your texture.\r\n     */\n\n    _this.renderSprites = false;\n    /**\r\n     * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\r\n     */\n\n    _this.ignoreCameraViewport = false;\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\n\n    _this.onBeforeBindObservable = new Observable();\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\n\n    _this.onAfterUnbindObservable = new Observable();\n    /**\r\n    * An event triggered before rendering the texture\r\n    */\n\n    _this.onBeforeRenderObservable = new Observable();\n    /**\r\n    * An event triggered after rendering the texture\r\n    */\n\n    _this.onAfterRenderObservable = new Observable();\n    /**\r\n    * An event triggered after the texture clear\r\n    */\n\n    _this.onClearObservable = new Observable();\n    /**\r\n     * An event triggered when the texture is resized.\r\n     */\n\n    _this.onResizeObservable = new Observable();\n    _this._currentRefreshId = -1;\n    _this._refreshRate = 1;\n    _this._samples = 1;\n    /**\r\n     * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\r\n     * It must define where the camera used to render the texture is set\r\n     */\n\n    _this.boundingBoxPosition = Vector3.Zero();\n    scene = _this.getScene();\n\n    if (!scene) {\n      return _this;\n    }\n\n    _this._coordinatesMode = Texture.PROJECTION_MODE;\n    _this.renderList = new Array();\n    _this.name = name;\n    _this.isRenderTarget = true;\n    _this._initialSizeParameter = size;\n\n    _this._processSizeParameter(size);\n\n    _this._resizeObserver = _this.getScene().getEngine().onResizeObservable.add(function () {});\n    _this._generateMipMaps = generateMipMaps ? true : false;\n    _this._doNotChangeAspectRatio = doNotChangeAspectRatio; // Rendering groups\n\n    _this._renderingManager = new RenderingManager(scene);\n    _this._renderingManager._useSceneAutoClearSetup = true;\n\n    if (isMulti) {\n      return _this;\n    }\n\n    _this._renderTargetOptions = {\n      generateMipMaps: generateMipMaps,\n      type: type,\n      format: format,\n      samplingMode: samplingMode,\n      generateDepthBuffer: generateDepthBuffer,\n      generateStencilBuffer: generateStencilBuffer\n    };\n\n    if (samplingMode === Texture.NEAREST_SAMPLINGMODE) {\n      _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n      _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    }\n\n    if (!delayAllocation) {\n      if (isCube) {\n        _this._texture = scene.getEngine().createRenderTargetCubeTexture(_this.getRenderSize(), _this._renderTargetOptions);\n        _this.coordinatesMode = Texture.INVCUBIC_MODE;\n        _this._textureMatrix = Matrix.Identity();\n      } else {\n        _this._texture = scene.getEngine().createRenderTargetTexture(_this._size, _this._renderTargetOptions);\n      }\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"renderList\", {\n    /**\r\n    * Use this list to define the list of mesh you want to render.\r\n    */\n    get: function get() {\n      return this._renderList;\n    },\n    set: function set(value) {\n      this._renderList = value;\n\n      if (this._renderList) {\n        this._hookArray(this._renderList);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RenderTargetTexture.prototype._hookArray = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var wasEmpty = array.length === 0;\n      var result = oldPush.apply(array, items);\n\n      if (wasEmpty && _this.getScene()) {\n        _this.getScene().meshes.forEach(function (mesh) {\n          mesh._markSubMeshesAsLightDirty();\n        });\n      }\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      if (array.length === 0) {\n        _this.getScene().meshes.forEach(function (mesh) {\n          mesh._markSubMeshesAsLightDirty();\n        });\n      }\n\n      return deleted;\n    };\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"onAfterUnbind\", {\n    /**\r\n     * Set a after unbind callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\r\n     */\n    set: function set(callback) {\n      if (this._onAfterUnbindObserver) {\n        this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n      }\n\n      this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"onBeforeRender\", {\n    /**\r\n     * Set a before render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\r\n     */\n    set: function set(callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"onAfterRender\", {\n    /**\r\n     * Set a after render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\r\n     */\n    set: function set(callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"onClear\", {\n    /**\r\n     * Set a clear callback in the texture.\r\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\r\n     */\n    set: function set(callback) {\n      if (this._onClearObserver) {\n        this.onClearObservable.remove(this._onClearObserver);\n      }\n\n      this._onClearObserver = this.onClearObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"renderTargetOptions\", {\n    /**\r\n     * Gets render target creation options that were used.\r\n     */\n    get: function get() {\n      return this._renderTargetOptions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RenderTargetTexture.prototype._onRatioRescale = function () {\n    if (this._sizeRatio) {\n      this.resize(this._initialSizeParameter);\n    }\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"boundingBoxSize\", {\n    get: function get() {\n      return this._boundingBoxSize;\n    },\n\n    /**\r\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\n    set: function set(value) {\n      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n        return;\n      }\n\n      this._boundingBoxSize = value;\n      var scene = this.getScene();\n\n      if (scene) {\n        scene.markAllMaterialsAsDirty(1);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"depthStencilTexture\", {\n    /**\r\n     * In case the RTT has been created with a depth texture, get the associated\r\n     * depth texture.\r\n     * Otherwise, return null.\r\n     */\n    get: function get() {\n      var _a;\n\n      return ((_a = this.getInternalTexture()) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a depth stencil texture.\r\n   * This is only available in WebGL 2 or with the depth texture extension available.\r\n   * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode\r\n   * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture\r\n   * @param generateStencil Specifies whether or not a stencil should be allocated in the texture\r\n   */\n\n  RenderTargetTexture.prototype.createDepthStencilTexture = function (comparisonFunction, bilinearFiltering, generateStencil) {\n    if (comparisonFunction === void 0) {\n      comparisonFunction = 0;\n    }\n\n    if (bilinearFiltering === void 0) {\n      bilinearFiltering = true;\n    }\n\n    if (generateStencil === void 0) {\n      generateStencil = false;\n    }\n\n    var internalTexture = this.getInternalTexture();\n\n    if (!this.getScene() || !internalTexture) {\n      return;\n    }\n\n    var engine = this.getScene().getEngine();\n    internalTexture._depthStencilTexture = engine.createDepthStencilTexture(this._size, {\n      bilinearFiltering: bilinearFiltering,\n      comparisonFunction: comparisonFunction,\n      generateStencil: generateStencil,\n      isCube: this.isCube\n    });\n  };\n\n  RenderTargetTexture.prototype._processSizeParameter = function (size) {\n    if (size.ratio) {\n      this._sizeRatio = size.ratio;\n\n      var engine = this._getEngine();\n\n      this._size = {\n        width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),\n        height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)\n      };\n    } else {\n      this._size = size;\n    }\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"samples\", {\n    /**\r\n     * Define the number of samples to use in case of MSAA.\r\n     * It defaults to one meaning no MSAA has been enabled.\r\n     */\n    get: function get() {\n      return this._samples;\n    },\n    set: function set(value) {\n      if (this._samples === value) {\n        return;\n      }\n\n      var scene = this.getScene();\n\n      if (!scene) {\n        return;\n      }\n\n      this._samples = scene.getEngine().updateRenderTargetTextureSampleCount(this._texture, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets the refresh counter of the texture and start bak from scratch.\r\n   * Could be useful to regenerate the texture if it is setup to render only once.\r\n   */\n\n  RenderTargetTexture.prototype.resetRefreshCounter = function () {\n    this._currentRefreshId = -1;\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"refreshRate\", {\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\n    get: function get() {\n      return this._refreshRate;\n    },\n    set: function set(value) {\n      this._refreshRate = value;\n      this.resetRefreshCounter();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Adds a post process to the render target rendering passes.\r\n   * @param postProcess define the post process to add\r\n   */\n\n  RenderTargetTexture.prototype.addPostProcess = function (postProcess) {\n    if (!this._postProcessManager) {\n      var scene = this.getScene();\n\n      if (!scene) {\n        return;\n      }\n\n      this._postProcessManager = new PostProcessManager(scene);\n      this._postProcesses = new Array();\n    }\n\n    this._postProcesses.push(postProcess);\n\n    this._postProcesses[0].autoClear = false;\n  };\n  /**\r\n   * Clear all the post processes attached to the render target\r\n   * @param dispose define if the cleared post processesshould also be disposed (false by default)\r\n   */\n\n\n  RenderTargetTexture.prototype.clearPostProcesses = function (dispose) {\n    if (dispose === void 0) {\n      dispose = false;\n    }\n\n    if (!this._postProcesses) {\n      return;\n    }\n\n    if (dispose) {\n      for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {\n        var postProcess = _a[_i];\n        postProcess.dispose();\n      }\n    }\n\n    this._postProcesses = [];\n  };\n  /**\r\n   * Remove one of the post process from the list of attached post processes to the texture\r\n   * @param postProcess define the post process to remove from the list\r\n   */\n\n\n  RenderTargetTexture.prototype.removePostProcess = function (postProcess) {\n    if (!this._postProcesses) {\n      return;\n    }\n\n    var index = this._postProcesses.indexOf(postProcess);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._postProcesses.splice(index, 1);\n\n    if (this._postProcesses.length > 0) {\n      this._postProcesses[0].autoClear = false;\n    }\n  };\n  /** @hidden */\n\n\n  RenderTargetTexture.prototype._shouldRender = function () {\n    if (this._currentRefreshId === -1) {\n      // At least render once\n      this._currentRefreshId = 1;\n      return true;\n    }\n\n    if (this.refreshRate === this._currentRefreshId) {\n      this._currentRefreshId = 1;\n      return true;\n    }\n\n    this._currentRefreshId++;\n    return false;\n  };\n  /**\r\n   * Gets the actual render size of the texture.\r\n   * @returns the width of the render size\r\n   */\n\n\n  RenderTargetTexture.prototype.getRenderSize = function () {\n    return this.getRenderWidth();\n  };\n  /**\r\n   * Gets the actual render width of the texture.\r\n   * @returns the width of the render size\r\n   */\n\n\n  RenderTargetTexture.prototype.getRenderWidth = function () {\n    if (this._size.width) {\n      return this._size.width;\n    }\n\n    return this._size;\n  };\n  /**\r\n   * Gets the actual render height of the texture.\r\n   * @returns the height of the render size\r\n   */\n\n\n  RenderTargetTexture.prototype.getRenderHeight = function () {\n    if (this._size.width) {\n      return this._size.height;\n    }\n\n    return this._size;\n  };\n  /**\r\n   * Gets the actual number of layers of the texture.\r\n   * @returns the number of layers\r\n   */\n\n\n  RenderTargetTexture.prototype.getRenderLayers = function () {\n    var layers = this._size.layers;\n\n    if (layers) {\n      return layers;\n    }\n\n    return 0;\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"canRescale\", {\n    /**\r\n     * Get if the texture can be rescaled or not.\r\n     */\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resize the texture using a ratio.\r\n   * @param ratio the ratio to apply to the texture size in order to compute the new target size\r\n   */\n\n  RenderTargetTexture.prototype.scale = function (ratio) {\n    var newSize = Math.max(1, this.getRenderSize() * ratio);\n    this.resize(newSize);\n  };\n  /**\r\n   * Get the texture reflection matrix used to rotate/transform the reflection.\r\n   * @returns the reflection matrix\r\n   */\n\n\n  RenderTargetTexture.prototype.getReflectionTextureMatrix = function () {\n    if (this.isCube) {\n      return this._textureMatrix;\n    }\n\n    return _super.prototype.getReflectionTextureMatrix.call(this);\n  };\n  /**\r\n   * Resize the texture to a new desired size.\r\n   * Be carrefull as it will recreate all the data in the new texture.\r\n   * @param size Define the new size. It can be:\r\n   *   - a number for squared texture,\r\n   *   - an object containing { width: number, height: number }\r\n   *   - or an object containing a ratio { ratio: number }\r\n   */\n\n\n  RenderTargetTexture.prototype.resize = function (size) {\n    var wasCube = this.isCube;\n    this.releaseInternalTexture();\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this._processSizeParameter(size);\n\n    if (wasCube) {\n      this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\n    } else {\n      this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\n    }\n\n    if (this.onResizeObservable.hasObservers()) {\n      this.onResizeObservable.notifyObservers(this);\n    }\n  };\n  /**\r\n   * Renders all the objects from the render list into the texture.\r\n   * @param useCameraPostProcess Define if camera post processes should be used during the rendering\r\n   * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\r\n   */\n\n\n  RenderTargetTexture.prototype.render = function (useCameraPostProcess, dumpForDebug) {\n    if (useCameraPostProcess === void 0) {\n      useCameraPostProcess = false;\n    }\n\n    if (dumpForDebug === void 0) {\n      dumpForDebug = false;\n    }\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = scene.getEngine();\n\n    if (this.useCameraPostProcesses !== undefined) {\n      useCameraPostProcess = this.useCameraPostProcesses;\n    }\n\n    if (this._waitingRenderList) {\n      this.renderList = [];\n\n      for (var index = 0; index < this._waitingRenderList.length; index++) {\n        var id = this._waitingRenderList[index];\n        var mesh_1 = scene.getMeshByID(id);\n\n        if (mesh_1) {\n          this.renderList.push(mesh_1);\n        }\n      }\n\n      this._waitingRenderList = undefined;\n    } // Is predicate defined?\n\n\n    if (this.renderListPredicate) {\n      if (this.renderList) {\n        this.renderList.length = 0; // Clear previous renderList\n      } else {\n        this.renderList = [];\n      }\n\n      var scene = this.getScene();\n\n      if (!scene) {\n        return;\n      }\n\n      var sceneMeshes = scene.meshes;\n\n      for (var index = 0; index < sceneMeshes.length; index++) {\n        var mesh = sceneMeshes[index];\n\n        if (this.renderListPredicate(mesh)) {\n          this.renderList.push(mesh);\n        }\n      }\n    }\n\n    this.onBeforeBindObservable.notifyObservers(this); // Set custom projection.\n    // Needs to be before binding to prevent changing the aspect ratio.\n\n    var camera;\n\n    if (this.activeCamera) {\n      camera = this.activeCamera;\n      engine.setViewport(this.activeCamera.viewport, this.getRenderWidth(), this.getRenderHeight());\n\n      if (this.activeCamera !== scene.activeCamera) {\n        scene.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(true));\n      }\n    } else {\n      camera = scene.activeCamera;\n\n      if (camera) {\n        engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());\n      }\n    }\n\n    this._defaultRenderListPrepared = false;\n\n    if (this.is2DArray) {\n      for (var layer = 0; layer < this.getRenderLayers(); layer++) {\n        this.renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);\n        scene.incrementRenderId();\n        scene.resetCachedMaterial();\n      }\n    } else if (this.isCube) {\n      for (var face = 0; face < 6; face++) {\n        this.renderToTarget(face, useCameraPostProcess, dumpForDebug, undefined, camera);\n        scene.incrementRenderId();\n        scene.resetCachedMaterial();\n      }\n    } else {\n      this.renderToTarget(0, useCameraPostProcess, dumpForDebug, undefined, camera);\n    }\n\n    this.onAfterUnbindObservable.notifyObservers(this);\n\n    if (scene.activeCamera) {\n      // Do not avoid setting uniforms when multiple scenes are active as another camera may have overwrite these\n      if (scene.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== scene.activeCamera) {\n        scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));\n      }\n\n      engine.setViewport(scene.activeCamera.viewport);\n    }\n\n    scene.resetCachedMaterial();\n  };\n\n  RenderTargetTexture.prototype._bestReflectionRenderTargetDimension = function (renderDimension, scale) {\n    var minimum = 128;\n    var x = renderDimension * scale;\n    var curved = Engine.NearestPOT(x + minimum * minimum / (minimum + x)); // Ensure we don't exceed the render dimension (while staying POT)\n\n    return Math.min(Engine.FloorPOT(renderDimension), curved);\n  };\n\n  RenderTargetTexture.prototype._prepareRenderingManager = function (currentRenderList, currentRenderListLength, camera, checkLayerMask) {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this._renderingManager.reset();\n\n    var sceneRenderId = scene.getRenderId();\n\n    for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\n      var mesh = currentRenderList[meshIndex];\n\n      if (mesh && !mesh.isBlocked) {\n        if (this.customIsReadyFunction) {\n          if (!this.customIsReadyFunction(mesh, this.refreshRate)) {\n            this.resetRefreshCounter();\n            continue;\n          }\n        } else if (!mesh.isReady(this.refreshRate === 0)) {\n          this.resetRefreshCounter();\n          continue;\n        }\n\n        if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {\n          mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector ? scene.customLODSelector(mesh, scene.activeCamera) : mesh.getLOD(scene.activeCamera);\n          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n        }\n\n        if (!mesh._internalAbstractMeshDataInfo._currentLOD) {\n          continue;\n        }\n\n        var meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;\n\n        meshToRender._preActivateForIntermediateRendering(sceneRenderId);\n\n        var isMasked = void 0;\n\n        if (checkLayerMask && camera) {\n          isMasked = (mesh.layerMask & camera.layerMask) === 0;\n        } else {\n          isMasked = false;\n        }\n\n        if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\n          if (meshToRender !== mesh) {\n            meshToRender._activate(sceneRenderId, true);\n          }\n\n          if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\n            if (!mesh.isAnInstance) {\n              meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\n            } else {\n              if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                meshToRender = mesh;\n              }\n            }\n\n            meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;\n\n            for (var subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {\n              var subMesh = meshToRender.subMeshes[subIndex];\n\n              this._renderingManager.dispatch(subMesh, meshToRender);\n            }\n          }\n        }\n      }\n    }\n\n    for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {\n      var particleSystem = scene.particleSystems[particleIndex];\n      var emitter = particleSystem.emitter;\n\n      if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {\n        continue;\n      }\n\n      if (currentRenderList.indexOf(emitter) >= 0) {\n        this._renderingManager.dispatchParticles(particleSystem);\n      }\n    }\n  };\n  /**\r\n   * @hidden\r\n   * @param faceIndex face index to bind to if this is a cubetexture\r\n   * @param layer defines the index of the texture to bind in the array\r\n   */\n\n\n  RenderTargetTexture.prototype._bindFrameBuffer = function (faceIndex, layer) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (layer === void 0) {\n      layer = 0;\n    }\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = scene.getEngine();\n\n    if (this._texture) {\n      engine.bindFramebuffer(this._texture, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\n    }\n  };\n\n  RenderTargetTexture.prototype.unbindFrameBuffer = function (engine, faceIndex) {\n    var _this = this;\n\n    if (!this._texture) {\n      return;\n    }\n\n    engine.unBindFramebuffer(this._texture, this.isCube, function () {\n      _this.onAfterRenderObservable.notifyObservers(faceIndex);\n    });\n  };\n\n  RenderTargetTexture.prototype.renderToTarget = function (faceIndex, useCameraPostProcess, dumpForDebug, layer, camera) {\n    if (layer === void 0) {\n      layer = 0;\n    }\n\n    if (camera === void 0) {\n      camera = null;\n    }\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = scene.getEngine();\n\n    if (!this._texture) {\n      return;\n    } // Bind\n\n\n    if (this._postProcessManager) {\n      this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\n    } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\n      this._bindFrameBuffer(faceIndex, layer);\n    }\n\n    if (this.is2DArray) {\n      this.onBeforeRenderObservable.notifyObservers(layer);\n    } else {\n      this.onBeforeRenderObservable.notifyObservers(faceIndex);\n    } // Get the list of meshes to render\n\n\n    var currentRenderList = null;\n    var defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\n    var defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\n\n    if (this.getCustomRenderList) {\n      currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);\n    }\n\n    if (!currentRenderList) {\n      // No custom render list provided, we prepare the rendering for the default list, but check\n      // first if we did not already performed the preparation before so as to avoid re-doing it several times\n      if (!this._defaultRenderListPrepared) {\n        this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList);\n\n        this._defaultRenderListPrepared = true;\n      }\n\n      currentRenderList = defaultRenderList;\n    } else {\n      // Prepare the rendering for the custom render list provided\n      this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, false);\n    } // Clear\n\n\n    if (this.onClearObservable.hasObservers()) {\n      this.onClearObservable.notifyObservers(engine);\n    } else {\n      engine.clear(this.clearColor || scene.clearColor, true, true, true);\n    }\n\n    if (!this._doNotChangeAspectRatio) {\n      scene.updateTransformMatrix(true);\n    } // Before Camera Draw\n\n\n    for (var _i = 0, _a = scene._beforeRenderTargetDrawStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      step.action(this);\n    } // Render\n\n\n    this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites); // After Camera Draw\n\n\n    for (var _b = 0, _c = scene._afterRenderTargetDrawStage; _b < _c.length; _b++) {\n      var step = _c[_b];\n      step.action(this);\n    }\n\n    if (this._postProcessManager) {\n      this._postProcessManager._finalizeFrame(false, this._texture, faceIndex, this._postProcesses, this.ignoreCameraViewport);\n    } else if (useCameraPostProcess) {\n      scene.postProcessManager._finalizeFrame(false, this._texture, faceIndex);\n    }\n\n    if (!this._doNotChangeAspectRatio) {\n      scene.updateTransformMatrix(true);\n    } // Dump ?\n\n\n    if (dumpForDebug) {\n      Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\n    } // Unbind\n\n\n    if (!this.isCube || faceIndex === 5) {\n      if (this.isCube) {\n        if (faceIndex === 5) {\n          engine.generateMipMapsForCubemap(this._texture);\n        }\n      }\n\n      this.unbindFrameBuffer(engine, faceIndex);\n    } else {\n      this.onAfterRenderObservable.notifyObservers(faceIndex);\n    }\n  };\n  /**\r\n   * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n   * This allowed control for front to back rendering or reversly depending of the special needs.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n   */\n\n\n  RenderTargetTexture.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n  };\n  /**\r\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n   */\n\n\n  RenderTargetTexture.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {\n    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n\n    this._renderingManager._useSceneAutoClearSetup = false;\n  };\n  /**\r\n   * Clones the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  RenderTargetTexture.prototype.clone = function () {\n    var textureSize = this.getSize();\n    var newTexture = new RenderTargetTexture(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // RenderTarget Texture\n\n    newTexture.coordinatesMode = this.coordinatesMode;\n\n    if (this.renderList) {\n      newTexture.renderList = this.renderList.slice(0);\n    }\n\n    return newTexture;\n  };\n  /**\r\n   * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.\r\n   * @returns The JSON representation of the texture\r\n   */\n\n\n  RenderTargetTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.renderTargetSize = this.getRenderSize();\n    serializationObject.renderList = [];\n\n    if (this.renderList) {\n      for (var index = 0; index < this.renderList.length; index++) {\n        serializationObject.renderList.push(this.renderList[index].id);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\r\n   */\n\n\n  RenderTargetTexture.prototype.disposeFramebufferObjects = function () {\n    var objBuffer = this.getInternalTexture();\n    var scene = this.getScene();\n\n    if (objBuffer && scene) {\n      scene.getEngine()._releaseFramebufferObjects(objBuffer);\n    }\n  };\n  /**\r\n   * Dispose the texture and release its associated resources.\r\n   */\n\n\n  RenderTargetTexture.prototype.dispose = function () {\n    this.onResizeObservable.clear();\n    this.onClearObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onAfterUnbindObservable.clear();\n    this.onBeforeBindObservable.clear();\n    this.onBeforeRenderObservable.clear();\n\n    if (this._postProcessManager) {\n      this._postProcessManager.dispose();\n\n      this._postProcessManager = null;\n    }\n\n    this.clearPostProcesses(true);\n\n    if (this._resizeObserver) {\n      this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);\n      this._resizeObserver = null;\n    }\n\n    this.renderList = null; // Remove from custom render targets\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var index = scene.customRenderTargets.indexOf(this);\n\n    if (index >= 0) {\n      scene.customRenderTargets.splice(index, 1);\n    }\n\n    for (var _i = 0, _a = scene.cameras; _i < _a.length; _i++) {\n      var camera = _a[_i];\n      index = camera.customRenderTargets.indexOf(this);\n\n      if (index >= 0) {\n        camera.customRenderTargets.splice(index, 1);\n      }\n    }\n\n    if (this.depthStencilTexture) {\n      this.getScene().getEngine()._releaseTexture(this.depthStencilTexture);\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /** @hidden */\n\n\n  RenderTargetTexture.prototype._rebuild = function () {\n    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    }\n\n    if (this._postProcessManager) {\n      this._postProcessManager._rebuild();\n    }\n  };\n  /**\r\n   * Clear the info related to rendering groups preventing retention point in material dispose.\r\n   */\n\n\n  RenderTargetTexture.prototype.freeRenderingGroups = function () {\n    if (this._renderingManager) {\n      this._renderingManager.freeRenderingGroups();\n    }\n  };\n  /**\r\n   * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n   * @returns the view count\r\n   */\n\n\n  RenderTargetTexture.prototype.getViewCount = function () {\n    return 1;\n  };\n  /**\r\n   * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n   */\n\n\n  RenderTargetTexture.REFRESHRATE_RENDER_ONCE = 0;\n  /**\r\n   * The texture will only be rendered rendered every frame and is recomended for dynamic contents.\r\n   */\n\n  RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME = 1;\n  /**\r\n   * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n   * the central point of your effect and can save a lot of performances.\r\n   */\n\n  RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;\n  return RenderTargetTexture;\n}(Texture);\n\nexport { RenderTargetTexture };\n\nTexture._CreateRenderTargetTexture = function (name, renderTargetSize, scene, generateMipMaps) {\n  return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\n};","map":null,"metadata":{},"sourceType":"module"}