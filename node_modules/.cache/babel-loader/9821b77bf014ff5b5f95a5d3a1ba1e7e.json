{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialConnectionPointDirection } from '../../nodeMaterialBlockConnectionPoint';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\nimport { ReflectionTextureBaseBlock } from '../Dual/reflectionTextureBaseBlock';\nimport { Texture } from '../../../Textures/texture';\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\nimport { Scalar } from '../../../../Maths/math.scalar';\n/**\r\n * Block used to implement the reflection module of the PBR material\r\n */\n\nvar ReflectionBlock =\n/** @class */\nfunction (_super) {\n  __extends(ReflectionBlock, _super);\n  /**\r\n   * Create a new ReflectionBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function ReflectionBlock(name) {\n    var _this = _super.call(this, name) || this;\n    /**\r\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\r\n     * diffuse part of the IBL.\r\n     */\n\n\n    _this.useSphericalHarmonics = true;\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     */\n\n    _this.forceIrradianceInFragment = false;\n    _this._isUnique = true;\n\n    _this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Vertex);\n\n    _this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\n\n    _this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerOutput(\"reflection\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"reflection\", _this, NodeMaterialConnectionPointDirection.Output, ReflectionBlock, \"ReflectionBlock\"));\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  ReflectionBlock.prototype.getClassName = function () {\n    return \"ReflectionBlock\";\n  };\n\n  Object.defineProperty(ReflectionBlock.prototype, \"position\", {\n    /**\r\n     * Gets the position input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"worldPosition\", {\n    /**\r\n     * Gets the world position input component\r\n     */\n    get: function get() {\n      return this.worldPositionConnectionPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"worldNormal\", {\n    /**\r\n     * Gets the world normal input component\r\n     */\n    get: function get() {\n      return this.worldNormalConnectionPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"world\", {\n    /**\r\n     * Gets the world input component\r\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"cameraPosition\", {\n    /**\r\n    * Gets the camera (or eye) position component\r\n    */\n    get: function get() {\n      return this.cameraPositionConnectionPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"view\", {\n    /**\r\n     * Gets the view input component\r\n     */\n    get: function get() {\n      return this.viewConnectionPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"color\", {\n    /**\r\n     * Gets the color input component\r\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"reflection\", {\n    /**\r\n     * Gets the reflection object output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"hasTexture\", {\n    /**\r\n     * Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)\r\n     */\n    get: function get() {\n      return !!this._getTexture();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionBlock.prototype, \"reflectionColor\", {\n    /**\r\n     * Gets the reflection color (either the name of the variable if the color input is connected, else a default value)\r\n     */\n    get: function get() {\n      return this.color.isConnected ? this.color.associatedVariableName : \"vec3(1., 1., 1.)\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ReflectionBlock.prototype._getTexture = function () {\n    if (this.texture) {\n      return this.texture;\n    }\n\n    return this._scene.environmentTexture;\n  };\n\n  ReflectionBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);\n\n    var reflectionTexture = this._getTexture();\n\n    var reflection = reflectionTexture && reflectionTexture.getTextureMatrix;\n    defines.setValue(\"REFLECTION\", reflection, true);\n\n    if (!reflection) {\n      return;\n    }\n\n    defines.setValue(this._defineLODReflectionAlpha, reflectionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularReflection, reflectionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ, true);\n    defines.setValue(\"SPHERICAL_HARMONICS\", this.useSphericalHarmonics, true);\n    defines.setValue(\"GAMMAREFLECTION\", reflectionTexture.gammaSpace, true);\n    defines.setValue(\"RGBDREFLECTION\", reflectionTexture.isRGBD, true);\n\n    if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\n      if (reflectionTexture.isCube) {\n        defines.setValue(\"USESPHERICALFROMREFLECTIONMAP\", true);\n        defines.setValue(\"USEIRRADIANCEMAP\", false);\n\n        if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {\n          defines.setValue(\"USESPHERICALINVERTEX\", false);\n        } else {\n          defines.setValue(\"USESPHERICALINVERTEX\", true);\n        }\n      }\n    }\n  };\n\n  ReflectionBlock.prototype.bind = function (effect, nodeMaterial, mesh, subMesh) {\n    _super.prototype.bind.call(this, effect, nodeMaterial, mesh);\n\n    var reflectionTexture = this._getTexture();\n\n    if (!reflectionTexture || !subMesh) {\n      return;\n    }\n\n    if (reflectionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, reflectionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, reflectionTexture);\n    }\n\n    var width = reflectionTexture.getSize().width;\n    effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n    effect.setFloat2(this._vReflectionFilteringInfoName, width, Scalar.Log2(width));\n    var defines = subMesh._materialDefines;\n    var polynomials = reflectionTexture.sphericalPolynomial;\n\n    if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\n      if (defines.SPHERICAL_HARMONICS) {\n        var preScaledHarmonics = polynomials.preScaledHarmonics;\n        effect.setVector3(\"vSphericalL00\", preScaledHarmonics.l00);\n        effect.setVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\n        effect.setVector3(\"vSphericalL10\", preScaledHarmonics.l10);\n        effect.setVector3(\"vSphericalL11\", preScaledHarmonics.l11);\n        effect.setVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\n        effect.setVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\n        effect.setVector3(\"vSphericalL20\", preScaledHarmonics.l20);\n        effect.setVector3(\"vSphericalL21\", preScaledHarmonics.l21);\n        effect.setVector3(\"vSphericalL22\", preScaledHarmonics.l22);\n      } else {\n        effect.setFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\n        effect.setFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\n        effect.setFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\n        effect.setFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\n        effect.setFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\n        effect.setFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\n        effect.setFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\n        effect.setFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\n        effect.setFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\n      }\n    }\n  };\n  /**\r\n   * Gets the code to inject in the vertex shader\r\n   * @param state current state of the node material building\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionBlock.prototype.handleVertexSide = function (state) {\n    var code = _super.prototype.handleVertexSide.call(this, state);\n\n    state._emitFunctionFromInclude(\"harmonicsFunctions\", \"//\" + this.name, {\n      replaceStrings: [{\n        search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g,\n        replace: \"\"\n      }, {\n        search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g,\n        replace: \"\"\n      }]\n    });\n\n    var reflectionVectorName = state._getFreeVariableName(\"reflectionVector\");\n\n    this._vEnvironmentIrradianceName = state._getFreeVariableName(\"vEnvironmentIrradiance\");\n\n    state._emitVaryingFromString(this._vEnvironmentIrradianceName, \"vec3\", \"defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\");\n\n    state._emitUniformFromString(\"vSphericalL00\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalL1_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalL10\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalL11\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalL2_2\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalL2_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalL20\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalL21\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalL22\", \"vec3\", \"SPHERICAL_HARMONICS\");\n\n    state._emitUniformFromString(\"vSphericalX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    state._emitUniformFromString(\"vSphericalY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    state._emitUniformFromString(\"vSphericalZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    state._emitUniformFromString(\"vSphericalXX_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    state._emitUniformFromString(\"vSphericalYY_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    state._emitUniformFromString(\"vSphericalZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    state._emitUniformFromString(\"vSphericalXY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    state._emitUniformFromString(\"vSphericalYZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    state._emitUniformFromString(\"vSphericalZX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n\n    code += \"#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\\n                vec3 \" + reflectionVectorName + \" = vec3(\" + this._reflectionMatrixName + \" * vec4(normalize(\" + this.worldNormal.associatedVariableName + \").xyz, 0)).xyz;\\n                #ifdef \" + this._defineOppositeZ + \"\\n                    \" + reflectionVectorName + \".z *= -1.0;\\n                #endif\\n                \" + this._vEnvironmentIrradianceName + \" = computeEnvironmentIrradiance(\" + reflectionVectorName + \");\\n            #endif\\r\\n\";\n    return code;\n  };\n  /**\r\n   * Gets the main code of the block (fragment side)\r\n   * @param state current state of the node material building\r\n   * @param normalVarName name of the existing variable corresponding to the normal\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionBlock.prototype.getCode = function (state, normalVarName) {\n    var code = \"\";\n    this.handleFragmentSideInits(state);\n\n    state._emitFunctionFromInclude(\"harmonicsFunctions\", \"//\" + this.name, {\n      replaceStrings: [{\n        search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g,\n        replace: \"\"\n      }, {\n        search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g,\n        replace: \"\"\n      }]\n    });\n\n    state._emitFunction(\"sampleReflection\", \"\\n            #ifdef \" + this._define3DName + \"\\n                #define sampleReflection(s, c) textureCube(s, c)\\n            #else\\n                #define sampleReflection(s, c) texture2D(s, c)\\n            #endif\\r\\n\", \"//\" + this.name);\n\n    state._emitFunction(\"sampleReflectionLod\", \"\\n            #ifdef \" + this._define3DName + \"\\n                #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)\\n            #else\\n                #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)\\n            #endif\\r\\n\", \"//\" + this.name);\n\n    var computeReflectionCoordsFunc = \"\\n            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {\\n                \" + this.handleFragmentSideCodeReflectionCoords('worldNormal', 'worldPos', true) + \"\\n                return \" + this._reflectionVectorName + \";\\n            }\\r\\n\";\n\n    state._emitFunction(\"computeReflectionCoordsPBR\", computeReflectionCoordsFunc, \"//\" + this.name);\n\n    this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName(\"vReflectionMicrosurfaceInfos\");\n\n    state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, \"vec3\");\n\n    this._vReflectionInfosName = state._getFreeVariableName(\"vReflectionInfos\");\n    this._vReflectionFilteringInfoName = state._getFreeVariableName(\"vReflectionFilteringInfo\");\n\n    state._emitUniformFromString(this._vReflectionFilteringInfoName, \"vec2\");\n\n    code += \"#ifdef REFLECTION\\n            vec2 \" + this._vReflectionInfosName + \" = vec2(1., 0.);\\n\\n            reflectionOutParams reflectionOut;\\n\\n            reflectionBlock(\\n                \" + (\"v_\" + this.worldPosition.associatedVariableName + \".xyz\") + \",\\n                \" + normalVarName + \",\\n                alphaG,\\n                \" + this._vReflectionMicrosurfaceInfosName + \",\\n                \" + this._vReflectionInfosName + \",\\n                \" + this.reflectionColor + \",\\n            #ifdef ANISOTROPIC\\n                anisotropicOut,\\n            #endif\\n            #if defined(\" + this._defineLODReflectionAlpha + \") && !defined(\" + this._defineSkyboxName + \")\\n                NdotVUnclamped,\\n            #endif\\n            #ifdef \" + this._defineLinearSpecularReflection + \"\\n                roughness,\\n            #endif\\n            #ifdef \" + this._define3DName + \"\\n                \" + this._cubeSamplerName + \",\\n            #else\\n                \" + this._2DSamplerName + \",\\n            #endif\\n            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)\\n                \" + this._vEnvironmentIrradianceName + \",\\n            #endif\\n            #ifdef USESPHERICALFROMREFLECTIONMAP\\n                #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\\n                    \" + this._reflectionMatrixName + \",\\n                #endif\\n            #endif\\n            #ifdef USEIRRADIANCEMAP\\n                irradianceSampler, // ** not handled **\\n            #endif\\n            #ifndef LODBASEDMICROSFURACE\\n                #ifdef \" + this._define3DName + \"\\n                    \" + this._cubeSamplerName + \",\\n                    \" + this._cubeSamplerName + \",\\n                #else\\n                    \" + this._2DSamplerName + \",\\n                    \" + this._2DSamplerName + \",\\n                #endif\\n            #endif\\n            #ifdef REALTIME_FILTERING\\n                \" + this._vReflectionFilteringInfoName + \",\\n            #endif\\n                reflectionOut\\n            );\\n        #endif\\r\\n\";\n    return code;\n  };\n\n  ReflectionBlock.prototype._buildBlock = function (state) {\n    this._scene = state.sharedData.scene;\n\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      this._defineLODReflectionAlpha = state._getFreeDefineName(\"LODINREFLECTIONALPHA\");\n      this._defineLinearSpecularReflection = state._getFreeDefineName(\"LINEARSPECULARREFLECTION\");\n    }\n\n    return this;\n  };\n\n  ReflectionBlock.prototype._dumpPropertiesCode = function () {\n    var codeString = _super.prototype._dumpPropertiesCode.call(this);\n\n    if (this.texture) {\n      codeString += this._codeVariableName + \".texture.gammaSpace = \" + this.texture.gammaSpace + \");\\r\\n\";\n    }\n\n    codeString += this._codeVariableName + \".useSphericalHarmonics = \" + this.useSphericalHarmonics + \";\\r\\n\";\n    codeString += this._codeVariableName + \".forceIrradianceInFragment = \" + this.forceIrradianceInFragment + \";\\r\\n\";\n    return codeString;\n  };\n\n  ReflectionBlock.prototype.serialize = function () {\n    var _a, _b;\n\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;\n    serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;\n    serializationObject.gammaSpace = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.gammaSpace) !== null && _b !== void 0 ? _b : true;\n    return serializationObject;\n  };\n\n  ReflectionBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;\n    this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;\n\n    if (this.texture) {\n      this.texture.gammaSpace = serializationObject.gammaSpace;\n    }\n  };\n\n  __decorate([editableInPropertyPage(\"Spherical Harmonics\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    \"notifiers\": {\n      \"update\": true\n    }\n  })], ReflectionBlock.prototype, \"useSphericalHarmonics\", void 0);\n\n  __decorate([editableInPropertyPage(\"Force irradiance in fragment\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    \"notifiers\": {\n      \"update\": true\n    }\n  })], ReflectionBlock.prototype, \"forceIrradianceInFragment\", void 0);\n\n  return ReflectionBlock;\n}(ReflectionTextureBaseBlock);\n\nexport { ReflectionBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.ReflectionBlock\"] = ReflectionBlock;","map":null,"metadata":{},"sourceType":"module"}