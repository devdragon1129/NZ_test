{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar _defineProperty = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _toConsumableArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectWithoutProperties = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar formatters_1 = require(\"../formatters\");\n\nvar subscriptions_1 = require(\"../subscriptions\");\n\nvar utils_1 = require(\"../utils\");\n\nvar tx_1 = require(\"./tx\");\n\nvar tx_deploy_1 = require(\"./tx-deploy\");\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\n\n\nvar Contract = /*#__PURE__*/function () {\n  function Contract(eth, contractAbi, address) {\n    var defaultOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, Contract);\n\n    this.eth = eth;\n    this.contractAbi = contractAbi;\n    this.address = address;\n    this.defaultOptions = defaultOptions;\n    this.linkTable = {};\n    this.methods = this.buildMethods();\n    this.events = this.buildEvents();\n  }\n\n  _createClass(Contract, [{\n    key: \"link\",\n    value: function link(name, address) {\n      this.linkTable[name] = address;\n    }\n  }, {\n    key: \"deployBytecode\",\n    value: function deployBytecode(data) {\n      var _this = this;\n\n      var linkedData = Object.entries(this.linkTable).reduce(function (data, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            name = _ref2[0],\n            address = _ref2[1];\n\n        return data.replace(new RegExp(\"_+\".concat(name, \"_+\"), 'gi'), address.toString().slice(2).toLowerCase());\n      }, data);\n\n      if (linkedData.includes('_')) {\n        throw new Error('Bytecode has not been fully linked.');\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return new tx_deploy_1.TxDeploy(this.eth, this.contractAbi.ctor, this.contractAbi, utils_1.hexToBuffer(linkedData), args, this.defaultOptions, function (addr) {\n        return _this.address = addr;\n      });\n    }\n  }, {\n    key: \"once\",\n    value: function once(event, options, callback) {\n      this.on(event, options, function (err, res, sub) {\n        sub.unsubscribe();\n        callback(err, res, sub);\n      });\n    }\n  }, {\n    key: \"getPastEvents\",\n    value: function () {\n      var _getPastEvents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(event) {\n        var _this2 = this;\n\n        var options,\n            logOptions,\n            result,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                logOptions = this.getLogOptions(event, options);\n                _context.next = 4;\n                return this.eth.getPastLogs(logOptions);\n\n              case 4:\n                result = _context.sent;\n                return _context.abrupt(\"return\", result.map(function (log) {\n                  return _this2.contractAbi.decodeEvent(log);\n                }));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getPastEvents(_x) {\n        return _getPastEvents.apply(this, arguments);\n      }\n\n      return getPastEvents;\n    }()\n  }, {\n    key: \"on\",\n    value: function on(event) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      var logOptions = this.getLogOptions(event, options);\n\n      var fromBlock = logOptions.fromBlock,\n          subLogOptions = _objectWithoutProperties(logOptions, [\"fromBlock\"]);\n\n      var params = [formatters_1.toRawLogRequest(subLogOptions)];\n      var subscription = new subscriptions_1.Subscription('eth', 'logs', params, this.eth.provider, function (result, sub) {\n        var output = formatters_1.fromRawLogResponse(result);\n\n        var eventLog = _this3.contractAbi.decodeEvent(output);\n\n        sub.emit(output.removed ? 'changed' : 'data', eventLog);\n\n        if (callback) {\n          callback(undefined, eventLog, sub);\n        }\n      }, false);\n      subscription.on('error', function (err) {\n        if (callback) {\n          callback(err, undefined, subscription);\n        }\n      });\n\n      if (fromBlock !== undefined) {\n        this.eth.getPastLogs(logOptions).then(function (logs) {\n          logs.forEach(function (result) {\n            var output = _this3.contractAbi.decodeEvent(result);\n\n            subscription.emit('data', output);\n          });\n          subscription.subscribe();\n        }).catch(function (err) {\n          subscription.emit('error', err);\n        });\n      } else {\n        subscription.subscribe();\n      }\n\n      return subscription;\n    }\n  }, {\n    key: \"executorFactory\",\n    value: function executorFactory(functions) {\n      var _this4 = this;\n\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        if (!_this4.address) {\n          throw new Error('No contract address.');\n        }\n\n        var firstMatchingOverload = functions.find(function (f) {\n          return args.length === f.numArgs();\n        });\n\n        if (!firstMatchingOverload) {\n          throw new Error(\"No matching method with \".concat(args.length, \" arguments for \").concat(functions[0].name, \".\"));\n        }\n\n        return new tx_1.Tx(_this4.eth, firstMatchingOverload, _this4.contractAbi, _this4.address, args, _this4.defaultOptions);\n      };\n    }\n  }, {\n    key: \"buildMethods\",\n    value: function buildMethods() {\n      var _this5 = this;\n\n      var methods = {};\n      this.contractAbi.functions.forEach(function (f) {\n        var executor = _this5.executorFactory([f]);\n\n        methods[f.asString()] = executor;\n        methods[f.signature] = executor;\n      });\n      var grouped = this.contractAbi.functions.reduce(function (acc, method) {\n        var funcs = [].concat(_toConsumableArray(acc[method.name] || []), [method]);\n        return _objectSpread({}, acc, _defineProperty({}, method.name, funcs));\n      }, {});\n      Object.entries(grouped).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            name = _ref4[0],\n            funcs = _ref4[1];\n\n        methods[name] = _this5.executorFactory(funcs);\n      });\n      return methods;\n    }\n  }, {\n    key: \"buildEvents\",\n    value: function buildEvents() {\n      var _this6 = this;\n\n      var events = {};\n      this.contractAbi.events.forEach(function (e) {\n        var event = _this6.on.bind(_this6, e.signature);\n\n        if (!events[e.name]) {\n          events[e.name] = event;\n        }\n\n        events[e.asString()] = event;\n        events[e.signature] = event;\n      });\n      events.allEvents = this.on.bind(this, 'allevents');\n      return events;\n    }\n  }, {\n    key: \"getLogOptions\",\n    value: function getLogOptions() {\n      var eventName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'allevents';\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!this.address) {\n        throw new Error('No contract address.');\n      }\n\n      if (eventName.toLowerCase() === 'allevents') {\n        return _objectSpread({}, options, {\n          address: this.address\n        });\n      }\n\n      var event = this.contractAbi.events.find(function (e) {\n        return e.name === eventName || e.signature === '0x' + eventName.replace('0x', '');\n      });\n\n      if (!event) {\n        throw new Error(\"Event \".concat(eventName, \" not found.\"));\n      }\n\n      return _objectSpread({}, options, {\n        address: this.address,\n        topics: event.getEventTopics(options.filter)\n      });\n    }\n  }]);\n\n  return Contract;\n}();\n\nexports.Contract = Contract;","map":null,"metadata":{},"sourceType":"script"}