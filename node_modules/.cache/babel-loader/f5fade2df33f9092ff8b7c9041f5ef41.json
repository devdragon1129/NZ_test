{"ast":null,"code":"import { VertexData } from \"../mesh.vertexData\";\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\n/**\r\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n * @param options the constructors options used to shape the mesh.\r\n * @returns the capsule VertexData\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\n\nVertexData.CreateCapsule = function (options) {\n  if (options === void 0) {\n    options = {\n      subdivisions: 2,\n      tessellation: 16,\n      height: 1,\n      radius: 0.25,\n      capSubdivisions: 6\n    };\n  }\n\n  var subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\n  var tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\n  var height = Math.max(options.height ? options.height : 1, 0.);\n  var radius = Math.max(options.radius ? options.radius : 0.25, 0.);\n  var capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\n  var radialSegments = tessellation;\n  var heightSegments = subdivisions;\n  var radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0.);\n  var radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0.);\n  var heightMinusCaps = height - (radiusTop + radiusBottom);\n  var thetaStart = 0.0;\n  var thetaLength = 2.0 * Math.PI;\n  var capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\n  var capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\n  var alpha = Math.acos((radiusBottom - radiusTop) / height);\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n  var index = 0,\n      indexArray = [],\n      halfHeight = heightMinusCaps * 0.5;\n  var pi2 = Math.PI * 0.5;\n  var x, y;\n  var normal = Vector3.Zero();\n  var vertex = Vector3.Zero();\n  var cosAlpha = Math.cos(alpha);\n  var sinAlpha = Math.sin(alpha);\n  var cone_length = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length(); // Total length for v texture coord\n\n  var vl = radiusTop * alpha + cone_length + radiusBottom * (pi2 - alpha);\n  var v = 0;\n\n  for (y = 0; y <= capsTopSegments; y++) {\n    var indexRow = [];\n    var a = pi2 - alpha * (y / capsTopSegments);\n    v += radiusTop * alpha / capsTopSegments;\n    var cosA = Math.cos(a);\n    var sinA = Math.sin(a); // calculate the radius of the current row\n\n    var _radius = cosA * radiusTop;\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + sinA * radiusTop;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  }\n\n  var cone_height = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\n  var slope = sinAlpha * (radiusBottom - radiusTop) / cone_height;\n\n  for (y = 1; y <= heightSegments; y++) {\n    var indexRow = [];\n    v += cone_length / heightSegments; // calculate the radius of the current row\n\n    var _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + cosAlpha * radiusTop - y * cone_height / heightSegments;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(sinTheta, slope, cosTheta).normalize();\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  }\n\n  for (y = 1; y <= capsBottomSegments; y++) {\n    var indexRow = [];\n    var a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\n    v += radiusBottom * alpha / capsBottomSegments;\n    var cosA = Math.cos(a);\n    var sinA = Math.sin(a); // calculate the radius of the current row\n\n    var _radius = cosA * radiusBottom;\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = -halfHeight + sinA * radiusBottom;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  } // generate indices\n\n\n  for (x = 0; x < radialSegments; x++) {\n    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\n      // we use the index array to access the correct indices\n      var i1 = indexArray[y][x];\n      var i2 = indexArray[y + 1][x];\n      var i3 = indexArray[y + 1][x + 1];\n      var i4 = indexArray[y][x + 1]; // face one\n\n      indices.push(i1);\n      indices.push(i2);\n      indices.push(i4); // face two\n\n      indices.push(i2);\n      indices.push(i3);\n      indices.push(i4);\n    }\n  }\n\n  indices = indices.reverse();\n\n  if (options.orientation && !options.orientation.equals(Vector3.Up())) {\n    var m = new Matrix();\n    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);\n    var v_1 = Vector3.Zero();\n\n    for (var i = 0; i < vertices.length; i += 3) {\n      v_1.set(vertices[i], vertices[i + 1], vertices[i + 2]);\n      Vector3.TransformCoordinatesToRef(v_1.clone(), m, v_1);\n      vertices[i] = v_1.x;\n      vertices[i + 1] = v_1.y;\n      vertices[i + 2] = v_1.z;\n    }\n  }\n\n  var vDat = new VertexData();\n  vDat.positions = vertices;\n  vDat.normals = normals;\n  vDat.uvs = uvs;\n  vDat.indices = indices;\n  return vDat;\n};\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh.\r\n * @param options the constructors options used to shape the mesh.\r\n * @param scene defines the scene the mesh is scoped to.\r\n * @returns the capsule mesh\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\n\n\nMesh.CreateCapsule = function (name, options, scene) {\n  return CapsuleBuilder.CreateCapsule(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar CapsuleBuilder =\n/** @class */\nfunction () {\n  function CapsuleBuilder() {}\n  /**\r\n   * Creates a capsule or a pill mesh\r\n   * @param name defines the name of the mesh\r\n   * @param options The constructors options.\r\n   * @param scene The scene the mesh is scoped to.\r\n   * @returns Capsule Mesh\r\n   */\n\n\n  CapsuleBuilder.CreateCapsule = function (name, options, scene) {\n    if (options === void 0) {\n      options = {\n        orientation: Vector3.Up(),\n        subdivisions: 2,\n        tessellation: 16,\n        height: 1,\n        radius: 0.25,\n        capSubdivisions: 6\n      };\n    }\n\n    var capsule = new Mesh(name, scene);\n    var vertexData = VertexData.CreateCapsule(options);\n    vertexData.applyToMesh(capsule);\n    return capsule;\n  };\n\n  return CapsuleBuilder;\n}();\n\nexport { CapsuleBuilder };","map":null,"metadata":{},"sourceType":"module"}