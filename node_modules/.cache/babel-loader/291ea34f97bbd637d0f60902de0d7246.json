{"ast":null,"code":"'use strict';\n\nvar pull = require('pull-stream/pull');\n\nvar values = require('pull-stream/sources/values');\n\nvar error = require('pull-stream/sources/error');\n\nvar filter = require('pull-stream/throughs/filter');\n\nvar map = require('pull-stream/throughs/map');\n\nvar CID = require('cids');\n\nvar createResolver = require('./resolve').createResolver;\n\nfunction pathBaseAndRest(path) {\n  // Buffer -> raw multihash or CID in buffer\n  var pathBase = path;\n  var pathRest = '/';\n\n  if (Buffer.isBuffer(path)) {\n    pathBase = new CID(path).toBaseEncodedString();\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = pathBase = path.substring(6);\n    }\n\n    var subtreeStart = path.indexOf('/');\n\n    if (subtreeStart > 0) {\n      pathBase = path.substring(0, subtreeStart);\n      pathRest = path.substring(subtreeStart);\n    }\n  } else if (CID.isCID(pathBase)) {\n    pathBase = pathBase.toBaseEncodedString();\n  }\n\n  pathBase = new CID(pathBase).toBaseEncodedString();\n  return {\n    base: pathBase,\n    rest: toPathComponents(pathRest)\n  };\n}\n\nvar defaultOptions = {\n  maxDepth: Infinity,\n  offset: undefined,\n  length: undefined,\n  fullPath: false\n};\n\nmodule.exports = function (path, dag, options) {\n  options = Object.assign({}, defaultOptions, options);\n  var dPath;\n\n  try {\n    dPath = pathBaseAndRest(path);\n  } catch (err) {\n    return error(err);\n  }\n\n  var pathLengthToCut = join([dPath.base].concat(dPath.rest.slice(0, dPath.rest.length - 1))).length;\n  var cid = new CID(dPath.base);\n  return pull(values([{\n    multihash: cid.buffer,\n    name: dPath.base,\n    path: dPath.base,\n    pathRest: dPath.rest,\n    depth: 0\n  }]), createResolver(dag, options), filter(Boolean), map(function (node) {\n    return {\n      depth: node.depth,\n      name: node.name,\n      path: options.fullPath ? node.path : finalPathFor(node),\n      size: node.size,\n      hash: node.multihash,\n      content: node.content,\n      type: node.type\n    };\n  }));\n\n  function finalPathFor(node) {\n    if (!dPath.rest.length) {\n      return node.path;\n    }\n\n    var retPath = node.path.substring(pathLengthToCut);\n\n    if (retPath.charAt(0) === '/') {\n      retPath = retPath.substring(1);\n    }\n\n    if (!retPath) {\n      retPath = dPath.rest[dPath.rest.length - 1] || dPath.base;\n    }\n\n    return retPath;\n  }\n};\n\nfunction join(paths) {\n  return paths.reduce(function (acc, path) {\n    if (acc.length) {\n      acc += '/';\n    }\n\n    return acc + path;\n  }, '');\n}\n\nvar toPathComponents = function toPathComponents() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  // split on / unless escaped with \\\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};","map":null,"metadata":{},"sourceType":"script"}