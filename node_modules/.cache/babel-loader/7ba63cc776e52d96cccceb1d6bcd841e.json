{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Engine } from \"../Engines/engine\";\nimport { RenderTargetCreationOptions } from \"../Materials/Textures/renderTargetCreationOptions\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { DataBuffer } from '../Meshes/dataBuffer';\nimport { PerformanceConfigurator } from './performanceConfigurator';\n/**\r\n * Options to create the null engine\r\n */\n\nvar NullEngineOptions =\n/** @class */\nfunction () {\n  function NullEngineOptions() {\n    /**\r\n     * Render width (Default: 512)\r\n     */\n    this.renderWidth = 512;\n    /**\r\n     * Render height (Default: 256)\r\n     */\n\n    this.renderHeight = 256;\n    /**\r\n     * Texture size (Default: 512)\r\n     */\n\n    this.textureSize = 512;\n    /**\r\n     * If delta time between frames should be constant\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\n\n    this.deterministicLockstep = false;\n    /**\r\n     * Maximum about of steps between frames (Default: 4)\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\n\n    this.lockstepMaxSteps = 4;\n  }\n\n  return NullEngineOptions;\n}();\n\nexport { NullEngineOptions };\n/**\r\n * The null engine class provides support for headless version of babylon.js.\r\n * This can be used in server side scenario or for testing purposes\r\n */\n\nvar NullEngine =\n/** @class */\nfunction (_super) {\n  __extends(NullEngine, _super);\n\n  function NullEngine(options) {\n    if (options === void 0) {\n      options = new NullEngineOptions();\n    }\n\n    var _this = _super.call(this, null) || this;\n\n    Engine.Instances.push(_this);\n\n    if (options.deterministicLockstep === undefined) {\n      options.deterministicLockstep = false;\n    }\n\n    if (options.lockstepMaxSteps === undefined) {\n      options.lockstepMaxSteps = 4;\n    }\n\n    _this._options = options;\n    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix); // Init caps\n    // We consider we are on a webgl1 capable device\n\n    _this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: 512,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: false,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 0,\n      uintIndices: false,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      textureFloat: false,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: false,\n      textureHalfFloat: false,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: false,\n      textureLOD: false,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: false,\n      instancedArrays: false,\n      canUseTimestampForTimerQuery: false,\n      maxMSAASamples: 1,\n      blendMinMax: false\n    };\n    Logger.Log(\"Babylon.js v\" + Engine.Version + \" - Null engine\"); // Wrappers\n\n    var theCurrentGlobal = typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window;\n\n    if (typeof URL === \"undefined\") {\n      theCurrentGlobal.URL = {\n        createObjectURL: function createObjectURL() {},\n        revokeObjectURL: function revokeObjectURL() {}\n      };\n    }\n\n    if (typeof Blob === \"undefined\") {\n      theCurrentGlobal.Blob = function () {};\n    }\n\n    return _this;\n  }\n  /**\r\n   * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns true if engine is in deterministic lock step mode\r\n   */\n\n\n  NullEngine.prototype.isDeterministicLockStep = function () {\n    return this._options.deterministicLockstep;\n  };\n  /**\r\n   * Gets the max steps when engine is running in deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns the max steps\r\n   */\n\n\n  NullEngine.prototype.getLockstepMaxSteps = function () {\n    return this._options.lockstepMaxSteps;\n  };\n  /**\r\n   * Gets the current hardware scaling level.\r\n   * By default the hardware scaling level is computed from the window device ratio.\r\n   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n   * @returns a number indicating the current hardware scaling level\r\n   */\n\n\n  NullEngine.prototype.getHardwareScalingLevel = function () {\n    return 1.0;\n  };\n  /**\r\n   * Creates a vertex buffer\r\n   * @param vertices the data for the vertex buffer\r\n   * @returns the new WebGL static buffer\r\n   */\n\n\n  NullEngine.prototype.createVertexBuffer = function (vertices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  };\n  /**\r\n   * Creates a new index buffer\r\n   * @param indices defines the content of the index buffer\r\n   * @param updatable defines if the index buffer must be updatable\r\n   * @returns a new webGL buffer\r\n   */\n\n\n  NullEngine.prototype.createIndexBuffer = function (indices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  };\n  /**\r\n   * Clear the current render buffer or the current render target (if any is set up)\r\n   * @param color defines the color to use\r\n   * @param backBuffer defines if the back buffer must be cleared\r\n   * @param depth defines if the depth buffer must be cleared\r\n   * @param stencil defines if the stencil buffer must be cleared\r\n   */\n\n\n  NullEngine.prototype.clear = function (color, backBuffer, depth, stencil) {\n    if (stencil === void 0) {\n      stencil = false;\n    }\n  };\n  /**\r\n   * Gets the current render width\r\n   * @param useScreen defines if screen size must be used (or the current render target if any)\r\n   * @returns a number defining the current render width\r\n   */\n\n\n  NullEngine.prototype.getRenderWidth = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n\n    return this._options.renderWidth;\n  };\n  /**\r\n   * Gets the current render height\r\n   * @param useScreen defines if screen size must be used (or the current render target if any)\r\n   * @returns a number defining the current render height\r\n   */\n\n\n  NullEngine.prototype.getRenderHeight = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n\n    return this._options.renderHeight;\n  };\n  /**\r\n   * Set the WebGL's viewport\r\n   * @param viewport defines the viewport element to be used\r\n   * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n   * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n   */\n\n\n  NullEngine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n  };\n\n  NullEngine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context) {\n    return {\n      __SPECTOR_rebuildProgram: null\n    };\n  };\n  /**\r\n   * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\r\n   * @param pipelineContext defines the pipeline context to use\r\n   * @param uniformsNames defines the list of uniform names\r\n   * @returns an array of webGL uniform locations\r\n   */\n\n\n  NullEngine.prototype.getUniforms = function (pipelineContext, uniformsNames) {\n    return [];\n  };\n  /**\r\n   * Gets the lsit of active attributes for a given webGL program\r\n   * @param pipelineContext defines the pipeline context to use\r\n   * @param attributesNames defines the list of attribute names to get\r\n   * @returns an array of indices indicating the offset of each attribute\r\n   */\n\n\n  NullEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {\n    return [];\n  };\n  /**\r\n   * Binds an effect to the webGL context\r\n   * @param effect defines the effect to bind\r\n   */\n\n\n  NullEngine.prototype.bindSamplers = function (effect) {\n    this._currentEffect = null;\n  };\n  /**\r\n   * Activates an effect, mkaing it the current one (ie. the one used for rendering)\r\n   * @param effect defines the effect to activate\r\n   */\n\n\n  NullEngine.prototype.enableEffect = function (effect) {\n    this._currentEffect = effect;\n\n    if (effect.onBind) {\n      effect.onBind(effect);\n    }\n\n    if (effect._onBindObservable) {\n      effect._onBindObservable.notifyObservers(effect);\n    }\n  };\n  /**\r\n   * Set various states to the webGL context\r\n   * @param culling defines backface culling state\r\n   * @param zOffset defines the value to apply to zOffset (0 by default)\r\n   * @param force defines if states must be applied even if cache is up to date\r\n   * @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)\r\n   */\n\n\n  NullEngine.prototype.setState = function (culling, zOffset, force, reverseSide) {\n    if (zOffset === void 0) {\n      zOffset = 0;\n    }\n\n    if (reverseSide === void 0) {\n      reverseSide = false;\n    }\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setIntArray = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setIntArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setIntArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec4)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setIntArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloatArray = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as vec2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloatArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as vec3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloatArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as vec4)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloatArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setArray = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec4)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as matrices)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrices defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setMatrices = function (uniform, matrices) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a matrix (3x3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrix defines the Float32Array representing the 3x3 matrix to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setMatrix3x3 = function (uniform, matrix) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a matrix (2x2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrix defines the Float32Array representing the 2x2 matrix to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setMatrix2x2 = function (uniform, matrix) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a number (float)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param value defines the float number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloat = function (uniform, value) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec2\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloat2 = function (uniform, x, y) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec3\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @param z defines the 3rd component of the value\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloat3 = function (uniform, x, y, z) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a boolean\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param bool defines the boolean to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setBool = function (uniform, bool) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec4\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @param z defines the 3rd component of the value\r\n   * @param w defines the 4th component of the value\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloat4 = function (uniform, x, y, z, w) {\n    return true;\n  };\n  /**\r\n   * Sets the current alpha mode\r\n   * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n   * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered\r\n   */\n\n\n  NullEngine.prototype.setAlphaMode = function (mode, noDepthWriteChange) {\n    if (noDepthWriteChange === void 0) {\n      noDepthWriteChange = false;\n    }\n\n    if (this._alphaMode === mode) {\n      return;\n    }\n\n    this.alphaState.alphaBlend = mode !== 0;\n\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n\n    this._alphaMode = mode;\n  };\n  /**\r\n   * Bind webGl buffers directly to the webGL context\r\n   * @param vertexBuffers defines the vertex buffer to bind\r\n   * @param indexBuffer defines the index buffer to bind\r\n   * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer\r\n   * @param vertexStrideSize defines the vertex stride of the vertex buffer\r\n   * @param effect defines the effect associated with the vertex buffer\r\n   */\n\n\n  NullEngine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect) {};\n  /**\r\n   * Force the entire cache to be cleared\r\n   * You should not have to use this function unless your engine needs to share the webGL context with another engine\r\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n   */\n\n\n  NullEngine.prototype.wipeCaches = function (bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n\n    this.resetTextureCache();\n    this._currentEffect = null;\n\n    if (bruteForce) {\n      this._currentProgram = null;\n      this.stencilState.reset();\n      this.depthCullingState.reset();\n      this.alphaState.reset();\n    }\n\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  };\n  /**\r\n   * Send a draw order\r\n   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n   * @param indexStart defines the starting index\r\n   * @param indexCount defines the number of index to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  NullEngine.prototype.draw = function (useTriangles, indexStart, indexCount, instancesCount) {};\n  /**\r\n   * Draw a list of indexed primitives\r\n   * @param fillMode defines the primitive to use\r\n   * @param indexStart defines the starting index\r\n   * @param indexCount defines the number of index to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  NullEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {};\n  /**\r\n   * Draw a list of unindexed primitives\r\n   * @param fillMode defines the primitive to use\r\n   * @param verticesStart defines the index of first vertex to draw\r\n   * @param verticesCount defines the count of vertices to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  NullEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {};\n  /** @hidden */\n\n\n  NullEngine.prototype._createTexture = function () {\n    return {};\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._releaseTexture = function (texture) {};\n  /**\r\n   * Usually called from Texture.ts.\r\n   * Passed information to create a WebGLTexture\r\n   * @param urlArg defines a value which contains one of the following:\r\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n   * @param scene needed for loading to the correct scene\r\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n   * @param onLoad optional callback to be called upon successful completion\r\n   * @param onError optional callback to be called upon failure\r\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n   * @param forcedExtension defines the extension to use to pick the right loader\r\n   * @param mimeType defines an optional mime type\r\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n   */\n\n\n  NullEngine.prototype.createTexture = function (urlArg, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType) {\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (fallback === void 0) {\n      fallback = null;\n    }\n\n    if (format === void 0) {\n      format = null;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.Url);\n    var url = String(urlArg);\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture.baseWidth = this._options.textureSize;\n    texture.baseHeight = this._options.textureSize;\n    texture.width = this._options.textureSize;\n    texture.height = this._options.textureSize;\n\n    if (format) {\n      texture.format = format;\n    }\n\n    texture.isReady = true;\n\n    if (onLoad) {\n      onLoad();\n    }\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n  /**\r\n   * Creates a new render target texture\r\n   * @param size defines the size of the texture\r\n   * @param options defines the options used to create the texture\r\n   * @returns a new render target texture stored in an InternalTexture\r\n   */\n\n\n  NullEngine.prototype.createRenderTargetTexture = function (size, options) {\n    var fullOptions = new RenderTargetCreationOptions();\n\n    if (options !== undefined && typeof options === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.generateDepthBuffer = true;\n      fullOptions.generateStencilBuffer = false;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n    var width = size.width || size;\n    var height = size.height || size;\n    texture._depthStencilBuffer = {};\n    texture._framebuffer = {};\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    texture._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n  /**\r\n   * Update the sampling mode of a given texture\r\n   * @param samplingMode defines the required sampling mode\r\n   * @param texture defines the texture to update\r\n   */\n\n\n  NullEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture) {\n    texture.samplingMode = samplingMode;\n  };\n  /**\r\n   * Binds the frame buffer to the specified texture.\r\n   * @param texture The texture to render to or null for the default canvas\r\n   * @param faceIndex The face of the texture to render to in case of cube texture\r\n   * @param requiredWidth The width of the target to render to\r\n   * @param requiredHeight The height of the target to render to\r\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n   * @param lodLevel defines le lod level to bind to the frame buffer\r\n   */\n\n\n  NullEngine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n\n    this._currentRenderTarget = texture;\n    this._currentFramebuffer = texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer;\n\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    }\n  };\n  /**\r\n   * Unbind the current render target texture from the webGL context\r\n   * @param texture defines the render target texture to unbind\r\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n   */\n\n\n  NullEngine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {\n    if (disableGenerateMipMaps === void 0) {\n      disableGenerateMipMaps = false;\n    }\n\n    this._currentRenderTarget = null;\n\n    if (onBeforeUnbind) {\n      if (texture._MSAAFramebuffer) {\n        this._currentFramebuffer = texture._framebuffer;\n      }\n\n      onBeforeUnbind();\n    }\n\n    this._currentFramebuffer = null;\n  };\n  /**\r\n   * Creates a dynamic vertex buffer\r\n   * @param vertices the data for the dynamic vertex buffer\r\n   * @returns the new WebGL dynamic buffer\r\n   */\n\n\n  NullEngine.prototype.createDynamicVertexBuffer = function (vertices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    buffer.capacity = 1;\n    return buffer;\n  };\n  /**\r\n   * Update the content of a dynamic texture\r\n   * @param texture defines the texture to update\r\n   * @param canvas defines the canvas containing the source\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param premulAlpha defines if alpha is stored as premultiplied\r\n   * @param format defines the format of the data\r\n   * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n   */\n\n\n  NullEngine.prototype.updateDynamicTexture = function (texture, canvas, invertY, premulAlpha, format) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n  };\n  /**\r\n   * Gets a boolean indicating if all created effects are ready\r\n   * @returns true if all effects are ready\r\n   */\n\n\n  NullEngine.prototype.areAllEffectsReady = function () {\n    return true;\n  };\n  /**\r\n   * @hidden\r\n   * Get the current error code of the webGL context\r\n   * @returns the error code\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\r\n   */\n\n\n  NullEngine.prototype.getError = function () {\n    return 0;\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._getUnpackAlignement = function () {\n    return 1;\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._unpackFlipY = function (value) {};\n  /**\r\n   * Update a dynamic index buffer\r\n   * @param indexBuffer defines the target index buffer\r\n   * @param indices defines the data to update\r\n   * @param offset defines the offset in the target index buffer where update should start\r\n   */\n\n\n  NullEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n  };\n  /**\r\n   * Updates a dynamic vertex buffer.\r\n   * @param vertexBuffer the vertex buffer to update\r\n   * @param vertices the data used to update the vertex buffer\r\n   * @param byteOffset the byte offset of the data (optional)\r\n   * @param byteLength the byte length of the data (optional)\r\n   */\n\n\n  NullEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, vertices, byteOffset, byteLength) {};\n  /** @hidden */\n\n\n  NullEngine.prototype._bindTextureDirectly = function (target, texture) {\n    if (this._boundTexturesCache[this._activeChannel] !== texture) {\n      this._boundTexturesCache[this._activeChannel] = texture;\n      return true;\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._bindTexture = function (channel, texture) {\n    if (channel < 0) {\n      return;\n    }\n\n    this._bindTextureDirectly(0, texture);\n  };\n\n  NullEngine.prototype._deleteBuffer = function (buffer) {};\n  /**\r\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n   */\n\n\n  NullEngine.prototype.releaseEffects = function () {};\n\n  NullEngine.prototype.displayLoadingUI = function () {};\n\n  NullEngine.prototype.hideLoadingUI = function () {};\n  /** @hidden */\n\n\n  NullEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, data, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n\n  return NullEngine;\n}(Engine);\n\nexport { NullEngine };","map":null,"metadata":{},"sourceType":"module"}