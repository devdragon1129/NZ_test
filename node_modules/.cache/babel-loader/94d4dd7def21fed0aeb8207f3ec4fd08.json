{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\n\nvar PanoramaToCubeMapTools =\n/** @class */\nfunction () {\n  function PanoramaToCubeMapTools() {}\n  /**\r\n   * Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).\r\n   *\r\n   * @param float32Array The source data.\r\n   * @param inputWidth The width of the input panorama.\r\n   * @param inputHeight The height of the input panorama.\r\n   * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n   * @return The cubemap data\r\n   */\n\n\n  PanoramaToCubeMapTools.ConvertPanoramaToCubemap = function (float32Array, inputWidth, inputHeight, size) {\n    if (!float32Array) {\n      throw \"ConvertPanoramaToCubemap: input cannot be null\";\n    }\n\n    if (float32Array.length != inputWidth * inputHeight * 3) {\n      throw \"ConvertPanoramaToCubemap: input size is wrong\";\n    }\n\n    var textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\n    var textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\n    var textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\n    var textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\n    var textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\n    var textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\n    return {\n      front: textureFront,\n      back: textureBack,\n      left: textureLeft,\n      right: textureRight,\n      up: textureUp,\n      down: textureDown,\n      size: size,\n      type: 1,\n      format: 4,\n      gammaSpace: false\n    };\n  };\n\n  PanoramaToCubeMapTools.CreateCubemapTexture = function (texSize, faceData, float32Array, inputWidth, inputHeight) {\n    var buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n    var textureArray = new Float32Array(buffer);\n    var rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\n    var rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\n    var dy = 1 / texSize;\n    var fy = 0;\n\n    for (var y = 0; y < texSize; y++) {\n      var xv1 = faceData[0];\n      var xv2 = faceData[2];\n\n      for (var x = 0; x < texSize; x++) {\n        var v = xv2.subtract(xv1).scale(fy).add(xv1);\n        v.normalize();\n        var color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight); // 3 channels per pixels\n\n        textureArray[y * texSize * 3 + x * 3 + 0] = color.r;\n        textureArray[y * texSize * 3 + x * 3 + 1] = color.g;\n        textureArray[y * texSize * 3 + x * 3 + 2] = color.b;\n        xv1 = xv1.add(rotDX1);\n        xv2 = xv2.add(rotDX2);\n      }\n\n      fy += dy;\n    }\n\n    return textureArray;\n  };\n\n  PanoramaToCubeMapTools.CalcProjectionSpherical = function (vDir, float32Array, inputWidth, inputHeight) {\n    var theta = Math.atan2(vDir.z, vDir.x);\n    var phi = Math.acos(vDir.y);\n\n    while (theta < -Math.PI) {\n      theta += 2 * Math.PI;\n    }\n\n    while (theta > Math.PI) {\n      theta -= 2 * Math.PI;\n    }\n\n    var dx = theta / Math.PI;\n    var dy = phi / Math.PI; // recenter.\n\n    dx = dx * 0.5 + 0.5;\n    var px = Math.round(dx * inputWidth);\n\n    if (px < 0) {\n      px = 0;\n    } else if (px >= inputWidth) {\n      px = inputWidth - 1;\n    }\n\n    var py = Math.round(dy * inputHeight);\n\n    if (py < 0) {\n      py = 0;\n    } else if (py >= inputHeight) {\n      py = inputHeight - 1;\n    }\n\n    var inputY = inputHeight - py - 1;\n    var r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\n    var g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\n    var b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  };\n\n  PanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\n  PanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\n  PanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\n  return PanoramaToCubeMapTools;\n}();\n\nexport { PanoramaToCubeMapTools };","map":null,"metadata":{},"sourceType":"module"}