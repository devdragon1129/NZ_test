{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color3, TmpColors } from \"../Maths/math.color\";\nimport { Node } from \"../node\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\n\nvar Light =\n/** @class */\nfunction (_super) {\n  __extends(Light, _super);\n  /**\r\n   * Creates a Light object in the scene.\r\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n   * @param name The firendly name of the light\r\n   * @param scene The scene the light belongs too\r\n   */\n\n\n  function Light(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\n\n\n    _this.diffuse = new Color3(1.0, 1.0, 1.0);\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is note affecting PBR materials.\r\n     */\n\n    _this.specular = new Color3(1.0, 1.0, 1.0);\n    /**\r\n     * Defines the falloff type for this light. This lets overrriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\n\n    _this.falloffType = Light.FALLOFF_DEFAULT;\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\n\n    _this.intensity = 1.0;\n    _this._range = Number.MAX_VALUE;\n    _this._inverseSquaredRange = 0;\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\n\n    _this._photometricScale = 1.0;\n    _this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n    _this._radius = 0.00001;\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\n\n    _this.renderPriority = 0;\n    _this._shadowEnabled = true;\n    _this._excludeWithLayerMask = 0;\n    _this._includeOnlyWithLayerMask = 0;\n    _this._lightmapMode = 0;\n    /**\r\n     * @hidden Internal use only.\r\n     */\n\n    _this._excludedMeshesIds = new Array();\n    /**\r\n     * @hidden Internal use only.\r\n     */\n\n    _this._includedOnlyMeshesIds = new Array();\n    /** @hidden */\n\n    _this._isLight = true;\n\n    _this.getScene().addLight(_this);\n\n    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine());\n\n    _this._buildUniformLayout();\n\n    _this.includedOnlyMeshes = new Array();\n    _this.excludedMeshes = new Array();\n\n    _this._resyncMeshes();\n\n    return _this;\n  }\n\n  Object.defineProperty(Light.prototype, \"range\", {\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\n    get: function get() {\n      return this._range;\n    },\n\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\n    set: function set(value) {\n      this._range = value;\n      this._inverseSquaredRange = 1.0 / (this.range * this.range);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"intensityMode\", {\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\n    get: function get() {\n      return this._intensityMode;\n    },\n\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\n    set: function set(value) {\n      this._intensityMode = value;\n\n      this._computePhotometricScale();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"radius\", {\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\n    get: function get() {\n      return this._radius;\n    },\n\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\n    set: function set(value) {\n      this._radius = value;\n\n      this._computePhotometricScale();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"shadowEnabled\", {\n    /**\r\n     * Gets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\n    get: function get() {\n      return this._shadowEnabled;\n    },\n\n    /**\r\n     * Sets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\n    set: function set(value) {\n      if (this._shadowEnabled === value) {\n        return;\n      }\n\n      this._shadowEnabled = value;\n\n      this._markMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"includedOnlyMeshes\", {\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\n    get: function get() {\n      return this._includedOnlyMeshes;\n    },\n\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\n    set: function set(value) {\n      this._includedOnlyMeshes = value;\n\n      this._hookArrayForIncludedOnly(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"excludedMeshes\", {\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\n    get: function get() {\n      return this._excludedMeshes;\n    },\n\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\n    set: function set(value) {\n      this._excludedMeshes = value;\n\n      this._hookArrayForExcluded(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"excludeWithLayerMask\", {\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\n    get: function get() {\n      return this._excludeWithLayerMask;\n    },\n\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\n    set: function set(value) {\n      this._excludeWithLayerMask = value;\n\n      this._resyncMeshes();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"includeOnlyWithLayerMask\", {\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\n    get: function get() {\n      return this._includeOnlyWithLayerMask;\n    },\n\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\n    set: function set(value) {\n      this._includeOnlyWithLayerMask = value;\n\n      this._resyncMeshes();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"lightmapMode\", {\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\n    get: function get() {\n      return this._lightmapMode;\n    },\n\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\n    set: function set(value) {\n      if (this._lightmapMode === value) {\n        return;\n      }\n\n      this._lightmapMode = value;\n\n      this._markMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the passed Effect \"effect\" with the Light textures.\r\n   * @param effect The effect to update\r\n   * @param lightIndex The index of the light in the effect to update\r\n   * @returns The light\r\n   */\n\n  Light.prototype.transferTexturesToEffect = function (effect, lightIndex) {\n    // Do nothing by default.\n    return this;\n  };\n  /**\r\n   * Binds the lights information from the scene to the effect for the given mesh.\r\n   * @param lightIndex Light index\r\n   * @param scene The scene where the light belongs to\r\n   * @param effect The effect we are binding the data to\r\n   * @param useSpecular Defines if specular is supported\r\n   * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n   */\n\n\n  Light.prototype._bindLight = function (lightIndex, scene, effect, useSpecular, rebuildInParallel) {\n    if (rebuildInParallel === void 0) {\n      rebuildInParallel = false;\n    }\n\n    var iAsString = lightIndex.toString();\n    var needUpdate = false;\n\n    if (rebuildInParallel && this._uniformBuffer._alreadyBound) {\n      return;\n    }\n\n    this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\n\n    if (this._renderId !== scene.getRenderId() || !this._uniformBuffer.useUbo) {\n      this._renderId = scene.getRenderId();\n      var scaledIntensity = this.getScaledIntensity();\n      this.transferToEffect(effect, iAsString);\n      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\n\n      this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\n\n      if (useSpecular) {\n        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\n\n        this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\n      }\n\n      needUpdate = true;\n    } // Textures might still need to be rebound.\n\n\n    this.transferTexturesToEffect(effect, iAsString); // Shadows\n\n    if (scene.shadowsEnabled && this.shadowEnabled) {\n      var shadowGenerator = this.getShadowGenerator();\n\n      if (shadowGenerator) {\n        shadowGenerator.bindShadowLight(iAsString, effect);\n        needUpdate = true;\n      }\n    }\n\n    if (needUpdate) {\n      this._uniformBuffer.update();\n    }\n  };\n  /**\r\n   * Returns the string \"Light\".\r\n   * @returns the class name\r\n   */\n\n\n  Light.prototype.getClassName = function () {\n    return \"Light\";\n  };\n  /**\r\n   * Converts the light information to a readable string for debug purpose.\r\n   * @param fullDetails Supports for multiple levels of logging within scene loading\r\n   * @returns the human readable light info\r\n   */\n\n\n  Light.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n    ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\n\n    if (this.animations) {\n      for (var i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n\n    if (fullDetails) {}\n\n    return ret;\n  };\n  /** @hidden */\n\n\n  Light.prototype._syncParentEnabledState = function () {\n    _super.prototype._syncParentEnabledState.call(this);\n\n    if (!this.isDisposed()) {\n      this._resyncMeshes();\n    }\n  };\n  /**\r\n   * Set the enabled state of this node.\r\n   * @param value - the new enabled state\r\n   */\n\n\n  Light.prototype.setEnabled = function (value) {\n    _super.prototype.setEnabled.call(this, value);\n\n    this._resyncMeshes();\n  };\n  /**\r\n   * Returns the Light associated shadow generator if any.\r\n   * @return the associated shadow generator.\r\n   */\n\n\n  Light.prototype.getShadowGenerator = function () {\n    return this._shadowGenerator;\n  };\n  /**\r\n   * Returns a Vector3, the absolute light position in the World.\r\n   * @returns the world space position of the light\r\n   */\n\n\n  Light.prototype.getAbsolutePosition = function () {\n    return Vector3.Zero();\n  };\n  /**\r\n   * Specifies if the light will affect the passed mesh.\r\n   * @param mesh The mesh to test against the light\r\n   * @return true the mesh is affected otherwise, false.\r\n   */\n\n\n  Light.prototype.canAffectMesh = function (mesh) {\n    if (!mesh) {\n      return true;\n    }\n\n    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n      return false;\n    }\n\n    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return false;\n    }\n\n    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n      return false;\n    }\n\n    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Sort function to order lights for rendering.\r\n   * @param a First Light object to compare to second.\r\n   * @param b Second Light object to compare first.\r\n   * @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\r\n   */\n\n\n  Light.CompareLightsPriority = function (a, b) {\n    //shadow-casting lights have priority over non-shadow-casting lights\n    //the renderPrioirty is a secondary sort criterion\n    if (a.shadowEnabled !== b.shadowEnabled) {\n      return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\n    }\n\n    return b.renderPriority - a.renderPriority;\n  };\n  /**\r\n   * Releases resources associated with this node.\r\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n   */\n\n\n  Light.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    if (this._shadowGenerator) {\n      this._shadowGenerator.dispose();\n\n      this._shadowGenerator = null;\n    } // Animations\n\n\n    this.getScene().stopAnimation(this); // Remove from meshes\n\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._removeLightSource(this, true);\n    }\n\n    this._uniformBuffer.dispose(); // Remove from scene\n\n\n    this.getScene().removeLight(this);\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\r\n   * Returns the light type ID (integer).\r\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n   */\n\n\n  Light.prototype.getTypeID = function () {\n    return 0;\n  };\n  /**\r\n   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n   * @returns the scaled intensity in intensity mode unit\r\n   */\n\n\n  Light.prototype.getScaledIntensity = function () {\n    return this._photometricScale * this.intensity;\n  };\n  /**\r\n   * Returns a new Light object, named \"name\", from the current one.\r\n   * @param name The name of the cloned light\r\n   * @param newParent The parent of this light, if it has one\r\n   * @returns the new created light\r\n   */\n\n\n  Light.prototype.clone = function (name, newParent) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    var constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\n\n    if (!constructor) {\n      return null;\n    }\n\n    var clonedLight = SerializationHelper.Clone(constructor, this);\n\n    if (newParent) {\n      clonedLight.parent = newParent;\n    }\n\n    clonedLight.setEnabled(this.isEnabled());\n    return clonedLight;\n  };\n  /**\r\n   * Serializes the current light into a Serialization object.\r\n   * @returns the serialized object.\r\n   */\n\n\n  Light.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this); // Type\n\n    serializationObject.type = this.getTypeID(); // Parent\n\n    if (this.parent) {\n      serializationObject.parentId = this.parent.id;\n    } // Inclusion / exclusions\n\n\n    if (this.excludedMeshes.length > 0) {\n      serializationObject.excludedMeshesIds = [];\n      this.excludedMeshes.forEach(function (mesh) {\n        serializationObject.excludedMeshesIds.push(mesh.id);\n      });\n    }\n\n    if (this.includedOnlyMeshes.length > 0) {\n      serializationObject.includedOnlyMeshesIds = [];\n      this.includedOnlyMeshes.forEach(function (mesh) {\n        serializationObject.includedOnlyMeshesIds.push(mesh.id);\n      });\n    } // Animations\n\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    return serializationObject;\n  };\n  /**\r\n   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n   * This new light is named \"name\" and added to the passed scene.\r\n   * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n   * @param name The friendly name of the light\r\n   * @param scene The scene the new light will belong to\r\n   * @returns the constructor function\r\n   */\n\n\n  Light.GetConstructorFromName = function (type, name, scene) {\n    var constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\n\n    if (constructorFunc) {\n      return constructorFunc;\n    } // Default to no light for none present once.\n\n\n    return null;\n  };\n  /**\r\n   * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n   * @param parsedLight The JSON representation of the light\r\n   * @param scene The scene to create the parsed light in\r\n   * @returns the created light after parsing\r\n   */\n\n\n  Light.Parse = function (parsedLight, scene) {\n    var constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\n\n    if (!constructor) {\n      return null;\n    }\n\n    var light = SerializationHelper.Parse(constructor, parsedLight, scene); // Inclusion / exclusions\n\n    if (parsedLight.excludedMeshesIds) {\n      light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n    }\n\n    if (parsedLight.includedOnlyMeshesIds) {\n      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n    } // Parent\n\n\n    if (parsedLight.parentId) {\n      light._waitingParentId = parsedLight.parentId;\n    } // Falloff\n\n\n    if (parsedLight.falloffType !== undefined) {\n      light.falloffType = parsedLight.falloffType;\n    } // Lightmaps\n\n\n    if (parsedLight.lightmapMode !== undefined) {\n      light.lightmapMode = parsedLight.lightmapMode;\n    } // Animations\n\n\n    if (parsedLight.animations) {\n      for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n        var parsedAnimation = parsedLight.animations[animationIndex];\n\n        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          light.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n\n      Node.ParseAnimationRanges(light, parsedLight, scene);\n    }\n\n    if (parsedLight.autoAnimate) {\n      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n    }\n\n    return light;\n  };\n\n  Light.prototype._hookArrayForExcluded = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {\n        var item = items_1[_a];\n\n        item._resyncLightSource(_this);\n      }\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      for (var _i = 0, deleted_1 = deleted; _i < deleted_1.length; _i++) {\n        var item = deleted_1[_i];\n\n        item._resyncLightSource(_this);\n      }\n\n      return deleted;\n    };\n\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n      var item = array_1[_i];\n\n      item._resyncLightSource(this);\n    }\n  };\n\n  Light.prototype._hookArrayForIncludedOnly = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      _this._resyncMeshes();\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      _this._resyncMeshes();\n\n      return deleted;\n    };\n\n    this._resyncMeshes();\n  };\n\n  Light.prototype._resyncMeshes = function () {\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._resyncLightSource(this);\n    }\n  };\n  /**\r\n   * Forces the meshes to update their light related information in their rendering used effects\r\n   * @hidden Internal Use Only\r\n   */\n\n\n  Light.prototype._markMeshesAsLightDirty = function () {\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.lightSources.indexOf(this) !== -1) {\n        mesh._markSubMeshesAsLightDirty();\n      }\n    }\n  };\n  /**\r\n   * Recomputes the cached photometric scale if needed.\r\n   */\n\n\n  Light.prototype._computePhotometricScale = function () {\n    this._photometricScale = this._getPhotometricScale();\n    this.getScene().resetCachedMaterial();\n  };\n  /**\r\n   * Returns the Photometric Scale according to the light type and intensity mode.\r\n   */\n\n\n  Light.prototype._getPhotometricScale = function () {\n    var photometricScale = 0.0;\n    var lightTypeID = this.getTypeID(); //get photometric mode\n\n    var photometricMode = this.intensityMode;\n\n    if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n      if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n        photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n      } else {\n        photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n      }\n    } //compute photometric scale\n\n\n    switch (lightTypeID) {\n      case Light.LIGHTTYPEID_POINTLIGHT:\n      case Light.LIGHTTYPEID_SPOTLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_LUMINOUSPOWER:\n            photometricScale = 1.0 / (4.0 * Math.PI);\n            break;\n\n          case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n            photometricScale = 1.0;\n            break;\n\n          case Light.INTENSITYMODE_LUMINANCE:\n            photometricScale = this.radius * this.radius;\n            break;\n        }\n\n        break;\n\n      case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_ILLUMINANCE:\n            photometricScale = 1.0;\n            break;\n\n          case Light.INTENSITYMODE_LUMINANCE:\n            // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n            // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n            var apexAngleRadians = this.radius; // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n\n            apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n            var solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n            photometricScale = solidAngle;\n            break;\n        }\n\n        break;\n\n      case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n        // No fall off in hemisperic light.\n        photometricScale = 1.0;\n        break;\n    }\n\n    return photometricScale;\n  };\n  /**\r\n   * Reorder the light in the scene according to their defined priority.\r\n   * @hidden Internal Use Only\r\n   */\n\n\n  Light.prototype._reorderLightsInScene = function () {\n    var scene = this.getScene();\n\n    if (this._renderPriority != 0) {\n      scene.requireLightSorting = true;\n    }\n\n    this.getScene().sortLightsByPriority();\n  };\n  /**\r\n   * Falloff Default: light is falling off following the material specification:\r\n   * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n   */\n\n\n  Light.FALLOFF_DEFAULT = 0;\n  /**\r\n   * Falloff Physical: light is falling off following the inverse squared distance law.\r\n   */\n\n  Light.FALLOFF_PHYSICAL = 1;\n  /**\r\n   * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n   * to enhance interoperability with other engines.\r\n   */\n\n  Light.FALLOFF_GLTF = 2;\n  /**\r\n   * Falloff Standard: light is falling off like in the standard material\r\n   * to enhance interoperability with other materials.\r\n   */\n\n  Light.FALLOFF_STANDARD = 3; //lightmapMode Consts\n\n  /**\r\n   * If every light affecting the material is in this lightmapMode,\r\n   * material.lightmapTexture adds or multiplies\r\n   * (depends on material.useLightmapAsShadowmap)\r\n   * after every other light calculations.\r\n   */\n\n  Light.LIGHTMAP_DEFAULT = 0;\n  /**\r\n   * material.lightmapTexture as only diffuse lighting from this light\r\n   * adds only specular lighting from this light\r\n   * adds dynamic shadows\r\n   */\n\n  Light.LIGHTMAP_SPECULAR = 1;\n  /**\r\n   * material.lightmapTexture as only lighting\r\n   * no light calculation from this light\r\n   * only adds dynamic shadows from this light\r\n   */\n\n  Light.LIGHTMAP_SHADOWSONLY = 2; // Intensity Mode Consts\n\n  /**\r\n   * Each light type uses the default quantity according to its type:\r\n   *      point/spot lights use luminous intensity\r\n   *      directional lights use illuminance\r\n   */\n\n  Light.INTENSITYMODE_AUTOMATIC = 0;\n  /**\r\n   * lumen (lm)\r\n   */\n\n  Light.INTENSITYMODE_LUMINOUSPOWER = 1;\n  /**\r\n   * candela (lm/sr)\r\n   */\n\n  Light.INTENSITYMODE_LUMINOUSINTENSITY = 2;\n  /**\r\n   * lux (lm/m^2)\r\n   */\n\n  Light.INTENSITYMODE_ILLUMINANCE = 3;\n  /**\r\n   * nit (cd/m^2)\r\n   */\n\n  Light.INTENSITYMODE_LUMINANCE = 4; // Light types ids const.\n\n  /**\r\n   * Light type const id of the point light.\r\n   */\n\n  Light.LIGHTTYPEID_POINTLIGHT = 0;\n  /**\r\n   * Light type const id of the directional light.\r\n   */\n\n  Light.LIGHTTYPEID_DIRECTIONALLIGHT = 1;\n  /**\r\n   * Light type const id of the spot light.\r\n   */\n\n  Light.LIGHTTYPEID_SPOTLIGHT = 2;\n  /**\r\n   * Light type const id of the hemispheric light.\r\n   */\n\n  Light.LIGHTTYPEID_HEMISPHERICLIGHT = 3;\n\n  __decorate([serializeAsColor3()], Light.prototype, \"diffuse\", void 0);\n\n  __decorate([serializeAsColor3()], Light.prototype, \"specular\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"falloffType\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"intensity\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"range\", null);\n\n  __decorate([serialize()], Light.prototype, \"intensityMode\", null);\n\n  __decorate([serialize()], Light.prototype, \"radius\", null);\n\n  __decorate([serialize()], Light.prototype, \"_renderPriority\", void 0);\n\n  __decorate([expandToProperty(\"_reorderLightsInScene\")], Light.prototype, \"renderPriority\", void 0);\n\n  __decorate([serialize(\"shadowEnabled\")], Light.prototype, \"_shadowEnabled\", void 0);\n\n  __decorate([serialize(\"excludeWithLayerMask\")], Light.prototype, \"_excludeWithLayerMask\", void 0);\n\n  __decorate([serialize(\"includeOnlyWithLayerMask\")], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n\n  __decorate([serialize(\"lightmapMode\")], Light.prototype, \"_lightmapMode\", void 0);\n\n  return Light;\n}(Node);\n\nexport { Light };","map":null,"metadata":{},"sourceType":"module"}