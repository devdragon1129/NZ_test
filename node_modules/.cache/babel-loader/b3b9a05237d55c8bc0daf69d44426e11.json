{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Epsilon } from '../Maths/math.constants';\n/**\r\n * Class used to store bounding box information\r\n */\n\nvar BoundingBox =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new bounding box\r\n   * @param min defines the minimum vector (in local space)\r\n   * @param max defines the maximum vector (in local space)\r\n   * @param worldMatrix defines the new world matrix\r\n   */\n  function BoundingBox(min, max, worldMatrix) {\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\n    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\n\n    this.center = Vector3.Zero();\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\n\n    this.centerWorld = Vector3.Zero();\n    /**\r\n     * Gets the extend size in local space\r\n     */\n\n    this.extendSize = Vector3.Zero();\n    /**\r\n     * Gets the extend size in world space\r\n     */\n\n    this.extendSizeWorld = Vector3.Zero();\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\n\n    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\n\n    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\n\n    this.minimumWorld = Vector3.Zero();\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\n\n    this.maximumWorld = Vector3.Zero();\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\n\n    this.minimum = Vector3.Zero();\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\n\n    this.maximum = Vector3.Zero();\n    this.reConstruct(min, max, worldMatrix);\n  } // Methods\n\n  /**\r\n   * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n   * @param min defines the new minimum vector (in local space)\r\n   * @param max defines the new maximum vector (in local space)\r\n   * @param worldMatrix defines the new world matrix\r\n   */\n\n\n  BoundingBox.prototype.reConstruct = function (min, max, worldMatrix) {\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n    var vectors = this.vectors;\n    this.minimum.copyFromFloats(minX, minY, minZ);\n    this.maximum.copyFromFloats(maxX, maxY, maxZ);\n    vectors[0].copyFromFloats(minX, minY, minZ);\n    vectors[1].copyFromFloats(maxX, maxY, maxZ);\n    vectors[2].copyFromFloats(maxX, minY, minZ);\n    vectors[3].copyFromFloats(minX, maxY, minZ);\n    vectors[4].copyFromFloats(minX, minY, maxZ);\n    vectors[5].copyFromFloats(maxX, maxY, minZ);\n    vectors[6].copyFromFloats(minX, maxY, maxZ);\n    vectors[7].copyFromFloats(maxX, minY, maxZ); // OBB\n\n    max.addToRef(min, this.center).scaleInPlace(0.5);\n    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\n    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\n\n    this._update(this._worldMatrix);\n  };\n  /**\r\n   * Scale the current bounding box by applying a scale factor\r\n   * @param factor defines the scale factor to apply\r\n   * @returns the current bounding box\r\n   */\n\n\n  BoundingBox.prototype.scale = function (factor) {\n    var tmpVectors = BoundingBox.TmpVector3;\n    var diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\n    var len = diff.length();\n    diff.normalizeFromLength(len);\n    var distance = len * factor;\n    var newRadius = diff.scaleInPlace(distance * 0.5);\n    var min = this.center.subtractToRef(newRadius, tmpVectors[1]);\n    var max = this.center.addToRef(newRadius, tmpVectors[2]);\n    this.reConstruct(min, max, this._worldMatrix);\n    return this;\n  };\n  /**\r\n   * Gets the world matrix of the bounding box\r\n   * @returns a matrix\r\n   */\n\n\n  BoundingBox.prototype.getWorldMatrix = function () {\n    return this._worldMatrix;\n  };\n  /** @hidden */\n\n\n  BoundingBox.prototype._update = function (world) {\n    var minWorld = this.minimumWorld;\n    var maxWorld = this.maximumWorld;\n    var directions = this.directions;\n    var vectorsWorld = this.vectorsWorld;\n    var vectors = this.vectors;\n\n    if (!world.isIdentity()) {\n      minWorld.setAll(Number.MAX_VALUE);\n      maxWorld.setAll(-Number.MAX_VALUE);\n\n      for (var index = 0; index < 8; ++index) {\n        var v = vectorsWorld[index];\n        Vector3.TransformCoordinatesToRef(vectors[index], world, v);\n        minWorld.minimizeInPlace(v);\n        maxWorld.maximizeInPlace(v);\n      } // Extend\n\n\n      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\n      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\n    } else {\n      minWorld.copyFrom(this.minimum);\n      maxWorld.copyFrom(this.maximum);\n\n      for (var index = 0; index < 8; ++index) {\n        vectorsWorld[index].copyFrom(vectors[index]);\n      } // Extend\n\n\n      this.extendSizeWorld.copyFrom(this.extendSize);\n      this.centerWorld.copyFrom(this.center);\n    }\n\n    Vector3.FromArrayToRef(world.m, 0, directions[0]);\n    Vector3.FromArrayToRef(world.m, 4, directions[1]);\n    Vector3.FromArrayToRef(world.m, 8, directions[2]);\n    this._worldMatrix = world;\n  };\n  /**\r\n   * Tests if the bounding box is intersecting the frustum planes\r\n   * @param frustumPlanes defines the frustum planes to test\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.prototype.isInFrustum = function (frustumPlanes) {\n    return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\n  };\n  /**\r\n   * Tests if the bounding box is entirely inside the frustum planes\r\n   * @param frustumPlanes defines the frustum planes to test\r\n   * @returns true if there is an inclusion\r\n   */\n\n\n  BoundingBox.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\n  };\n  /**\r\n   * Tests if a point is inside the bounding box\r\n   * @param point defines the point to test\r\n   * @returns true if the point is inside the bounding box\r\n   */\n\n\n  BoundingBox.prototype.intersectsPoint = function (point) {\n    var min = this.minimumWorld;\n    var max = this.maximumWorld;\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n    var pointX = point.x,\n        pointY = point.y,\n        pointZ = point.z;\n    var delta = -Epsilon;\n\n    if (maxX - pointX < delta || delta > pointX - minX) {\n      return false;\n    }\n\n    if (maxY - pointY < delta || delta > pointY - minY) {\n      return false;\n    }\n\n    if (maxZ - pointZ < delta || delta > pointZ - minZ) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Tests if the bounding box intersects with a bounding sphere\r\n   * @param sphere defines the sphere to test\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.prototype.intersectsSphere = function (sphere) {\n    return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\n  };\n  /**\r\n   * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n   * @param min defines the min vector to use\r\n   * @param max defines the max vector to use\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.prototype.intersectsMinMax = function (min, max) {\n    var myMin = this.minimumWorld;\n    var myMax = this.maximumWorld;\n    var myMinX = myMin.x,\n        myMinY = myMin.y,\n        myMinZ = myMin.z,\n        myMaxX = myMax.x,\n        myMaxY = myMax.y,\n        myMaxZ = myMax.z;\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n\n    if (myMaxX < minX || myMinX > maxX) {\n      return false;\n    }\n\n    if (myMaxY < minY || myMinY > maxY) {\n      return false;\n    }\n\n    if (myMaxZ < minZ || myMinZ > maxZ) {\n      return false;\n    }\n\n    return true;\n  }; // Statics\n\n  /**\r\n   * Tests if two bounding boxes are intersections\r\n   * @param box0 defines the first box to test\r\n   * @param box1 defines the second box to test\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.Intersects = function (box0, box1) {\n    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\n  };\n  /**\r\n   * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n   * @param minPoint defines the minimum vector of the bounding box\r\n   * @param maxPoint defines the maximum vector of the bounding box\r\n   * @param sphereCenter defines the sphere center\r\n   * @param sphereRadius defines the sphere radius\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.IntersectsSphere = function (minPoint, maxPoint, sphereCenter, sphereRadius) {\n    var vector = BoundingBox.TmpVector3[0];\n    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\n    var num = Vector3.DistanceSquared(sphereCenter, vector);\n    return num <= sphereRadius * sphereRadius;\n  };\n  /**\r\n   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n   * @param frustumPlanes defines the frustum planes to test\r\n   * @return true if there is an inclusion\r\n   */\n\n\n  BoundingBox.IsCompletelyInFrustum = function (boundingVectors, frustumPlanes) {\n    for (var p = 0; p < 6; ++p) {\n      var frustumPlane = frustumPlanes[p];\n\n      for (var i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n   * @param frustumPlanes defines the frustum planes to test\r\n   * @return true if there is an intersection\r\n   */\n\n\n  BoundingBox.IsInFrustum = function (boundingVectors, frustumPlanes) {\n    for (var p = 0; p < 6; ++p) {\n      var canReturnFalse = true;\n      var frustumPlane = frustumPlanes[p];\n\n      for (var i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\n          canReturnFalse = false;\n          break;\n        }\n      }\n\n      if (canReturnFalse) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  BoundingBox.TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\n  return BoundingBox;\n}();\n\nexport { BoundingBox };","map":null,"metadata":{},"sourceType":"module"}