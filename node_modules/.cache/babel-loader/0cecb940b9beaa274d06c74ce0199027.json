{"ast":null,"code":"import { __assign, __decorate } from \"tslib\";\nimport { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\nimport { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { Color4 } from '../Maths/math.color';\nimport { Engine } from \"../Engines/engine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { Material } from \"../Materials/material\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport \"../Shaders/glowMapGeneration.fragment\";\nimport \"../Shaders/glowMapGeneration.vertex\";\nimport { _DevTools } from '../Misc/devTools';\nimport { EffectFallbacks } from '../Materials/effectFallbacks';\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or higlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\n\nvar EffectLayer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new effect Layer and references it in the scene.\r\n   * @param name The name of the layer\r\n   * @param scene The scene to use the layer in\r\n   */\n  function EffectLayer(\n  /** The Friendly of the effect in the scene */\n  name, scene) {\n    this._vertexBuffers = {};\n    this._maxSize = 0;\n    this._mainTextureDesiredSize = {\n      width: 0,\n      height: 0\n    };\n    this._shouldRender = true;\n    this._postProcesses = [];\n    this._textures = [];\n    this._emissiveTextureAndColor = {\n      texture: null,\n      color: new Color4()\n    };\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\n\n    this.neutralColor = new Color4();\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\n\n    this.isEnabled = true;\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\n\n    this.disableBoundingBoxesFromEffectLayer = false;\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\n\n    this.onDisposeObservable = new Observable();\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\n\n    this.onBeforeRenderMainTextureObservable = new Observable();\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\n\n    this.onBeforeComposeObservable = new Observable();\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\n\n    this.onBeforeRenderMeshToEffect = new Observable();\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\n\n    this.onAfterRenderMeshToEffect = new Observable();\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\n\n    this.onAfterComposeObservable = new Observable();\n    /**\r\n     * An event triggered when the efffect layer changes its size.\r\n     */\n\n    this.onSizeChangedObservable = new Observable();\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    EffectLayer._SceneComponentInitialization(this._scene);\n\n    this._engine = this._scene.getEngine();\n    this._maxSize = this._engine.getCaps().maxTextureSize;\n\n    this._scene.effectLayers.push(this); // Generate Buffers\n\n\n    this._generateIndexBuffer();\n\n    this._generateVertexBuffer();\n  }\n\n  Object.defineProperty(EffectLayer.prototype, \"camera\", {\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\n    get: function get() {\n      return this._effectLayerOptions.camera;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EffectLayer.prototype, \"renderingGroupId\", {\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\n    get: function get() {\n      return this._effectLayerOptions.renderingGroupId;\n    },\n    set: function set(renderingGroupId) {\n      this._effectLayerOptions.renderingGroupId = renderingGroupId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initializes the effect layer with the required options.\r\n   * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n   */\n\n  EffectLayer.prototype._init = function (options) {\n    // Adapt options\n    this._effectLayerOptions = __assign({\n      mainTextureRatio: 0.5,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1\n    }, options);\n\n    this._setMainTextureSize();\n\n    this._createMainTexture();\n\n    this._createTextureAndPostProcesses();\n\n    this._mergeEffect = this._createMergeEffect();\n  };\n  /**\r\n   * Generates the index buffer of the full screen quad blending to the main canvas.\r\n   */\n\n\n  EffectLayer.prototype._generateIndexBuffer = function () {\n    // Indices\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  };\n  /**\r\n   * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n   */\n\n\n  EffectLayer.prototype._generateVertexBuffer = function () {\n    // VBO\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    var vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n  };\n  /**\r\n   * Sets the main texture desired size which is the closest power of two\r\n   * of the engine canvas size.\r\n   */\n\n\n  EffectLayer.prototype._setMainTextureSize = function () {\n    if (this._effectLayerOptions.mainTextureFixedSize) {\n      this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\n      this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\n    } else {\n      this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;\n      this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;\n    }\n\n    this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\n    this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\n  };\n  /**\r\n   * Creates the main texture for the effect layer.\r\n   */\n\n\n  EffectLayer.prototype._createMainTexture = function () {\n    var _this = this;\n\n    this._mainTexture = new RenderTargetTexture(\"HighlightLayerMainRTT\", {\n      width: this._mainTextureDesiredSize.width,\n      height: this._mainTextureDesiredSize.height\n    }, this._scene, false, true, 0);\n    this._mainTexture.activeCamera = this._effectLayerOptions.camera;\n    this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.anisotropicFilteringLevel = 1;\n\n    this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._mainTexture.renderParticles = false;\n    this._mainTexture.renderList = null;\n    this._mainTexture.ignoreCameraViewport = true; // Custom render function\n\n    this._mainTexture.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      _this.onBeforeRenderMainTextureObservable.notifyObservers(_this);\n\n      var index;\n\n      var engine = _this._scene.getEngine();\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          _this._renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        _this._renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        _this._renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      var previousAlphaMode = engine.getAlphaMode();\n\n      for (index = 0; index < transparentSubMeshes.length; index++) {\n        _this._renderSubMesh(transparentSubMeshes.data[index], true);\n      }\n\n      engine.setAlphaMode(previousAlphaMode);\n    };\n\n    this._mainTexture.onClearObservable.add(function (engine) {\n      engine.clear(_this.neutralColor, true, true, true);\n    });\n\n    var boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\n\n    this._mainTexture.onBeforeBindObservable.add(function () {\n      _this._scene.getBoundingBoxRenderer().enabled = !_this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\n    });\n\n    this._mainTexture.onAfterUnbindObservable.add(function () {\n      _this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\n    });\n  };\n  /**\r\n   * Adds specific effects defines.\r\n   * @param defines The defines to add specifics to.\r\n   */\n\n\n  EffectLayer.prototype._addCustomEffectDefines = function (defines) {// Nothing to add by default.\n  };\n  /**\r\n   * Checks for the readiness of the element composing the layer.\r\n   * @param subMesh the mesh to check for\r\n   * @param useInstances specify whether or not to use instances to render the mesh\r\n   * @param emissiveTexture the associated emissive texture used to generate the glow\r\n   * @return true if ready otherwise, false\r\n   */\n\n\n  EffectLayer.prototype._isReady = function (subMesh, useInstances, emissiveTexture) {\n    var material = subMesh.getMaterial();\n\n    if (!material) {\n      return false;\n    }\n\n    if (!material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\n      return false;\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind];\n    var mesh = subMesh.getMesh();\n    var uv1 = false;\n    var uv2 = false; // Diffuse\n\n    if (material) {\n      var needAlphaTest = material.needAlphaTesting();\n      var diffuseTexture = material.getAlphaTestTexture();\n      var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n\n      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n        defines.push(\"#define DIFFUSE\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\n          defines.push(\"#define DIFFUSEUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define DIFFUSEUV1\");\n          uv1 = true;\n        }\n\n        if (needAlphaTest) {\n          defines.push(\"#define ALPHATEST\");\n          defines.push(\"#define ALPHATESTVALUE 0.4\");\n        }\n      }\n\n      var opacityTexture = material.opacityTexture;\n\n      if (opacityTexture) {\n        defines.push(\"#define OPACITY\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\n          defines.push(\"#define OPACITYUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define OPACITYUV1\");\n          uv1 = true;\n        }\n      }\n    } // Emissive\n\n\n    if (emissiveTexture) {\n      defines.push(\"#define EMISSIVE\");\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\n        defines.push(\"#define EMISSIVEUV2\");\n        uv2 = true;\n      } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        defines.push(\"#define EMISSIVEUV1\");\n        uv1 = true;\n      }\n    } // Vertex\n\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXALPHA\");\n    }\n\n    if (uv1) {\n      attribs.push(VertexBuffer.UVKind);\n      defines.push(\"#define UV1\");\n    }\n\n    if (uv2) {\n      attribs.push(VertexBuffer.UV2Kind);\n      defines.push(\"#define UV2\");\n    } // Bones\n\n\n    var fallbacks = new EffectFallbacks();\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      var skeleton = mesh.skeleton;\n\n      if (skeleton && skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\n      }\n\n      if (mesh.numBoneInfluencers > 0) {\n        fallbacks.addCPUSkinningFallback(0, mesh);\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var manager = mesh.morphTargetManager;\n    var morphInfluencers = 0;\n\n    if (manager) {\n      if (manager.numInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        morphInfluencers = manager.numInfluencers;\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n\n    this._addCustomEffectDefines(defines); // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effectLayerMapGenerationEffect = this._scene.getEngine().createEffect(\"glowMapGeneration\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"glowColor\", \"morphTargetInfluences\", \"boneTextureWidth\", \"diffuseMatrix\", \"emissiveMatrix\", \"opacityMatrix\", \"opacityIntensity\"], [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\"], join, fallbacks, undefined, undefined, {\n        maxSimultaneousMorphTargets: morphInfluencers\n      });\n    }\n\n    return this._effectLayerMapGenerationEffect.isReady();\n  };\n  /**\r\n   * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n   */\n\n\n  EffectLayer.prototype.render = function () {\n    var currentEffect = this._mergeEffect; // Check\n\n    if (!currentEffect.isReady()) {\n      return;\n    }\n\n    for (var i = 0; i < this._postProcesses.length; i++) {\n      if (!this._postProcesses[i].isReady()) {\n        return;\n      }\n    }\n\n    var engine = this._scene.getEngine();\n\n    this.onBeforeComposeObservable.notifyObservers(this); // Render\n\n    engine.enableEffect(currentEffect);\n    engine.setState(false); // VBOs\n\n    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect); // Cache\n\n    var previousAlphaMode = engine.getAlphaMode(); // Go Blend.\n\n    engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode); // Blends the map on the main canvas.\n\n    this._internalRender(currentEffect); // Restore Alpha\n\n\n    engine.setAlphaMode(previousAlphaMode);\n    this.onAfterComposeObservable.notifyObservers(this); // Handle size changes.\n\n    var size = this._mainTexture.getSize();\n\n    this._setMainTextureSize();\n\n    if (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) {\n      // Recreate RTT and post processes on size change.\n      this.onSizeChangedObservable.notifyObservers(this);\n\n      this._disposeTextureAndPostProcesses();\n\n      this._createMainTexture();\n\n      this._createTextureAndPostProcesses();\n    }\n  };\n  /**\r\n   * Determine if a given mesh will be used in the current effect.\r\n   * @param mesh mesh to test\r\n   * @returns true if the mesh will be used\r\n   */\n\n\n  EffectLayer.prototype.hasMesh = function (mesh) {\n    if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns true if the layer contains information to display, otherwise false.\r\n   * @returns true if the glow layer should be rendered\r\n   */\n\n\n  EffectLayer.prototype.shouldRender = function () {\n    return this.isEnabled && this._shouldRender;\n  };\n  /**\r\n   * Returns true if the mesh should render, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @returns true if it should render otherwise false\r\n   */\n\n\n  EffectLayer.prototype._shouldRenderMesh = function (mesh) {\n    return true;\n  };\n  /**\r\n   * Returns true if the mesh can be rendered, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @param material The material used on the mesh\r\n   * @returns true if it can be rendered otherwise false\r\n   */\n\n\n  EffectLayer.prototype._canRenderMesh = function (mesh, material) {\n    return !material.needAlphaBlendingForMesh(mesh);\n  };\n  /**\r\n   * Returns true if the mesh should render, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @returns true if it should render otherwise false\r\n   */\n\n\n  EffectLayer.prototype._shouldRenderEmissiveTextureForMesh = function () {\n    return true;\n  };\n  /**\r\n   * Renders the submesh passed in parameter to the generation map.\r\n   */\n\n\n  EffectLayer.prototype._renderSubMesh = function (subMesh, enableAlphaMode) {\n    var _this = this;\n\n    var _a;\n\n    if (enableAlphaMode === void 0) {\n      enableAlphaMode = false;\n    }\n\n    if (!this.shouldRender()) {\n      return;\n    }\n\n    var material = subMesh.getMaterial();\n    var ownerMesh = subMesh.getMesh();\n    var replacementMesh = subMesh.getReplacementMesh();\n    var renderingMesh = subMesh.getRenderingMesh();\n    var effectiveMesh = subMesh.getEffectiveMesh();\n    var scene = this._scene;\n    var engine = scene.getEngine();\n    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n\n    if (!material) {\n      return;\n    } // Do not block in blend mode.\n\n\n    if (!this._canRenderMesh(renderingMesh, material)) {\n      return;\n    } // Culling\n\n\n    var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n\n    var mainDeterminant = renderingMesh._getWorldMatrixDeterminant();\n\n    if (mainDeterminant < 0) {\n      sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n    }\n\n    var reverse = sideOrientation === Material.ClockWiseSideOrientation;\n    engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse); // Managing instances\n\n    var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\n\n    if (batch.mustReturn) {\n      return;\n    } // Early Exit per mesh\n\n\n    if (!this._shouldRenderMesh(renderingMesh)) {\n      return;\n    }\n\n    var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n\n    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n\n    this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\n\n    if (this._useMeshMaterial(renderingMesh)) {\n      renderingMesh.render(subMesh, hardwareInstancedRendering, replacementMesh || undefined);\n    } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n      engine.enableEffect(this._effectLayerMapGenerationEffect);\n\n      renderingMesh._bind(subMesh, this._effectLayerMapGenerationEffect, Material.TriangleFillMode);\n\n      this._effectLayerMapGenerationEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n      this._effectLayerMapGenerationEffect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n\n      this._effectLayerMapGenerationEffect.setFloat4(\"glowColor\", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);\n\n      var needAlphaTest = material.needAlphaTesting();\n      var diffuseTexture = material.getAlphaTestTexture();\n      var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n\n      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n        this._effectLayerMapGenerationEffect.setTexture(\"diffuseSampler\", diffuseTexture);\n\n        var textureMatrix = diffuseTexture.getTextureMatrix();\n\n        if (textureMatrix) {\n          this._effectLayerMapGenerationEffect.setMatrix(\"diffuseMatrix\", textureMatrix);\n        }\n      }\n\n      var opacityTexture = material.opacityTexture;\n\n      if (opacityTexture) {\n        this._effectLayerMapGenerationEffect.setTexture(\"opacitySampler\", opacityTexture);\n\n        this._effectLayerMapGenerationEffect.setFloat(\"opacityIntensity\", opacityTexture.level);\n\n        var textureMatrix = opacityTexture.getTextureMatrix();\n\n        if (textureMatrix) {\n          this._effectLayerMapGenerationEffect.setMatrix(\"opacityMatrix\", textureMatrix);\n        }\n      } // Glow emissive only\n\n\n      if (this._emissiveTextureAndColor.texture) {\n        this._effectLayerMapGenerationEffect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\n\n        this._effectLayerMapGenerationEffect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\n      } // Bones\n\n\n      if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n        var skeleton = renderingMesh.skeleton;\n\n        if (skeleton.isUsingTextureForMatrices) {\n          var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n\n          if (!boneTexture) {\n            return;\n          }\n\n          this._effectLayerMapGenerationEffect.setTexture(\"boneSampler\", boneTexture);\n\n          this._effectLayerMapGenerationEffect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n        } else {\n          this._effectLayerMapGenerationEffect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n        }\n      } // Morph targets\n\n\n      MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effectLayerMapGenerationEffect); // Alpha mode\n\n      if (enableAlphaMode) {\n        engine.setAlphaMode(material.alphaMode);\n      } // Draw\n\n\n      renderingMesh._processRendering(effectiveMesh, subMesh, this._effectLayerMapGenerationEffect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n        return _this._effectLayerMapGenerationEffect.setMatrix(\"world\", world);\n      });\n    } else {\n      // Need to reset refresh rate of the main map\n      this._mainTexture.resetRefreshCounter();\n    }\n\n    this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\n  };\n  /**\r\n   * Defines whether the current material of the mesh should be use to render the effect.\r\n   * @param mesh defines the current mesh to render\r\n   */\n\n\n  EffectLayer.prototype._useMeshMaterial = function (mesh) {\n    return false;\n  };\n  /**\r\n   * Rebuild the required buffers.\r\n   * @hidden Internal use only.\r\n   */\n\n\n  EffectLayer.prototype._rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._generateIndexBuffer();\n  };\n  /**\r\n   * Dispose only the render target textures and post process.\r\n   */\n\n\n  EffectLayer.prototype._disposeTextureAndPostProcesses = function () {\n    this._mainTexture.dispose();\n\n    for (var i = 0; i < this._postProcesses.length; i++) {\n      if (this._postProcesses[i]) {\n        this._postProcesses[i].dispose();\n      }\n    }\n\n    this._postProcesses = [];\n\n    for (var i = 0; i < this._textures.length; i++) {\n      if (this._textures[i]) {\n        this._textures[i].dispose();\n      }\n    }\n\n    this._textures = [];\n  };\n  /**\r\n   * Dispose the highlight layer and free resources.\r\n   */\n\n\n  EffectLayer.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    } // Clean textures and post processes\n\n\n    this._disposeTextureAndPostProcesses(); // Remove from scene\n\n\n    var index = this._scene.effectLayers.indexOf(this, 0);\n\n    if (index > -1) {\n      this._scene.effectLayers.splice(index, 1);\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderMainTextureObservable.clear();\n    this.onBeforeComposeObservable.clear();\n    this.onBeforeRenderMeshToEffect.clear();\n    this.onAfterRenderMeshToEffect.clear();\n    this.onAfterComposeObservable.clear();\n    this.onSizeChangedObservable.clear();\n  };\n  /**\r\n    * Gets the class name of the effect layer\r\n    * @returns the string with the class name of the effect layer\r\n    */\n\n\n  EffectLayer.prototype.getClassName = function () {\n    return \"EffectLayer\";\n  };\n  /**\r\n   * Creates an effect layer from parsed effect layer data\r\n   * @param parsedEffectLayer defines effect layer data\r\n   * @param scene defines the current scene\r\n   * @param rootUrl defines the root URL containing the effect layer information\r\n   * @returns a parsed effect Layer\r\n   */\n\n\n  EffectLayer.Parse = function (parsedEffectLayer, scene, rootUrl) {\n    var effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\n    return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\n  };\n  /** @hidden */\n\n\n  EffectLayer._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"EffectLayerSceneComponent\");\n  };\n\n  __decorate([serialize()], EffectLayer.prototype, \"name\", void 0);\n\n  __decorate([serializeAsColor4()], EffectLayer.prototype, \"neutralColor\", void 0);\n\n  __decorate([serialize()], EffectLayer.prototype, \"isEnabled\", void 0);\n\n  __decorate([serializeAsCameraReference()], EffectLayer.prototype, \"camera\", null);\n\n  __decorate([serialize()], EffectLayer.prototype, \"renderingGroupId\", null);\n\n  __decorate([serialize()], EffectLayer.prototype, \"disableBoundingBoxesFromEffectLayer\", void 0);\n\n  return EffectLayer;\n}();\n\nexport { EffectLayer };","map":null,"metadata":{},"sourceType":"module"}