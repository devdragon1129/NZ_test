{"ast":null,"code":"import { Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateSphere = function (options) {\n  var segments = options.segments || 32;\n  var diameterX = options.diameterX || options.diameter || 1;\n  var diameterY = options.diameterY || options.diameter || 1;\n  var diameterZ = options.diameterZ || options.diameter || 1;\n  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  var slice = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var dedupTopBottomIndices = !!options.dedupTopBottomIndices;\n  var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\n  var totalZRotationSteps = 2 + segments;\n  var totalYRotationSteps = 2 * totalZRotationSteps;\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n\n  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n    var normalizedZ = zRotationStep / totalZRotationSteps;\n    var angleZ = normalizedZ * Math.PI * slice;\n\n    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n      var normalizedY = yRotationStep / totalYRotationSteps;\n      var angleY = normalizedY * Math.PI * 2 * arc;\n      var rotationZ = Matrix.RotationZ(-angleZ);\n      var rotationY = Matrix.RotationY(angleY);\n      var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\n      var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\n      var vertex = complete.multiply(radius);\n      var normal = complete.divide(radius).normalize();\n      positions.push(vertex.x, vertex.y, vertex.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(normalizedY, normalizedZ);\n    }\n\n    if (zRotationStep > 0) {\n      var verticesCount = positions.length / 3;\n\n      for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n        if (dedupTopBottomIndices) {\n          if (zRotationStep > 1) {\n            indices.push(firstIndex);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 1);\n          }\n\n          if (zRotationStep < totalZRotationSteps || slice < 1.0) {\n            indices.push(firstIndex + totalYRotationSteps + 1);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 2);\n          }\n        } else {\n          indices.push(firstIndex);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 2);\n        }\n      }\n    }\n  } // Sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nMesh.CreateSphere = function (name, segments, diameter, scene, updatable, sideOrientation) {\n  var options = {\n    segments: segments,\n    diameterX: diameter,\n    diameterY: diameter,\n    diameterZ: diameter,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return SphereBuilder.CreateSphere(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar SphereBuilder =\n/** @class */\nfunction () {\n  function SphereBuilder() {}\n  /**\r\n   * Creates a sphere mesh\r\n   * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n   * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n   * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n   * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n   * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the sphere mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n   */\n\n\n  SphereBuilder.CreateSphere = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var sphere = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateSphere(options);\n    vertexData.applyToMesh(sphere, options.updatable);\n    return sphere;\n  };\n\n  return SphereBuilder;\n}();\n\nexport { SphereBuilder };","map":null,"metadata":{},"sourceType":"module"}