{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar bn_js_1 = tslib_1.__importDefault(require(\"bn.js\"));\n\nvar util_1 = require(\"util\");\n\nvar address_1 = require(\"../address\");\n\nvar bn_1 = require(\"./bn\");\n\nvar hex_1 = require(\"./hex\");\n\nvar hex_utf8_1 = require(\"./hex-utf8\");\n\nvar padding_1 = require(\"./padding\");\n\nvar sha3_1 = require(\"./sha3\");\n\nvar elementaryName = function elementaryName(name) {\n  /*jshint maxcomplexity:false */\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3);\n  } else if (name === 'int') {\n    return 'int256';\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4);\n  } else if (name === 'uint') {\n    return 'uint256';\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5);\n  } else if (name === 'fixed') {\n    return 'fixed128x128';\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6);\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128';\n  }\n\n  return name;\n}; // Parse N from type<N>\n\n\nvar parseTypeN = function parseTypeN(type) {\n  var typesize = /^\\D+(\\d+).*$/.exec(type);\n  return typesize ? parseInt(typesize[1], 10) : null;\n}; // Parse N from type[<N>]\n\n\nvar parseTypeNArray = function parseTypeNArray(type) {\n  var arraySize = /^\\D+\\d*\\[(\\d+)\\]$/.exec(type);\n  return arraySize ? parseInt(arraySize[1], 10) : null;\n};\n\nvar parseNumber = function parseNumber(arg) {\n  var type = typeof arg;\n\n  if (type === 'string') {\n    if (hex_1.isHexStrict(arg)) {\n      return new bn_js_1.default(arg.replace(/0x/i, ''), 16);\n    } else {\n      return new bn_js_1.default(arg, 10);\n    }\n  } else if (type === 'number') {\n    return new bn_js_1.default(arg);\n  } else if (bn_1.isBN(arg)) {\n    return arg;\n  } else {\n    throw new Error(arg + ' is not a number');\n  }\n};\n\nvar solidityPack = function solidityPack(type, value, arraySize) {\n  /*jshint maxcomplexity:false */\n  var size;\n  var num;\n  type = elementaryName(type);\n\n  if (type === 'bytes') {\n    if (value.replace(/^0x/i, '').length % 2 !== 0) {\n      throw new Error('Invalid bytes characters ' + value.length);\n    }\n\n    return value;\n  } else if (type === 'string') {\n    return hex_utf8_1.utf8ToHex(value);\n  } else if (type === 'bool') {\n    return value ? '01' : '00';\n  } else if (type.startsWith('address')) {\n    if (arraySize) {\n      size = 64;\n    } else {\n      size = 40;\n    }\n\n    if (!address_1.Address.isAddress(value)) {\n      throw new Error(value + ' is not a valid address, or the checksum is invalid.');\n    }\n\n    return padding_1.leftPad(value.toLowerCase(), size);\n  }\n\n  size = parseTypeN(type);\n\n  if (type.startsWith('bytes')) {\n    if (!size) {\n      throw new Error('bytes[] not yet supported in solidity');\n    } // must be 32 byte slices when in an array\n\n\n    if (arraySize) {\n      size = 32;\n    }\n\n    if (size < 1 || size > 32 || size < value.replace(/^0x/i, '').length / 2) {\n      throw new Error('Invalid bytes' + size + ' for ' + value);\n    }\n\n    return padding_1.rightPad(value, size * 2);\n  } else if (type.startsWith('uint')) {\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint' + size + ' size');\n    }\n\n    num = parseNumber(value);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    if (num.lt(new bn_js_1.default(0))) {\n      throw new Error('Supplied uint ' + num.toString() + ' is negative');\n    }\n\n    return size ? padding_1.leftPad(num.toString('hex'), size / 8 * 2) : num;\n  } else if (type.startsWith('int')) {\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int' + size + ' size');\n    }\n\n    num = parseNumber(value);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    if (num.lt(new bn_js_1.default(0))) {\n      return num.toTwos(size).toString('hex');\n    } else {\n      return size ? padding_1.leftPad(num.toString('hex'), size / 8 * 2) : num;\n    }\n  } else {\n    // FIXME: support all other types\n    throw new Error('Unsupported or invalid type: ' + type);\n  }\n};\n\nvar processSoliditySha3Args = function processSoliditySha3Args(arg) {\n  /*jshint maxcomplexity:false */\n  if (util_1.isArray(arg)) {\n    throw new Error('Autodetection of array types is not supported.');\n  }\n\n  var type;\n  var value = '';\n  var hexArg;\n  var arraySize; // if type is given\n\n  if (util_1.isObject(arg) && (arg.hasOwnProperty('v') || arg.hasOwnProperty('t') || arg.hasOwnProperty('value') || arg.hasOwnProperty('type'))) {\n    type = arg.hasOwnProperty('t') ? arg.t : arg.type;\n    value = arg.hasOwnProperty('v') ? arg.v : arg.value; // otherwise try to guess the type\n  } else {\n    type = hex_1.toHex(arg, true);\n    value = hex_1.toHex(arg);\n\n    if (!type.startsWith('int') && !type.startsWith('uint')) {\n      type = 'bytes';\n    }\n  }\n\n  if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {\n    value = new bn_js_1.default(value);\n  } // get the array size\n\n\n  if (util_1.isArray(value)) {\n    arraySize = parseTypeNArray(type);\n\n    if (arraySize && value.length !== arraySize) {\n      throw new Error(type + ' is not matching the given array ' + JSON.stringify(value));\n    } else {\n      arraySize = value.length;\n    }\n  }\n\n  if (util_1.isArray(value)) {\n    hexArg = value.map(function (val) {\n      return solidityPack(type, val, arraySize).toString('hex').replace('0x', '');\n    });\n    return hexArg.join('');\n  } else {\n    hexArg = solidityPack(type, value, arraySize);\n    return hexArg.toString('hex').replace('0x', '');\n  }\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256\n *\n * @method soliditySha3\n * @return {Object} the sha3\n */\n\n\nexports.soliditySha3 = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  /*jshint maxcomplexity:false */\n  var hexArgs = args.map(processSoliditySha3Args); // console.log(args, hexArgs);\n  // console.log('0x'+ hexArgs.join(''));\n\n  return sha3_1.sha3('0x' + hexArgs.join(''));\n};","map":null,"metadata":{},"sourceType":"script"}