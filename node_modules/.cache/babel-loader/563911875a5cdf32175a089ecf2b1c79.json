{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Engine } from \"../Engines/engine\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { DataBuffer } from '../Meshes/dataBuffer';\nimport { Tools } from \"../Misc/tools\";\nimport { EnvironmentTextureTools } from \"../Misc/environmentTextureTools\";\nimport { RenderTargetCreationOptions } from \"../Materials/Textures/renderTargetCreationOptions\";\nimport { Logger } from \"../Misc/logger\";\nimport { ThinEngine } from './thinEngine';\nimport { EngineStore } from './engineStore';\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\nimport { WebGL2ShaderProcessor } from '../Engines/WebGL/webGL2ShaderProcessors';\n\nvar NativePipelineContext =\n/** @class */\nfunction () {\n  function NativePipelineContext() {\n    // TODO: async should be true?\n    this.isAsync = false;\n    this.isReady = false;\n  }\n\n  NativePipelineContext.prototype._getVertexShaderCode = function () {\n    return null;\n  };\n\n  NativePipelineContext.prototype._getFragmentShaderCode = function () {\n    return null;\n  }; // TODO: what should this do?\n\n\n  NativePipelineContext.prototype._handlesSpectorRebuildCallback = function (onCompiled) {\n    throw new Error(\"Not implemented\");\n  };\n\n  return NativePipelineContext;\n}();\n/**\r\n * Container for accessors for natively-stored mesh data buffers.\r\n */\n\n\nvar NativeDataBuffer =\n/** @class */\nfunction (_super) {\n  __extends(NativeDataBuffer, _super);\n\n  function NativeDataBuffer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return NativeDataBuffer;\n}(DataBuffer);\n/** @hidden */\n\n\nvar NativeTexture =\n/** @class */\nfunction (_super) {\n  __extends(NativeTexture, _super);\n\n  function NativeTexture() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NativeTexture.prototype.getInternalTexture = function () {\n    return this;\n  };\n\n  NativeTexture.prototype.getViewCount = function () {\n    return 1;\n  };\n\n  return NativeTexture;\n}(InternalTexture);\n/** @hidden */\n\n\nvar NativeEngine =\n/** @class */\nfunction (_super) {\n  __extends(NativeEngine, _super);\n\n  function NativeEngine() {\n    var _this = _super.call(this, null) || this;\n\n    _this._native = new _native.Engine();\n    /** Defines the invalid handle returned by bgfx when resource creation goes wrong */\n\n    _this.INVALID_HANDLE = 65535;\n    _this._boundBuffersVertexArray = null;\n    _this._currentDepthTest = _this._native.DEPTH_TEST_LEQUAL;\n    _this._webGLVersion = 2;\n    _this.disableUniformBuffers = true; // TODO: Initialize this more correctly based on the hardware capabilities.\n    // Init caps\n\n    _this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: 512,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: true,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 16,\n      uintIndices: true,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      textureFloat: false,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: false,\n      textureHalfFloat: false,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: false,\n      textureLOD: true,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: true,\n      instancedArrays: false,\n      canUseTimestampForTimerQuery: false,\n      blendMinMax: false,\n      maxMSAASamples: 1\n    };\n    Tools.Log(\"Babylon Native (v\" + Engine.Version + \") launched\");\n\n    Tools.LoadScript = function (scriptUrl, onSuccess, onError, scriptId) {\n      Tools.LoadFile(scriptUrl, function (data) {\n        Function(data).apply(null);\n\n        if (onSuccess) {\n          onSuccess();\n        }\n      }, undefined, undefined, false, function (request, exception) {\n        if (onError) {\n          onError(\"LoadScript Error\", exception);\n        }\n      });\n    }; // Wrappers\n\n\n    if (typeof URL === \"undefined\") {\n      window.URL = {\n        createObjectURL: function createObjectURL() {},\n        revokeObjectURL: function revokeObjectURL() {}\n      };\n    }\n\n    if (typeof Blob === \"undefined\") {\n      window.Blob = function () {};\n    } // Shader processor\n\n\n    _this._shaderProcessor = new WebGL2ShaderProcessor();\n    return _this;\n  }\n\n  NativeEngine.prototype.getHardwareScalingLevel = function () {\n    return 1.0;\n  };\n\n  NativeEngine.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this._boundBuffersVertexArray) {\n      this._native.deleteVertexArray(this._boundBuffersVertexArray);\n    }\n\n    this._native.dispose();\n  };\n  /**\r\n   * Can be used to override the current requestAnimationFrame requester.\r\n   * @hidden\r\n   */\n\n\n  NativeEngine.prototype._queueNewFrame = function (bindedRenderFunction, requester) {\n    // Use the provided requestAnimationFrame, unless the requester is the window. In that case, we will default to the Babylon Native version of requestAnimationFrame.\n    if (requester.requestAnimationFrame && requester !== window) {\n      requester.requestAnimationFrame(bindedRenderFunction);\n    } else {\n      this._native.requestAnimationFrame(bindedRenderFunction);\n    }\n\n    return 0;\n  };\n  /**\r\n   * Override default engine behavior.\r\n   * @param color\r\n   * @param backBuffer\r\n   * @param depth\r\n   * @param stencil\r\n   */\n\n\n  NativeEngine.prototype._bindUnboundFramebuffer = function (framebuffer) {\n    if (this._currentFramebuffer !== framebuffer) {\n      if (this._currentFramebuffer) {\n        this._native.unbindFramebuffer(this._currentFramebuffer);\n      }\n\n      if (framebuffer) {\n        this._native.bindFramebuffer(framebuffer);\n      }\n\n      this._currentFramebuffer = framebuffer;\n    }\n  };\n  /**\r\n   * Gets host document\r\n   * @returns the host document object\r\n   */\n\n\n  NativeEngine.prototype.getHostDocument = function () {\n    return null;\n  };\n\n  NativeEngine.prototype.clear = function (color, backBuffer, depth, stencil) {\n    if (stencil === void 0) {\n      stencil = false;\n    }\n\n    var mode = 0;\n\n    if (backBuffer && color) {\n      this._native.clearColor(color.r, color.g, color.b, color.a !== undefined ? color.a : 1.0);\n\n      mode |= this._native.CLEAR_FLAG_COLOR;\n    }\n\n    if (depth) {\n      this._native.clearDepth(1.0);\n\n      mode |= this._native.CLEAR_FLAG_DEPTH;\n    }\n\n    if (stencil) {\n      this._native.clearStencil(0);\n\n      mode |= this._native.CLEAR_FLAG_STENCIL;\n    }\n\n    this._native.clear(mode);\n  };\n\n  NativeEngine.prototype.createIndexBuffer = function (indices, updateable) {\n    var data = this._normalizeIndexData(indices);\n\n    var buffer = new NativeDataBuffer();\n    buffer.references = 1;\n    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n\n    if (data.length) {\n      buffer.nativeIndexBuffer = this._native.createIndexBuffer(data, updateable !== null && updateable !== void 0 ? updateable : false);\n\n      if (buffer.nativeVertexBuffer === this.INVALID_HANDLE) {\n        throw new Error(\"Could not create a native index buffer.\");\n      }\n    } else {\n      buffer.nativeVertexBuffer = this.INVALID_HANDLE;\n    }\n\n    return buffer;\n  };\n\n  NativeEngine.prototype.createVertexBuffer = function (data, updateable) {\n    var buffer = new NativeDataBuffer();\n    buffer.references = 1;\n    buffer.nativeVertexBuffer = this._native.createVertexBuffer(ArrayBuffer.isView(data) ? data : new Float32Array(data), updateable !== null && updateable !== void 0 ? updateable : false);\n\n    if (buffer.nativeVertexBuffer === this.INVALID_HANDLE) {\n      throw new Error(\"Could not create a native vertex buffer.\");\n    }\n\n    return buffer;\n  };\n\n  NativeEngine.prototype._recordVertexArrayObject = function (vertexArray, vertexBuffers, indexBuffer, effect) {\n    if (indexBuffer) {\n      this._native.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer);\n    }\n\n    var attributes = effect.getAttributesNames();\n\n    for (var index = 0; index < attributes.length; index++) {\n      var location_1 = effect.getAttributeLocation(index);\n\n      if (location_1 >= 0) {\n        var kind = attributes[index];\n        var vertexBuffer = vertexBuffers[kind];\n\n        if (vertexBuffer) {\n          var buffer = vertexBuffer.getBuffer();\n\n          if (buffer) {\n            this._native.recordVertexBuffer(vertexArray, buffer.nativeVertexBuffer, location_1, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.getSize(), this._getNativeAttribType(vertexBuffer.type), vertexBuffer.normalized);\n          }\n        }\n      }\n    }\n  };\n\n  NativeEngine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect) {\n    if (this._boundBuffersVertexArray) {\n      this._native.deleteVertexArray(this._boundBuffersVertexArray);\n    }\n\n    this._boundBuffersVertexArray = this._native.createVertexArray();\n\n    this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);\n\n    this._native.bindVertexArray(this._boundBuffersVertexArray);\n  };\n\n  NativeEngine.prototype.recordVertexArrayObject = function (vertexBuffers, indexBuffer, effect) {\n    var vertexArray = this._native.createVertexArray();\n\n    this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect);\n\n    return vertexArray;\n  };\n\n  NativeEngine.prototype.bindVertexArrayObject = function (vertexArray) {\n    this._native.bindVertexArray(vertexArray);\n  };\n\n  NativeEngine.prototype.releaseVertexArrayObject = function (vertexArray) {\n    this._native.deleteVertexArray(vertexArray);\n  };\n\n  NativeEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {\n    var nativePipelineContext = pipelineContext;\n    return this._native.getAttributes(nativePipelineContext.nativeProgram, attributesNames);\n  };\n  /**\r\n   * Draw a list of indexed primitives\r\n   * @param fillMode defines the primitive to use\r\n   * @param indexStart defines the starting index\r\n   * @param indexCount defines the number of index to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  NativeEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {\n    // Apply states\n    this._drawCalls.addCount(1, false); // TODO: Make this implementation more robust like core Engine version.\n    // Render\n    //var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;\n    //var mult = this._uintIndicesCurrentlySet ? 4 : 2;\n    // if (instancesCount) {\n    //     this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);\n    // } else {\n\n\n    this._native.drawIndexed(fillMode, indexStart, indexCount); // }\n\n  };\n  /**\r\n   * Draw a list of unindexed primitives\r\n   * @param fillMode defines the primitive to use\r\n   * @param verticesStart defines the index of first vertex to draw\r\n   * @param verticesCount defines the count of vertices to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  NativeEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {\n    // Apply states\n    this._drawCalls.addCount(1, false); // TODO: Make this implementation more robust like core Engine version.\n    // if (instancesCount) {\n    //     this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);\n    // } else {\n\n\n    this._native.draw(fillMode, verticesStart, verticesCount); // }\n\n  };\n\n  NativeEngine.prototype.createPipelineContext = function () {\n    return new NativePipelineContext();\n  };\n\n  NativeEngine.prototype._preparePipelineContext = function (pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rebuildRebind, defines, transformFeedbackVaryings) {\n    var nativePipelineContext = pipelineContext;\n\n    if (createAsRaw) {\n      nativePipelineContext.nativeProgram = this.createRawShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, undefined, transformFeedbackVaryings);\n    } else {\n      nativePipelineContext.nativeProgram = this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines, undefined, transformFeedbackVaryings);\n    }\n  };\n  /** @hidden */\n\n\n  NativeEngine.prototype._isRenderingStateCompiled = function (pipelineContext) {\n    // TODO: support async shader compilcation\n    return true;\n  };\n  /** @hidden */\n\n\n  NativeEngine.prototype._executeWhenRenderingStateIsCompiled = function (pipelineContext, action) {\n    // TODO: support async shader compilcation\n    action();\n  };\n\n  NativeEngine.prototype.createRawShaderProgram = function (pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings) {\n    if (transformFeedbackVaryings === void 0) {\n      transformFeedbackVaryings = null;\n    }\n\n    throw new Error(\"Not Supported\");\n  };\n\n  NativeEngine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {\n    if (transformFeedbackVaryings === void 0) {\n      transformFeedbackVaryings = null;\n    }\n\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    var vertexInliner = new ShaderCodeInliner(vertexCode);\n    vertexInliner.processCode();\n    vertexCode = vertexInliner.code;\n    var fragmentInliner = new ShaderCodeInliner(fragmentCode);\n    fragmentInliner.processCode();\n    fragmentCode = fragmentInliner.code;\n    vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);\n    fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);\n\n    var program = this._native.createProgram(vertexCode, fragmentCode);\n\n    this.onAfterShaderCompilationObservable.notifyObservers(this);\n    return program;\n  };\n\n  NativeEngine.prototype._setProgram = function (program) {\n    if (this._currentProgram !== program) {\n      this._native.setProgram(program);\n\n      this._currentProgram = program;\n    }\n  };\n\n  NativeEngine.prototype._releaseEffect = function (effect) {// TODO\n  };\n\n  NativeEngine.prototype._deletePipelineContext = function (pipelineContext) {// TODO\n  };\n\n  NativeEngine.prototype.getUniforms = function (pipelineContext, uniformsNames) {\n    var nativePipelineContext = pipelineContext;\n    return this._native.getUniforms(nativePipelineContext.nativeProgram, uniformsNames);\n  };\n\n  NativeEngine.prototype.bindUniformBlock = function (pipelineContext, blockName, index) {\n    // TODO\n    throw new Error(\"Not Implemented\");\n  };\n\n  NativeEngine.prototype.bindSamplers = function (effect) {\n    var nativePipelineContext = effect.getPipelineContext();\n\n    this._setProgram(nativePipelineContext.nativeProgram); // TODO: share this with engine?\n\n\n    var samplers = effect.getSamplers();\n\n    for (var index = 0; index < samplers.length; index++) {\n      var uniform = effect.getUniform(samplers[index]);\n\n      if (uniform) {\n        this._boundUniforms[index] = uniform;\n      }\n    }\n\n    this._currentEffect = null;\n  };\n\n  NativeEngine.prototype.setMatrix = function (uniform, matrix) {\n    if (!uniform) {\n      return;\n    }\n\n    this._native.setMatrix(uniform, matrix.toArray());\n  };\n\n  NativeEngine.prototype.getRenderWidth = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n\n    return this._native.getRenderWidth();\n  };\n\n  NativeEngine.prototype.getRenderHeight = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n\n    return this._native.getRenderHeight();\n  };\n\n  NativeEngine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n\n    this._native.setViewPort(viewport.x, viewport.y, viewport.width, viewport.height);\n  };\n\n  NativeEngine.prototype.setState = function (culling, zOffset, force, reverseSide) {\n    if (zOffset === void 0) {\n      zOffset = 0;\n    }\n\n    if (reverseSide === void 0) {\n      reverseSide = false;\n    }\n\n    this._native.setState(culling, zOffset, reverseSide);\n  };\n  /**\r\n   * Set the z offset to apply to current rendering\r\n   * @param value defines the offset to apply\r\n   */\n\n\n  NativeEngine.prototype.setZOffset = function (value) {\n    this._native.setZOffset(value);\n  };\n  /**\r\n   * Gets the current value of the zOffset\r\n   * @returns the current zOffset state\r\n   */\n\n\n  NativeEngine.prototype.getZOffset = function () {\n    return this._native.getZOffset();\n  };\n  /**\r\n   * Enable or disable depth buffering\r\n   * @param enable defines the state to set\r\n   */\n\n\n  NativeEngine.prototype.setDepthBuffer = function (enable) {\n    this._native.setDepthTest(enable ? this._currentDepthTest : this._native.DEPTH_TEST_ALWAYS);\n  };\n  /**\r\n   * Gets a boolean indicating if depth writing is enabled\r\n   * @returns the current depth writing state\r\n   */\n\n\n  NativeEngine.prototype.getDepthWrite = function () {\n    return this._native.getDepthWrite();\n  };\n\n  NativeEngine.prototype.setDepthFunctionToGreater = function () {\n    this._currentDepthTest = this._native.DEPTH_TEST_GREATER;\n\n    this._native.setDepthTest(this._currentDepthTest);\n  };\n\n  NativeEngine.prototype.setDepthFunctionToGreaterOrEqual = function () {\n    this._currentDepthTest = this._native.DEPTH_TEST_GEQUAL;\n\n    this._native.setDepthTest(this._currentDepthTest);\n  };\n\n  NativeEngine.prototype.setDepthFunctionToLess = function () {\n    this._currentDepthTest = this._native.DEPTH_TEST_LESS;\n\n    this._native.setDepthTest(this._currentDepthTest);\n  };\n\n  NativeEngine.prototype.setDepthFunctionToLessOrEqual = function () {\n    this._currentDepthTest = this._native.DEPTH_TEST_LEQUAL;\n\n    this._native.setDepthTest(this._currentDepthTest);\n  };\n  /**\r\n   * Enable or disable depth writing\r\n   * @param enable defines the state to set\r\n   */\n\n\n  NativeEngine.prototype.setDepthWrite = function (enable) {\n    this._native.setDepthWrite(enable);\n  };\n  /**\r\n   * Enable or disable color writing\r\n   * @param enable defines the state to set\r\n   */\n\n\n  NativeEngine.prototype.setColorWrite = function (enable) {\n    this._native.setColorWrite(enable);\n\n    this._colorWrite = enable;\n  };\n  /**\r\n   * Gets a boolean indicating if color writing is enabled\r\n   * @returns the current color writing state\r\n   */\n\n\n  NativeEngine.prototype.getColorWrite = function () {\n    return this._colorWrite;\n  };\n  /**\r\n   * Sets alpha constants used by some alpha blending modes\r\n   * @param r defines the red component\r\n   * @param g defines the green component\r\n   * @param b defines the blue component\r\n   * @param a defines the alpha component\r\n   */\n\n\n  NativeEngine.prototype.setAlphaConstants = function (r, g, b, a) {\n    throw new Error(\"Setting alpha blend constant color not yet implemented.\");\n  };\n  /**\r\n   * Sets the current alpha mode\r\n   * @param mode defines the mode to use (one of the BABYLON.undefined)\r\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n   * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered\r\n   */\n\n\n  NativeEngine.prototype.setAlphaMode = function (mode, noDepthWriteChange) {\n    if (noDepthWriteChange === void 0) {\n      noDepthWriteChange = false;\n    }\n\n    if (this._alphaMode === mode) {\n      return;\n    }\n\n    mode = this._getNativeAlphaMode(mode);\n\n    this._native.setBlendMode(mode);\n\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n\n    this._alphaMode = mode;\n  };\n  /**\r\n   * Gets the current alpha mode\r\n   * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered\r\n   * @returns the current alpha mode\r\n   */\n\n\n  NativeEngine.prototype.getAlphaMode = function () {\n    return this._alphaMode;\n  };\n\n  NativeEngine.prototype.setInt = function (uniform, int) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setInt(uniform, int);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setIntArray = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setIntArray(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setIntArray2 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setIntArray2(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setIntArray3 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setIntArray3(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setIntArray4 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setIntArray4(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setFloatArray = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloatArray(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setFloatArray2 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloatArray2(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setFloatArray3 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloatArray3(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setFloatArray4 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloatArray4(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setArray = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloatArray(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setArray2 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloatArray2(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setArray3 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloatArray3(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setArray4 = function (uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloatArray4(uniform, array);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setMatrices = function (uniform, matrices) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setMatrices(uniform, matrices);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setMatrix3x3 = function (uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setMatrix3x3(uniform, matrix);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setMatrix2x2 = function (uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setMatrix2x2(uniform, matrix);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setFloat = function (uniform, value) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloat(uniform, value);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setFloat2 = function (uniform, x, y) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloat2(uniform, x, y);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setFloat3 = function (uniform, x, y, z) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloat3(uniform, x, y, z);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setFloat4 = function (uniform, x, y, z, w) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloat4(uniform, x, y, z, w);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setColor3 = function (uniform, color3) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloat3(uniform, color3.r, color3.g, color3.b);\n\n    return true;\n  };\n\n  NativeEngine.prototype.setColor4 = function (uniform, color3, alpha) {\n    if (!uniform) {\n      return false;\n    }\n\n    this._native.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);\n\n    return true;\n  };\n\n  NativeEngine.prototype.wipeCaches = function (bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n\n    this.resetTextureCache();\n    this._currentEffect = null;\n\n    if (bruteForce) {\n      this._currentProgram = null;\n\n      this._stencilState.reset();\n\n      this._depthCullingState.reset();\n\n      this._alphaState.reset();\n    }\n\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  };\n\n  NativeEngine.prototype._createTexture = function () {\n    return this._native.createTexture();\n  };\n\n  NativeEngine.prototype._deleteTexture = function (texture) {\n    this._native.deleteTexture(texture);\n  };\n  /**\r\n   * Update the content of a dynamic texture\r\n   * @param texture defines the texture to update\r\n   * @param canvas defines the canvas containing the source\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param premulAlpha defines if alpha is stored as premultiplied\r\n   * @param format defines the format of the data\r\n   * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n   */\n\n\n  NativeEngine.prototype.updateDynamicTexture = function (texture, canvas, invertY, premulAlpha, format) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    } // TODO: Stub! This function is needed for some GLTF validation tests.\n    // Loads a dummy 8x8 transparent png\n\n\n    var imageData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYSURBVChTY/z//z8DPsAEpXGC4aCAgQEAGGMDDWwwgqsAAAAASUVORK5CYII=';\n    this.createTexture('data:my_image_name', true, invertY, null, Texture.BILINEAR_SAMPLINGMODE, undefined, undefined, imageData, texture, NativeEngine.TEXTUREFORMAT_RGBA, null, undefined);\n  }; // TODO: Refactor to share more logic with babylon.engine.ts version.\n\n  /**\r\n   * Usually called from Texture.ts.\r\n   * Passed information to create a WebGLTexture\r\n   * @param url defines a value which contains one of the following:\r\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n   * @param scene needed for loading to the correct scene\r\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n   * @param onLoad optional callback to be called upon successful completion\r\n   * @param onError optional callback to be called upon failure\r\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n   * @param forcedExtension defines the extension to use to pick the right loader\r\n   * @param mimeType defines an optional mime type\r\n   * @param loaderOptions options to be passed to the loader\r\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n   */\n\n\n  NativeEngine.prototype.createTexture = function (url, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType, loaderOptions) {\n    var _this = this;\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (fallback === void 0) {\n      fallback = null;\n    }\n\n    if (format === void 0) {\n      format = null;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    url = url || \"\";\n    var fromData = url.substr(0, 5) === \"data:\"; //const fromBlob = url.substr(0, 5) === \"blob:\";\n\n    var isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\n    var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\n    var originalUrl = url;\n\n    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\n      url = this._transformTextureUrl(url);\n    } // establish the file extension, if possible\n\n\n    var lastDot = url.lastIndexOf('.');\n    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n    var loader = null;\n\n    for (var _i = 0, _a = Engine._TextureLoaders; _i < _a.length; _i++) {\n      var availableLoader = _a[_i];\n\n      if (availableLoader.canLoad(extension)) {\n        loader = availableLoader;\n        break;\n      }\n    }\n\n    if (scene) {\n      scene._addPendingData(texture);\n    }\n\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n\n    if (!this.doNotHandleContextLost) {\n      // Keep a link to the buffer only if we plan to handle context lost\n      texture._buffer = buffer;\n    }\n\n    var onLoadObserver = null;\n\n    if (onLoad && !fallback) {\n      onLoadObserver = texture.onLoadedObservable.add(onLoad);\n    }\n\n    if (!fallback) {\n      this._internalTexturesCache.push(texture);\n    }\n\n    var onInternalError = function onInternalError(message, exception) {\n      if (scene) {\n        scene._removePendingData(texture);\n      }\n\n      if (url === originalUrl) {\n        if (onLoadObserver) {\n          texture.onLoadedObservable.remove(onLoadObserver);\n        }\n\n        if (EngineStore.UseFallbackTexture) {\n          _this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);\n        }\n\n        if (onError) {\n          onError((message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\"), exception);\n        }\n      } else {\n        // fall back to the original url if the transformed url fails to load\n        Logger.Warn(\"Failed to load \" + url + \", falling back to \" + originalUrl);\n\n        _this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);\n      }\n    }; // processing for non-image formats\n\n\n    if (loader) {\n      throw new Error(\"Loading textures from IInternalTextureLoader not yet implemented.\");\n    } else {\n      var onload_1 = function onload_1(data) {\n        var webGLTexture = texture._webGLTexture;\n\n        if (!webGLTexture) {\n          if (scene) {\n            scene._removePendingData(texture);\n          }\n\n          return;\n        }\n\n        _this._native.loadTexture(webGLTexture, data, !noMipmap, invertY, function () {\n          texture.baseWidth = _this._native.getTextureWidth(webGLTexture);\n          texture.baseHeight = _this._native.getTextureHeight(webGLTexture);\n          texture.width = texture.baseWidth;\n          texture.height = texture.baseHeight;\n          texture.isReady = true;\n\n          var filter = _this._getNativeSamplingMode(samplingMode);\n\n          _this._native.setTextureSampling(webGLTexture, filter);\n\n          if (scene) {\n            scene._removePendingData(texture);\n          }\n\n          texture.onLoadedObservable.notifyObservers(texture);\n          texture.onLoadedObservable.clear();\n        }, function () {\n          throw new Error(\"Could not load a native texture.\");\n        });\n      };\n\n      if (fromData) {\n        if (buffer instanceof ArrayBuffer) {\n          onload_1(new Uint8Array(buffer));\n        } else if (ArrayBuffer.isView(buffer)) {\n          onload_1(buffer);\n        } else if (typeof buffer === \"string\") {\n          onload_1(new Uint8Array(Tools.DecodeBase64(buffer)));\n        } else {\n          throw new Error(\"Unsupported buffer type\");\n        }\n      } else {\n        if (isBase64) {\n          onload_1(new Uint8Array(Tools.DecodeBase64(url)));\n        } else {\n          this._loadFile(url, function (data) {\n            return onload_1(new Uint8Array(data));\n          }, undefined, undefined, true, function (request, exception) {\n            onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\n          });\n        }\n      }\n    }\n\n    return texture;\n  };\n\n  NativeEngine.prototype._createDepthStencilTexture = function (size, options) {\n    var texture = new NativeTexture(this, InternalTextureSource.Depth);\n    var width = size.width || size;\n    var height = size.height || size;\n\n    var framebuffer = this._native.createDepthTexture(texture._webGLTexture, width, height);\n\n    texture._framebuffer = framebuffer;\n    return texture;\n  };\n\n  NativeEngine.prototype._releaseFramebufferObjects = function (texture) {// TODO\n  };\n  /**\r\n   * Creates a cube texture\r\n   * @param rootUrl defines the url where the files to load is located\r\n   * @param scene defines the current scene\r\n   * @param files defines the list of files to load (1 per face)\r\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n   * @param onLoad defines an optional callback raised when the texture is loaded\r\n   * @param onError defines an optional callback raised if there is an issue to load the texture\r\n   * @param format defines the format of the data\r\n   * @param forcedExtension defines the extension to use to pick the right loader\r\n   * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n   * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n   * @returns the cube texture as an InternalTexture\r\n   */\n\n\n  NativeEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback) {\n    var _this = this;\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    if (createPolynomials === void 0) {\n      createPolynomials = false;\n    }\n\n    if (lodScale === void 0) {\n      lodScale = 0;\n    }\n\n    if (lodOffset === void 0) {\n      lodOffset = 0;\n    }\n\n    if (fallback === void 0) {\n      fallback = null;\n    }\n\n    var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n    texture.isCube = true;\n    texture.url = rootUrl;\n    texture.generateMipMaps = !noMipmap;\n    texture._lodGenerationScale = lodScale;\n    texture._lodGenerationOffset = lodOffset;\n\n    if (!this._doNotHandleContextLost) {\n      texture._extension = forcedExtension;\n      texture._files = files;\n    }\n\n    var lastDot = rootUrl.lastIndexOf('.');\n    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\"; // TODO: use texture loader to load env files?\n\n    if (extension === \".env\") {\n      var onloaddata_1 = function onloaddata_1(data) {\n        var info = EnvironmentTextureTools.GetEnvInfo(data);\n        texture.width = info.width;\n        texture.height = info.width;\n        EnvironmentTextureTools.UploadEnvSpherical(texture, info);\n\n        if (info.version !== 1) {\n          throw new Error(\"Unsupported babylon environment map version \\\"\" + info.version + \"\\\"\");\n        }\n\n        var specularInfo = info.specular;\n\n        if (!specularInfo) {\n          throw new Error(\"Nothing else parsed so far\");\n        }\n\n        texture._lodGenerationScale = specularInfo.lodGenerationScale;\n        var imageData = EnvironmentTextureTools.CreateImageDataArrayBufferViews(data, info);\n        texture.format = 5;\n        texture.type = 0;\n        texture.generateMipMaps = true;\n        texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);\n        texture._isRGBD = true;\n        texture.invertY = true;\n\n        _this._native.loadCubeTextureWithMips(texture._webGLTexture, imageData, function () {\n          texture.isReady = true;\n\n          if (onLoad) {\n            onLoad();\n          }\n        }, function () {\n          throw new Error(\"Could not load a native cube texture.\");\n        });\n      };\n\n      if (files && files.length === 6) {\n        throw new Error(\"Multi-file loading not allowed on env files.\");\n      } else {\n        var onInternalError = function onInternalError(request, exception) {\n          if (onError && request) {\n            onError(request.status + \" \" + request.statusText, exception);\n          }\n        };\n\n        this._loadFile(rootUrl, function (data) {\n          return onloaddata_1(new Uint8Array(data));\n        }, undefined, undefined, true, onInternalError);\n      }\n    } else {\n      if (!files || files.length !== 6) {\n        throw new Error(\"Cannot load cubemap because 6 files were not defined\");\n      } // Reorder from [+X, +Y, +Z, -X, -Y, -Z] to [+X, -X, +Y, -Y, +Z, -Z].\n\n\n      var reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];\n      Promise.all(reorderedFiles.map(function (file) {\n        return Tools.LoadFileAsync(file).then(function (data) {\n          return new Uint8Array(data);\n        });\n      })).then(function (data) {\n        return new Promise(function (resolve, reject) {\n          _this._native.loadCubeTexture(texture._webGLTexture, data, !noMipmap, resolve, reject);\n        });\n      }).then(function () {\n        texture.isReady = true;\n\n        if (onLoad) {\n          onLoad();\n        }\n      }, function (error) {\n        if (onError) {\n          onError(\"Failed to load cubemap: \" + error.message, error);\n        }\n      });\n    }\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n\n  NativeEngine.prototype.createRenderTargetTexture = function (size, options) {\n    var fullOptions = new RenderTargetCreationOptions();\n\n    if (options !== undefined && typeof options === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n      fullOptions.format = options.format === undefined ? 5 : options.format;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.generateDepthBuffer = true;\n      fullOptions.generateStencilBuffer = false;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n      fullOptions.format = 5;\n    }\n\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      fullOptions.samplingMode = 1;\n    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      fullOptions.samplingMode = 1;\n    }\n\n    var texture = new NativeTexture(this, InternalTextureSource.RenderTarget);\n    var width = size.width || size;\n    var height = size.height || size;\n\n    if (fullOptions.type === 1 && !this._caps.textureFloat) {\n      fullOptions.type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n\n    var framebuffer = this._native.createFramebuffer(texture._webGLTexture, width, height, this._getNativeTextureFormat(fullOptions.format, fullOptions.type), fullOptions.samplingMode, fullOptions.generateStencilBuffer ? true : false, fullOptions.generateDepthBuffer, fullOptions.generateMipMaps ? true : false);\n\n    texture._framebuffer = framebuffer;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    texture.format = fullOptions.format;\n    texture._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n\n  NativeEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture) {\n    if (texture._webGLTexture) {\n      var filter = this._getNativeSamplingMode(samplingMode);\n\n      this._native.setTextureSampling(texture._webGLTexture, filter);\n    }\n\n    texture.samplingMode = samplingMode;\n  };\n\n  NativeEngine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    if (faceIndex) {\n      throw new Error(\"Cuboid frame buffers are not yet supported in NativeEngine.\");\n    }\n\n    if (requiredWidth || requiredHeight) {\n      throw new Error(\"Required width/height for frame buffers not yet supported in NativeEngine.\");\n    }\n\n    if (forceFullscreenViewport) {//Not supported yet but don't stop rendering\n    }\n\n    if (texture._depthStencilTexture) {\n      this._bindUnboundFramebuffer(texture._depthStencilTexture._framebuffer);\n    } else {\n      this._bindUnboundFramebuffer(texture._framebuffer);\n    }\n  };\n\n  NativeEngine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {\n    if (disableGenerateMipMaps === void 0) {\n      disableGenerateMipMaps = false;\n    }\n\n    if (disableGenerateMipMaps) {\n      Logger.Warn(\"Disabling mipmap generation not yet supported in NativeEngine. Ignoring.\");\n    }\n\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n\n    this._bindUnboundFramebuffer(null);\n  };\n\n  NativeEngine.prototype.createDynamicVertexBuffer = function (data) {\n    return this.createVertexBuffer(data, true);\n  };\n\n  NativeEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var buffer = indexBuffer;\n\n    var data = this._normalizeIndexData(indices);\n\n    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n\n    this._native.updateDynamicIndexBuffer(buffer.nativeIndexBuffer, data, offset);\n  };\n  /**\r\n   * Updates a dynamic vertex buffer.\r\n   * @param vertexBuffer the vertex buffer to update\r\n   * @param data the data used to update the vertex buffer\r\n   * @param byteOffset the byte offset of the data (optional)\r\n   * @param byteLength the byte length of the data (optional)\r\n   */\n\n\n  NativeEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, data, byteOffset, byteLength) {\n    var buffer = vertexBuffer;\n    var dataView = ArrayBuffer.isView(data) ? data : new Float32Array(data);\n\n    this._native.updateDynamicVertexBuffer(buffer.nativeVertexBuffer, dataView, byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0, byteLength !== null && byteLength !== void 0 ? byteLength : dataView.byteLength);\n  }; // TODO: Refactor to share more logic with base Engine implementation.\n\n\n  NativeEngine.prototype._setTexture = function (channel, texture, isPartOfTextureArray, depthStencilTexture) {\n    if (isPartOfTextureArray === void 0) {\n      isPartOfTextureArray = false;\n    }\n\n    if (depthStencilTexture === void 0) {\n      depthStencilTexture = false;\n    }\n\n    var uniform = this._boundUniforms[channel];\n\n    if (!uniform) {\n      return false;\n    } // Not ready?\n\n\n    if (!texture) {\n      if (this._boundTexturesCache[channel] != null) {\n        this._activeChannel = channel;\n\n        this._native.setTexture(uniform, null);\n      }\n\n      return false;\n    } // Video\n\n\n    if (texture.video) {\n      this._activeChannel = channel;\n      texture.update();\n    } else if (texture.delayLoadState === 4) {\n      // Delay loading\n      texture.delayLoad();\n      return false;\n    }\n\n    var internalTexture;\n\n    if (depthStencilTexture) {\n      internalTexture = texture.depthStencilTexture;\n    } else if (texture.isReady()) {\n      internalTexture = texture.getInternalTexture();\n    } else if (texture.isCube) {\n      internalTexture = this.emptyCubeTexture;\n    } else if (texture.is3D) {\n      internalTexture = this.emptyTexture3D;\n    } else if (texture.is2DArray) {\n      internalTexture = this.emptyTexture2DArray;\n    } else {\n      internalTexture = this.emptyTexture;\n    }\n\n    this._activeChannel = channel;\n\n    if (!internalTexture || !internalTexture._webGLTexture) {\n      return false;\n    }\n\n    this._native.setTextureWrapMode(internalTexture._webGLTexture, this._getAddressMode(texture.wrapU), this._getAddressMode(texture.wrapV), this._getAddressMode(texture.wrapR));\n\n    this._updateAnisotropicLevel(texture);\n\n    this._native.setTexture(uniform, internalTexture._webGLTexture);\n\n    return true;\n  }; // TODO: Share more of this logic with the base implementation.\n  // TODO: Rename to match naming in base implementation once refactoring allows different parameters.\n\n\n  NativeEngine.prototype._updateAnisotropicLevel = function (texture) {\n    var internalTexture = texture.getInternalTexture();\n    var value = texture.anisotropicFilteringLevel;\n\n    if (!internalTexture || !internalTexture._webGLTexture) {\n      return;\n    }\n\n    if (internalTexture._cachedAnisotropicFilteringLevel !== value) {\n      this._native.setTextureAnisotropicLevel(internalTexture._webGLTexture, value);\n\n      internalTexture._cachedAnisotropicFilteringLevel = value;\n    }\n  }; // Returns a NativeAddressMode.XXX value.\n\n\n  NativeEngine.prototype._getAddressMode = function (wrapMode) {\n    switch (wrapMode) {\n      case 1:\n        return this._native.ADDRESS_MODE_WRAP;\n\n      case 0:\n        return this._native.ADDRESS_MODE_CLAMP;\n\n      case 2:\n        return this._native.ADDRESS_MODE_MIRROR;\n\n      default:\n        throw new Error(\"Unexpected wrap mode: \" + wrapMode + \".\");\n    }\n  };\n  /** @hidden */\n\n\n  NativeEngine.prototype._bindTexture = function (channel, texture) {\n    var uniform = this._boundUniforms[channel];\n\n    if (!uniform) {\n      return;\n    }\n\n    this._native.setTexture(uniform, texture._webGLTexture);\n  };\n\n  NativeEngine.prototype._deleteBuffer = function (buffer) {\n    if (buffer.nativeIndexBuffer) {\n      this._native.deleteIndexBuffer(buffer.nativeIndexBuffer);\n\n      delete buffer.nativeIndexBuffer;\n    }\n\n    if (buffer.nativeVertexBuffer) {\n      this._native.deleteVertexBuffer(buffer.nativeVertexBuffer);\n\n      delete buffer.nativeVertexBuffer;\n    }\n  };\n\n  NativeEngine.prototype.releaseEffects = function () {// TODO\n  };\n  /** @hidden */\n\n\n  NativeEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, data, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    throw new Error(\"_uploadCompressedDataToTextureDirectly not implemented.\");\n  };\n  /** @hidden */\n\n\n  NativeEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    throw new Error(\"_uploadDataToTextureDirectly not implemented.\");\n  };\n  /** @hidden */\n\n\n  NativeEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\n  };\n  /** @hidden */\n\n\n  NativeEngine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n\n    throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\n  }; // JavaScript-to-Native conversion helper functions.\n\n\n  NativeEngine.prototype._getNativeSamplingMode = function (samplingMode) {\n    switch (samplingMode) {\n      case 1:\n        return this._native.TEXTURE_NEAREST_NEAREST;\n\n      case 2:\n        return this._native.TEXTURE_LINEAR_LINEAR;\n\n      case 3:\n        return this._native.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\n\n      case 4:\n        return this._native.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\n\n      case 5:\n        return this._native.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\n\n      case 6:\n        return this._native.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\n\n      case 7:\n        return this._native.TEXTURE_NEAREST_LINEAR;\n\n      case 8:\n        return this._native.TEXTURE_NEAREST_NEAREST_MIPLINEAR;\n\n      case 9:\n        return this._native.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\n\n      case 10:\n        return this._native.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\n\n      case 11:\n        return this._native.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\n\n      case 12:\n        return this._native.TEXTURE_LINEAR_NEAREST;\n\n      default:\n        throw new Error(\"Unsupported sampling mode: \" + samplingMode + \".\");\n    }\n  };\n\n  NativeEngine.prototype._getNativeTextureFormat = function (format, type) {\n    if (format == 5 && type == 0) {\n      return this._native.TEXTURE_FORMAT_RGBA8;\n    } else if (format == 5 && type == 1) {\n      return this._native.TEXTURE_FORMAT_RGBA32F;\n    } else {\n      throw new Error(\"Unsupported texture format or type: format \" + format + \", type \" + type + \".\");\n    }\n  };\n\n  NativeEngine.prototype._getNativeAlphaMode = function (mode) {\n    switch (mode) {\n      case 0:\n        return this._native.ALPHA_DISABLE;\n\n      case 1:\n        return this._native.ALPHA_ADD;\n\n      case 2:\n        return this._native.ALPHA_COMBINE;\n\n      case 3:\n        return this._native.ALPHA_SUBTRACT;\n\n      case 4:\n        return this._native.ALPHA_MULTIPLY;\n\n      case 5:\n        return this._native.ALPHA_MAXIMIZED;\n\n      case 6:\n        return this._native.ALPHA_ONEONE;\n\n      case 7:\n        return this._native.ALPHA_PREMULTIPLIED;\n\n      case 8:\n        return this._native.ALPHA_PREMULTIPLIED_PORTERDUFF;\n\n      case 9:\n        return this._native.ALPHA_INTERPOLATE;\n\n      case 10:\n        return this._native.ALPHA_SCREENMODE;\n\n      default:\n        throw new Error(\"Unsupported alpha mode: \" + mode + \".\");\n    }\n  };\n\n  NativeEngine.prototype._getNativeAttribType = function (type) {\n    switch (type) {\n      case VertexBuffer.UNSIGNED_BYTE:\n        return this._native.ATTRIB_TYPE_UINT8;\n\n      case VertexBuffer.SHORT:\n        return this._native.ATTRIB_TYPE_INT16;\n\n      case VertexBuffer.FLOAT:\n        return this._native.ATTRIB_TYPE_FLOAT;\n\n      default:\n        throw new Error(\"Unsupported attribute type: \" + type + \".\");\n    }\n  };\n\n  return NativeEngine;\n}(Engine);\n\nexport { NativeEngine };","map":null,"metadata":{},"sourceType":"module"}