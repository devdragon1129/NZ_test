{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from '../Materials/standardMaterial';\nimport { BoxBuilder } from \"../Meshes/Builders/boxBuilder\";\nimport { CylinderBuilder } from '../Meshes/Builders/cylinderBuilder';\nimport { Matrix } from '../Maths/math';\nimport { LinesBuilder } from \"../Meshes/Builders/linesBuilder\";\nimport { PointerEventTypes } from '../Events/pointerEvents';\nimport { Observable } from \"../Misc/observable\";\n/**\r\n * Gizmo that enables viewing a camera\r\n */\n\nvar CameraGizmo =\n/** @class */\nfunction (_super) {\n  __extends(CameraGizmo, _super);\n  /**\r\n   * Creates a CameraGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   */\n\n\n  function CameraGizmo(gizmoLayer) {\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._pointerObserver = null;\n    /**\r\n     * Event that fires each time the gizmo is clicked\r\n     */\n\n    _this.onClickedObservable = new Observable();\n    _this._camera = null;\n    _this._invProjection = new Matrix();\n    _this._material = new StandardMaterial(\"cameraGizmoMaterial\", _this.gizmoLayer.utilityLayerScene);\n    _this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\n    _this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      if (!_this._camera) {\n        return;\n      }\n\n      _this._isHovered = !!(pointerInfo.pickInfo && _this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n\n      if (_this._isHovered && pointerInfo.event.button === 0) {\n        _this.onClickedObservable.notifyObservers(_this._camera);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n    return _this;\n  }\n\n  Object.defineProperty(CameraGizmo.prototype, \"displayFrustum\", {\n    /** Gets or sets a boolean indicating if frustum lines must be rendered (true by default)) */\n    get: function get() {\n      return this._cameraLinesMesh.isEnabled();\n    },\n    set: function set(value) {\n      this._cameraLinesMesh.setEnabled(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CameraGizmo.prototype, \"camera\", {\n    get: function get() {\n      return this._camera;\n    },\n\n    /**\r\n     * The camera that the gizmo is attached to\r\n     */\n    set: function set(camera) {\n      var _this = this;\n\n      this._camera = camera;\n      this.attachedNode = camera;\n\n      if (camera) {\n        // Create the mesh for the given camera\n        if (this._cameraMesh) {\n          this._cameraMesh.dispose();\n        }\n\n        if (this._cameraLinesMesh) {\n          this._cameraLinesMesh.dispose();\n        }\n\n        this._cameraMesh = CameraGizmo._CreateCameraMesh(this.gizmoLayer.utilityLayerScene);\n        this._cameraLinesMesh = CameraGizmo._CreateCameraFrustum(this.gizmoLayer.utilityLayerScene);\n\n        this._cameraMesh.getChildMeshes(false).forEach(function (m) {\n          m.material = _this._material;\n        });\n\n        this._cameraMesh.parent = this._rootMesh;\n        this._cameraLinesMesh.parent = this._rootMesh;\n\n        if (this.gizmoLayer.utilityLayerScene.activeCamera && this.gizmoLayer.utilityLayerScene.activeCamera.maxZ < camera.maxZ * 1.5) {\n          this.gizmoLayer.utilityLayerScene.activeCamera.maxZ = camera.maxZ * 1.5;\n        }\n\n        if (!this.attachedNode.reservedDataStore) {\n          this.attachedNode.reservedDataStore = {};\n        }\n\n        this.attachedNode.reservedDataStore.cameraGizmo = this; // Add lighting to the camera gizmo\n\n        var gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n\n        gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._cameraMesh.getChildMeshes(false));\n\n        this._update();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CameraGizmo.prototype, \"material\", {\n    /**\r\n     * Gets the material used to render the camera gizmo\r\n     */\n    get: function get() {\n      return this._material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @hidden\r\n   * Updates the gizmo to match the attached mesh's position/rotation\r\n   */\n\n  CameraGizmo.prototype._update = function () {\n    _super.prototype._update.call(this);\n\n    if (!this._camera) {\n      return;\n    } // frustum matrix\n\n\n    this._camera.getProjectionMatrix().invertToRef(this._invProjection);\n\n    this._cameraLinesMesh.setPivotMatrix(this._invProjection, false);\n\n    this._cameraLinesMesh.scaling.x = 1 / this._rootMesh.scaling.x;\n    this._cameraLinesMesh.scaling.y = 1 / this._rootMesh.scaling.y;\n    this._cameraLinesMesh.scaling.z = 1 / this._rootMesh.scaling.z; // take care of coordinate system in camera scene to properly display the mesh with the good Y axis orientation in this scene\n\n    this._cameraMesh.parent = null;\n    this._cameraMesh.rotation.y = Math.PI * 0.5 * (this._camera.getScene().useRightHandedSystem ? 1 : -1);\n    this._cameraMesh.parent = this._rootMesh;\n  };\n  /**\r\n   * Disposes of the camera gizmo\r\n   */\n\n\n  CameraGizmo.prototype.dispose = function () {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n\n    if (this._cameraMesh) {\n      this._cameraMesh.dispose();\n    }\n\n    if (this._cameraLinesMesh) {\n      this._cameraLinesMesh.dispose();\n    }\n\n    this._material.dispose();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  CameraGizmo._CreateCameraMesh = function (scene) {\n    var root = new Mesh(\"rootCameraGizmo\", scene);\n    var mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    var box = BoxBuilder.CreateBox(root.name, {\n      width: 1.0,\n      height: 0.8,\n      depth: 0.5\n    }, scene);\n    box.parent = mesh;\n    var cyl1 = CylinderBuilder.CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.8,\n      diameterBottom: 0.8\n    }, scene);\n    cyl1.parent = mesh;\n    cyl1.position.y = 0.3;\n    cyl1.position.x = -0.6;\n    cyl1.rotation.x = Math.PI * 0.5;\n    var cyl2 = CylinderBuilder.CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.6,\n      diameterBottom: 0.6\n    }, scene);\n    cyl2.parent = mesh;\n    cyl2.position.y = 0.5;\n    cyl2.position.x = 0.4;\n    cyl2.rotation.x = Math.PI * 0.5;\n    var cyl3 = CylinderBuilder.CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.5,\n      diameterBottom: 0.5\n    }, scene);\n    cyl3.parent = mesh;\n    cyl3.position.y = 0.0;\n    cyl3.position.x = 0.6;\n    cyl3.rotation.z = Math.PI * 0.5;\n    root.scaling.scaleInPlace(CameraGizmo._Scale);\n    mesh.position.x = -0.9;\n    return root;\n  };\n\n  CameraGizmo._CreateCameraFrustum = function (scene) {\n    var root = new Mesh(\"rootCameraGizmo\", scene);\n    var mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n\n    for (var y = 0; y < 4; y += 2) {\n      for (var x = 0; x < 4; x += 2) {\n        var line = LinesBuilder.CreateLines(\"lines\", {\n          points: [new Vector3(-1 + x, -1 + y, -1), new Vector3(-1 + x, -1 + y, 1)]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n        var line = LinesBuilder.CreateLines(\"lines\", {\n          points: [new Vector3(-1, -1 + x, -1 + y), new Vector3(1, -1 + x, -1 + y)]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n        var line = LinesBuilder.CreateLines(\"lines\", {\n          points: [new Vector3(-1 + x, -1, -1 + y), new Vector3(-1 + x, 1, -1 + y)]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n      }\n    }\n\n    return root;\n  }; // Static helper methods\n\n\n  CameraGizmo._Scale = 0.05;\n  return CameraGizmo;\n}(Gizmo);\n\nexport { CameraGizmo };","map":null,"metadata":{},"sourceType":"module"}