{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Ray } from \"../Culling/ray\";\nimport { Material } from \"../Materials/material\";\nimport { LensFlare } from \"./lensFlare\";\nimport \"../Shaders/lensFlare.fragment\";\nimport \"../Shaders/lensFlare.vertex\";\nimport { _DevTools } from '../Misc/devTools';\nimport { Color3 } from '../Maths/math.color';\n/**\r\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n * It is usually composed of several `lensFlare`.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n */\n\nvar LensFlareSystem =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a lens flare system.\r\n   * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n   * It is usually composed of several `lensFlare`.\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n   * @param name Define the name of the lens flare system in the scene\r\n   * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\r\n   * @param scene Define the scene the lens flare system belongs to\r\n   */\n  function LensFlareSystem(\n  /**\r\n   * Define the name of the lens flare system\r\n   */\n  name, emitter, scene) {\n    this.name = name;\n    /**\r\n     * List of lens flares used in this system.\r\n     */\n\n    this.lensFlares = new Array();\n    /**\r\n     * Define a limit from the border the lens flare can be visible.\r\n     */\n\n    this.borderLimit = 300;\n    /**\r\n     * Define a viewport border we do not want to see the lens flare in.\r\n     */\n\n    this.viewportBorder = 0;\n    /**\r\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\r\n     */\n\n    this.layerMask = 0x0FFFFFFF;\n    this._vertexBuffers = {};\n    this._isEnabled = true;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    LensFlareSystem._SceneComponentInitialization(this._scene);\n\n    this._emitter = emitter;\n    this.id = name;\n    scene.lensFlareSystems.push(this);\n\n    this.meshesSelectionPredicate = function (m) {\n      return scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0;\n    };\n\n    var engine = scene.getEngine(); // VBO\n\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2); // Indices\n\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices); // Effects\n\n    this._effect = engine.createEffect(\"lensFlare\", [VertexBuffer.PositionKind], [\"color\", \"viewportMatrix\"], [\"textureSampler\"], \"\");\n  }\n\n  Object.defineProperty(LensFlareSystem.prototype, \"isEnabled\", {\n    /**\r\n     * Define if the lens flare system is enabled.\r\n     */\n    get: function get() {\n      return this._isEnabled;\n    },\n    set: function set(value) {\n      this._isEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the scene the effects belongs to.\r\n   * @returns the scene holding the lens flare system\r\n   */\n\n  LensFlareSystem.prototype.getScene = function () {\n    return this._scene;\n  };\n  /**\r\n   * Get the emitter of the lens flare system.\r\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n   * @returns the emitter of the lens flare system\r\n   */\n\n\n  LensFlareSystem.prototype.getEmitter = function () {\n    return this._emitter;\n  };\n  /**\r\n   * Set the emitter of the lens flare system.\r\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n   * @param newEmitter Define the new emitter of the system\r\n   */\n\n\n  LensFlareSystem.prototype.setEmitter = function (newEmitter) {\n    this._emitter = newEmitter;\n  };\n  /**\r\n   * Get the lens flare system emitter position.\r\n   * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n   * @returns the position\r\n   */\n\n\n  LensFlareSystem.prototype.getEmitterPosition = function () {\n    return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  LensFlareSystem.prototype.computeEffectivePosition = function (globalViewport) {\n    var position = this.getEmitterPosition();\n    position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\n    this._positionX = position.x;\n    this._positionY = position.y;\n    position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\n\n    if (this.viewportBorder > 0) {\n      globalViewport.x -= this.viewportBorder;\n      globalViewport.y -= this.viewportBorder;\n      globalViewport.width += this.viewportBorder * 2;\n      globalViewport.height += this.viewportBorder * 2;\n      position.x += this.viewportBorder;\n      position.y += this.viewportBorder;\n      this._positionX += this.viewportBorder;\n      this._positionY += this.viewportBorder;\n    }\n\n    if (position.z > 0) {\n      if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\n        if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\n          return true;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  LensFlareSystem.prototype._isVisible = function () {\n    if (!this._isEnabled || !this._scene.activeCamera) {\n      return false;\n    }\n\n    var emitterPosition = this.getEmitterPosition();\n    var direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\n    var distance = direction.length();\n    direction.normalize();\n    var ray = new Ray(this._scene.activeCamera.globalPosition, direction);\n\n    var pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\n\n    return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  LensFlareSystem.prototype.render = function () {\n    if (!this._effect.isReady() || !this._scene.activeCamera) {\n      return false;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var viewport = this._scene.activeCamera.viewport;\n    var globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true)); // Position\n\n    if (!this.computeEffectivePosition(globalViewport)) {\n      return false;\n    } // Visibility\n\n\n    if (!this._isVisible()) {\n      return false;\n    } // Intensity\n\n\n    var awayX;\n    var awayY;\n\n    if (this._positionX < this.borderLimit + globalViewport.x) {\n      awayX = this.borderLimit + globalViewport.x - this._positionX;\n    } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\n      awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\n    } else {\n      awayX = 0;\n    }\n\n    if (this._positionY < this.borderLimit + globalViewport.y) {\n      awayY = this.borderLimit + globalViewport.y - this._positionY;\n    } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\n      awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\n    } else {\n      awayY = 0;\n    }\n\n    var away = awayX > awayY ? awayX : awayY;\n    away -= this.viewportBorder;\n\n    if (away > this.borderLimit) {\n      away = this.borderLimit;\n    }\n\n    var intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\n\n    if (intensity < 0) {\n      return false;\n    }\n\n    if (intensity > 1.0) {\n      intensity = 1.0;\n    }\n\n    if (this.viewportBorder > 0) {\n      globalViewport.x += this.viewportBorder;\n      globalViewport.y += this.viewportBorder;\n      globalViewport.width -= this.viewportBorder * 2;\n      globalViewport.height -= this.viewportBorder * 2;\n      this._positionX -= this.viewportBorder;\n      this._positionY -= this.viewportBorder;\n    } // Position\n\n\n    var centerX = globalViewport.x + globalViewport.width / 2;\n    var centerY = globalViewport.y + globalViewport.height / 2;\n    var distX = centerX - this._positionX;\n    var distY = centerY - this._positionY; // Effects\n\n    engine.enableEffect(this._effect);\n    engine.setState(false);\n    engine.setDepthBuffer(false); // VBOs\n\n    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect); // Flares\n\n    for (var index = 0; index < this.lensFlares.length; index++) {\n      var flare = this.lensFlares[index];\n\n      if (flare.texture && !flare.texture.isReady()) {\n        continue;\n      }\n\n      engine.setAlphaMode(flare.alphaMode);\n      var x = centerX - distX * flare.position;\n      var y = centerY - distY * flare.position;\n      var cw = flare.size;\n      var ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\n      var cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\n      var cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\n      var viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\n\n      this._effect.setMatrix(\"viewportMatrix\", viewportMatrix); // Texture\n\n\n      this._effect.setTexture(\"textureSampler\", flare.texture); // Color\n\n\n      this._effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0); // Draw order\n\n\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n\n    engine.setDepthBuffer(true);\n    engine.setAlphaMode(0);\n    return true;\n  };\n  /**\r\n   * Dispose and release the lens flare with its associated resources.\r\n   */\n\n\n  LensFlareSystem.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    while (this.lensFlares.length) {\n      this.lensFlares[0].dispose();\n    } // Remove from scene\n\n\n    var index = this._scene.lensFlareSystems.indexOf(this);\n\n    this._scene.lensFlareSystems.splice(index, 1);\n  };\n  /**\r\n   * Parse a lens flare system from a JSON repressentation\r\n   * @param parsedLensFlareSystem Define the JSON to parse\r\n   * @param scene Define the scene the parsed system should be instantiated in\r\n   * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\r\n   * @returns the parsed system\r\n   */\n\n\n  LensFlareSystem.Parse = function (parsedLensFlareSystem, scene, rootUrl) {\n    var emitter = scene.getLastEntryByID(parsedLensFlareSystem.emitterId);\n    var name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\n    var lensFlareSystem = new LensFlareSystem(name, emitter, scene);\n    lensFlareSystem.id = parsedLensFlareSystem.id || name;\n    lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\n\n    for (var index = 0; index < parsedLensFlareSystem.flares.length; index++) {\n      var parsedFlare = parsedLensFlareSystem.flares[index];\n      LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\n    }\n\n    return lensFlareSystem;\n  };\n  /**\r\n   * Serialize the current Lens Flare System into a JSON representation.\r\n   * @returns the serialized JSON\r\n   */\n\n\n  LensFlareSystem.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.name = this.name;\n    serializationObject.emitterId = this.getEmitter().id;\n    serializationObject.borderLimit = this.borderLimit;\n    serializationObject.flares = [];\n\n    for (var index = 0; index < this.lensFlares.length; index++) {\n      var flare = this.lensFlares[index];\n      serializationObject.flares.push({\n        size: flare.size,\n        position: flare.position,\n        color: flare.color.asArray(),\n        textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\")\n      });\n    }\n\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  LensFlareSystem._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"LensFlareSystemSceneComponent\");\n  };\n\n  return LensFlareSystem;\n}();\n\nexport { LensFlareSystem };","map":null,"metadata":{},"sourceType":"module"}