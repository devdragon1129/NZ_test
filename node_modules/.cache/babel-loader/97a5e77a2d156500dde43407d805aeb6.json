{"ast":null,"code":"import { NodeMaterialBlockConnectionPointTypes } from './Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from './nodeMaterialBlockConnectionPoint';\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\nimport { UniqueIdGenerator } from '../../Misc/uniqueIdGenerator';\nimport { _TypeStore } from '../../Misc/typeStore';\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\n\nvar NodeMaterialBlock =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new NodeMaterialBlock\r\n   * @param name defines the block name\r\n   * @param target defines the target of that block (Vertex by default)\r\n   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n   * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\r\n   */\n  function NodeMaterialBlock(name, target, isFinalMerger, isInput) {\n    if (target === void 0) {\n      target = NodeMaterialBlockTargets.Vertex;\n    }\n\n    if (isFinalMerger === void 0) {\n      isFinalMerger = false;\n    }\n\n    if (isInput === void 0) {\n      isInput = false;\n    }\n\n    this._isFinalMerger = false;\n    this._isInput = false;\n    this._name = \"\";\n    this._isUnique = false;\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\n\n    this.inputsAreExclusive = false;\n    /** @hidden */\n\n    this._codeVariableName = \"\";\n    /** @hidden */\n\n    this._inputs = new Array();\n    /** @hidden */\n\n    this._outputs = new Array();\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\n\n    this.comments = \"\";\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\n\n    this.visibleInInspector = false;\n    this._target = target;\n    this._isFinalMerger = isFinalMerger;\n    this._isInput = isInput;\n    this._name = name;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n  }\n\n  Object.defineProperty(NodeMaterialBlock.prototype, \"name\", {\n    /**\r\n     * Gets the name of the block\r\n     */\n    get: function get() {\n      return this._name;\n    },\n\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\n    set: function set(newName) {\n      if (!this.validateBlockName(newName)) {\n        return;\n      }\n\n      this._name = newName;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isUnique\", {\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\n    get: function get() {\n      return this._isUnique;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isFinalMerger\", {\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\n    get: function get() {\n      return this._isFinalMerger;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isInput\", {\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\n    get: function get() {\n      return this._isInput;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"buildId\", {\n    /**\r\n     * Gets or sets the build Id\r\n     */\n    get: function get() {\n      return this._buildId;\n    },\n    set: function set(value) {\n      this._buildId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"target\", {\n    /**\r\n     * Gets or sets the target of the block\r\n     */\n    get: function get() {\n      return this._target;\n    },\n    set: function set(value) {\n      if ((this._target & value) !== 0) {\n        return;\n      }\n\n      this._target = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"inputs\", {\n    /**\r\n     * Gets the list of input points\r\n     */\n    get: function get() {\n      return this._inputs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"outputs\", {\n    /** Gets the list of output points */\n    get: function get() {\n      return this._outputs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Find an input by its name\r\n   * @param name defines the name of the input to look for\r\n   * @returns the input or null if not found\r\n   */\n\n  NodeMaterialBlock.prototype.getInputByName = function (name) {\n    var filter = this._inputs.filter(function (e) {\n      return e.name === name;\n    });\n\n    if (filter.length) {\n      return filter[0];\n    }\n\n    return null;\n  };\n  /**\r\n   * Find an output by its name\r\n   * @param name defines the name of the outputto look for\r\n   * @returns the output or null if not found\r\n   */\n\n\n  NodeMaterialBlock.prototype.getOutputByName = function (name) {\n    var filter = this._outputs.filter(function (e) {\n      return e.name === name;\n    });\n\n    if (filter.length) {\n      return filter[0];\n    }\n\n    return null;\n  };\n  /**\r\n   * Initialize the block and prepare the context for build\r\n   * @param state defines the state that will be used for the build\r\n   */\n\n\n  NodeMaterialBlock.prototype.initialize = function (state) {// Do nothing\n  };\n  /**\r\n   * Bind data to effect. Will only be called for blocks with isBindable === true\r\n   * @param effect defines the effect to bind data to\r\n   * @param nodeMaterial defines the hosting NodeMaterial\r\n   * @param mesh defines the mesh that will be rendered\r\n   * @param subMesh defines the submesh that will be rendered\r\n   */\n\n\n  NodeMaterialBlock.prototype.bind = function (effect, nodeMaterial, mesh, subMesh) {// Do nothing\n  };\n\n  NodeMaterialBlock.prototype._declareOutput = function (output, state) {\n    return state._getGLType(output.type) + \" \" + output.associatedVariableName;\n  };\n\n  NodeMaterialBlock.prototype._writeVariable = function (currentPoint) {\n    var connectionPoint = currentPoint.connectedPoint;\n\n    if (connectionPoint) {\n      return \"\" + currentPoint.associatedVariableName;\n    }\n\n    return \"0.\";\n  };\n\n  NodeMaterialBlock.prototype._writeFloat = function (value) {\n    var stringVersion = value.toString();\n\n    if (stringVersion.indexOf(\".\") === -1) {\n      stringVersion += \".0\";\n    }\n\n    return \"\" + stringVersion;\n  };\n  /**\r\n   * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n   * @returns the class name\r\n   */\n\n\n  NodeMaterialBlock.prototype.getClassName = function () {\n    return \"NodeMaterialBlock\";\n  };\n  /**\r\n   * Register a new input. Must be called inside a block constructor\r\n   * @param name defines the connection point name\r\n   * @param type defines the connection point type\r\n   * @param isOptional defines a boolean indicating that this input can be omitted\r\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n   * @param point an already created connection point. If not provided, create a new one\r\n   * @returns the current block\r\n   */\n\n\n  NodeMaterialBlock.prototype.registerInput = function (name, type, isOptional, target, point) {\n    if (isOptional === void 0) {\n      isOptional = false;\n    }\n\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\n    point.type = type;\n    point.isOptional = isOptional;\n\n    if (target) {\n      point.target = target;\n    }\n\n    this._inputs.push(point);\n\n    return this;\n  };\n  /**\r\n   * Register a new output. Must be called inside a block constructor\r\n   * @param name defines the connection point name\r\n   * @param type defines the connection point type\r\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n   * @param point an already created connection point. If not provided, create a new one\r\n   * @returns the current block\r\n   */\n\n\n  NodeMaterialBlock.prototype.registerOutput = function (name, type, target, point) {\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\n    point.type = type;\n\n    if (target) {\n      point.target = target;\n    }\n\n    this._outputs.push(point);\n\n    return this;\n  };\n  /**\r\n   * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n   * @param forOutput defines an optional connection point to check compatibility with\r\n   * @returns the first available input or null\r\n   */\n\n\n  NodeMaterialBlock.prototype.getFirstAvailableInput = function (forOutput) {\n    if (forOutput === void 0) {\n      forOutput = null;\n    }\n\n    for (var _i = 0, _a = this._inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.connectedPoint) {\n        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n          return input;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n   * @param forBlock defines an optional block to check compatibility with\r\n   * @returns the first available input or null\r\n   */\n\n\n  NodeMaterialBlock.prototype.getFirstAvailableOutput = function (forBlock) {\n    if (forBlock === void 0) {\n      forBlock = null;\n    }\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\n        return output;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets the sibling of the given output\r\n   * @param current defines the current output\r\n   * @returns the next output in the list or null\r\n   */\n\n\n  NodeMaterialBlock.prototype.getSiblingOutput = function (current) {\n    var index = this._outputs.indexOf(current);\n\n    if (index === -1 || index >= this._outputs.length) {\n      return null;\n    }\n\n    return this._outputs[index + 1];\n  };\n  /**\r\n   * Connect current block with another block\r\n   * @param other defines the block to connect with\r\n   * @param options define the various options to help pick the right connections\r\n   * @returns the current block\r\n   */\n\n\n  NodeMaterialBlock.prototype.connectTo = function (other, options) {\n    if (this._outputs.length === 0) {\n      return;\n    }\n\n    var output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\n    var notFound = true;\n\n    while (notFound) {\n      var input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\n\n      if (output && input && output.canConnectTo(input)) {\n        output.connectTo(input);\n        notFound = false;\n      } else if (!output) {\n        throw \"Unable to find a compatible match\";\n      } else {\n        output = this.getSiblingOutput(output);\n      }\n    }\n\n    return this;\n  };\n\n  NodeMaterialBlock.prototype._buildBlock = function (state) {// Empty. Must be defined by child nodes\n  };\n  /**\r\n   * Add uniforms, samplers and uniform buffers at compilation time\r\n   * @param state defines the state to update\r\n   * @param nodeMaterial defines the node material requesting the update\r\n   * @param defines defines the material defines to update\r\n   * @param uniformBuffers defines the list of uniform buffer names\r\n   */\n\n\n  NodeMaterialBlock.prototype.updateUniformsAndSamples = function (state, nodeMaterial, defines, uniformBuffers) {// Do nothing\n  };\n  /**\r\n   * Add potential fallbacks if shader compilation fails\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param fallbacks defines the current prioritized list of fallbacks\r\n   */\n\n\n  NodeMaterialBlock.prototype.provideFallbacks = function (mesh, fallbacks) {// Do nothing\n  };\n  /**\r\n   * Initialize defines for shader compilation\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param nodeMaterial defines the node material requesting the update\r\n   * @param defines defines the material defines to update\r\n   * @param useInstances specifies that instances should be used\r\n   */\n\n\n  NodeMaterialBlock.prototype.initializeDefines = function (mesh, nodeMaterial, defines, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n  };\n  /**\r\n   * Update defines for shader compilation\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param nodeMaterial defines the node material requesting the update\r\n   * @param defines defines the material defines to update\r\n   * @param useInstances specifies that instances should be used\r\n   * @param subMesh defines which submesh to render\r\n   */\n\n\n  NodeMaterialBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines, useInstances, subMesh) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    } // Do nothing\n\n  };\n  /**\r\n   * Lets the block try to connect some inputs automatically\r\n   * @param material defines the hosting NodeMaterial\r\n   */\n\n\n  NodeMaterialBlock.prototype.autoConfigure = function (material) {// Do nothing\n  };\n  /**\r\n   * Function called when a block is declared as repeatable content generator\r\n   * @param vertexShaderState defines the current compilation state for the vertex shader\r\n   * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param defines defines the material defines to update\r\n   */\n\n\n  NodeMaterialBlock.prototype.replaceRepeatableContent = function (vertexShaderState, fragmentShaderState, mesh, defines) {// Do nothing\n  };\n  /**\r\n   * Checks if the block is ready\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param nodeMaterial defines the node material requesting the update\r\n   * @param defines defines the material defines to update\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns true if the block is ready\r\n   */\n\n\n  NodeMaterialBlock.prototype.isReady = function (mesh, nodeMaterial, defines, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    return true;\n  };\n\n  NodeMaterialBlock.prototype._linkConnectionTypes = function (inputIndex0, inputIndex1, looseCoupling) {\n    if (looseCoupling === void 0) {\n      looseCoupling = false;\n    }\n\n    if (looseCoupling) {\n      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\n    } else {\n      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\n    }\n\n    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\n  };\n\n  NodeMaterialBlock.prototype._processBuild = function (block, state, input, activeBlocks) {\n    block.build(state, activeBlocks);\n    var localBlockIsFragment = state._vertexState != null;\n    var otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\n\n    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {\n      // context switch! We need a varying\n      if (!block.isInput && state.target !== block._buildTarget // block was already emitted by vertex shader\n      || block.isInput && block.isAttribute && !block._noContextSwitch // block is an attribute\n      ) {\n        var connectedPoint = input.connectedPoint;\n\n        if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\n          state._vertexState.compilationString += \"v_\" + connectedPoint.associatedVariableName + \" = \" + connectedPoint.associatedVariableName + \";\\r\\n\";\n        }\n\n        input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\n        input._enforceAssociatedVariableName = true;\n      }\n    }\n  };\n  /**\r\n  * Validates the new name for the block node.\r\n  * @param newName the new name to be given to the node.\r\n  * @returns false if the name is a reserve word, else true.\r\n  */\n\n\n  NodeMaterialBlock.prototype.validateBlockName = function (newName) {\n    var reservedNames = [\"position\", \"normal\", \"tangent\", \"particle_positionw\", \"uv\", \"uv2\", \"position2d\", \"particle_uv\", \"matricesIndices\", \"matricesWeights\", \"world0\", \"world1\", \"world2\", \"world3\", \"particle_color\", \"particle_texturemask\"];\n\n    for (var _i = 0, reservedNames_1 = reservedNames; _i < reservedNames_1.length; _i++) {\n      var reservedName = reservedNames_1[_i];\n\n      if (newName === reservedName) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Compile the current node and generate the shader code\r\n   * @param state defines the current compilation state (uniforms, samplers, current string)\r\n   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n   * @returns true if already built\r\n   */\n\n\n  NodeMaterialBlock.prototype.build = function (state, activeBlocks) {\n    if (this._buildId === state.sharedData.buildId) {\n      return true;\n    }\n\n    if (!this.isInput) {\n      /** Prepare outputs */\n      for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n        var output = _a[_i];\n\n        if (!output.associatedVariableName) {\n          output.associatedVariableName = state._getFreeVariableName(output.name);\n        }\n      }\n    } // Check if \"parent\" blocks are compiled\n\n\n    for (var _b = 0, _c = this._inputs; _b < _c.length; _b++) {\n      var input = _c[_b];\n\n      if (!input.connectedPoint) {\n        if (!input.isOptional) {\n          // Emit a warning\n          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\n        }\n\n        continue;\n      }\n\n      if (this.target !== NodeMaterialBlockTargets.Neutral) {\n        if ((input.target & this.target) === 0) {\n          continue;\n        }\n\n        if ((input.target & state.target) === 0) {\n          continue;\n        }\n      }\n\n      var block = input.connectedPoint.ownerBlock;\n\n      if (block && block !== this) {\n        this._processBuild(block, state, input, activeBlocks);\n      }\n    }\n\n    if (this._buildId === state.sharedData.buildId) {\n      return true; // Need to check again as inputs can be connected multiple time to this endpoint\n    } // Logs\n\n\n    if (state.sharedData.verbose) {\n      console.log((state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\") + \": Building \" + this.name + \" [\" + this.getClassName() + \"]\");\n    } // Checks final outputs\n\n\n    if (this.isFinalMerger) {\n      switch (state.target) {\n        case NodeMaterialBlockTargets.Vertex:\n          state.sharedData.checks.emitVertex = true;\n          break;\n\n        case NodeMaterialBlockTargets.Fragment:\n          state.sharedData.checks.emitFragment = true;\n          break;\n      }\n    }\n\n    if (!this.isInput && state.sharedData.emitComments) {\n      state.compilationString += \"\\r\\n//\" + this.name + \"\\r\\n\";\n    }\n\n    this._buildBlock(state);\n\n    this._buildId = state.sharedData.buildId;\n    this._buildTarget = state.target; // Compile connected blocks\n\n    for (var _d = 0, _e = this._outputs; _d < _e.length; _d++) {\n      var output = _e[_d];\n\n      if ((output.target & state.target) === 0) {\n        continue;\n      }\n\n      for (var _f = 0, _g = output.endpoints; _f < _g.length; _f++) {\n        var endpoint = _g[_f];\n        var block = endpoint.ownerBlock;\n\n        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\n          this._processBuild(block, state, endpoint, activeBlocks);\n        }\n      }\n    }\n\n    return false;\n  };\n\n  NodeMaterialBlock.prototype._inputRename = function (name) {\n    return name;\n  };\n\n  NodeMaterialBlock.prototype._outputRename = function (name) {\n    return name;\n  };\n\n  NodeMaterialBlock.prototype._dumpPropertiesCode = function () {\n    var variableName = this._codeVariableName;\n    return variableName + \".visibleInInspector = \" + this.visibleInInspector + \";\\r\\n\";\n  };\n  /** @hidden */\n\n\n  NodeMaterialBlock.prototype._dumpCode = function (uniqueNames, alreadyDumped) {\n    alreadyDumped.push(this);\n    var codeString; // Get unique name\n\n    var nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\n    this._codeVariableName = nameAsVariableName || this.getClassName() + \"_\" + this.uniqueId;\n\n    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\n      var index = 0;\n\n      do {\n        index++;\n        this._codeVariableName = nameAsVariableName + index;\n      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\n    }\n\n    uniqueNames.push(this._codeVariableName); // Declaration\n\n    codeString = \"\\r\\n// \" + this.getClassName() + \"\\r\\n\";\n\n    if (this.comments) {\n      codeString += \"// \" + this.comments + \"\\r\\n\";\n    }\n\n    codeString += \"var \" + this._codeVariableName + \" = new BABYLON.\" + this.getClassName() + \"(\\\"\" + this.name + \"\\\");\\r\\n\"; // Properties\n\n    codeString += this._dumpPropertiesCode(); // Inputs\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.isConnected) {\n        continue;\n      }\n\n      var connectedOutput = input.connectedPoint;\n      var connectedBlock = connectedOutput.ownerBlock;\n\n      if (alreadyDumped.indexOf(connectedBlock) === -1) {\n        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Outputs\n\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n\n      if (!output.hasEndpoints) {\n        continue;\n      }\n\n      for (var _d = 0, _e = output.endpoints; _d < _e.length; _d++) {\n        var endpoint = _e[_d];\n        var connectedBlock = endpoint.ownerBlock;\n\n        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\n          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n        }\n      }\n    }\n\n    return codeString;\n  };\n  /** @hidden */\n\n\n  NodeMaterialBlock.prototype._dumpCodeForOutputConnections = function (alreadyDumped) {\n    var codeString = \"\";\n\n    if (alreadyDumped.indexOf(this) !== -1) {\n      return codeString;\n    }\n\n    alreadyDumped.push(this);\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.isConnected) {\n        continue;\n      }\n\n      var connectedOutput = input.connectedPoint;\n      var connectedBlock = connectedOutput.ownerBlock;\n      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\n      codeString += connectedBlock._codeVariableName + \".\" + connectedBlock._outputRename(connectedOutput.name) + \".connectTo(\" + this._codeVariableName + \".\" + this._inputRename(input.name) + \");\\r\\n\";\n    }\n\n    return codeString;\n  };\n  /**\r\n   * Clone the current block to a new identical block\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a copy of the current block\r\n   */\n\n\n  NodeMaterialBlock.prototype.clone = function (scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    var serializationObject = this.serialize();\n\n    var blockType = _TypeStore.GetClass(serializationObject.customType);\n\n    if (blockType) {\n      var block = new blockType();\n\n      block._deserialize(serializationObject, scene, rootUrl);\n\n      return block;\n    }\n\n    return null;\n  };\n  /**\r\n   * Serializes this block in a JSON representation\r\n   * @returns the serialized block object\r\n   */\n\n\n  NodeMaterialBlock.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.id = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject.comments = this.comments;\n    serializationObject.visibleInInspector = this.visibleInInspector;\n    serializationObject.inputs = [];\n    serializationObject.outputs = [];\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      serializationObject.inputs.push(input.serialize());\n    }\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n      serializationObject.outputs.push(output.serialize(false));\n    }\n\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  NodeMaterialBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    this.name = serializationObject.name;\n    this.comments = serializationObject.comments;\n    this.visibleInInspector = !!serializationObject.visibleInInspector;\n\n    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\n  };\n\n  NodeMaterialBlock.prototype._deserializePortDisplayNamesAndExposedOnFrame = function (serializationObject) {\n    var _this = this;\n\n    var serializedInputs = serializationObject.inputs;\n    var serializedOutputs = serializationObject.outputs;\n\n    if (serializedInputs) {\n      serializedInputs.forEach(function (port, i) {\n        if (port.displayName) {\n          _this.inputs[i].displayName = port.displayName;\n        }\n\n        if (port.isExposedOnFrame) {\n          _this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          _this.inputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n\n    if (serializedOutputs) {\n      serializedOutputs.forEach(function (port, i) {\n        if (port.displayName) {\n          _this.outputs[i].displayName = port.displayName;\n        }\n\n        if (port.isExposedOnFrame) {\n          _this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          _this.outputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n  };\n  /**\r\n   * Release resources\r\n   */\n\n\n  NodeMaterialBlock.prototype.dispose = function () {\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      input.dispose();\n    }\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n      output.dispose();\n    }\n  };\n\n  return NodeMaterialBlock;\n}();\n\nexport { NodeMaterialBlock };","map":null,"metadata":{},"sourceType":"module"}