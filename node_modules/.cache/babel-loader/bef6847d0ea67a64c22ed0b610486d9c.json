{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar pbkdf2_1 = require(\"./pbkdf2\");\n\nvar MAX_VALUE = 0x7fffffff; // The following is an adaptation of scryptsy\n// See: https://www.npmjs.com/package/scryptsy\n\nfunction blockmix_salsa8(BY, Yi, r, x, _X) {\n  var i;\n  arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);\n\n  for (i = 0; i < 2 * r; i++) {\n    blockxor(BY, i * 16, _X, 16);\n    salsa20_8(_X, x);\n    arraycopy(_X, 0, BY, Yi + i * 16, 16);\n  }\n\n  for (i = 0; i < r; i++) {\n    arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);\n  }\n\n  for (i = 0; i < r; i++) {\n    arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);\n  }\n}\n\nfunction R(a, b) {\n  return a << b | a >>> 32 - b;\n}\n\nfunction salsa20_8(B, x) {\n  arraycopy(B, 0, x, 0, 16);\n\n  for (var i = 8; i > 0; i -= 2) {\n    x[4] ^= R(x[0] + x[12], 7);\n    x[8] ^= R(x[4] + x[0], 9);\n    x[12] ^= R(x[8] + x[4], 13);\n    x[0] ^= R(x[12] + x[8], 18);\n    x[9] ^= R(x[5] + x[1], 7);\n    x[13] ^= R(x[9] + x[5], 9);\n    x[1] ^= R(x[13] + x[9], 13);\n    x[5] ^= R(x[1] + x[13], 18);\n    x[14] ^= R(x[10] + x[6], 7);\n    x[2] ^= R(x[14] + x[10], 9);\n    x[6] ^= R(x[2] + x[14], 13);\n    x[10] ^= R(x[6] + x[2], 18);\n    x[3] ^= R(x[15] + x[11], 7);\n    x[7] ^= R(x[3] + x[15], 9);\n    x[11] ^= R(x[7] + x[3], 13);\n    x[15] ^= R(x[11] + x[7], 18);\n    x[1] ^= R(x[0] + x[3], 7);\n    x[2] ^= R(x[1] + x[0], 9);\n    x[3] ^= R(x[2] + x[1], 13);\n    x[0] ^= R(x[3] + x[2], 18);\n    x[6] ^= R(x[5] + x[4], 7);\n    x[7] ^= R(x[6] + x[5], 9);\n    x[4] ^= R(x[7] + x[6], 13);\n    x[5] ^= R(x[4] + x[7], 18);\n    x[11] ^= R(x[10] + x[9], 7);\n    x[8] ^= R(x[11] + x[10], 9);\n    x[9] ^= R(x[8] + x[11], 13);\n    x[10] ^= R(x[9] + x[8], 18);\n    x[12] ^= R(x[15] + x[14], 7);\n    x[13] ^= R(x[12] + x[15], 9);\n    x[14] ^= R(x[13] + x[12], 13);\n    x[15] ^= R(x[14] + x[13], 18);\n  }\n\n  for (var _i = 0; _i < 16; ++_i) {\n    B[_i] += x[_i];\n  }\n} // naive approach... going back to loop unrolling may yield additional performance\n\n\nfunction blockxor(S, Si, D, len) {\n  for (var i = 0; i < len; i++) {\n    D[i] ^= S[Si + i];\n  }\n}\n\nfunction arraycopy(src, srcPos, dest, destPos, length) {\n  while (length--) {\n    dest[destPos++] = src[srcPos++];\n  }\n}\n\nfunction ensureInteger(value, name) {\n  var intValue = parseInt(value, 10);\n\n  if (value !== intValue) {\n    throw new Error('invalid ' + name);\n  }\n\n  return intValue;\n} // N = Cpu cost, r = Memory cost, p = parallelization cost\n// callback(error, progress, key)\n\n\nfunction scrypt(password, salt, N, r, p, dkLen, callback) {\n  return new Promise( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(resolve, reject) {\n      var b, B, i, j, XY, V, Yi, x, _X, totalOps, currentOp, lastPercent10, stop, state, i0, i1, Bi, limit, nextTick, incrementalSMix;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              N = ensureInteger(N, 'N');\n              r = ensureInteger(r, 'r');\n              p = ensureInteger(p, 'p');\n              dkLen = ensureInteger(dkLen, 'dkLen');\n\n              if (N === 0 || (N & N - 1) !== 0) {\n                reject(new Error('N must be power of 2'));\n              }\n\n              if (N > MAX_VALUE / 128 / r) {\n                reject(new Error('N too large'));\n              }\n\n              if (r > MAX_VALUE / 128 / p) {\n                reject(new Error('r too large'));\n              }\n\n              _context2.t0 = _toConsumableArray;\n              _context2.next = 10;\n              return pbkdf2_1.pbkdf2(password, salt, 1, p * 128 * r);\n\n            case 10:\n              _context2.t1 = _context2.sent;\n              b = (0, _context2.t0)(_context2.t1);\n              B = new Uint32Array(p * 32 * r);\n\n              for (i = 0; i < B.length; i++) {\n                j = i * 4;\n                B[i] = (b[j + 3] & 0xff) << 24 | (b[j + 2] & 0xff) << 16 | (b[j + 1] & 0xff) << 8 | (b[j + 0] & 0xff) << 0;\n              }\n\n              XY = new Uint32Array(64 * r);\n              V = new Uint32Array(32 * r * N);\n              Yi = 32 * r; // scratch space\n\n              x = new Uint32Array(16); // salsa20_8\n\n              _X = new Uint32Array(16); // blockmix_salsa8\n\n              totalOps = p * N * 2;\n              currentOp = 0;\n              lastPercent10 = null; // Set this to true to abandon the scrypt on the next step\n\n              stop = false; // State information\n\n              state = 0;\n              i0 = 0;\n              i1 = 0;\n              // How many blockmix_salsa8 can we do per step?\n              limit = Math.trunc(1000 / r); // Trick from scrypt-async; if there is a setImmediate shim in place, use it\n\n              nextTick = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout; // This is really all I changed; making scryptsy a state machine so we occasionally\n              // stop and give other evnts on the evnt loop a chance to run. ~RicMoo\n\n              incrementalSMix = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  var steps, _i2, percent10, _steps, _i3, offset, _j, _percent, _iterator, _step, bb, derivedKey;\n\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          if (!stop) {\n                            _context.next = 4;\n                            break;\n                          }\n\n                          if (callback) {\n                            callback(currentOp / totalOps);\n                          }\n\n                          reject(new Error('cancelled'));\n                          return _context.abrupt(\"return\");\n\n                        case 4:\n                          _context.t0 = state;\n                          _context.next = _context.t0 === 0 ? 7 : _context.t0 === 1 ? 11 : _context.t0 === 2 ? 26 : 53;\n                          break;\n\n                        case 7:\n                          // for (var i = 0; i < p; i++)...\n                          Bi = i0 * 32 * r;\n                          arraycopy(B, Bi, XY, 0, Yi); // ROMix - 1\n\n                          state = 1; // Move to ROMix 2\n\n                          i1 = 0;\n\n                        case 11:\n                          // Run up to 1000 steps of the first inner smix loop\n                          steps = N - i1;\n\n                          if (steps > limit) {\n                            steps = limit;\n                          }\n\n                          for (_i2 = 0; _i2 < steps; _i2++) {\n                            // ROMix - 2\n                            arraycopy(XY, 0, V, (i1 + _i2) * Yi, Yi); // ROMix - 3\n\n                            blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 4\n                          } // for (var i = 0; i < N; i++)\n\n\n                          i1 += steps;\n                          currentOp += steps; // Call the callback with the progress (optionally stopping us)\n\n                          percent10 = Math.trunc(1000 * currentOp / totalOps);\n\n                          if (!(percent10 !== lastPercent10)) {\n                            _context.next = 22;\n                            break;\n                          }\n\n                          if (callback) {\n                            stop = callback(currentOp / totalOps);\n                          }\n\n                          if (!stop) {\n                            _context.next = 21;\n                            break;\n                          }\n\n                          return _context.abrupt(\"break\", 53);\n\n                        case 21:\n                          lastPercent10 = percent10;\n\n                        case 22:\n                          if (!(i1 < N)) {\n                            _context.next = 24;\n                            break;\n                          }\n\n                          return _context.abrupt(\"break\", 53);\n\n                        case 24:\n                          i1 = 0; // Move to ROMix 6\n\n                          state = 2;\n\n                        case 26:\n                          // Run up to 1000 steps of the second inner smix loop\n                          _steps = N - i1;\n\n                          if (_steps > limit) {\n                            _steps = limit;\n                          }\n\n                          for (_i3 = 0; _i3 < _steps; _i3++) {\n                            // ROMix - 6\n                            offset = (2 * r - 1) * 16; // ROMix - 7\n\n                            _j = XY[offset] & N - 1;\n                            blockxor(V, _j * Yi, XY, Yi); // ROMix - 8 (inner)\n\n                            blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 9 (outer)\n                          } // for (var i = 0; i < N; i++)...\n\n\n                          i1 += _steps;\n                          currentOp += _steps; // Call the callback with the progress (optionally stopping us)\n\n                          _percent = Math.trunc(1000 * currentOp / totalOps);\n\n                          if (!(_percent !== lastPercent10)) {\n                            _context.next = 37;\n                            break;\n                          }\n\n                          if (callback) {\n                            stop = callback(currentOp / totalOps);\n                          }\n\n                          if (!stop) {\n                            _context.next = 36;\n                            break;\n                          }\n\n                          return _context.abrupt(\"break\", 53);\n\n                        case 36:\n                          lastPercent10 = _percent;\n\n                        case 37:\n                          if (!(i1 < N)) {\n                            _context.next = 39;\n                            break;\n                          }\n\n                          return _context.abrupt(\"break\", 53);\n\n                        case 39:\n                          arraycopy(XY, 0, B, Bi, Yi); // ROMix - 10\n                          // for (var i = 0; i < p; i++)...\n\n                          i0++;\n\n                          if (!(i0 < p)) {\n                            _context.next = 44;\n                            break;\n                          }\n\n                          state = 0;\n                          return _context.abrupt(\"break\", 53);\n\n                        case 44:\n                          b = [];\n                          _iterator = _createForOfIteratorHelper(B);\n\n                          try {\n                            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                              bb = _step.value;\n                              b.push(bb >> 0 & 0xff);\n                              b.push(bb >> 8 & 0xff);\n                              b.push(bb >> 16 & 0xff);\n                              b.push(bb >> 24 & 0xff);\n                            }\n                          } catch (err) {\n                            _iterator.e(err);\n                          } finally {\n                            _iterator.f();\n                          }\n\n                          _context.next = 49;\n                          return pbkdf2_1.pbkdf2(password, Buffer.from(b), 1, dkLen);\n\n                        case 49:\n                          derivedKey = _context.sent;\n\n                          // Done; don't break (which would reschedule)\n                          if (callback) {\n                            callback(1.0);\n                          }\n\n                          resolve(derivedKey);\n                          return _context.abrupt(\"return\");\n\n                        case 53:\n                          // Schedule the next steps\n                          nextTick(incrementalSMix);\n\n                        case 54:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function incrementalSMix() {\n                  return _ref2.apply(this, arguments);\n                };\n              }(); // Bootstrap the incremental smix\n\n\n              incrementalSMix();\n\n            case 30:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n}\n\nexports.scrypt = scrypt;","map":null,"metadata":{},"sourceType":"script"}