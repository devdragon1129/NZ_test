{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../../Meshes/mesh\";\nimport { Ray } from \"../../Culling/ray\";\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\nimport { WebVRController } from \"./webVRController\";\nimport { GenericController } from \"./genericController\";\nimport { PoseEnabledController, PoseEnabledControllerType, PoseEnabledControllerHelper } from \"./poseEnabledController\";\n/**\r\n * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh\r\n */\n\nvar LoadedMeshInfo =\n/** @class */\nfunction () {\n  function LoadedMeshInfo() {\n    /**\r\n     * Map of the button meshes contained in the controller\r\n     */\n    this.buttonMeshes = {};\n    /**\r\n     * Map of the axis meshes contained in the controller\r\n     */\n\n    this.axisMeshes = {};\n  }\n\n  return LoadedMeshInfo;\n}();\n/**\r\n * Defines the WindowsMotionController object that the state of the windows motion controller\r\n */\n\n\nvar WindowsMotionController =\n/** @class */\nfunction (_super) {\n  __extends(WindowsMotionController, _super);\n  /**\r\n   * Creates a new WindowsMotionController from a gamepad\r\n   * @param vrGamepad the gamepad that the controller should be created from\r\n   */\n\n\n  function WindowsMotionController(vrGamepad) {\n    var _this = _super.call(this, vrGamepad) || this;\n\n    _this._mapping = {\n      // Semantic button names\n      buttons: ['thumbstick', 'trigger', 'grip', 'menu', 'trackpad'],\n      // trigger, grip, trackpad, thumbstick, menu\n      // A mapping of the button name to glTF model node name\n      // that should be transformed by button value.\n      buttonMeshNames: {\n        'trigger': 'SELECT',\n        'menu': 'MENU',\n        'grip': 'GRASP',\n        'thumbstick': 'THUMBSTICK_PRESS',\n        'trackpad': 'TOUCHPAD_PRESS'\n      },\n      // This mapping is used to translate from the Motion Controller to Babylon semantics\n      buttonObservableNames: {\n        'trigger': 'onTriggerStateChangedObservable',\n        'menu': 'onSecondaryButtonStateChangedObservable',\n        'grip': 'onMainButtonStateChangedObservable',\n        'thumbstick': 'onPadStateChangedObservable',\n        'trackpad': 'onTrackpadChangedObservable'\n      },\n      // A mapping of the axis name to glTF model node name\n      // that should be transformed by axis value.\n      // This array mirrors the browserGamepad.axes array, such that\n      // the mesh corresponding to axis 0 is in this array index 0.\n      axisMeshNames: ['THUMBSTICK_X', 'THUMBSTICK_Y', 'TOUCHPAD_TOUCH_X', 'TOUCHPAD_TOUCH_Y'],\n      // upside down in webxr\n      pointingPoseMeshName: PoseEnabledController.POINTING_POSE\n    };\n    /**\r\n     * Fired when the trackpad on this controller is clicked\r\n     */\n\n    _this.onTrackpadChangedObservable = new Observable();\n    /**\r\n     * Fired when the trackpad on this controller is modified\r\n     */\n\n    _this.onTrackpadValuesChangedObservable = new Observable();\n    /**\r\n     * The current x and y values of this controller's trackpad\r\n     */\n\n    _this.trackpad = {\n      x: 0,\n      y: 0\n    };\n    _this.controllerType = PoseEnabledControllerType.WINDOWS;\n    _this._loadedMeshInfo = null;\n    return _this;\n  }\n\n  Object.defineProperty(WindowsMotionController.prototype, \"onTriggerButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the trigger on this controller is modified\r\n     */\n    get: function get() {\n      return this.onTriggerStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onMenuButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the menu button on this controller is modified\r\n     */\n    get: function get() {\n      return this.onSecondaryButtonStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onGripButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the grip button on this controller is modified\r\n     */\n    get: function get() {\n      return this.onMainButtonStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onThumbstickButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     */\n    get: function get() {\n      return this.onPadStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onTouchpadButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\n    get: function get() {\n      return this.onTrackpadChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onTouchpadValuesChangedObservable\", {\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\n    get: function get() {\n      return this.onTrackpadValuesChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WindowsMotionController.prototype._updateTrackpad = function () {\n    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {\n      this.trackpad.x = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf('TOUCHPAD_TOUCH_X')];\n      this.trackpad.y = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf('TOUCHPAD_TOUCH_Y')];\n      this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);\n    }\n  };\n  /**\r\n   * Called once per frame by the engine.\r\n   */\n\n\n  WindowsMotionController.prototype.update = function () {\n    _super.prototype.update.call(this);\n\n    if (this.browserGamepad.axes) {\n      this._updateTrackpad(); // Only need to animate axes if there is a loaded mesh\n\n\n      if (this._loadedMeshInfo) {\n        for (var axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {\n          this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);\n        }\n      }\n    }\n  };\n  /**\r\n   * Called once for each button that changed state since the last frame\r\n   * @param buttonIdx Which button index changed\r\n   * @param state New state of the button\r\n   * @param changes Which properties on the state changed since last frame\r\n   */\n\n\n  WindowsMotionController.prototype._handleButtonChange = function (buttonIdx, state, changes) {\n    var buttonName = this._mapping.buttons[buttonIdx];\n\n    if (!buttonName) {\n      return;\n    } // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames\n\n\n    this._updateTrackpad(); // Only emit events for buttons that we know how to map from index to name\n\n\n    var observable = this[this._mapping.buttonObservableNames[buttonName]];\n\n    if (observable) {\n      observable.notifyObservers(state);\n    }\n\n    this._lerpButtonTransform(buttonName, state.value);\n  };\n  /**\r\n   * Moves the buttons on the controller mesh based on their current state\r\n   * @param buttonName the name of the button to move\r\n   * @param buttonValue the value of the button which determines the buttons new position\r\n   */\n\n\n  WindowsMotionController.prototype._lerpButtonTransform = function (buttonName, buttonValue) {\n    // If there is no loaded mesh, there is nothing to transform.\n    if (!this._loadedMeshInfo) {\n      return;\n    }\n\n    var meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];\n\n    if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\n      return;\n    }\n\n    Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);\n    Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);\n  };\n  /**\r\n   * Moves the axis on the controller mesh based on its current state\r\n   * @param axis the index of the axis\r\n   * @param axisValue the value of the axis which determines the meshes new position\r\n   * @hidden\r\n   */\n\n\n  WindowsMotionController.prototype._lerpAxisTransform = function (axis, axisValue) {\n    if (!this._loadedMeshInfo) {\n      return;\n    }\n\n    var meshInfo = this._loadedMeshInfo.axisMeshes[axis];\n\n    if (!meshInfo) {\n      return;\n    }\n\n    if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\n      return;\n    } // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\n\n\n    var lerpValue = axisValue * 0.5 + 0.5;\n    Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);\n    Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);\n  };\n  /**\r\n   * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\r\n   * @param scene scene in which to add meshes\r\n   * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\r\n   */\n\n\n  WindowsMotionController.prototype.initControllerMesh = function (scene, meshLoaded, forceDefault) {\n    var _this = this;\n\n    if (forceDefault === void 0) {\n      forceDefault = false;\n    }\n\n    var path;\n    var filename; // Checking if GLB loader is present\n\n    if (SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\n      // Determine the device specific folder based on the ID suffix\n      var device = 'default';\n\n      if (this.id && !forceDefault) {\n        var match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);\n        device = match && match[0] || device;\n      } // Hand\n\n\n      if (this.hand === 'left') {\n        filename = WindowsMotionController.MODEL_LEFT_FILENAME;\n      } else {\n        // Right is the default if no hand is specified\n        filename = WindowsMotionController.MODEL_RIGHT_FILENAME;\n      }\n\n      path = WindowsMotionController.MODEL_BASE_URL + device + '/';\n    } else {\n      Logger.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\");\n      path = GenericController.MODEL_BASE_URL;\n      filename = GenericController.MODEL_FILENAME;\n    }\n\n    SceneLoader.ImportMesh(\"\", path, filename, scene, function (meshes) {\n      // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.\n      _this._loadedMeshInfo = _this.processModel(scene, meshes);\n\n      if (!_this._loadedMeshInfo) {\n        return;\n      }\n\n      _this._defaultModel = _this._loadedMeshInfo.rootNode;\n\n      _this.attachToMesh(_this._defaultModel);\n\n      if (meshLoaded) {\n        meshLoaded(_this._defaultModel);\n      }\n    }, null, function (scene, message) {\n      Logger.Log(message);\n      Logger.Warn('Failed to retrieve controller model from the remote server: ' + path + filename);\n\n      if (!forceDefault) {\n        _this.initControllerMesh(scene, meshLoaded, true);\n      }\n    });\n  };\n  /**\r\n   * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that\r\n   * can be transformed by button presses and axes values, based on this._mapping.\r\n   *\r\n   * @param scene scene in which the meshes exist\r\n   * @param meshes list of meshes that make up the controller model to process\r\n   * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.\r\n   */\n\n\n  WindowsMotionController.prototype.processModel = function (scene, meshes) {\n    var loadedMeshInfo = null; // Create a new mesh to contain the glTF hierarchy\n\n    var parentMesh = new Mesh(this.id + \" \" + this.hand, scene); // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\n\n    var childMesh = null;\n\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n\n      if (!mesh.parent) {\n        // Exclude controller meshes from picking results\n        mesh.isPickable = false; // Handle root node, attach to the new parentMesh\n\n        childMesh = mesh;\n        break;\n      }\n    }\n\n    if (childMesh) {\n      childMesh.setParent(parentMesh); // Create our mesh info. Note that this method will always return non-null.\n\n      loadedMeshInfo = this.createMeshInfo(parentMesh);\n    } else {\n      Logger.Warn('Could not find root node in model file.');\n    }\n\n    return loadedMeshInfo;\n  };\n\n  WindowsMotionController.prototype.createMeshInfo = function (rootNode) {\n    var loadedMeshInfo = new LoadedMeshInfo();\n    var i;\n    loadedMeshInfo.rootNode = rootNode; // Reset the caches\n\n    loadedMeshInfo.buttonMeshes = {};\n    loadedMeshInfo.axisMeshes = {}; // Button Meshes\n\n    for (i = 0; i < this._mapping.buttons.length; i++) {\n      var buttonMeshName = this._mapping.buttonMeshNames[this._mapping.buttons[i]];\n\n      if (!buttonMeshName) {\n        Logger.Log('Skipping unknown button at index: ' + i + ' with mapped name: ' + this._mapping.buttons[i]);\n        continue;\n      }\n\n      var buttonMesh = getChildByName(rootNode, buttonMeshName);\n\n      if (!buttonMesh) {\n        Logger.Warn('Missing button mesh with name: ' + buttonMeshName);\n        continue;\n      }\n\n      var buttonMeshInfo = {\n        index: i,\n        value: getImmediateChildByName(buttonMesh, 'VALUE'),\n        pressed: getImmediateChildByName(buttonMesh, 'PRESSED'),\n        unpressed: getImmediateChildByName(buttonMesh, 'UNPRESSED')\n      };\n\n      if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {\n        loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;\n      } else {\n        // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\n        Logger.Warn('Missing button submesh under mesh with name: ' + buttonMeshName + '(VALUE: ' + !!buttonMeshInfo.value + ', PRESSED: ' + !!buttonMeshInfo.pressed + ', UNPRESSED:' + !!buttonMeshInfo.unpressed + ')');\n      }\n    } // Axis Meshes\n\n\n    for (i = 0; i < this._mapping.axisMeshNames.length; i++) {\n      var axisMeshName = this._mapping.axisMeshNames[i];\n\n      if (!axisMeshName) {\n        Logger.Log('Skipping unknown axis at index: ' + i);\n        continue;\n      }\n\n      var axisMesh = getChildByName(rootNode, axisMeshName);\n\n      if (!axisMesh) {\n        Logger.Warn('Missing axis mesh with name: ' + axisMeshName);\n        continue;\n      }\n\n      var axisMeshInfo = {\n        index: i,\n        value: getImmediateChildByName(axisMesh, 'VALUE'),\n        min: getImmediateChildByName(axisMesh, 'MIN'),\n        max: getImmediateChildByName(axisMesh, 'MAX')\n      };\n\n      if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {\n        loadedMeshInfo.axisMeshes[i] = axisMeshInfo;\n      } else {\n        // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.\n        Logger.Warn('Missing axis submesh under mesh with name: ' + axisMeshName + '(VALUE: ' + !!axisMeshInfo.value + ', MIN: ' + !!axisMeshInfo.min + ', MAX:' + !!axisMeshInfo.max + ')');\n      }\n    } // Pointing Ray\n\n\n    loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);\n\n    if (!loadedMeshInfo.pointingPoseNode) {\n      Logger.Warn('Missing pointing pose mesh with name: ' + this._mapping.pointingPoseMeshName);\n    } else {\n      this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;\n    }\n\n    return loadedMeshInfo; // Look through all children recursively. This will return null if no mesh exists with the given name.\n\n    function getChildByName(node, name) {\n      return node.getChildren(function (n) {\n        return n.name === name;\n      }, false)[0];\n    } // Look through only immediate children. This will return null if no mesh exists with the given name.\n\n\n    function getImmediateChildByName(node, name) {\n      return node.getChildren(function (n) {\n        return n.name == name;\n      }, true)[0];\n    }\n  };\n  /**\r\n   * Gets the ray of the controller in the direction the controller is pointing\r\n   * @param length the length the resulting ray should be\r\n   * @returns a ray in the direction the controller is pointing\r\n   */\n\n\n  WindowsMotionController.prototype.getForwardRay = function (length) {\n    if (length === void 0) {\n      length = 100;\n    }\n\n    if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {\n      return _super.prototype.getForwardRay.call(this, length);\n    }\n\n    var m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();\n\n    var origin = m.getTranslation();\n    var forward = new Vector3(0, 0, -1);\n    var forwardWorld = Vector3.TransformNormal(forward, m);\n    var direction = Vector3.Normalize(forwardWorld);\n    return new Ray(origin, direction, length);\n  };\n  /**\r\n  * Disposes of the controller\r\n  */\n\n\n  WindowsMotionController.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onTrackpadChangedObservable.clear();\n    this.onTrackpadValuesChangedObservable.clear();\n  };\n  /**\r\n   * The base url used to load the left and right controller models\r\n   */\n\n\n  WindowsMotionController.MODEL_BASE_URL = 'https://controllers.babylonjs.com/microsoft/';\n  /**\r\n   * The name of the left controller model file\r\n   */\n\n  WindowsMotionController.MODEL_LEFT_FILENAME = 'left.glb';\n  /**\r\n   * The name of the right controller model file\r\n   */\n\n  WindowsMotionController.MODEL_RIGHT_FILENAME = 'right.glb';\n  /**\r\n   * The controller name prefix for this controller type\r\n   */\n\n  WindowsMotionController.GAMEPAD_ID_PREFIX = 'Spatial Controller (Spatial Interaction Source) ';\n  /**\r\n   * The controller id pattern for this controller type\r\n   */\n\n  WindowsMotionController.GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\n  return WindowsMotionController;\n}(WebVRController);\n\nexport { WindowsMotionController };\n/**\r\n * This class represents a new windows motion controller in XR.\r\n */\n\nvar XRWindowsMotionController =\n/** @class */\nfunction (_super) {\n  __extends(XRWindowsMotionController, _super);\n  /**\r\n   * Construct a new XR-Based windows motion controller\r\n   *\r\n   * @param gamepadInfo the gamepad object from the browser\r\n   */\n\n\n  function XRWindowsMotionController(gamepadInfo) {\n    var _this = _super.call(this, gamepadInfo) || this;\n    /**\r\n     * Changing the original WIndowsMotionController mapping to fir the new mapping\r\n     */\n\n\n    _this._mapping = {\n      // Semantic button names\n      buttons: ['trigger', 'grip', 'trackpad', 'thumbstick', 'menu'],\n      // trigger, grip, trackpad, thumbstick, menu\n      // A mapping of the button name to glTF model node name\n      // that should be transformed by button value.\n      buttonMeshNames: {\n        'trigger': 'SELECT',\n        'menu': 'MENU',\n        'grip': 'GRASP',\n        'thumbstick': 'THUMBSTICK_PRESS',\n        'trackpad': 'TOUCHPAD_PRESS'\n      },\n      // This mapping is used to translate from the Motion Controller to Babylon semantics\n      buttonObservableNames: {\n        'trigger': 'onTriggerStateChangedObservable',\n        'menu': 'onSecondaryButtonStateChangedObservable',\n        'grip': 'onMainButtonStateChangedObservable',\n        'thumbstick': 'onThumbstickStateChangedObservable',\n        'trackpad': 'onTrackpadChangedObservable'\n      },\n      // A mapping of the axis name to glTF model node name\n      // that should be transformed by axis value.\n      // This array mirrors the browserGamepad.axes array, such that\n      // the mesh corresponding to axis 0 is in this array index 0.\n      axisMeshNames: ['TOUCHPAD_TOUCH_X', 'TOUCHPAD_TOUCH_Y', 'THUMBSTICK_X', 'THUMBSTICK_Y'],\n      // upside down in webxr\n      pointingPoseMeshName: PoseEnabledController.POINTING_POSE\n    };\n    /**\r\n     * holds the thumbstick values (X,Y)\r\n     */\n\n    _this.thumbstickValues = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * Fired when the thumbstick on this controller is clicked\r\n     */\n\n    _this.onThumbstickStateChangedObservable = new Observable();\n    /**\r\n     * Fired when the thumbstick on this controller is modified\r\n     */\n\n    _this.onThumbstickValuesChangedObservable = new Observable();\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\n\n    _this.onTrackpadChangedObservable = _this.onPadStateChangedObservable;\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\n\n    _this.onTrackpadValuesChangedObservable = _this.onPadValuesChangedObservable;\n    return _this;\n  }\n\n  Object.defineProperty(XRWindowsMotionController.prototype, \"onThumbstickButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     * here to prevent breaking changes\r\n     */\n    get: function get() {\n      return this.onThumbstickStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * updating the thumbstick(!) and not the trackpad.\r\n   * This is named this way due to the difference between WebVR and XR and to avoid\r\n   * changing the parent class.\r\n   */\n\n  XRWindowsMotionController.prototype._updateTrackpad = function () {\n    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {\n      this.trackpad.x = this.browserGamepad[\"axes\"][2];\n      this.trackpad.y = this.browserGamepad[\"axes\"][3];\n      this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);\n    }\n  };\n  /**\r\n   * Disposes the class with joy\r\n   */\n\n\n  XRWindowsMotionController.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onThumbstickStateChangedObservable.clear();\n    this.onThumbstickValuesChangedObservable.clear();\n  };\n\n  return XRWindowsMotionController;\n}(WindowsMotionController);\n\nexport { XRWindowsMotionController };\n\nPoseEnabledControllerHelper._ControllerFactories.push({\n  canCreate: function canCreate(gamepadInfo) {\n    return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;\n  },\n  create: function create(gamepadInfo) {\n    return new WindowsMotionController(gamepadInfo);\n  }\n});","map":null,"metadata":{},"sourceType":"module"}