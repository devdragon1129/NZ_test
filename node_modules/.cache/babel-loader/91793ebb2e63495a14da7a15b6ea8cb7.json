{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { _TypeStore } from '../../Misc/typeStore';\nimport \"../../Engines/Extensions/engine.cubeTexture\";\nimport { StringTools } from '../../Misc/stringTools';\nimport { Observable } from '../../Misc/observable';\n/**\r\n * Class for creating a cube texture\r\n */\n\nvar CubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(CubeTexture, _super);\n  /**\r\n   * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n   * as prefiltered data.\r\n   * @param rootUrl defines the url of the texture or the root name of the six images\r\n   * @param null defines the scene or engine the texture is attached to\r\n   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n   * @param noMipmap defines if mipmaps should be created or not\r\n   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n   * @param onLoad defines a callback triggered at the end of the file load if no errors occured\r\n   * @param onError defines a callback triggered in case of error during load\r\n   * @param format defines the internal format to use for the texture once loaded\r\n   * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n   * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n   * @param loaderOptions options to be passed to the loader\r\n   * @return the cube texture\r\n   */\n\n\n  function CubeTexture(rootUrl, sceneOrEngine, extensions, noMipmap, files, onLoad, onError, format, prefiltered, forcedExtension, createPolynomials, lodScale, lodOffset, loaderOptions) {\n    if (extensions === void 0) {\n      extensions = null;\n    }\n\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (files === void 0) {\n      files = null;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (prefiltered === void 0) {\n      prefiltered = false;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    if (createPolynomials === void 0) {\n      createPolynomials = false;\n    }\n\n    if (lodScale === void 0) {\n      lodScale = 0.8;\n    }\n\n    if (lodOffset === void 0) {\n      lodOffset = 0;\n    }\n\n    var _a;\n\n    var _this = _super.call(this, sceneOrEngine) || this;\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\n\n\n    _this.onLoadObservable = new Observable();\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\n\n    _this.boundingBoxPosition = Vector3.Zero();\n    _this._rotationY = 0;\n    _this._files = null;\n    _this._forcedExtension = null;\n    _this._extensions = null;\n    _this.name = rootUrl;\n    _this.url = rootUrl;\n    _this._noMipmap = noMipmap;\n    _this.hasAlpha = false;\n    _this._format = format;\n    _this.isCube = true;\n    _this._textureMatrix = Matrix.Identity();\n    _this._createPolynomials = createPolynomials;\n    _this.coordinatesMode = Texture.CUBIC_MODE;\n    _this._extensions = extensions;\n    _this._files = files;\n    _this._forcedExtension = forcedExtension;\n    _this._loaderOptions = loaderOptions;\n\n    if (!rootUrl && !files) {\n      return _this;\n    }\n\n    var lastDot = rootUrl.lastIndexOf(\".\");\n    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\n    var isDDS = extension === \".dds\";\n    var isEnv = extension === \".env\";\n\n    if (isEnv) {\n      _this.gammaSpace = false;\n      _this._prefiltered = false;\n      _this.anisotropicFilteringLevel = 1;\n    } else {\n      _this._prefiltered = prefiltered;\n\n      if (prefiltered) {\n        _this.gammaSpace = false;\n        _this.anisotropicFilteringLevel = 1;\n      }\n    }\n\n    _this._texture = _this._getFromCache(rootUrl, noMipmap);\n\n    if (!files) {\n      if (!isEnv && !isDDS && !extensions) {\n        extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\n      }\n\n      files = [];\n\n      if (extensions) {\n        for (var index = 0; index < extensions.length; index++) {\n          files.push(rootUrl + extensions[index]);\n        }\n      }\n    }\n\n    _this._files = files;\n\n    var onLoadProcessing = function onLoadProcessing() {\n      _this.onLoadObservable.notifyObservers(_this);\n\n      if (onLoad) {\n        onLoad();\n      }\n    };\n\n    if (!_this._texture) {\n      var scene = _this.getScene();\n\n      if (!(scene === null || scene === void 0 ? void 0 : scene.useDelayedTextureLoading)) {\n        if (prefiltered) {\n          _this._texture = _this._getEngine().createPrefilteredCubeTexture(rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, _this._createPolynomials);\n        } else {\n          _this._texture = _this._getEngine().createCubeTexture(rootUrl, scene, files, noMipmap, onLoad, onError, _this._format, forcedExtension, false, lodScale, lodOffset, null, loaderOptions);\n        }\n\n        (_a = _this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(function () {\n          return _this.onLoadObservable.notifyObservers(_this);\n        });\n      } else {\n        _this.delayLoadState = 4;\n      }\n    } else {\n      if (_this._texture.isReady) {\n        Tools.SetImmediate(function () {\n          return onLoadProcessing();\n        });\n      } else {\n        _this._texture.onLoadedObservable.add(function () {\n          return onLoadProcessing();\n        });\n      }\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(CubeTexture.prototype, \"boundingBoxSize\", {\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\n    get: function get() {\n      return this._boundingBoxSize;\n    },\n\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\n    set: function set(value) {\n      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n        return;\n      }\n\n      this._boundingBoxSize = value;\n      var scene = this.getScene();\n\n      if (scene) {\n        scene.markAllMaterialsAsDirty(1);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CubeTexture.prototype, \"rotationY\", {\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\n    get: function get() {\n      return this._rotationY;\n    },\n\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\n    set: function set(value) {\n      this._rotationY = value;\n      this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CubeTexture.prototype, \"noMipmap\", {\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\n    get: function get() {\n      return this._noMipmap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a cube texture from an array of image urls\r\n   * @param files defines an array of image urls\r\n   * @param scene defines the hosting scene\r\n   * @param noMipmap specifies if mip maps are not used\r\n   * @returns a cube texture\r\n   */\n\n  CubeTexture.CreateFromImages = function (files, scene, noMipmap) {\n    var rootUrlKey = \"\";\n    files.forEach(function (url) {\n      return rootUrlKey += url;\n    });\n    return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\n  };\n  /**\r\n   * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n   * @param url defines the url of the prefiltered texture\r\n   * @param scene defines the scene the texture is attached to\r\n   * @param forcedExtension defines the extension of the file if different from the url\r\n   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n   * @return the prefiltered texture\r\n   */\n\n\n  CubeTexture.CreateFromPrefilteredData = function (url, scene, forcedExtension, createPolynomials) {\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    if (createPolynomials === void 0) {\n      createPolynomials = true;\n    }\n\n    var oldValue = scene.useDelayedTextureLoading;\n    scene.useDelayedTextureLoading = false;\n    var result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\n    scene.useDelayedTextureLoading = oldValue;\n    return result;\n  };\n  /**\r\n   * Get the current class name of the texture useful for serialization or dynamic coding.\r\n   * @returns \"CubeTexture\"\r\n   */\n\n\n  CubeTexture.prototype.getClassName = function () {\n    return \"CubeTexture\";\n  };\n  /**\r\n   * Update the url (and optional buffer) of this texture if url was null during construction.\r\n   * @param url the url of the texture\r\n   * @param forcedExtension defines the extension to use\r\n   * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n   * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n   */\n\n\n  CubeTexture.prototype.updateURL = function (url, forcedExtension, onLoad, prefiltered) {\n    var _a;\n\n    if (prefiltered === void 0) {\n      prefiltered = false;\n    }\n\n    if (this.url) {\n      this.releaseInternalTexture();\n      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1);\n    }\n\n    if (!this.name || StringTools.StartsWith(this.name, \"data:\")) {\n      this.name = url;\n    }\n\n    this.url = url;\n    this.delayLoadState = 4;\n    this._prefiltered = prefiltered;\n\n    if (this._prefiltered) {\n      this.gammaSpace = false;\n      this.anisotropicFilteringLevel = 1;\n    }\n\n    this._forcedExtension = forcedExtension || null;\n\n    if (onLoad) {\n      this._delayedOnLoad = onLoad;\n    }\n\n    this.delayLoad(forcedExtension);\n  };\n  /**\r\n   * Delays loading of the cube texture\r\n   * @param forcedExtension defines the extension to use\r\n   */\n\n\n  CubeTexture.prototype.delayLoad = function (forcedExtension) {\n    var _this = this;\n\n    var _a;\n\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, this._noMipmap);\n\n    if (!this._texture) {\n      var scene = this.getScene();\n\n      if (this._prefiltered) {\n        this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, 0.8, 0, this._delayedOnLoad, undefined, this._format, forcedExtension, this._createPolynomials);\n      } else {\n        this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, this._delayedOnLoad, null, this._format, forcedExtension, false, 0, 0, null, this._loaderOptions);\n      }\n\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(function () {\n        return _this.onLoadObservable.notifyObservers(_this);\n      });\n    }\n  };\n  /**\r\n   * Returns the reflection texture matrix\r\n   * @returns the reflection texture matrix\r\n   */\n\n\n  CubeTexture.prototype.getReflectionTextureMatrix = function () {\n    return this._textureMatrix;\n  };\n  /**\r\n   * Sets the reflection texture matrix\r\n   * @param value Reflection texture matrix\r\n   */\n\n\n  CubeTexture.prototype.setReflectionTextureMatrix = function (value) {\n    var _this = this;\n\n    var _a;\n\n    if (value.updateFlag === this._textureMatrix.updateFlag) {\n      return;\n    }\n\n    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, function (mat) {\n        return mat.getActiveTextures().indexOf(_this) !== -1;\n      });\n    }\n\n    this._textureMatrix = value;\n  };\n  /**\r\n   * Parses text to create a cube texture\r\n   * @param parsedTexture define the serialized text to read from\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root url of the cube texture\r\n   * @returns a cube texture\r\n   */\n\n\n  CubeTexture.Parse = function (parsedTexture, scene, rootUrl) {\n    var texture = SerializationHelper.Parse(function () {\n      var prefiltered = false;\n\n      if (parsedTexture.prefiltered) {\n        prefiltered = parsedTexture.prefiltered;\n      }\n\n      return new CubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, undefined, prefiltered, parsedTexture.forcedExtension);\n    }, parsedTexture, scene); // Local Cubemaps\n\n    if (parsedTexture.boundingBoxPosition) {\n      texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n    }\n\n    if (parsedTexture.boundingBoxSize) {\n      texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n    } // Animations\n\n\n    if (parsedTexture.animations) {\n      for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n        var parsedAnimation = parsedTexture.animations[animationIndex];\n\n        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          texture.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n    }\n\n    return texture;\n  };\n  /**\r\n   * Makes a clone, or deep copy, of the cube texture\r\n   * @returns a new cube texture\r\n   */\n\n\n  CubeTexture.prototype.clone = function () {\n    var _this = this;\n\n    var uniqueId = 0;\n    var newCubeTexture = SerializationHelper.Clone(function () {\n      var cubeTexture = new CubeTexture(_this.url, _this.getScene() || _this._getEngine(), _this._extensions, _this._noMipmap, _this._files);\n      uniqueId = cubeTexture.uniqueId;\n      return cubeTexture;\n    }, this);\n    newCubeTexture.uniqueId = uniqueId;\n    return newCubeTexture;\n  };\n\n  __decorate([serialize()], CubeTexture.prototype, \"url\", void 0);\n\n  __decorate([serialize(\"rotationY\")], CubeTexture.prototype, \"rotationY\", null);\n\n  __decorate([serialize(\"files\")], CubeTexture.prototype, \"_files\", void 0);\n\n  __decorate([serialize(\"forcedExtension\")], CubeTexture.prototype, \"_forcedExtension\", void 0);\n\n  __decorate([serialize(\"extensions\")], CubeTexture.prototype, \"_extensions\", void 0);\n\n  __decorate([serializeAsMatrix(\"textureMatrix\")], CubeTexture.prototype, \"_textureMatrix\", void 0);\n\n  return CubeTexture;\n}(BaseTexture);\n\nexport { CubeTexture };\nTexture._CubeTextureParser = CubeTexture.Parse; // Some exporters relies on Tools.Instantiate\n\n_TypeStore.RegisteredTypes[\"BABYLON.CubeTexture\"] = CubeTexture;","map":null,"metadata":{},"sourceType":"module"}