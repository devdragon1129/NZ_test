{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\nimport { Scalar } from \"../../Maths/math.scalar\";\n/**\r\n * Particle emitter emitting particles from the inside of a cone.\r\n * It emits the particles alongside the cone volume from the base to the particle.\r\n * The emission direction might be randomized.\r\n */\n\nvar ConeParticleEmitter =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance ConeParticleEmitter\r\n   * @param radius the radius of the emission cone (1 by default)\r\n   * @param angle the cone base angle (PI by default)\r\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\r\n   */\n  function ConeParticleEmitter(radius, angle,\n  /** defines how much to randomize the particle direction [0-1] (default is 0) */\n  directionRandomizer) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (angle === void 0) {\n      angle = Math.PI;\n    }\n\n    if (directionRandomizer === void 0) {\n      directionRandomizer = 0;\n    }\n\n    this.directionRandomizer = directionRandomizer;\n    /**\r\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\n\n    this.radiusRange = 1;\n    /**\r\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\n\n    this.heightRange = 1;\n    /**\r\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\r\n     */\n\n    this.emitFromSpawnPointOnly = false;\n    this.angle = angle;\n    this.radius = radius;\n  }\n\n  Object.defineProperty(ConeParticleEmitter.prototype, \"radius\", {\n    /**\r\n     * Gets or sets the radius of the emission cone\r\n     */\n    get: function get() {\n      return this._radius;\n    },\n    set: function set(value) {\n      this._radius = value;\n\n      this._buildHeight();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConeParticleEmitter.prototype, \"angle\", {\n    /**\r\n     * Gets or sets the angle of the emission cone\r\n     */\n    get: function get() {\n      return this._angle;\n    },\n    set: function set(value) {\n      this._angle = value;\n\n      this._buildHeight();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ConeParticleEmitter.prototype._buildHeight = function () {\n    if (this._angle !== 0) {\n      this._height = this._radius / Math.tan(this._angle / 2);\n    } else {\n      this._height = 1;\n    }\n  };\n  /**\r\n   * Called by the particle System when the direction is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param directionToUpdate is the direction vector to update with the result\r\n   * @param particle is the particle we are computed the direction for\r\n   * @param isLocal defines if the direction should be set in local space\r\n   */\n\n\n  ConeParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    if (isLocal) {\n      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();\n    } else {\n      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\n    }\n\n    var randX = Scalar.RandomRange(0, this.directionRandomizer);\n    var randY = Scalar.RandomRange(0, this.directionRandomizer);\n    var randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\n    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\n    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\n    directionToUpdate.normalize();\n  };\n  /**\r\n   * Called by the particle System when the position is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param positionToUpdate is the position vector to update with the result\r\n   * @param particle is the particle we are computed the position for\r\n   * @param isLocal defines if the position should be set in local space\r\n   */\n\n\n  ConeParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var s = Scalar.RandomRange(0, Math.PI * 2);\n    var h;\n\n    if (!this.emitFromSpawnPointOnly) {\n      h = Scalar.RandomRange(0, this.heightRange); // Better distribution in a cone at normal angles.\n\n      h = 1 - h * h;\n    } else {\n      h = 0.0001;\n    }\n\n    var radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\n    radius = radius * h;\n    var randX = radius * Math.sin(s);\n    var randZ = radius * Math.cos(s);\n    var randY = h * this._height;\n\n    if (isLocal) {\n      positionToUpdate.x = randX;\n      positionToUpdate.y = randY;\n      positionToUpdate.z = randZ;\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  };\n  /**\r\n   * Clones the current emitter and returns a copy of it\r\n   * @returns the new emitter\r\n   */\n\n\n  ConeParticleEmitter.prototype.clone = function () {\n    var newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\r\n   * Called by the GPUParticleSystem to setup the update shader\r\n   * @param effect defines the update shader\r\n   */\n\n\n  ConeParticleEmitter.prototype.applyToShader = function (effect) {\n    effect.setFloat2(\"radius\", this._radius, this.radiusRange);\n    effect.setFloat(\"coneAngle\", this._angle);\n    effect.setFloat2(\"height\", this._height, this.heightRange);\n    effect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  };\n  /**\r\n   * Returns a string to use to update the GPU particles update shader\r\n   * @returns a string containng the defines string\r\n   */\n\n\n  ConeParticleEmitter.prototype.getEffectDefines = function () {\n    var defines = \"#define CONEEMITTER\";\n\n    if (this.emitFromSpawnPointOnly) {\n      defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\n    }\n\n    return defines;\n  };\n  /**\r\n   * Returns the string \"ConeParticleEmitter\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  ConeParticleEmitter.prototype.getClassName = function () {\n    return \"ConeParticleEmitter\";\n  };\n  /**\r\n   * Serializes the particle system to a JSON object.\r\n   * @returns the JSON object\r\n   */\n\n\n  ConeParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this._radius;\n    serializationObject.angle = this._angle;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.heightRange = this.heightRange;\n    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\n    return serializationObject;\n  };\n  /**\r\n   * Parse properties from a JSON object\r\n   * @param serializationObject defines the JSON object\r\n   */\n\n\n  ConeParticleEmitter.prototype.parse = function (serializationObject) {\n    this.radius = serializationObject.radius;\n    this.angle = serializationObject.angle;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n    this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\n    this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\n    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\n  };\n\n  return ConeParticleEmitter;\n}();\n\nexport { ConeParticleEmitter };","map":null,"metadata":{},"sourceType":"module"}