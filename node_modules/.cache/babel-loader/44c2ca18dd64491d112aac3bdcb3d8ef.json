{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { DomManagement } from \"../Misc/domManagement\";\nimport { Logger } from \"../Misc/logger\";\nimport { ShaderProcessor } from '../Engines/Processors/shaderProcessor';\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\n\nvar Effect =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates an effect.\r\n   * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n   * @param baseName Name of the effect.\r\n   * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n   * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n   * @param samplers List of sampler variables that will be passed to the shader.\r\n   * @param engine Engine to be used to render the effect\r\n   * @param defines Define statements to be added to the shader.\r\n   * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n   * @param onCompiled Callback that will be called when the shader is compiled.\r\n   * @param onError Callback that will be called if an error occurs during shader compilation.\r\n   * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})\r\n   */\n  function Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, engine, defines, fallbacks, onCompiled, onError, indexParameters) {\n    var _this = this;\n\n    if (samplers === void 0) {\n      samplers = null;\n    }\n\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (fallbacks === void 0) {\n      fallbacks = null;\n    }\n\n    if (onCompiled === void 0) {\n      onCompiled = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _a;\n    /**\r\n     * Name of the effect.\r\n     */\n\n\n    this.name = null;\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\n\n    this.defines = \"\";\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\n\n    this.onCompiled = null;\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\n\n    this.onError = null;\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\n\n    this.onBind = null;\n    /**\r\n     * Unique ID of the effect.\r\n     */\n\n    this.uniqueId = 0;\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\n\n    this.onCompileObservable = new Observable();\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\n\n    this.onErrorObservable = new Observable();\n    /** @hidden */\n\n    this._onBindObservable = null;\n    /**\r\n     * @hidden\r\n     * Specifies if the effect was previously ready\r\n     */\n\n    this._wasPreviouslyReady = false;\n    /** @hidden */\n\n    this._bonesComputationForcedToCPU = false;\n    /** @hidden */\n\n    this._multiTarget = false;\n    this._uniformBuffersNames = {};\n    this._samplers = {};\n    this._isReady = false;\n    this._compilationError = \"\";\n    this._allFallbacksProcessed = false;\n    this._uniforms = {};\n    /**\r\n     * Key for the effect.\r\n     * @hidden\r\n     */\n\n    this._key = \"\";\n    this._fallbacks = null;\n    this._vertexSourceCode = \"\";\n    this._fragmentSourceCode = \"\";\n    this._vertexSourceCodeOverride = \"\";\n    this._fragmentSourceCodeOverride = \"\";\n    this._transformFeedbackVaryings = null;\n    this._rawVertexSourceCode = \"\";\n    this._rawFragmentSourceCode = \"\";\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @hidden\r\n     */\n\n    this._pipelineContext = null;\n    this._valueCache = {};\n    this.name = baseName;\n    var processFinalCode = null;\n\n    if (attributesNamesOrOptions.attributes) {\n      var options = attributesNamesOrOptions;\n      this._engine = uniformsNamesOrEngine;\n      this._attributesNames = options.attributes;\n      this._uniformsNames = options.uniformsNames.concat(options.samplers);\n      this._samplerList = options.samplers.slice();\n      this.defines = options.defines;\n      this.onError = options.onError;\n      this.onCompiled = options.onCompiled;\n      this._fallbacks = options.fallbacks;\n      this._indexParameters = options.indexParameters;\n      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\n      this._multiTarget = !!options.multiTarget;\n\n      if (options.uniformBuffersNames) {\n        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\n\n        for (var i = 0; i < options.uniformBuffersNames.length; i++) {\n          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\n        }\n      }\n\n      processFinalCode = (_a = options.processFinalCode) !== null && _a !== void 0 ? _a : null;\n    } else {\n      this._engine = engine;\n      this.defines = defines == null ? \"\" : defines;\n      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);\n      this._samplerList = samplers ? samplers.slice() : [];\n      this._attributesNames = attributesNamesOrOptions;\n      this._uniformBuffersNamesList = [];\n      this.onError = onError;\n      this.onCompiled = onCompiled;\n      this._indexParameters = indexParameters;\n      this._fallbacks = fallbacks;\n    }\n\n    this._attributeLocationByName = {};\n    this.uniqueId = Effect._uniqueIdSeed++;\n    var vertexSource;\n    var fragmentSource;\n    var hostDocument = DomManagement.IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n\n    if (baseName.vertexSource) {\n      vertexSource = \"source:\" + baseName.vertexSource;\n    } else if (baseName.vertexElement) {\n      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\n\n      if (!vertexSource) {\n        vertexSource = baseName.vertexElement;\n      }\n    } else {\n      vertexSource = baseName.vertex || baseName;\n    }\n\n    if (baseName.fragmentSource) {\n      fragmentSource = \"source:\" + baseName.fragmentSource;\n    } else if (baseName.fragmentElement) {\n      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\n\n      if (!fragmentSource) {\n        fragmentSource = baseName.fragmentElement;\n      }\n    } else {\n      fragmentSource = baseName.fragment || baseName;\n    }\n\n    var processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: this._indexParameters,\n      isFragment: false,\n      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\n      processor: this._engine._shaderProcessor,\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: Effect.ShadersRepository,\n      includesShadersStore: Effect.IncludesShadersStore,\n      version: (this._engine.webGLVersion * 100).toString(),\n      platformName: this._engine.webGLVersion >= 2 ? \"WEBGL2\" : \"WEBGL1\"\n    };\n\n    this._loadShader(vertexSource, \"Vertex\", \"\", function (vertexCode) {\n      _this._rawVertexSourceCode = vertexCode;\n\n      _this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", function (fragmentCode) {\n        _this._rawFragmentSourceCode = fragmentCode;\n        ShaderProcessor.Process(vertexCode, processorOptions, function (migratedVertexCode) {\n          if (processFinalCode) {\n            migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\n          }\n\n          processorOptions.isFragment = true;\n          ShaderProcessor.Process(fragmentCode, processorOptions, function (migratedFragmentCode) {\n            if (processFinalCode) {\n              migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\n            }\n\n            _this._useFinalCode(migratedVertexCode, migratedFragmentCode, baseName);\n          }, _this._engine);\n        }, _this._engine);\n      });\n    });\n  }\n\n  Object.defineProperty(Effect.prototype, \"onBindObservable\", {\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\n    get: function get() {\n      if (!this._onBindObservable) {\n        this._onBindObservable = new Observable();\n      }\n\n      return this._onBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Effect.prototype._useFinalCode = function (migratedVertexCode, migratedFragmentCode, baseName) {\n    if (baseName) {\n      var vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\n      var fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\n      this._vertexSourceCode = \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\n      this._fragmentSourceCode = \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\n    } else {\n      this._vertexSourceCode = migratedVertexCode;\n      this._fragmentSourceCode = migratedFragmentCode;\n    }\n\n    this._prepareEffect();\n  };\n\n  Object.defineProperty(Effect.prototype, \"key\", {\n    /**\r\n     * Unique key for this effect\r\n     */\n    get: function get() {\n      return this._key;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * If the effect has been compiled and prepared.\r\n   * @returns if the effect is compiled and prepared.\r\n   */\n\n  Effect.prototype.isReady = function () {\n    try {\n      return this._isReadyInternal();\n    } catch (_a) {\n      return false;\n    }\n  };\n\n  Effect.prototype._isReadyInternal = function () {\n    if (this._isReady) {\n      return true;\n    }\n\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n\n    return false;\n  };\n  /**\r\n   * The engine the effect was initialized with.\r\n   * @returns the engine.\r\n   */\n\n\n  Effect.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * The pipeline context for this effect\r\n   * @returns the associated pipeline context\r\n   */\n\n\n  Effect.prototype.getPipelineContext = function () {\n    return this._pipelineContext;\n  };\n  /**\r\n   * The set of names of attribute variables for the shader.\r\n   * @returns An array of attribute names.\r\n   */\n\n\n  Effect.prototype.getAttributesNames = function () {\n    return this._attributesNames;\n  };\n  /**\r\n   * Returns the attribute at the given index.\r\n   * @param index The index of the attribute.\r\n   * @returns The location of the attribute.\r\n   */\n\n\n  Effect.prototype.getAttributeLocation = function (index) {\n    return this._attributes[index];\n  };\n  /**\r\n   * Returns the attribute based on the name of the variable.\r\n   * @param name of the attribute to look up.\r\n   * @returns the attribute location.\r\n   */\n\n\n  Effect.prototype.getAttributeLocationByName = function (name) {\n    return this._attributeLocationByName[name];\n  };\n  /**\r\n   * The number of attributes.\r\n   * @returns the numnber of attributes.\r\n   */\n\n\n  Effect.prototype.getAttributesCount = function () {\n    return this._attributes.length;\n  };\n  /**\r\n   * Gets the index of a uniform variable.\r\n   * @param uniformName of the uniform to look up.\r\n   * @returns the index.\r\n   */\n\n\n  Effect.prototype.getUniformIndex = function (uniformName) {\n    return this._uniformsNames.indexOf(uniformName);\n  };\n  /**\r\n   * Returns the attribute based on the name of the variable.\r\n   * @param uniformName of the uniform to look up.\r\n   * @returns the location of the uniform.\r\n   */\n\n\n  Effect.prototype.getUniform = function (uniformName) {\n    return this._uniforms[uniformName];\n  };\n  /**\r\n   * Returns an array of sampler variable names\r\n   * @returns The array of sampler variable names.\r\n   */\n\n\n  Effect.prototype.getSamplers = function () {\n    return this._samplerList;\n  };\n  /**\r\n   * Returns an array of uniform variable names\r\n   * @returns The array of uniform variable names.\r\n   */\n\n\n  Effect.prototype.getUniformNames = function () {\n    return this._uniformsNames;\n  };\n  /**\r\n   * Returns an array of uniform buffer variable names\r\n   * @returns The array of uniform buffer variable names.\r\n   */\n\n\n  Effect.prototype.getUniformBuffersNames = function () {\n    return this._uniformBuffersNamesList;\n  };\n  /**\r\n   * Returns the index parameters used to create the effect\r\n   * @returns The index parameters object\r\n   */\n\n\n  Effect.prototype.getIndexParameters = function () {\n    return this._indexParameters;\n  };\n  /**\r\n   * The error from the last compilation.\r\n   * @returns the error string.\r\n   */\n\n\n  Effect.prototype.getCompilationError = function () {\n    return this._compilationError;\n  };\n  /**\r\n   * Gets a boolean indicating that all fallbacks were used during compilation\r\n   * @returns true if all fallbacks were used\r\n   */\n\n\n  Effect.prototype.allFallbacksProcessed = function () {\n    return this._allFallbacksProcessed;\n  };\n  /**\r\n   * Adds a callback to the onCompiled observable and call the callback imediatly if already ready.\r\n   * @param func The callback to be used.\r\n   */\n\n\n  Effect.prototype.executeWhenCompiled = function (func) {\n    var _this = this;\n\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n\n    this.onCompileObservable.add(function (effect) {\n      func(effect);\n    });\n\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(function () {\n        _this._checkIsReady(null);\n      }, 16);\n    }\n  };\n\n  Effect.prototype._checkIsReady = function (previousPipelineContext) {\n    var _this = this;\n\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n\n      return;\n    }\n\n    setTimeout(function () {\n      _this._checkIsReady(previousPipelineContext);\n    }, 16);\n  };\n\n  Effect.prototype._loadShader = function (shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        var shaderCode = DomManagement.GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    } // Direct source ?\n\n\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    } // Base64 encoded ?\n\n\n    if (shader.substr(0, 7) === \"base64:\") {\n      var shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    } // Is in local store ?\n\n\n    if (Effect.ShadersStore[shader + key + \"Shader\"]) {\n      callback(Effect.ShadersStore[shader + key + \"Shader\"]);\n      return;\n    }\n\n    if (optionalKey && Effect.ShadersStore[shader + optionalKey + \"Shader\"]) {\n      callback(Effect.ShadersStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n\n    var shaderUrl;\n\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = Effect.ShadersRepository + shader;\n    } // Vertex shader\n\n\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  };\n\n  Object.defineProperty(Effect.prototype, \"vertexSourceCode\", {\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     */\n    get: function get() {\n      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : this._vertexSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"fragmentSourceCode\", {\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     */\n    get: function get() {\n      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : this._fragmentSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"rawVertexSourceCode\", {\n    /**\r\n     * Gets the vertex shader source code before it has been processed by the preprocessor\r\n     */\n    get: function get() {\n      return this._rawVertexSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"rawFragmentSourceCode\", {\n    /**\r\n     * Gets the fragment shader source code before it has been processed by the preprocessor\r\n     */\n    get: function get() {\n      return this._rawFragmentSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Recompiles the webGL program\r\n   * @param vertexSourceCode The source code for the vertex shader.\r\n   * @param fragmentSourceCode The source code for the fragment shader.\r\n   * @param onCompiled Callback called when completed.\r\n   * @param onError Callback called on error.\r\n   * @hidden\r\n   */\n\n  Effect.prototype._rebuildProgram = function (vertexSourceCode, fragmentSourceCode, onCompiled, onError) {\n    var _this = this;\n\n    this._isReady = false;\n    this._vertexSourceCodeOverride = vertexSourceCode;\n    this._fragmentSourceCodeOverride = fragmentSourceCode;\n\n    this.onError = function (effect, error) {\n      if (onError) {\n        onError(error);\n      }\n    };\n\n    this.onCompiled = function () {\n      var scenes = _this.getEngine().scenes;\n\n      if (scenes) {\n        for (var i = 0; i < scenes.length; i++) {\n          scenes[i].markAllMaterialsAsDirty(63);\n        }\n      }\n\n      _this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);\n    };\n\n    this._fallbacks = null;\n\n    this._prepareEffect();\n  };\n  /**\r\n   * Prepares the effect\r\n   * @hidden\r\n   */\n\n\n  Effect.prototype._prepareEffect = function () {\n    var _this = this;\n\n    var attributesNames = this._attributesNames;\n    var defines = this.defines;\n    this._valueCache = {};\n    var previousPipelineContext = this._pipelineContext;\n\n    try {\n      var engine_1 = this._engine;\n      this._pipelineContext = engine_1.createPipelineContext();\n\n      var rebuildRebind = this._rebuildProgram.bind(this);\n\n      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\n        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, rebuildRebind, null, this._transformFeedbackVaryings);\n      } else {\n        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, rebuildRebind, defines, this._transformFeedbackVaryings);\n      }\n\n      engine_1._executeWhenRenderingStateIsCompiled(this._pipelineContext, function () {\n        if (engine_1.supportsUniformBuffers) {\n          for (var name in _this._uniformBuffersNames) {\n            _this.bindUniformBlock(name, _this._uniformBuffersNames[name]);\n          }\n        }\n\n        var uniforms = engine_1.getUniforms(_this._pipelineContext, _this._uniformsNames);\n        uniforms.forEach(function (uniform, index) {\n          _this._uniforms[_this._uniformsNames[index]] = uniform;\n        });\n        _this._attributes = engine_1.getAttributes(_this._pipelineContext, attributesNames);\n\n        if (attributesNames) {\n          for (var i = 0; i < attributesNames.length; i++) {\n            var name_1 = attributesNames[i];\n            _this._attributeLocationByName[name_1] = _this._attributes[i];\n          }\n        }\n\n        var index;\n\n        for (index = 0; index < _this._samplerList.length; index++) {\n          var sampler = _this.getUniform(_this._samplerList[index]);\n\n          if (sampler == null) {\n            _this._samplerList.splice(index, 1);\n\n            index--;\n          }\n        }\n\n        _this._samplerList.forEach(function (name, index) {\n          _this._samplers[name] = index;\n        });\n\n        engine_1.bindSamplers(_this);\n        _this._compilationError = \"\";\n        _this._isReady = true;\n\n        if (_this.onCompiled) {\n          _this.onCompiled(_this);\n        }\n\n        _this.onCompileObservable.notifyObservers(_this);\n\n        _this.onCompileObservable.clear(); // Unbind mesh reference in fallbacks\n\n\n        if (_this._fallbacks) {\n          _this._fallbacks.unBindMesh();\n        }\n\n        if (previousPipelineContext) {\n          _this.getEngine()._deletePipelineContext(previousPipelineContext);\n        }\n      });\n\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  };\n\n  Effect.prototype._getShaderCodeAndErrorLine = function (code, error, isFragment) {\n    var regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\n    var errorLine = null;\n\n    if (error && code) {\n      var res = error.match(regexp);\n\n      if (res && res.length === 2) {\n        var lineNumber = parseInt(res[1]);\n        var lines = code.split(\"\\n\", -1);\n\n        if (lines.length >= lineNumber) {\n          errorLine = \"Offending line [\" + lineNumber + \"] in \" + (isFragment ? \"fragment\" : \"vertex\") + \" code: \" + lines[lineNumber - 1];\n        }\n      }\n    }\n\n    return [code, errorLine];\n  };\n\n  Effect.prototype._processCompilationErrors = function (e, previousPipelineContext) {\n    var _a, _b;\n\n    var _c, _d, _e;\n\n    if (previousPipelineContext === void 0) {\n      previousPipelineContext = null;\n    }\n\n    this._compilationError = e.message;\n    var attributesNames = this._attributesNames;\n    var fallbacks = this._fallbacks; // Let's go through fallbacks then\n\n    Logger.Error(\"Unable to compile effect:\");\n    Logger.Error(\"Uniforms: \" + this._uniformsNames.map(function (uniform) {\n      return \" \" + uniform;\n    }));\n    Logger.Error(\"Attributes: \" + attributesNames.map(function (attribute) {\n      return \" \" + attribute;\n    }));\n    Logger.Error(\"Defines:\\r\\n\" + this.defines);\n\n    if (Effect.LogShaderCodeOnCompilationError) {\n      var lineErrorVertex = null,\n          lineErrorFragment = null,\n          code = null;\n\n      if ((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getVertexShaderCode()) {\n        _a = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false), code = _a[0], lineErrorVertex = _a[1];\n\n        if (code) {\n          Logger.Error(\"Vertex code:\");\n          Logger.Error(code);\n        }\n      }\n\n      if ((_d = this._pipelineContext) === null || _d === void 0 ? void 0 : _d._getFragmentShaderCode()) {\n        _b = this._getShaderCodeAndErrorLine((_e = this._pipelineContext) === null || _e === void 0 ? void 0 : _e._getFragmentShaderCode(), this._compilationError, true), code = _b[0], lineErrorFragment = _b[1];\n\n        if (code) {\n          Logger.Error(\"Fragment code:\");\n          Logger.Error(code);\n        }\n      }\n\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n\n      if (lineErrorFragment) {\n        Logger.Error(lineErrorFragment);\n      }\n    }\n\n    Logger.Error(\"Error: \" + this._compilationError);\n\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n\n      this.onErrorObservable.notifyObservers(this);\n    }\n\n    if (fallbacks) {\n      this._pipelineContext = null;\n\n      if (fallbacks.hasMoreFallbacks) {\n        this._allFallbacksProcessed = false;\n        Logger.Error(\"Trying next fallback.\");\n        this.defines = fallbacks.reduce(this.defines, this);\n\n        this._prepareEffect();\n      } else {\n        // Sorry we did everything we can\n        this._allFallbacksProcessed = true;\n\n        if (this.onError) {\n          this.onError(this, this._compilationError);\n        }\n\n        this.onErrorObservable.notifyObservers(this);\n        this.onErrorObservable.clear(); // Unbind mesh reference in fallbacks\n\n        if (this._fallbacks) {\n          this._fallbacks.unBindMesh();\n        }\n      }\n    } else {\n      this._allFallbacksProcessed = true;\n    }\n  };\n\n  Object.defineProperty(Effect.prototype, \"isSupported\", {\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\n    get: function get() {\n      return this._compilationError === \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Binds a texture to the engine to be used as output of the shader.\r\n   * @param channel Name of the output variable.\r\n   * @param texture Texture to bind.\r\n   * @hidden\r\n   */\n\n  Effect.prototype._bindTexture = function (channel, texture) {\n    this._engine._bindTexture(this._samplers[channel], texture);\n  };\n  /**\r\n   * Sets a texture on the engine to be used in the shader.\r\n   * @param channel Name of the sampler variable.\r\n   * @param texture Texture to set.\r\n   */\n\n\n  Effect.prototype.setTexture = function (channel, texture) {\n    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture);\n  };\n  /**\r\n   * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n   * @param channel Name of the sampler variable.\r\n   * @param texture Texture to set.\r\n   */\n\n\n  Effect.prototype.setDepthStencilTexture = function (channel, texture) {\n    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture);\n  };\n  /**\r\n   * Sets an array of textures on the engine to be used in the shader.\r\n   * @param channel Name of the variable.\r\n   * @param textures Textures to set.\r\n   */\n\n\n  Effect.prototype.setTextureArray = function (channel, textures) {\n    var exName = channel + \"Ex\";\n\n    if (this._samplerList.indexOf(exName + \"0\") === -1) {\n      var initialPos = this._samplerList.indexOf(channel);\n\n      for (var index = 1; index < textures.length; index++) {\n        var currentExName = exName + (index - 1).toString();\n\n        this._samplerList.splice(initialPos + index, 0, currentExName);\n      } // Reset every channels\n\n\n      var channelIndex = 0;\n\n      for (var _i = 0, _a = this._samplerList; _i < _a.length; _i++) {\n        var key = _a[_i];\n        this._samplers[key] = channelIndex;\n        channelIndex += 1;\n      }\n    }\n\n    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures);\n  };\n  /**\r\n   * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n   * @param channel Name of the sampler variable.\r\n   * @param postProcess Post process to get the input texture from.\r\n   */\n\n\n  Effect.prototype.setTextureFromPostProcess = function (channel, postProcess) {\n    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess);\n  };\n  /**\r\n   * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n   * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n   * @param channel Name of the sampler variable.\r\n   * @param postProcess Post process to get the output texture from.\r\n   */\n\n\n  Effect.prototype.setTextureFromPostProcessOutput = function (channel, postProcess) {\n    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess);\n  };\n  /** @hidden */\n\n\n  Effect.prototype._cacheMatrix = function (uniformName, matrix) {\n    var cache = this._valueCache[uniformName];\n    var flag = matrix.updateFlag;\n\n    if (cache !== undefined && cache === flag) {\n      return false;\n    }\n\n    this._valueCache[uniformName] = flag;\n    return true;\n  };\n  /** @hidden */\n\n\n  Effect.prototype._cacheFloat2 = function (uniformName, x, y) {\n    var cache = this._valueCache[uniformName];\n\n    if (!cache || cache.length !== 2) {\n      cache = [x, y];\n      this._valueCache[uniformName] = cache;\n      return true;\n    }\n\n    var changed = false;\n\n    if (cache[0] !== x) {\n      cache[0] = x;\n      changed = true;\n    }\n\n    if (cache[1] !== y) {\n      cache[1] = y;\n      changed = true;\n    }\n\n    return changed;\n  };\n  /** @hidden */\n\n\n  Effect.prototype._cacheFloat3 = function (uniformName, x, y, z) {\n    var cache = this._valueCache[uniformName];\n\n    if (!cache || cache.length !== 3) {\n      cache = [x, y, z];\n      this._valueCache[uniformName] = cache;\n      return true;\n    }\n\n    var changed = false;\n\n    if (cache[0] !== x) {\n      cache[0] = x;\n      changed = true;\n    }\n\n    if (cache[1] !== y) {\n      cache[1] = y;\n      changed = true;\n    }\n\n    if (cache[2] !== z) {\n      cache[2] = z;\n      changed = true;\n    }\n\n    return changed;\n  };\n  /** @hidden */\n\n\n  Effect.prototype._cacheFloat4 = function (uniformName, x, y, z, w) {\n    var cache = this._valueCache[uniformName];\n\n    if (!cache || cache.length !== 4) {\n      cache = [x, y, z, w];\n      this._valueCache[uniformName] = cache;\n      return true;\n    }\n\n    var changed = false;\n\n    if (cache[0] !== x) {\n      cache[0] = x;\n      changed = true;\n    }\n\n    if (cache[1] !== y) {\n      cache[1] = y;\n      changed = true;\n    }\n\n    if (cache[2] !== z) {\n      cache[2] = z;\n      changed = true;\n    }\n\n    if (cache[3] !== w) {\n      cache[3] = w;\n      changed = true;\n    }\n\n    return changed;\n  };\n  /**\r\n   * Binds a buffer to a uniform.\r\n   * @param buffer Buffer to bind.\r\n   * @param name Name of the uniform variable to bind to.\r\n   */\n\n\n  Effect.prototype.bindUniformBuffer = function (buffer, name) {\n    var bufferName = this._uniformBuffersNames[name];\n\n    if (bufferName === undefined || Effect._baseCache[bufferName] === buffer) {\n      return;\n    }\n\n    Effect._baseCache[bufferName] = buffer;\n\n    this._engine.bindUniformBufferBase(buffer, bufferName);\n  };\n  /**\r\n   * Binds block to a uniform.\r\n   * @param blockName Name of the block to bind.\r\n   * @param index Index to bind.\r\n   */\n\n\n  Effect.prototype.bindUniformBlock = function (blockName, index) {\n    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);\n  };\n  /**\r\n   * Sets an interger value on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param value Value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setInt = function (uniformName, value) {\n    var cache = this._valueCache[uniformName];\n\n    if (cache !== undefined && cache === value) {\n      return this;\n    }\n\n    if (this._engine.setInt(this._uniforms[uniformName], value)) {\n      this._valueCache[uniformName] = value;\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets an int array on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setIntArray = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setIntArray(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setIntArray2 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setIntArray2(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setIntArray3 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setIntArray3(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setIntArray4 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setIntArray4(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an float array on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloatArray = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloatArray2 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray2(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloatArray3 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray3(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloatArray4 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray4(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an array on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setArray = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setArray2 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray2(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setArray3 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray3(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setArray4 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray4(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets matrices on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param matrices matrices to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setMatrices = function (uniformName, matrices) {\n    if (!matrices) {\n      return this;\n    }\n\n    this._valueCache[uniformName] = null;\n\n    this._engine.setMatrices(this._uniforms[uniformName], matrices); // the cast is ok because it is gl.uniformMatrix4fv() which is called at the end, and this function accepts Float32Array and Array<number>\n\n\n    return this;\n  };\n  /**\r\n   * Sets matrix on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param matrix matrix to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setMatrix = function (uniformName, matrix) {\n    if (this._cacheMatrix(uniformName, matrix)) {\n      if (!this._engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n   * @param uniformName Name of the variable.\r\n   * @param matrix matrix to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setMatrix3x3 = function (uniformName, matrix) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setMatrix3x3(this._uniforms[uniformName], matrix); // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\n\n\n    return this;\n  };\n  /**\r\n   * Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n   * @param uniformName Name of the variable.\r\n   * @param matrix matrix to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setMatrix2x2 = function (uniformName, matrix) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setMatrix2x2(this._uniforms[uniformName], matrix); // the cast is ok because it is gl.uniformMatrix2fv() which is called at the end, and this function accepts Float32Array and Array<number>\n\n\n    return this;\n  };\n  /**\r\n   * Sets a float on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param value value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloat = function (uniformName, value) {\n    var cache = this._valueCache[uniformName];\n\n    if (cache !== undefined && cache === value) {\n      return this;\n    }\n\n    if (this._engine.setFloat(this._uniforms[uniformName], value)) {\n      this._valueCache[uniformName] = value;\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a boolean on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param bool value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setBool = function (uniformName, bool) {\n    var cache = this._valueCache[uniformName];\n\n    if (cache !== undefined && cache === bool) {\n      return this;\n    }\n\n    if (this._engine.setInt(this._uniforms[uniformName], bool ? 1 : 0)) {\n      this._valueCache[uniformName] = bool;\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Vector2 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param vector2 vector2 to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setVector2 = function (uniformName, vector2) {\n    if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\n      if (!this._engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a float2 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param x First float in float2.\r\n   * @param y Second float in float2.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloat2 = function (uniformName, x, y) {\n    if (this._cacheFloat2(uniformName, x, y)) {\n      if (!this._engine.setFloat2(this._uniforms[uniformName], x, y)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Vector3 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param vector3 Value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setVector3 = function (uniformName, vector3) {\n    if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\n      if (!this._engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a float3 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param x First float in float3.\r\n   * @param y Second float in float3.\r\n   * @param z Third float in float3.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloat3 = function (uniformName, x, y, z) {\n    if (this._cacheFloat3(uniformName, x, y, z)) {\n      if (!this._engine.setFloat3(this._uniforms[uniformName], x, y, z)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Vector4 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param vector4 Value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setVector4 = function (uniformName, vector4) {\n    if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\n      if (!this._engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a float4 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param x First float in float4.\r\n   * @param y Second float in float4.\r\n   * @param z Third float in float4.\r\n   * @param w Fourth float in float4.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloat4 = function (uniformName, x, y, z, w) {\n    if (this._cacheFloat4(uniformName, x, y, z, w)) {\n      if (!this._engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Color3 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param color3 Value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setColor3 = function (uniformName, color3) {\n    if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\n      if (!this._engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Color4 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param color3 Value to be set.\r\n   * @param alpha Alpha value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setColor4 = function (uniformName, color3, alpha) {\n    if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\n      if (!this._engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Color4 on a uniform variable\r\n   * @param uniformName defines the name of the variable\r\n   * @param color4 defines the value to be set\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setDirectColor4 = function (uniformName, color4) {\n    if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {\n      if (!this._engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /** Release all associated resources */\n\n\n  Effect.prototype.dispose = function () {\n    this._engine._releaseEffect(this);\n  };\n  /**\r\n   * This function will add a new shader to the shader store\r\n   * @param name the name of the shader\r\n   * @param pixelShader optional pixel shader content\r\n   * @param vertexShader optional vertex shader content\r\n   */\n\n\n  Effect.RegisterShader = function (name, pixelShader, vertexShader) {\n    if (pixelShader) {\n      Effect.ShadersStore[name + \"PixelShader\"] = pixelShader;\n    }\n\n    if (vertexShader) {\n      Effect.ShadersStore[name + \"VertexShader\"] = vertexShader;\n    }\n  };\n  /**\r\n   * Resets the cache of effects.\r\n   */\n\n\n  Effect.ResetCache = function () {\n    Effect._baseCache = {};\n  };\n  /**\r\n   * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n   */\n\n\n  Effect.ShadersRepository = \"src/Shaders/\";\n  /**\r\n   * Enable logging of the shader code when a compilation error occurs\r\n   */\n\n  Effect.LogShaderCodeOnCompilationError = true;\n  Effect._uniqueIdSeed = 0;\n  Effect._baseCache = {};\n  /**\r\n   * Store of each shader (The can be looked up using effect.key)\r\n   */\n\n  Effect.ShadersStore = {};\n  /**\r\n   * Store of each included file for a shader (The can be looked up using effect.key)\r\n   */\n\n  Effect.IncludesShadersStore = {};\n  return Effect;\n}();\n\nexport { Effect };","map":null,"metadata":{},"sourceType":"module"}