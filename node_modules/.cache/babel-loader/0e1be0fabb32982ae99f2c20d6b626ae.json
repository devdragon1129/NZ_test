{"ast":null,"code":"import { Quaternion, Vector3, Matrix } from \"../Maths/math.vector\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { PointerEventTypes } from '../Events/pointerEvents';\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\n\nvar Gizmo =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a gizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   */\n  function Gizmo(\n  /** The utility layer the gizmo will be added to */\n  gizmoLayer) {\n    var _this = this;\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    this.gizmoLayer = gizmoLayer;\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\n\n    this._scaleRatio = 1;\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\n\n    this._isHovered = false;\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\n\n    this._customMeshSet = false;\n    this._updateGizmoRotationToMatchAttachedMesh = true;\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\n\n    this.updateGizmoPositionToMatchAttachedMesh = true;\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\n\n    this.updateScale = true;\n    this._interactionsEnabled = true;\n    this._tempQuaternion = new Quaternion(0, 0, 0, 1);\n    this._tempVector = new Vector3();\n    this._tempVector2 = new Vector3();\n    this._tempMatrix1 = new Matrix();\n    this._tempMatrix2 = new Matrix();\n    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\n    this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\n    this._rootMesh.rotationQuaternion = Quaternion.Identity();\n    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(function () {\n      _this._update();\n    });\n  }\n\n  Object.defineProperty(Gizmo.prototype, \"scaleRatio\", {\n    get: function get() {\n      return this._scaleRatio;\n    },\n\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\n    set: function set(value) {\n      this._scaleRatio = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"isHovered\", {\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\n    get: function get() {\n      return this._isHovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"attachedMesh\", {\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\n    get: function get() {\n      return this._attachedMesh;\n    },\n    set: function set(value) {\n      this._attachedMesh = value;\n\n      if (value) {\n        this._attachedNode = value;\n      }\n\n      this._rootMesh.setEnabled(value ? true : false);\n\n      this._attachedNodeChanged(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"attachedNode\", {\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\n    get: function get() {\n      return this._attachedNode;\n    },\n    set: function set(value) {\n      this._attachedNode = value;\n      this._attachedMesh = null;\n\n      this._rootMesh.setEnabled(value ? true : false);\n\n      this._attachedNodeChanged(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n   * @param mesh The mesh to replace the default mesh of the gizmo\r\n   */\n\n  Gizmo.prototype.setCustomMesh = function (mesh) {\n    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\n      throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\n    }\n\n    this._rootMesh.getChildMeshes().forEach(function (c) {\n      c.dispose();\n    });\n\n    mesh.parent = this._rootMesh;\n    this._customMeshSet = true;\n  };\n\n  Object.defineProperty(Gizmo.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n    get: function get() {\n      return this._updateGizmoRotationToMatchAttachedMesh;\n    },\n\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\n    set: function set(value) {\n      this._updateGizmoRotationToMatchAttachedMesh = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Gizmo.prototype._attachedNodeChanged = function (value) {};\n  /**\r\n   * Updates the gizmo to match the attached mesh's position/rotation\r\n   */\n\n\n  Gizmo.prototype._update = function () {\n    if (this.attachedNode) {\n      var effectiveNode = this.attachedNode;\n\n      if (this.attachedMesh) {\n        effectiveNode = this.attachedMesh._effectiveMesh || this.attachedNode;\n      } // Position\n\n\n      if (this.updateGizmoPositionToMatchAttachedMesh) {\n        var row = effectiveNode.getWorldMatrix().getRow(3);\n        var position = row ? row.toVector3() : new Vector3(0, 0, 0);\n\n        this._rootMesh.position.copyFrom(position);\n      } // Rotation\n\n\n      if (this.updateGizmoRotationToMatchAttachedMesh) {\n        effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion);\n      } else {\n        this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);\n      } // Scale\n\n\n      if (this.updateScale) {\n        var activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;\n        var cameraPosition = activeCamera.globalPosition;\n\n        if (activeCamera.devicePosition) {\n          cameraPosition = activeCamera.devicePosition;\n        }\n\n        this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);\n\n        var dist = this._tempVector.length() * this.scaleRatio;\n\n        this._rootMesh.scaling.set(dist, dist, dist); // Account for handedness, similar to Matrix.decompose\n\n\n        if (effectiveNode._getWorldMatrixDeterminant() < 0) {\n          this._rootMesh.scaling.y *= -1;\n        }\n      } else {\n        this._rootMesh.scaling.setAll(this.scaleRatio);\n      }\n    }\n  };\n  /**\r\n   * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n   * @param value Node, TransformNode or mesh\r\n   */\n\n\n  Gizmo.prototype._matrixChanged = function () {\n    if (!this._attachedNode) {\n      return;\n    }\n\n    if (this._attachedNode._isCamera) {\n      var camera = this._attachedNode;\n      var worldMatrix;\n      var worldMatrixUC;\n\n      if (camera.parent) {\n        var parentInv = this._tempMatrix2;\n\n        camera.parent._worldMatrix.invertToRef(parentInv);\n\n        this._attachedNode._worldMatrix.multiplyToRef(parentInv, this._tempMatrix1);\n\n        worldMatrix = this._tempMatrix1;\n      } else {\n        worldMatrix = this._attachedNode._worldMatrix;\n      }\n\n      if (camera.getScene().useRightHandedSystem) {\n        // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\n        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, this._tempMatrix2);\n\n        worldMatrixUC = this._tempMatrix2;\n      } else {\n        worldMatrixUC = worldMatrix;\n      }\n\n      worldMatrixUC.decompose(this._tempVector2, this._tempQuaternion, this._tempVector);\n      var inheritsTargetCamera = this._attachedNode.getClassName() === \"FreeCamera\" || this._attachedNode.getClassName() === \"FlyCamera\" || this._attachedNode.getClassName() === \"ArcFollowCamera\" || this._attachedNode.getClassName() === \"TargetCamera\" || this._attachedNode.getClassName() === \"TouchCamera\" || this._attachedNode.getClassName() === \"UniversalCamera\";\n\n      if (inheritsTargetCamera) {\n        var targetCamera = this._attachedNode;\n        targetCamera.rotation = this._tempQuaternion.toEulerAngles();\n\n        if (targetCamera.rotationQuaternion) {\n          targetCamera.rotationQuaternion.copyFrom(this._tempQuaternion);\n        }\n      }\n\n      camera.position.copyFrom(this._tempVector);\n    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === \"AbstractMesh\" || this._attachedNode.getClassName() === \"TransformNode\" || this._attachedNode.getClassName() === \"InstancedMesh\") {\n      var transform = this._attachedNode;\n\n      if (transform.parent) {\n        var parentInv = this._tempMatrix1;\n        var localMat = this._tempMatrix2;\n        transform.parent.getWorldMatrix().invertToRef(parentInv);\n\n        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\n\n        localMat.decompose(transform.scaling, this._tempQuaternion, transform.position);\n      } else {\n        this._attachedNode._worldMatrix.decompose(transform.scaling, this._tempQuaternion, transform.position);\n      }\n\n      if (!transform.billboardMode) {\n        if (transform.rotationQuaternion) {\n          transform.rotationQuaternion.copyFrom(this._tempQuaternion);\n        } else {\n          transform.rotation = this._tempQuaternion.toEulerAngles();\n        }\n      }\n    } else if (this._attachedNode.getClassName() === \"Bone\") {\n      var bone = this._attachedNode;\n      var parent_1 = bone.getParent();\n\n      if (parent_1) {\n        var invParent = this._tempMatrix1;\n        var boneLocalMatrix = this._tempMatrix2;\n        parent_1.getWorldMatrix().invertToRef(invParent);\n        bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\n        var lmat = bone.getLocalMatrix();\n        lmat.copyFrom(boneLocalMatrix);\n      } else {\n        var lmat = bone.getLocalMatrix();\n        lmat.copyFrom(bone.getWorldMatrix());\n      }\n\n      bone.markAsDirty();\n    }\n  };\n  /**\r\n   * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n   * @returns {Observer<PointerInfo>} pointerObserver\r\n   */\n\n\n  Gizmo.GizmoAxisPointerObserver = function (gizmoLayer, gizmoAxisCache) {\n    var dragging = false;\n    var pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a, _b;\n\n      if (pointerInfo.pickInfo) {\n        // On Hover Logic\n        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\n          if (dragging) {\n            return;\n          }\n\n          gizmoAxisCache.forEach(function (cache) {\n            var _a, _b;\n\n            if (cache.colliderMeshes && cache.gizmoMeshes) {\n              var isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              var material_1 = isHovered || cache.active ? cache.hoverMaterial : cache.material;\n              cache.gizmoMeshes.forEach(function (m) {\n                m.material = material_1;\n\n                if (m.color) {\n                  m.color = material_1.diffuseColor;\n                }\n              });\n            }\n          });\n        } // On Mouse Down\n\n\n        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n          // If user Clicked Gizmo\n          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) === null || _a === void 0 ? void 0 : _a.parent)) {\n            dragging = true;\n            var statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) === null || _b === void 0 ? void 0 : _b.parent);\n            statusMap.active = true;\n            gizmoAxisCache.forEach(function (cache) {\n              var _a, _b;\n\n              var isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              var material = isHovered || cache.active ? cache.hoverMaterial : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(function (m) {\n                m.material = material;\n\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            });\n          }\n        } // On Mouse Up\n\n\n        if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n          gizmoAxisCache.forEach(function (cache) {\n            cache.active = false;\n            dragging = false;\n            cache.gizmoMeshes.forEach(function (m) {\n              m.material = cache.material;\n\n              if (m.color) {\n                m.color = cache.material.diffuseColor;\n              }\n            });\n          });\n        }\n      }\n    });\n    return pointerObserver;\n  };\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n\n  Gizmo.prototype.dispose = function () {\n    this._rootMesh.dispose();\n\n    if (this._beforeRenderObserver) {\n      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }\n  };\n\n  return Gizmo;\n}();\n\nexport { Gizmo };","map":null,"metadata":{},"sourceType":"module"}