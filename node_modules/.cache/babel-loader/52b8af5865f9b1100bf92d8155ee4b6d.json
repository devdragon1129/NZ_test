{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\nimport { AbstractScene } from \"../abstractScene\";\nimport { Engine } from \"../Engines/engine\";\nimport { ParticleSystem } from \"./particleSystem\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport \"../Shaders/particles.vertex\"; // Adds the parsers to the scene parsers.\n\nAbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedData, scene, container, rootUrl) {\n  var individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n\n  if (!individualParser) {\n    return;\n  } // Particles Systems\n\n\n  if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n    for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n      var parsedParticleSystem = parsedData.particleSystems[index];\n      container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\n    }\n  }\n});\nAbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedParticleSystem, scene, rootUrl) {\n  if (parsedParticleSystem.activeParticleCount) {\n    var ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n    return ps;\n  } else {\n    var ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n    return ps;\n  }\n});\n\nEngine.prototype.createEffectForParticles = function (fragmentName, uniformsNames, samplers, defines, fallbacks, onCompiled, onError, particleSystem) {\n  var _a;\n\n  if (uniformsNames === void 0) {\n    uniformsNames = [];\n  }\n\n  if (samplers === void 0) {\n    samplers = [];\n  }\n\n  if (defines === void 0) {\n    defines = \"\";\n  }\n\n  var attributesNamesOrOptions = [];\n  var effectCreationOption = [];\n  var allSamplers = [];\n\n  if (particleSystem) {\n    particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\n  } else {\n    attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\n    effectCreationOption = ParticleSystem._GetEffectCreationOptions();\n  }\n\n  if (defines.indexOf(\" BILLBOARD\") === -1) {\n    defines += \"\\n#define BILLBOARD\\n\";\n  }\n\n  if (samplers.indexOf(\"diffuseSampler\") === -1) {\n    samplers.push(\"diffuseSampler\");\n  }\n\n  return this.createEffect({\n    vertex: (_a = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.vertexShaderName) !== null && _a !== void 0 ? _a : \"particles\",\n    fragmentElement: fragmentName\n  }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);\n};\n\nMesh.prototype.getEmittedParticleSystems = function () {\n  var results = new Array();\n\n  for (var index = 0; index < this.getScene().particleSystems.length; index++) {\n    var particleSystem = this.getScene().particleSystems[index];\n\n    if (particleSystem.emitter === this) {\n      results.push(particleSystem);\n    }\n  }\n\n  return results;\n};\n\nMesh.prototype.getHierarchyEmittedParticleSystems = function () {\n  var results = new Array();\n  var descendants = this.getDescendants();\n  descendants.push(this);\n\n  for (var index = 0; index < this.getScene().particleSystems.length; index++) {\n    var particleSystem = this.getScene().particleSystems[index];\n    var emitter = particleSystem.emitter;\n\n    if (emitter.position && descendants.indexOf(emitter) !== -1) {\n      results.push(particleSystem);\n    }\n  }\n\n  return results;\n};","map":null,"metadata":{},"sourceType":"module"}