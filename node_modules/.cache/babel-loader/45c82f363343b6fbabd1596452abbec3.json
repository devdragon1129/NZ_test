{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"util\");\n\nvar legacy_provider_adapter_1 = require(\"./legacy-provider-adapter\");\n\nvar IpcProvider = /*#__PURE__*/function (_legacy_provider_adap) {\n  _inherits(IpcProvider, _legacy_provider_adap);\n\n  function IpcProvider(path, net) {\n    _classCallCheck(this, IpcProvider);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(IpcProvider).call(this, new LegacyIpcProvider(path, net)));\n  }\n\n  return IpcProvider;\n}(legacy_provider_adapter_1.LegacyProviderAdapter);\n\nexports.IpcProvider = IpcProvider;\n\nvar LegacyIpcProvider = /*#__PURE__*/function () {\n  function LegacyIpcProvider(path, net) {\n    var _this2 = this;\n\n    _classCallCheck(this, LegacyIpcProvider);\n\n    this.path = path;\n    this.responseCallbacks = {};\n    this.notificationCallbacks = [];\n    this.path = path;\n    this.connected = false;\n    this.connection = net.connect({\n      path: this.path\n    });\n    this.addDefaultEvents(); // LISTEN FOR CONNECTION RESPONSES\n\n    var callback = function callback(result) {\n      var _this = this;\n\n      var id = null; // get the id which matches the returned id\n\n      if (util_1.isArray(result)) {\n        result.forEach(function (load) {\n          if (_this.responseCallbacks[load.id]) {\n            id = load.id;\n          }\n        });\n      } else {\n        id = result.id;\n      } // notification\n\n\n      if (!id && result.method.indexOf('_subscription') !== -1) {\n        this.notificationCallbacks.forEach(function (callback) {\n          if (util_1.isFunction(callback)) {\n            callback(result);\n          }\n        }); // fire the callback\n      } else if (this.responseCallbacks[id]) {\n        this.responseCallbacks[id](null, result);\n        delete this.responseCallbacks[id];\n      }\n    };\n\n    this.connection.on('data', function (data) {\n      _this2._parseResponse(data.toString()).forEach(callback);\n    });\n  }\n\n  _createClass(LegacyIpcProvider, [{\n    key: \"addDefaultEvents\",\n    value: function addDefaultEvents() {\n      var _this3 = this;\n\n      this.connection.on('connect', function () {\n        _this3.connected = true;\n      });\n      this.connection.on('close', function () {\n        _this3.connected = false;\n      });\n      this.connection.on('error', function () {\n        _this3._timeout();\n      });\n      this.connection.on('end', function () {\n        _this3._timeout();\n      });\n      this.connection.on('timeout', function () {\n        _this3._timeout();\n      });\n    }\n  }, {\n    key: \"_parseResponse\",\n    value: function _parseResponse(data) {\n      var _this4 = this;\n\n      var returnValues = []; // DE-CHUNKER\n\n      var dechunkedData = data.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n      .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n      .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n      .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n      .split('|--|');\n      dechunkedData.forEach(function (data) {\n        // prepend the last chunk\n        if (_this4.lastChunk) {\n          data = _this4.lastChunk + data;\n        }\n\n        var result = null;\n\n        try {\n          result = JSON.parse(data);\n        } catch (e) {\n          _this4.lastChunk = data; // start timeout to cancel all requests\n\n          clearTimeout(_this4.lastChunkTimeout);\n          _this4.lastChunkTimeout = setTimeout(function () {\n            _this4._timeout();\n\n            throw new Error('Timeout');\n          }, 1000 * 15);\n          return;\n        } // cancel timeout and set chunk to null\n\n\n        clearTimeout(_this4.lastChunkTimeout);\n        _this4.lastChunk = null;\n\n        if (result) {\n          returnValues.push(result);\n        }\n      });\n      return returnValues;\n    }\n  }, {\n    key: \"_addResponseCallback\",\n    value: function _addResponseCallback(payload, callback) {\n      var id = payload.id || payload[0].id;\n      var method = payload.method || payload[0].method;\n      this.responseCallbacks[id] = callback;\n      this.responseCallbacks[id].method = method;\n    }\n  }, {\n    key: \"_timeout\",\n    value: function _timeout() {\n      for (var key in this.responseCallbacks) {\n        if (this.responseCallbacks.hasOwnProperty(key)) {\n          this.responseCallbacks[key](new Error(\"CONNECTION ERROR: Couldn't connect to node on IPC.\"));\n          delete this.responseCallbacks[key];\n        }\n      }\n    }\n  }, {\n    key: \"reconnect\",\n    value: function reconnect() {\n      this.connection.connect({\n        path: this.path\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload, callback) {\n      // try reconnect, when connection is gone\n      if (!this.connection.writable) {\n        this.connection.connect({\n          path: this.path\n        });\n      }\n\n      this.connection.write(JSON.stringify(payload));\n\n      this._addResponseCallback(payload, callback);\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, callback) {\n      if (typeof callback !== 'function') {\n        throw new Error('The second parameter callback must be a function.');\n      }\n\n      switch (type) {\n        case 'data':\n          this.notificationCallbacks.push(callback);\n          break;\n        // adds error, end, timeout, connect\n\n        default:\n          this.connection.on(type, callback);\n          break;\n      }\n    }\n  }, {\n    key: \"once\",\n    value: function once(type, callback) {\n      if (typeof callback !== 'function') {\n        throw new Error('The second parameter callback must be a function.');\n      }\n\n      this.connection.once(type, callback);\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(type, callback) {\n      var _this5 = this;\n\n      switch (type) {\n        case 'data':\n          this.notificationCallbacks.forEach(function (cb, index) {\n            if (cb === callback) {\n              _this5.notificationCallbacks.splice(index, 1);\n            }\n          });\n          break;\n\n        default:\n          this.connection.removeListener(type, callback);\n          break;\n      }\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(type) {\n      switch (type) {\n        case 'data':\n          this.notificationCallbacks = [];\n          break;\n\n        default:\n          this.connection.removeAllListeners(type);\n          break;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._timeout();\n\n      this.notificationCallbacks = [];\n      this.connection.removeAllListeners('error');\n      this.connection.removeAllListeners('end');\n      this.connection.removeAllListeners('timeout');\n      this.addDefaultEvents();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.connection.close();\n    }\n  }]);\n\n  return LegacyIpcProvider;\n}();","map":null,"metadata":{},"sourceType":"script"}