{"ast":null,"code":"import _regeneratorRuntime from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { take, fork, cancel } from 'redux-saga/effects';\nexport var takeLatestCancellable = function takeLatestCancellable(_ref, saga) {\n  var initializer = _ref.initializer,\n      cancellable = _ref.cancellable;\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return fork( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var lastTask, action;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!true) {\n              _context.next = 13;\n              break;\n            }\n\n            _context.next = 3;\n            return take([initializer, cancellable]);\n\n          case 3:\n            action = _context.sent;\n\n            if (!lastTask) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.next = 7;\n            return cancel(lastTask);\n\n          case 7:\n            if (!(action.type === initializer)) {\n              _context.next = 11;\n              break;\n            }\n\n            _context.next = 10;\n            return fork.apply(void 0, [saga].concat(_toConsumableArray(args.concat(action))));\n\n          case 10:\n            lastTask = _context.sent;\n\n          case 11:\n            _context.next = 0;\n            break;\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n};","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/common/utils.ts"],"names":["take","fork","cancel","takeLatestCancellable","saga","initializer","cancellable","args","action","lastTask","type","concat"],"mappings":";;AAEA,SAASA,IAAT,EAAeC,IAAf,EAAgDC,MAAhD,QAA8D,oBAA9D;AAEA,OAAO,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB,OAEnCC,IAFmC;AAAA,MACjCC,WADiC,QACjCA,WADiC;AAAA,MACpBC,WADoB,QACpBA,WADoB;;AAAA,oCAGhCC,IAHgC;AAGhCA,IAAAA,IAHgC;AAAA;;AAAA,SAKnCN,IAAI,wCAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAEI,IAFJ;AAAA;AAAA;AAAA;;AAAA;AAGiB,mBAAMD,IAAI,CAAC,CAACK,WAAD,EAAcC,WAAd,CAAD,CAAV;;AAHjB;AAGKE,YAAAA,MAHL;;AAAA,iBAIGC,QAJH;AAAA;AAAA;AAAA;;AAAA;AAKC,mBAAMP,MAAM,CAACO,QAAD,CAAZ;;AALD;AAAA,kBAQGD,MAAM,CAACE,IAAP,KAAgBL,WARnB;AAAA;AAAA;AAAA;;AAAA;AASY,mBAAMJ,IAAI,MAAJ,UAAKG,IAAL,4BAAcG,IAAI,CAACI,MAAL,CAAYH,MAAZ,CAAd,GAAN;;AATZ;AASCC,YAAAA,QATD;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAD,EAL+B;AAAA,CAA9B","sourcesContent":["import { Task } from 'redux-saga'\nimport { Action } from 'redux'\nimport { take, fork, ActionPattern, ForkEffect, cancel } from 'redux-saga/effects'\n\nexport const takeLatestCancellable = <A extends Action>(\n  { initializer, cancellable }: { initializer: ActionPattern<A>; cancellable: ActionPattern<A> },\n  saga: (...args: any[]) => any,\n  ...args: any[]\n): ForkEffect<never> =>\n  fork(function*() {\n    let lastTask: Task | undefined\n    while (true) {\n      const action: A = yield take([initializer, cancellable] as ActionPattern<Action<A>>)\n      if (lastTask) {\n        yield cancel(lastTask) // cancel is no-op if the task has already terminated\n      }\n\n      if (action.type === initializer) {\n        lastTask = yield fork(saga, ...args.concat(action))\n      }\n    }\n  })\n"]},"metadata":{},"sourceType":"module"}