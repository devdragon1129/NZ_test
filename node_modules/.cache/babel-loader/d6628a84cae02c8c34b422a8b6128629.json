{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { MaterialHelper } from '../../../materialHelper';\nimport { VertexBuffer } from '../../../../Meshes/buffer';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\n/**\r\n * Block used to add morph targets support to vertex shader\r\n */\n\nvar MorphTargetsBlock =\n/** @class */\nfunction (_super) {\n  __extends(MorphTargetsBlock, _super);\n  /**\r\n   * Create a new MorphTargetsBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function MorphTargetsBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Vertex) || this;\n\n    _this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\n\n    _this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  MorphTargetsBlock.prototype.getClassName = function () {\n    return \"MorphTargetsBlock\";\n  };\n\n  Object.defineProperty(MorphTargetsBlock.prototype, \"position\", {\n    /**\r\n     * Gets the position input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"normal\", {\n    /**\r\n     * Gets the normal input component\r\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"tangent\", {\n    /**\r\n     * Gets the tangent input component\r\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the tangent input component\r\n     */\n    get: function get() {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"positionOutput\", {\n    /**\r\n     * Gets the position output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"normalOutput\", {\n    /**\r\n     * Gets the normal output component\r\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"tangentOutput\", {\n    /**\r\n     * Gets the tangent output component\r\n     */\n    get: function get() {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"uvOutput\", {\n    /**\r\n     * Gets the tangent output component\r\n     */\n    get: function get() {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MorphTargetsBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"morphTargetInfluences\");\n  };\n\n  MorphTargetsBlock.prototype.autoConfigure = function (material) {\n    if (!this.position.isConnected) {\n      var positionInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"position\";\n      });\n\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n\n      positionInput.output.connectTo(this.position);\n    }\n\n    if (!this.normal.isConnected) {\n      var normalInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"normal\";\n      });\n\n      if (!normalInput) {\n        normalInput = new InputBlock(\"normal\");\n        normalInput.setAsAttribute(\"normal\");\n      }\n\n      normalInput.output.connectTo(this.normal);\n    }\n\n    if (!this.tangent.isConnected) {\n      var tangentInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"tangent\";\n      });\n\n      if (!tangentInput) {\n        tangentInput = new InputBlock(\"tangent\");\n        tangentInput.setAsAttribute(\"tangent\");\n      }\n\n      tangentInput.output.connectTo(this.tangent);\n    }\n\n    if (!this.uv.isConnected) {\n      var uvInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"uv\";\n      });\n\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"uv\");\n      }\n\n      uvInput.output.connectTo(this.uv);\n    }\n  };\n\n  MorphTargetsBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areAttributesDirty) {\n      return;\n    }\n\n    MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);\n  };\n\n  MorphTargetsBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\n      MaterialHelper.BindMorphTargetParameters(mesh, effect);\n    }\n  };\n\n  MorphTargetsBlock.prototype.replaceRepeatableContent = function (vertexShaderState, fragmentShaderState, mesh, defines) {\n    var position = this.position;\n    var normal = this.normal;\n    var tangent = this.tangent;\n    var uv = this.uv;\n    var positionOutput = this.positionOutput;\n    var normalOutput = this.normalOutput;\n    var tangentOutput = this.tangentOutput;\n    var uvOutput = this.uvOutput;\n    var state = vertexShaderState;\n    var repeatCount = defines.NUM_MORPH_INFLUENCERS;\n    var manager = mesh.morphTargetManager;\n    var hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\n    var hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\n    var hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\n    var injectionCode = \"\";\n\n    for (var index = 0; index < repeatCount; index++) {\n      injectionCode += \"#ifdef MORPHTARGETS\\r\\n\";\n      injectionCode += positionOutput.associatedVariableName + \" += (position\" + index + \" - \" + position.associatedVariableName + \") * morphTargetInfluences[\" + index + \"];\\r\\n\";\n\n      if (hasNormals) {\n        injectionCode += \"#ifdef MORPHTARGETS_NORMAL\\r\\n\";\n        injectionCode += normalOutput.associatedVariableName + \" += (normal\" + index + \" - \" + normal.associatedVariableName + \") * morphTargetInfluences[\" + index + \"];\\r\\n\";\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      if (hasTangents) {\n        injectionCode += \"#ifdef MORPHTARGETS_TANGENT\\r\\n\";\n        injectionCode += tangentOutput.associatedVariableName + \".xyz += (tangent\" + index + \" - \" + tangent.associatedVariableName + \".xyz) * morphTargetInfluences[\" + index + \"];\\r\\n\";\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      if (hasUVs) {\n        injectionCode += \"#ifdef MORPHTARGETS_UV\\r\\n\";\n        injectionCode += uvOutput.associatedVariableName + \".xy += (uv_\" + index + \" - \" + uv.associatedVariableName + \".xy) * morphTargetInfluences[\" + index + \"];\\r\\n\";\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      injectionCode += \"#endif\\r\\n\";\n    }\n\n    state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\n\n    if (repeatCount > 0) {\n      for (var index = 0; index < repeatCount; index++) {\n        state.attributes.push(VertexBuffer.PositionKind + index);\n\n        if (hasNormals) {\n          state.attributes.push(VertexBuffer.NormalKind + index);\n        }\n\n        if (hasTangents) {\n          state.attributes.push(VertexBuffer.TangentKind + index);\n        }\n\n        if (hasUVs) {\n          state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n      }\n    }\n  };\n\n  MorphTargetsBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state); // Register for defines\n\n\n    state.sharedData.blocksWithDefines.push(this); // Register for binding\n\n    state.sharedData.bindableBlocks.push(this); // Register for repeatable content generation\n\n    state.sharedData.repeatableContentBlocks.push(this); // Emit code\n\n    var position = this.position;\n    var normal = this.normal;\n    var tangent = this.tangent;\n    var uv = this.uv;\n    var positionOutput = this.positionOutput;\n    var normalOutput = this.normalOutput;\n    var tangentOutput = this.tangentOutput;\n    var uvOutput = this.uvOutput;\n    var comments = \"//\" + this.name;\n    state.uniforms.push(\"morphTargetInfluences\");\n\n    state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\n\n    state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\n      repeatKey: \"maxSimultaneousMorphTargets\"\n    });\n\n    state.compilationString += this._declareOutput(positionOutput, state) + \" = \" + position.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#ifdef NORMAL\\r\\n\";\n    state.compilationString += this._declareOutput(normalOutput, state) + \" = \" + normal.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += this._declareOutput(normalOutput, state) + \" = vec3(0., 0., 0.);\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef TANGENT\\r\\n\";\n    state.compilationString += this._declareOutput(tangentOutput, state) + \" = \" + tangent.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += this._declareOutput(tangentOutput, state) + \" = vec3(0., 0., 0.);\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef UV1\\r\\n\";\n    state.compilationString += this._declareOutput(uvOutput, state) + \" = \" + uv.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += this._declareOutput(uvOutput, state) + \" = vec2(0., 0.);\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\"; // Repeatable content\n\n    this._repeatableContentAnchor = state._repeatableContentAnchor;\n    state.compilationString += this._repeatableContentAnchor;\n    return this;\n  };\n\n  return MorphTargetsBlock;\n}(NodeMaterialBlock);\n\nexport { MorphTargetsBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.MorphTargetsBlock\"] = MorphTargetsBlock;","map":null,"metadata":{},"sourceType":"module"}