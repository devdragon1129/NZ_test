{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Variant_1 = require(\"./Variant\");\n/**\n *\n */\n\n\nvar Experiment =\n/** @class */\nfunction () {\n  function Experiment(options) {\n    this.options = options;\n    this.completed = false;\n    this.active = false;\n    this.activeVariant = undefined;\n  }\n\n  Object.defineProperty(Experiment.prototype, \"name\", {\n    /**\n     * Name of the current Experiment\n     */\n    get: function get() {\n      return this.options.name;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Experiment.prototype, \"value\", {\n    /**\n     * Value of the current variation\n     */\n    get: function get() {\n      return this.activeVariant && this.activeVariant.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Experiment.prototype, \"variant\", {\n    /**\n     *\n     */\n    get: function get() {\n      return this.activeVariant || Variant_1.EmptyVariant;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Finish the test, marks it as completed and dispatch\n   * the `experiment_conversion` event with the final state to segment\n   */\n\n  Experiment.prototype.complete = function () {\n    this.active = false;\n    this.completed = true;\n  };\n  /**\n   * Activate the current experiment\n   */\n\n\n  Experiment.prototype.activate = function (forceVariant) {\n    if (!this.isActive() && !this.isCompleted()) {\n      this.state = typeof this.options.initialState === 'function' ? this.options.initialState() : {};\n      var variant = void 0;\n\n      if (forceVariant) {\n        variant = this.getVariant(forceVariant);\n      }\n\n      if (variant === undefined) {\n        variant = this.getRandomVariant();\n      }\n\n      this.active = true;\n      this.activeVariant = variant;\n    }\n  };\n  /**\n   * Random return a varia`nt\n   */\n\n\n  Experiment.prototype.getRandomVariant = function () {\n    var e_1, _a;\n\n    if (Array.isArray(this.options.variants) && this.options.variants.length > 0) {\n      var offset = 0;\n      var random = Math.random();\n\n      try {\n        for (var _b = __values(this.options.variants), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var variant = _c.value;\n\n          if (random < variant.ratio + offset) {\n            return variant;\n          } else {\n            offset += variant.ratio;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    return Variant_1.EmptyVariant;\n  };\n\n  Experiment.prototype.getVariant = function (name) {\n    if (name === Variant_1.EmptyVariant.name || !Array.isArray(this.options.variants)) {\n      return Variant_1.EmptyVariant;\n    }\n\n    return this.options.variants.find(function (current) {\n      return current.name === name;\n    });\n  };\n  /**\n   * Return all available values\n   */\n\n\n  Experiment.prototype.getAllVariants = function () {\n    if (!Array.isArray(this.options.variants)) {\n      return [];\n    }\n\n    return this.options.variants.slice();\n  };\n  /**\n   * Modify de state using `Object.assign`\n   */\n\n\n  Experiment.prototype.setState = function (patchState) {\n    if (patchState && this.isActive() && !this.isCompleted()) {\n      this.state = Object.assign({}, this.state, patchState);\n    }\n  };\n  /**\n   * Return if the experiment is completed\n   */\n\n\n  Experiment.prototype.isCompleted = function () {\n    return this.completed;\n  };\n  /**\n   * Return if the experiment is active\n   */\n\n\n  Experiment.prototype.isActive = function () {\n    return this.active;\n  };\n  /**\n   * Execute the tracker\n   */\n\n\n  Experiment.prototype.track = function (segmentEvent) {\n    if (this.isActive() && !this.isCompleted()) {\n      this.options.track(segmentEvent, this);\n    }\n  };\n\n  return Experiment;\n}();\n\nexports.default = Experiment;","map":null,"metadata":{},"sourceType":"script"}