{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\n/**\r\n * Wraps one or more Sound objects and selects one with random weight for playback.\r\n */\n\nvar WeightedSound =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new WeightedSound from the list of sounds given.\r\n   * @param loop When true a Sound will be selected and played when the current playing Sound completes.\r\n   * @param sounds Array of Sounds that will be selected from.\r\n   * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\r\n   */\n  function WeightedSound(loop, sounds, weights) {\n    var _this = this;\n    /** When true a Sound will be selected and played when the current playing Sound completes. */\n\n\n    this.loop = false;\n    this._coneInnerAngle = 360;\n    this._coneOuterAngle = 360;\n    this._volume = 1;\n    /** A Sound is currently playing. */\n\n    this.isPlaying = false;\n    /** A Sound is currently paused. */\n\n    this.isPaused = false;\n    this._sounds = [];\n    this._weights = [];\n\n    if (sounds.length !== weights.length) {\n      throw new Error('Sounds length does not equal weights length');\n    }\n\n    this.loop = loop;\n    this._weights = weights; // Normalize the weights\n\n    var weightSum = 0;\n\n    for (var _i = 0, weights_1 = weights; _i < weights_1.length; _i++) {\n      var weight = weights_1[_i];\n      weightSum += weight;\n    }\n\n    var invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\n\n    for (var i = 0; i < this._weights.length; i++) {\n      this._weights[i] *= invWeightSum;\n    }\n\n    this._sounds = sounds;\n\n    for (var _a = 0, _b = this._sounds; _a < _b.length; _a++) {\n      var sound = _b[_a];\n      sound.onEndedObservable.add(function () {\n        _this._onended();\n      });\n    }\n  }\n\n  Object.defineProperty(WeightedSound.prototype, \"directionalConeInnerAngle\", {\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\n    get: function get() {\n      return this._coneInnerAngle;\n    },\n\n    /**\r\n     * The size of cone in degress for a directional sound in which there will be no attenuation.\r\n     */\n    set: function set(value) {\n      if (value !== this._coneInnerAngle) {\n        if (this._coneOuterAngle < value) {\n          Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneInnerAngle = value;\n\n        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {\n          var sound = _a[_i];\n          sound.directionalConeInnerAngle = value;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WeightedSound.prototype, \"directionalConeOuterAngle\", {\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\n    get: function get() {\n      return this._coneOuterAngle;\n    },\n\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\n    set: function set(value) {\n      if (value !== this._coneOuterAngle) {\n        if (value < this._coneInnerAngle) {\n          Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneOuterAngle = value;\n\n        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {\n          var sound = _a[_i];\n          sound.directionalConeOuterAngle = value;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WeightedSound.prototype, \"volume\", {\n    /**\r\n     * Playback volume.\r\n     */\n    get: function get() {\n      return this._volume;\n    },\n\n    /**\r\n     * Playback volume.\r\n     */\n    set: function set(value) {\n      if (value !== this._volume) {\n        for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {\n          var sound = _a[_i];\n          sound.setVolume(value);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WeightedSound.prototype._onended = function () {\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].autoplay = false;\n    }\n\n    if (this.loop && this.isPlaying) {\n      this.play();\n    } else {\n      this.isPlaying = false;\n    }\n  };\n  /**\r\n   * Suspend playback\r\n   */\n\n\n  WeightedSound.prototype.pause = function () {\n    this.isPaused = true;\n\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].pause();\n    }\n  };\n  /**\r\n   * Stop playback\r\n   */\n\n\n  WeightedSound.prototype.stop = function () {\n    this.isPlaying = false;\n\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].stop();\n    }\n  };\n  /**\r\n   * Start playback.\r\n   * @param startOffset Position the clip head at a specific time in seconds.\r\n   */\n\n\n  WeightedSound.prototype.play = function (startOffset) {\n    if (!this.isPaused) {\n      this.stop();\n      var randomValue = Math.random();\n      var total = 0;\n\n      for (var i = 0; i < this._weights.length; i++) {\n        total += this._weights[i];\n\n        if (randomValue <= total) {\n          this._currentIndex = i;\n          break;\n        }\n      }\n    }\n\n    var sound = this._sounds[this._currentIndex];\n\n    if (sound.isReady()) {\n      sound.play(0, this.isPaused ? undefined : startOffset);\n    } else {\n      sound.autoplay = true;\n    }\n\n    this.isPlaying = true;\n    this.isPaused = false;\n  };\n\n  return WeightedSound;\n}();\n\nexport { WeightedSound };","map":null,"metadata":{},"sourceType":"module"}