{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { Logger } from \"../../../Misc/logger\";\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators\";\nimport { Vector3, TmpVectors } from \"../../../Maths/math.vector\";\nimport { Texture } from \"../../../Materials/Textures/texture\";\nimport { DynamicTexture } from \"../../../Materials/Textures/dynamicTexture\";\nimport { PostProcess } from \"../../../PostProcesses/postProcess\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\nimport { PassPostProcess } from \"../../../PostProcesses/passPostProcess\";\nimport { _TypeStore } from '../../../Misc/typeStore';\nimport { EngineStore } from '../../../Engines/engineStore';\nimport { SSAO2Configuration } from \"../../../Rendering/ssao2Configuration\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\nimport \"../../../Shaders/ssao2.fragment\";\nimport \"../../../Shaders/ssaoCombine.fragment\";\n/**\r\n * Render pipeline to produce ssao effect\r\n */\n\nvar SSAO2RenderingPipeline =\n/** @class */\nfunction (_super) {\n  __extends(SSAO2RenderingPipeline, _super);\n  /**\r\n   * @constructor\r\n   * @param name The rendering pipeline name\r\n   * @param scene The scene linked to this pipeline\r\n   * @param ratio The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }\r\n   * @param cameras The array of cameras that the rendering pipeline will be attached to\r\n   * @param forceGeometryBuffer Set to true if you want to use the legacy geometry buffer renderer\r\n   */\n\n\n  function SSAO2RenderingPipeline(name, scene, ratio, cameras, forceGeometryBuffer) {\n    if (forceGeometryBuffer === void 0) {\n      forceGeometryBuffer = true;\n    }\n\n    var _this = _super.call(this, scene.getEngine(), name) || this; // Members\n\n    /**\r\n     * @ignore\r\n    * The PassPostProcess id in the pipeline that contains the original scene color\r\n    */\n\n\n    _this.SSAOOriginalSceneColorEffect = \"SSAOOriginalSceneColorEffect\";\n    /**\r\n     * @ignore\r\n    * The SSAO PostProcess id in the pipeline\r\n    */\n\n    _this.SSAORenderEffect = \"SSAORenderEffect\";\n    /**\r\n     * @ignore\r\n    * The horizontal blur PostProcess id in the pipeline\r\n    */\n\n    _this.SSAOBlurHRenderEffect = \"SSAOBlurHRenderEffect\";\n    /**\r\n     * @ignore\r\n    * The vertical blur PostProcess id in the pipeline\r\n    */\n\n    _this.SSAOBlurVRenderEffect = \"SSAOBlurVRenderEffect\";\n    /**\r\n     * @ignore\r\n    * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)\r\n    */\n\n    _this.SSAOCombineRenderEffect = \"SSAOCombineRenderEffect\";\n    /**\r\n    * The output strength of the SSAO post-process. Default value is 1.0.\r\n    */\n\n    _this.totalStrength = 1.0;\n    /**\r\n    * Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.\r\n    */\n\n    _this.maxZ = 100.0;\n    /**\r\n    * In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much\r\n    */\n\n    _this.minZAspect = 0.2;\n    _this._samples = 8;\n    _this._textureSamples = 1;\n    /**\r\n     * Force rendering the geometry through geometry buffer\r\n     */\n\n    _this._forceGeometryBuffer = false;\n    _this._expensiveBlur = true;\n    /**\r\n    * The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0\r\n    */\n\n    _this.radius = 2.0;\n    /**\r\n    * The base color of the SSAO post-process\r\n    * The final result is \"base + ssao\" between [0, 1]\r\n    */\n\n    _this.base = 0;\n    _this._bits = new Uint32Array(1);\n    _this._scene = scene;\n    _this._ratio = ratio;\n    _this._forceGeometryBuffer = forceGeometryBuffer;\n\n    if (!_this.isSupported) {\n      Logger.Error(\"SSAO 2 needs WebGL 2 support.\");\n      return _this;\n    }\n\n    var ssaoRatio = _this._ratio.ssaoRatio || ratio;\n    var blurRatio = _this._ratio.blurRatio || ratio; // Set up assets\n\n    if (_this._forceGeometryBuffer) {\n      scene.enableGeometryBufferRenderer();\n    } else {\n      _this._prePassRenderer = scene.enablePrePassRenderer();\n    }\n\n    _this._createRandomTexture();\n\n    _this._originalColorPostProcess = new PassPostProcess(\"SSAOOriginalSceneColor\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);\n    _this._originalColorPostProcess.samples = _this.textureSamples;\n\n    _this._createSSAOPostProcess(1.0);\n\n    _this._createBlurPostProcess(ssaoRatio, blurRatio);\n\n    _this._createSSAOCombinePostProcess(blurRatio); // Set up pipeline\n\n\n    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOOriginalSceneColorEffect, function () {\n      return _this._originalColorPostProcess;\n    }, true));\n\n    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAORenderEffect, function () {\n      return _this._ssaoPostProcess;\n    }, true));\n\n    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurHRenderEffect, function () {\n      return _this._blurHPostProcess;\n    }, true));\n\n    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurVRenderEffect, function () {\n      return _this._blurVPostProcess;\n    }, true));\n\n    _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), _this.SSAOCombineRenderEffect, function () {\n      return _this._ssaoCombinePostProcess;\n    }, true)); // Finish\n\n\n    scene.postProcessRenderPipelineManager.addPipeline(_this);\n\n    if (cameras) {\n      scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(SSAO2RenderingPipeline.prototype, \"samples\", {\n    get: function get() {\n      return this._samples;\n    },\n\n    /**\r\n    * Number of samples used for the SSAO calculations. Default value is 8\r\n    */\n    set: function set(n) {\n      this._samples = n;\n\n      this._ssaoPostProcess.updateEffect(this._getDefinesForSSAO());\n\n      this._sampleSphere = this._generateHemisphere();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SSAO2RenderingPipeline.prototype, \"textureSamples\", {\n    get: function get() {\n      return this._textureSamples;\n    },\n\n    /**\r\n    * Number of samples to use for antialiasing\r\n    */\n    set: function set(n) {\n      this._textureSamples = n;\n      this._originalColorPostProcess.samples = n;\n      this._blurHPostProcess.samples = n;\n      this._blurVPostProcess.samples = n;\n      this._ssaoPostProcess.samples = n;\n      this._ssaoCombinePostProcess.samples = n;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SSAO2RenderingPipeline.prototype, \"expensiveBlur\", {\n    get: function get() {\n      return this._expensiveBlur;\n    },\n\n    /**\r\n    * If bilateral blur should be used\r\n    */\n    set: function set(b) {\n      this._blurHPostProcess.updateEffect(\"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_H\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (b ? \"1\" : \"0\") + \"\\n\", null, [\"textureSampler\", \"depthNormalSampler\"]);\n\n      this._blurVPostProcess.updateEffect(\"#define BILATERAL_BLUR\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (b ? \"1\" : \"0\") + \"\\n\", null, [\"textureSampler\", \"depthNormalSampler\"]);\n\n      this._expensiveBlur = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SSAO2RenderingPipeline, \"IsSupported\", {\n    /**\r\n    *  Support test.\r\n    */\n    get: function get() {\n      var engine = EngineStore.LastCreatedEngine;\n\n      if (!engine) {\n        return false;\n      }\n\n      return engine.webGLVersion >= 2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SSAO2RenderingPipeline.prototype, \"scene\", {\n    /**\r\n     * Gets active scene\r\n     */\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Public Methods\n\n  /**\r\n   * Get the class name\r\n   * @returns \"SSAO2RenderingPipeline\"\r\n   */\n\n  SSAO2RenderingPipeline.prototype.getClassName = function () {\n    return \"SSAO2RenderingPipeline\";\n  };\n  /**\r\n   * Removes the internal pipeline assets and detatches the pipeline from the scene cameras\r\n   */\n\n\n  SSAO2RenderingPipeline.prototype.dispose = function (disableGeometryBufferRenderer) {\n    if (disableGeometryBufferRenderer === void 0) {\n      disableGeometryBufferRenderer = false;\n    }\n\n    for (var i = 0; i < this._scene.cameras.length; i++) {\n      var camera = this._scene.cameras[i];\n\n      this._originalColorPostProcess.dispose(camera);\n\n      this._ssaoPostProcess.dispose(camera);\n\n      this._blurHPostProcess.dispose(camera);\n\n      this._blurVPostProcess.dispose(camera);\n\n      this._ssaoCombinePostProcess.dispose(camera);\n    }\n\n    this._randomTexture.dispose();\n\n    if (disableGeometryBufferRenderer) {\n      this._scene.disableGeometryBufferRenderer();\n    }\n\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);\n\n    _super.prototype.dispose.call(this);\n  }; // Private Methods\n\n\n  SSAO2RenderingPipeline.prototype._createBlurPostProcess = function (ssaoRatio, blurRatio) {\n    var _this = this;\n\n    this._samplerOffsets = [];\n    var expensive = this.expensiveBlur;\n\n    for (var i = -8; i < 8; i++) {\n      this._samplerOffsets.push(i * 2 + 0.5);\n    }\n\n    this._blurHPostProcess = new PostProcess(\"BlurH\", \"ssao2\", [\"outSize\", \"samplerOffsets\", \"near\", \"far\", \"radius\"], [\"depthNormalSampler\"], ssaoRatio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_H\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (expensive ? \"1\" : \"0\") + \"\\n\");\n\n    this._blurHPostProcess.onApply = function (effect) {\n      if (!_this._scene.activeCamera) {\n        return;\n      }\n\n      effect.setFloat(\"outSize\", _this._ssaoCombinePostProcess.width > 0 ? _this._ssaoCombinePostProcess.width : _this._originalColorPostProcess.width);\n      effect.setFloat(\"near\", _this._scene.activeCamera.minZ);\n      effect.setFloat(\"far\", _this._scene.activeCamera.maxZ);\n      effect.setFloat(\"radius\", _this.radius);\n\n      if (_this._forceGeometryBuffer) {\n        effect.setTexture(\"depthNormalSampler\", _this._scene.enableGeometryBufferRenderer().getGBuffer().textures[0]);\n      } else {\n        effect.setTexture(\"depthNormalSampler\", _this._prePassRenderer.prePassRT.textures[_this._prePassRenderer.getIndex(5)]);\n      }\n\n      effect.setArray(\"samplerOffsets\", _this._samplerOffsets);\n    };\n\n    this._blurVPostProcess = new PostProcess(\"BlurV\", \"ssao2\", [\"outSize\", \"samplerOffsets\", \"near\", \"far\", \"radius\"], [\"depthNormalSampler\"], blurRatio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_V\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (expensive ? \"1\" : \"0\") + \"\\n\");\n\n    this._blurVPostProcess.onApply = function (effect) {\n      if (!_this._scene.activeCamera) {\n        return;\n      }\n\n      effect.setFloat(\"outSize\", _this._ssaoCombinePostProcess.height > 0 ? _this._ssaoCombinePostProcess.height : _this._originalColorPostProcess.height);\n      effect.setFloat(\"near\", _this._scene.activeCamera.minZ);\n      effect.setFloat(\"far\", _this._scene.activeCamera.maxZ);\n      effect.setFloat(\"radius\", _this.radius);\n\n      if (_this._forceGeometryBuffer) {\n        effect.setTexture(\"depthNormalSampler\", _this._scene.enableGeometryBufferRenderer().getGBuffer().textures[0]);\n      } else {\n        effect.setTexture(\"depthNormalSampler\", _this._prePassRenderer.prePassRT.textures[_this._prePassRenderer.getIndex(5)]);\n      }\n\n      effect.setArray(\"samplerOffsets\", _this._samplerOffsets);\n    };\n\n    this._blurHPostProcess.samples = this.textureSamples;\n    this._blurVPostProcess.samples = this.textureSamples;\n  };\n  /** @hidden */\n\n\n  SSAO2RenderingPipeline.prototype._rebuild = function () {\n    _super.prototype._rebuild.call(this);\n  }; //Van der Corput radical inverse\n\n\n  SSAO2RenderingPipeline.prototype._radicalInverse_VdC = function (i) {\n    this._bits[0] = i;\n    this._bits[0] = (this._bits[0] << 16 | this._bits[0] >> 16) >>> 0;\n    this._bits[0] = (this._bits[0] & 0x55555555) << 1 | (this._bits[0] & 0xAAAAAAAA) >>> 1 >>> 0;\n    this._bits[0] = (this._bits[0] & 0x33333333) << 2 | (this._bits[0] & 0xCCCCCCCC) >>> 2 >>> 0;\n    this._bits[0] = (this._bits[0] & 0x0F0F0F0F) << 4 | (this._bits[0] & 0xF0F0F0F0) >>> 4 >>> 0;\n    this._bits[0] = (this._bits[0] & 0x00FF00FF) << 8 | (this._bits[0] & 0xFF00FF00) >>> 8 >>> 0;\n    return this._bits[0] * 2.3283064365386963e-10; // / 0x100000000 or / 4294967296\n  };\n\n  SSAO2RenderingPipeline.prototype._hammersley = function (i, n) {\n    return [i / n, this._radicalInverse_VdC(i)];\n  };\n\n  SSAO2RenderingPipeline.prototype._hemisphereSample_uniform = function (u, v) {\n    var phi = v * 2.0 * Math.PI; // rejecting samples that are close to tangent plane to avoid z-fighting artifacts\n\n    var cosTheta = 1.0 - (u * 0.85 + 0.15);\n    var sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n    return new Vector3(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta);\n  };\n\n  SSAO2RenderingPipeline.prototype._generateHemisphere = function () {\n    var numSamples = this.samples;\n    var result = [];\n    var vector;\n    var i = 0;\n\n    while (i < numSamples) {\n      if (numSamples < 16) {\n        vector = this._hemisphereSample_uniform(Math.random(), Math.random());\n      } else {\n        var rand = this._hammersley(i, numSamples);\n\n        vector = this._hemisphereSample_uniform(rand[0], rand[1]);\n      }\n\n      result.push(vector.x, vector.y, vector.z);\n      i++;\n    }\n\n    return result;\n  };\n\n  SSAO2RenderingPipeline.prototype._getDefinesForSSAO = function () {\n    var defines = \"#define SAMPLES \" + this.samples + \"\\n#define SSAO\";\n\n    if (this._forceGeometryBuffer) {\n      defines = defines + \"\\n#define GEOMETRYBUFFER\";\n    }\n\n    return defines;\n  };\n\n  SSAO2RenderingPipeline.prototype._createSSAOPostProcess = function (ratio) {\n    var _this = this;\n\n    this._sampleSphere = this._generateHemisphere();\n\n    var defines = this._getDefinesForSSAO();\n\n    var samplers;\n\n    if (this._forceGeometryBuffer) {\n      samplers = [\"randomSampler\", \"depthSampler\", \"normalSampler\"];\n    } else {\n      samplers = [\"randomSampler\", \"depthNormalSampler\"];\n    }\n\n    this._ssaoPostProcess = new PostProcess(\"ssao2\", \"ssao2\", [\"sampleSphere\", \"samplesFactor\", \"randTextureTiles\", \"totalStrength\", \"radius\", \"base\", \"range\", \"projection\", \"near\", \"far\", \"texelSize\", \"xViewport\", \"yViewport\", \"maxZ\", \"minZAspect\"], samplers, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, defines);\n\n    this._ssaoPostProcess.onApply = function (effect) {\n      if (!_this._scene.activeCamera) {\n        return;\n      }\n\n      effect.setArray3(\"sampleSphere\", _this._sampleSphere);\n      effect.setFloat(\"randTextureTiles\", 32.0);\n      effect.setFloat(\"samplesFactor\", 1 / _this.samples);\n      effect.setFloat(\"totalStrength\", _this.totalStrength);\n      effect.setFloat2(\"texelSize\", 1 / _this._ssaoPostProcess.width, 1 / _this._ssaoPostProcess.height);\n      effect.setFloat(\"radius\", _this.radius);\n      effect.setFloat(\"maxZ\", _this.maxZ);\n      effect.setFloat(\"minZAspect\", _this.minZAspect);\n      effect.setFloat(\"base\", _this.base);\n      effect.setFloat(\"near\", _this._scene.activeCamera.minZ);\n      effect.setFloat(\"far\", _this._scene.activeCamera.maxZ);\n      effect.setFloat(\"xViewport\", Math.tan(_this._scene.activeCamera.fov / 2) * _this._scene.getEngine().getAspectRatio(_this._scene.activeCamera, true));\n      effect.setFloat(\"yViewport\", Math.tan(_this._scene.activeCamera.fov / 2));\n      effect.setMatrix(\"projection\", _this._scene.getProjectionMatrix());\n\n      if (_this._forceGeometryBuffer) {\n        effect.setTexture(\"depthSampler\", _this._scene.enableGeometryBufferRenderer().getGBuffer().textures[0]);\n        effect.setTexture(\"normalSampler\", _this._scene.enableGeometryBufferRenderer().getGBuffer().textures[1]);\n      } else {\n        effect.setTexture(\"depthNormalSampler\", _this._prePassRenderer.prePassRT.textures[_this._prePassRenderer.getIndex(5)]);\n      }\n\n      effect.setTexture(\"randomSampler\", _this._randomTexture);\n    };\n\n    this._ssaoPostProcess.samples = this.textureSamples;\n  };\n\n  SSAO2RenderingPipeline.prototype._createSSAOCombinePostProcess = function (ratio) {\n    var _this = this;\n\n    this._ssaoCombinePostProcess = new PostProcess(\"ssaoCombine\", \"ssaoCombine\", [], [\"originalColor\", \"viewport\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);\n\n    this._ssaoCombinePostProcess.onApply = function (effect) {\n      var viewport = _this._scene.activeCamera.viewport;\n      effect.setVector4(\"viewport\", TmpVectors.Vector4[0].copyFromFloats(viewport.x, viewport.y, viewport.width, viewport.height));\n      effect.setTextureFromPostProcessOutput(\"originalColor\", _this._originalColorPostProcess);\n    };\n\n    this._ssaoCombinePostProcess.samples = this.textureSamples;\n\n    if (!this._forceGeometryBuffer) {\n      this._ssaoCombinePostProcess._prePassEffectConfiguration = new SSAO2Configuration();\n    }\n  };\n\n  SSAO2RenderingPipeline.prototype._createRandomTexture = function () {\n    var size = 128;\n    this._randomTexture = new DynamicTexture(\"SSAORandomTexture\", size, this._scene, false, Texture.TRILINEAR_SAMPLINGMODE);\n    this._randomTexture.wrapU = Texture.WRAP_ADDRESSMODE;\n    this._randomTexture.wrapV = Texture.WRAP_ADDRESSMODE;\n\n    var context = this._randomTexture.getContext();\n\n    var rand = function rand(min, max) {\n      return Math.random() * (max - min) + min;\n    };\n\n    var randVector = Vector3.Zero();\n\n    for (var x = 0; x < size; x++) {\n      for (var y = 0; y < size; y++) {\n        randVector.x = rand(0.0, 1.0);\n        randVector.y = rand(0.0, 1.0);\n        randVector.z = 0.0;\n        randVector.normalize();\n        randVector.scaleInPlace(255);\n        randVector.x = Math.floor(randVector.x);\n        randVector.y = Math.floor(randVector.y);\n        context.fillStyle = 'rgb(' + randVector.x + ', ' + randVector.y + ', ' + randVector.z + ')';\n        context.fillRect(x, y, 1, 1);\n      }\n    }\n\n    this._randomTexture.update(false);\n  };\n  /**\r\n   * Serialize the rendering pipeline (Used when exporting)\r\n   * @returns the serialized object\r\n   */\n\n\n  SSAO2RenderingPipeline.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"SSAO2RenderingPipeline\";\n    return serializationObject;\n  };\n  /**\r\n   * Parse the serialized pipeline\r\n   * @param source Source pipeline.\r\n   * @param scene The scene to load the pipeline to.\r\n   * @param rootUrl The URL of the serialized pipeline.\r\n   * @returns An instantiated pipeline from the serialized object.\r\n   */\n\n\n  SSAO2RenderingPipeline.Parse = function (source, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new SSAO2RenderingPipeline(source._name, scene, source._ratio);\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serialize()], SSAO2RenderingPipeline.prototype, \"totalStrength\", void 0);\n\n  __decorate([serialize()], SSAO2RenderingPipeline.prototype, \"maxZ\", void 0);\n\n  __decorate([serialize()], SSAO2RenderingPipeline.prototype, \"minZAspect\", void 0);\n\n  __decorate([serialize(\"samples\")], SSAO2RenderingPipeline.prototype, \"_samples\", void 0);\n\n  __decorate([serialize(\"textureSamples\")], SSAO2RenderingPipeline.prototype, \"_textureSamples\", void 0);\n\n  __decorate([serialize()], SSAO2RenderingPipeline.prototype, \"_ratio\", void 0);\n\n  __decorate([serialize(\"expensiveBlur\")], SSAO2RenderingPipeline.prototype, \"_expensiveBlur\", void 0);\n\n  __decorate([serialize()], SSAO2RenderingPipeline.prototype, \"radius\", void 0);\n\n  __decorate([serialize()], SSAO2RenderingPipeline.prototype, \"base\", void 0);\n\n  return SSAO2RenderingPipeline;\n}(PostProcessRenderPipeline);\n\nexport { SSAO2RenderingPipeline };\n_TypeStore.RegisteredTypes[\"BABYLON.SSAO2RenderingPipeline\"] = SSAO2RenderingPipeline;","map":null,"metadata":{},"sourceType":"module"}