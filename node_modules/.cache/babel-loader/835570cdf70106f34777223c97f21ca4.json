{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateTorusKnot = function (options) {\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var radius = options.radius || 2;\n  var tube = options.tube || 0.5;\n  var radialSegments = options.radialSegments || 32;\n  var tubularSegments = options.tubularSegments || 32;\n  var p = options.p || 2;\n  var q = options.q || 3;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // Helper\n\n  var getPos = function getPos(angle) {\n    var cu = Math.cos(angle);\n    var su = Math.sin(angle);\n    var quOverP = q / p * angle;\n    var cs = Math.cos(quOverP);\n    var tx = radius * (2 + cs) * 0.5 * cu;\n    var ty = radius * (2 + cs) * su * 0.5;\n    var tz = radius * Math.sin(quOverP) * 0.5;\n    return new Vector3(tx, ty, tz);\n  }; // Vertices\n\n\n  var i;\n  var j;\n\n  for (i = 0; i <= radialSegments; i++) {\n    var modI = i % radialSegments;\n    var u = modI / radialSegments * 2 * p * Math.PI;\n    var p1 = getPos(u);\n    var p2 = getPos(u + 0.01);\n    var tang = p2.subtract(p1);\n    var n = p2.add(p1);\n    var bitan = Vector3.Cross(tang, n);\n    n = Vector3.Cross(bitan, tang);\n    bitan.normalize();\n    n.normalize();\n\n    for (j = 0; j < tubularSegments; j++) {\n      var modJ = j % tubularSegments;\n      var v = modJ / tubularSegments * 2 * Math.PI;\n      var cx = -tube * Math.cos(v);\n      var cy = tube * Math.sin(v);\n      positions.push(p1.x + cx * n.x + cy * bitan.x);\n      positions.push(p1.y + cx * n.y + cy * bitan.y);\n      positions.push(p1.z + cx * n.z + cy * bitan.z);\n      uvs.push(i / radialSegments);\n      uvs.push(j / tubularSegments);\n    }\n  }\n\n  for (i = 0; i < radialSegments; i++) {\n    for (j = 0; j < tubularSegments; j++) {\n      var jNext = (j + 1) % tubularSegments;\n      var a = i * tubularSegments + j;\n      var b = (i + 1) * tubularSegments + j;\n      var c = (i + 1) * tubularSegments + jNext;\n      var d = i * tubularSegments + jNext;\n      indices.push(d);\n      indices.push(b);\n      indices.push(a);\n      indices.push(d);\n      indices.push(c);\n      indices.push(b);\n    }\n  } // Normals\n\n\n  VertexData.ComputeNormals(positions, indices, normals); // Sides\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nMesh.CreateTorusKnot = function (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {\n  var options = {\n    radius: radius,\n    tube: tube,\n    radialSegments: radialSegments,\n    tubularSegments: tubularSegments,\n    p: p,\n    q: q,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return TorusKnotBuilder.CreateTorusKnot(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar TorusKnotBuilder =\n/** @class */\nfunction () {\n  function TorusKnotBuilder() {}\n  /**\r\n   * Creates a torus knot mesh\r\n   * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n   * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n   * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n   * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the torus knot mesh\r\n   * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\r\n   */\n\n\n  TorusKnotBuilder.CreateTorusKnot = function (name, options, scene) {\n    var torusKnot = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateTorusKnot(options);\n    vertexData.applyToMesh(torusKnot, options.updatable);\n    return torusKnot;\n  };\n\n  return TorusKnotBuilder;\n}();\n\nexport { TorusKnotBuilder };","map":null,"metadata":{},"sourceType":"module"}