{"ast":null,"code":"import { Scene } from \"../scene\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { PrePassRenderer } from \"./prePassRenderer\";\nimport { Logger } from \"../Misc/logger\";\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\n  get: function get() {\n    return this._prePassRenderer;\n  },\n  set: function set(value) {\n    if (value && value.isSupported) {\n      this._prePassRenderer = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nScene.prototype.enablePrePassRenderer = function () {\n  if (this._prePassRenderer) {\n    return this._prePassRenderer;\n  }\n\n  this._prePassRenderer = new PrePassRenderer(this);\n\n  if (!this._prePassRenderer.isSupported) {\n    this._prePassRenderer = null;\n    Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\n  }\n\n  return this._prePassRenderer;\n};\n\nScene.prototype.disablePrePassRenderer = function () {\n  if (!this._prePassRenderer) {\n    return;\n  }\n\n  this._prePassRenderer.dispose();\n\n  this._prePassRenderer = null;\n};\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\n\n\nvar PrePassRendererSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function PrePassRendererSceneComponent(scene) {\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n    this.scene = scene;\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  PrePassRendererSceneComponent.prototype.register = function () {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\n\n    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEARSTAGE_PREPASS, this, this._beforeClearStage);\n\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\n\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeCameraDraw = function () {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._beforeCameraDraw();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._afterCameraDraw = function () {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._afterCameraDraw();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeClearStage = function () {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer.clear();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeRenderingMeshStage = function (mesh, subMesh, batch, effect) {\n    if (!effect) {\n      return;\n    } // Render to MRT\n\n\n    var scene = mesh.getScene();\n\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._afterRenderingMeshStage = function (mesh) {\n    var scene = mesh.getScene();\n\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.restoreAttachments();\n    }\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  PrePassRendererSceneComponent.prototype.rebuild = function () {// Nothing to do for this component\n  };\n  /**\r\n   * Disposes the component and the associated ressources\r\n   */\n\n\n  PrePassRendererSceneComponent.prototype.dispose = function () {// Nothing to do for this component\n  };\n\n  return PrePassRendererSceneComponent;\n}();\n\nexport { PrePassRendererSceneComponent };\n\nPrePassRenderer._SceneComponentInitialization = function (scene) {\n  // Register the G Buffer component to the scene.\n  var component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);\n\n  if (!component) {\n    component = new PrePassRendererSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}