{"ast":null,"code":"import { RenderingGroup } from \"./renderingGroup\";\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\n\nvar RenderingGroupInfo =\n/** @class */\nfunction () {\n  function RenderingGroupInfo() {}\n\n  return RenderingGroupInfo;\n}();\n\nexport { RenderingGroupInfo };\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\n\nvar RenderingManager =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new rendering group for a particular scene\r\n   * @param scene Defines the scene the groups belongs to\r\n   */\n  function RenderingManager(scene) {\n    /**\r\n     * @hidden\r\n     */\n    this._useSceneAutoClearSetup = false;\n    this._renderingGroups = new Array();\n    this._autoClearDepthStencil = {};\n    this._customOpaqueSortCompareFn = {};\n    this._customAlphaTestSortCompareFn = {};\n    this._customTransparentSortCompareFn = {};\n    this._renderingGroupInfo = new RenderingGroupInfo();\n    this._scene = scene;\n\n    for (var i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n      this._autoClearDepthStencil[i] = {\n        autoClear: true,\n        depth: true,\n        stencil: true\n      };\n    }\n  }\n\n  RenderingManager.prototype._clearDepthStencilBuffer = function (depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    if (this._depthStencilBufferAlreadyCleaned) {\n      return;\n    }\n\n    this._scene.getEngine().clear(null, false, depth, stencil);\n\n    this._depthStencilBufferAlreadyCleaned = true;\n  };\n  /**\r\n   * Renders the entire managed groups. This is used by the scene or the different rennder targets.\r\n   * @hidden\r\n   */\n\n\n  RenderingManager.prototype.render = function (customRenderFunction, activeMeshes, renderParticles, renderSprites) {\n    // Update the observable context (not null as it only goes away on dispose)\n    var info = this._renderingGroupInfo;\n    info.scene = this._scene;\n    info.camera = this._scene.activeCamera; // Dispatch sprites\n\n    if (this._scene.spriteManagers && renderSprites) {\n      for (var index = 0; index < this._scene.spriteManagers.length; index++) {\n        var manager = this._scene.spriteManagers[index];\n        this.dispatchSprites(manager);\n      }\n    } // Render\n\n\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\n      var renderingGroup = this._renderingGroups[index];\n\n      if (!renderingGroup) {\n        continue;\n      }\n\n      var renderingGroupMask = Math.pow(2, index);\n      info.renderingGroupId = index; // Before Observable\n\n      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask); // Clear depth/stencil if needed\n\n\n      if (RenderingManager.AUTOCLEAR) {\n        var autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\n\n        if (autoClear && autoClear.autoClear) {\n          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\n        }\n      } // Render\n\n\n      for (var _i = 0, _a = this._scene._beforeRenderingGroupDrawStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        step.action(index);\n      }\n\n      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\n\n      for (var _b = 0, _c = this._scene._afterRenderingGroupDrawStage; _b < _c.length; _b++) {\n        var step = _c[_b];\n        step.action(index);\n      } // After Observable\n\n\n      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n    }\n  };\n  /**\r\n   * Resets the different information of the group to prepare a new frame\r\n   * @hidden\r\n   */\n\n\n  RenderingManager.prototype.reset = function () {\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      var renderingGroup = this._renderingGroups[index];\n\n      if (renderingGroup) {\n        renderingGroup.prepare();\n      }\n    }\n  };\n  /**\r\n   * Dispose and release the group and its associated resources.\r\n   * @hidden\r\n   */\n\n\n  RenderingManager.prototype.dispose = function () {\n    this.freeRenderingGroups();\n    this._renderingGroups.length = 0;\n    this._renderingGroupInfo = null;\n  };\n  /**\r\n   * Clear the info related to rendering groups preventing retention points during dispose.\r\n   */\n\n\n  RenderingManager.prototype.freeRenderingGroups = function () {\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      var renderingGroup = this._renderingGroups[index];\n\n      if (renderingGroup) {\n        renderingGroup.dispose();\n      }\n    }\n  };\n\n  RenderingManager.prototype._prepareRenderingGroup = function (renderingGroupId) {\n    if (this._renderingGroups[renderingGroupId] === undefined) {\n      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);\n    }\n  };\n  /**\r\n   * Add a sprite manager to the rendering manager in order to render it this frame.\r\n   * @param spriteManager Define the sprite manager to render\r\n   */\n\n\n  RenderingManager.prototype.dispatchSprites = function (spriteManager) {\n    var renderingGroupId = spriteManager.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);\n  };\n  /**\r\n   * Add a particle system to the rendering manager in order to render it this frame.\r\n   * @param particleSystem Define the particle system to render\r\n   */\n\n\n  RenderingManager.prototype.dispatchParticles = function (particleSystem) {\n    var renderingGroupId = particleSystem.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);\n  };\n  /**\r\n   * Add a submesh to the manager in order to render it this frame\r\n   * @param subMesh The submesh to dispatch\r\n   * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n   * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n   */\n\n\n  RenderingManager.prototype.dispatch = function (subMesh, mesh, material) {\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n\n    var renderingGroupId = mesh.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);\n  };\n  /**\r\n   * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n   * This allowed control for front to back rendering or reversly depending of the special needs.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n   */\n\n\n  RenderingManager.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\n    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\n    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\n\n    if (this._renderingGroups[renderingGroupId]) {\n      var group = this._renderingGroups[renderingGroupId];\n      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\n      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\n      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\n    }\n  };\n  /**\r\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n   */\n\n\n  RenderingManager.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    this._autoClearDepthStencil[renderingGroupId] = {\n      autoClear: autoClearDepthStencil,\n      depth: depth,\n      stencil: stencil\n    };\n  };\n  /**\r\n   * Gets the current auto clear configuration for one rendering group of the rendering\r\n   * manager.\r\n   * @param index the rendering group index to get the information for\r\n   * @returns The auto clear setup for the requested rendering group\r\n   */\n\n\n  RenderingManager.prototype.getAutoClearDepthStencilSetup = function (index) {\n    return this._autoClearDepthStencil[index];\n  };\n  /**\r\n   * The max id used for rendering groups (not included)\r\n   */\n\n\n  RenderingManager.MAX_RENDERINGGROUPS = 4;\n  /**\r\n   * The min id used for rendering groups (included)\r\n   */\n\n  RenderingManager.MIN_RENDERINGGROUPS = 0;\n  /**\r\n   * Used to globally prevent autoclearing scenes.\r\n   */\n\n  RenderingManager.AUTOCLEAR = true;\n  return RenderingManager;\n}();\n\nexport { RenderingManager };","map":null,"metadata":{},"sourceType":"module"}