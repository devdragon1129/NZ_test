{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { CylinderBuilder } from \"../Meshes/Builders/cylinderBuilder\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { Color3 } from '../Maths/math.color';\n/**\r\n * Single axis drag gizmo\r\n */\n\nvar AxisDragGizmo =\n/** @class */\nfunction (_super) {\n  __extends(AxisDragGizmo, _super);\n  /**\r\n   * Creates an AxisDragGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param dragAxis The axis which the gizmo will be able to drag on\r\n   * @param color The color of the gizmo\r\n   * @param thickness display gizmo axis thickness\r\n   */\n\n\n  function AxisDragGizmo(dragAxis, color, gizmoLayer, parent, thickness) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _a;\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._pointerObserver = null;\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\n\n    _this.snapDistance = 0;\n    /**\r\n     * Event that fires each time the gizmo snaps to a new location.\r\n     * * snapDistance is the the change in distance\r\n     */\n\n    _this.onSnapObservable = new Observable();\n    _this._isEnabled = true;\n    _this._parent = null;\n    _this._dragging = false;\n    _this._parent = parent; // Create Material\n\n    _this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._coloredMaterial.diffuseColor = color;\n    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    _this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._hoverMaterial.diffuseColor = Color3.Yellow();\n    _this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._disableMaterial.diffuseColor = Color3.Gray();\n    _this._disableMaterial.alpha = 0.4; // Build Mesh + Collider\n\n    var arrow = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, _this._coloredMaterial, thickness);\n\n    var collider = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, _this._coloredMaterial, thickness + 4, true); // Add to Root Node\n\n\n    _this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n\n    _this._gizmoMesh.addChild(arrow);\n\n    _this._gizmoMesh.addChild(collider);\n\n    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(dragAxis));\n\n    _this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n\n    _this._gizmoMesh.parent = _this._rootMesh;\n    var currentSnapDragDistance = 0;\n    var tmpVector = new Vector3();\n    var tmpSnapEvent = {\n      snapDistance: 0\n    }; // Add drag behavior to handle events when the gizmo is dragged\n\n    _this.dragBehavior = new PointerDragBehavior({\n      dragAxis: dragAxis\n    });\n    _this.dragBehavior.moveAttached = false;\n\n    _this._rootMesh.addBehavior(_this.dragBehavior);\n\n    _this.dragBehavior.onDragObservable.add(function (event) {\n      if (_this.attachedNode) {\n        // Keep world translation and use it to update world transform\n        // if the node has parent, the local transform properties (position, rotation, scale)\n        // will be recomputed in _matrixChanged function\n        // Snapping logic\n        if (_this.snapDistance == 0) {\n          if (_this.attachedNode.position) {\n            // Required for nodes like lights\n            _this.attachedNode.position.addInPlaceFromFloats(event.delta.x, event.delta.y, event.delta.z);\n          } // use _worldMatrix to not force a matrix update when calling GetWorldMatrix especialy with Cameras\n\n\n          _this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);\n\n          _this.attachedNode.updateCache();\n        } else {\n          currentSnapDragDistance += event.dragDistance;\n\n          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {\n            var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);\n            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;\n            event.delta.normalizeToRef(tmpVector);\n            tmpVector.scaleInPlace(_this.snapDistance * dragSteps);\n\n            _this.attachedNode.getWorldMatrix().addTranslationFromFloats(tmpVector.x, tmpVector.y, tmpVector.z);\n\n            _this.attachedNode.updateCache();\n\n            tmpSnapEvent.snapDistance = _this.snapDistance * dragSteps;\n\n            _this.onSnapObservable.notifyObservers(tmpSnapEvent);\n          }\n        }\n\n        _this._matrixChanged();\n      }\n    });\n\n    _this.dragBehavior.onDragStartObservable.add(function () {\n      _this._dragging = true;\n    });\n\n    _this.dragBehavior.onDragEndObservable.add(function () {\n      _this._dragging = false;\n    });\n\n    var light = gizmoLayer._getSharedGizmoLight();\n\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));\n    var cache = {\n      gizmoMeshes: arrow.getChildMeshes(),\n      colliderMeshes: collider.getChildMeshes(),\n      material: _this._coloredMaterial,\n      hoverMaterial: _this._hoverMaterial,\n      disableMaterial: _this._disableMaterial,\n      active: false\n    };\n    (_a = _this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(collider, cache);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a;\n\n      if (_this._customMeshSet) {\n        return;\n      }\n\n      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) != -1);\n\n      if (!_this._parent) {\n        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;\n        cache.gizmoMeshes.forEach(function (m) {\n          m.material = material;\n\n          if (m.color) {\n            m.color = material.diffuseColor;\n          }\n        });\n      }\n    });\n    return _this;\n  }\n  /** @hidden */\n\n\n  AxisDragGizmo._CreateArrow = function (scene, material, thickness, isCollider) {\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    if (isCollider === void 0) {\n      isCollider = false;\n    }\n\n    var arrow = new TransformNode(\"arrow\", scene);\n    var cylinder = CylinderBuilder.CreateCylinder(\"cylinder\", {\n      diameterTop: 0,\n      height: 0.075,\n      diameterBottom: 0.0375 * (1 + (thickness - 1) / 4),\n      tessellation: 96\n    }, scene);\n    var line = CylinderBuilder.CreateCylinder(\"cylinder\", {\n      diameterTop: 0.005 * thickness,\n      height: 0.275,\n      diameterBottom: 0.005 * thickness,\n      tessellation: 96\n    }, scene); // Position arrow pointing in its drag axis\n\n    cylinder.parent = arrow;\n    cylinder.material = material;\n    cylinder.rotation.x = Math.PI / 2;\n    cylinder.position.z += 0.3;\n    line.parent = arrow;\n    line.material = material;\n    line.position.z += 0.275 / 2;\n    line.rotation.x = Math.PI / 2;\n\n    if (isCollider) {\n      line.visibility = 0;\n      cylinder.visibility = 0;\n    }\n\n    return arrow;\n  };\n  /** @hidden */\n\n\n  AxisDragGizmo._CreateArrowInstance = function (scene, arrow) {\n    var instance = new TransformNode(\"arrow\", scene);\n\n    for (var _i = 0, _a = arrow.getChildMeshes(); _i < _a.length; _i++) {\n      var mesh = _a[_i];\n      var childInstance = mesh.createInstance(mesh.name);\n      childInstance.parent = instance;\n    }\n\n    return instance;\n  };\n\n  AxisDragGizmo.prototype._attachedNodeChanged = function (value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  };\n\n  Object.defineProperty(AxisDragGizmo.prototype, \"isEnabled\", {\n    get: function get() {\n      return this._isEnabled;\n    },\n\n    /**\r\n     * If the gizmo is enabled\r\n     */\n    set: function set(value) {\n      this._isEnabled = value;\n\n      if (!value) {\n        this.attachedMesh = null;\n        this.attachedNode = null;\n      } else {\n        if (this._parent) {\n          this.attachedMesh = this._parent.attachedMesh;\n          this.attachedNode = this._parent.attachedNode;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n  AxisDragGizmo.prototype.dispose = function () {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function (matl) {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n\n    _super.prototype.dispose.call(this);\n  };\n\n  return AxisDragGizmo;\n}(Gizmo);\n\nexport { AxisDragGizmo };","map":null,"metadata":{},"sourceType":"module"}