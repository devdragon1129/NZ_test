{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\nimport { ArrayTools } from \"../Misc/arrayTools\";\nimport { Node } from \"../node\";\nimport { Space } from '../Maths/math.axis';\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\n\nvar Bone =\n/** @class */\nfunction (_super) {\n  __extends(Bone, _super);\n  /**\r\n   * Create a new bone\r\n   * @param name defines the bone name\r\n   * @param skeleton defines the parent skeleton\r\n   * @param parentBone defines the parent (can be null if the bone is the root)\r\n   * @param localMatrix defines the local matrix\r\n   * @param restPose defines the rest pose matrix\r\n   * @param baseMatrix defines the base matrix\r\n   * @param index defines index of the bone in the hiearchy\r\n   */\n\n\n  function Bone(\n  /**\r\n   * defines the bone name\r\n   */\n  name, skeleton, parentBone, localMatrix, restPose, baseMatrix, index) {\n    if (parentBone === void 0) {\n      parentBone = null;\n    }\n\n    if (localMatrix === void 0) {\n      localMatrix = null;\n    }\n\n    if (restPose === void 0) {\n      restPose = null;\n    }\n\n    if (baseMatrix === void 0) {\n      baseMatrix = null;\n    }\n\n    if (index === void 0) {\n      index = null;\n    }\n\n    var _this = _super.call(this, name, skeleton.getScene()) || this;\n\n    _this.name = name;\n    /**\r\n     * Gets the list of child bones\r\n     */\n\n    _this.children = new Array();\n    /** Gets the animations associated with this bone */\n\n    _this.animations = new Array();\n    /**\r\n     * @hidden Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\n\n    _this._index = null;\n    _this._absoluteTransform = new Matrix();\n    _this._invertedAbsoluteTransform = new Matrix();\n    _this._scalingDeterminant = 1;\n    _this._worldTransform = new Matrix();\n    _this._needToDecompose = true;\n    _this._needToCompose = false;\n    /** @hidden */\n\n    _this._linkedTransformNode = null;\n    /** @hidden */\n\n    _this._waitingTransformNodeId = null;\n    _this._skeleton = skeleton;\n    _this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\n    _this._restPose = restPose ? restPose : _this._localMatrix.clone();\n    _this._bindPose = _this._localMatrix.clone();\n    _this._baseMatrix = baseMatrix ? baseMatrix : _this._localMatrix.clone();\n    _this._index = index;\n    skeleton.bones.push(_this);\n\n    _this.setParent(parentBone, false);\n\n    if (baseMatrix || localMatrix) {\n      _this._updateDifferenceMatrix();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(Bone.prototype, \"_matrix\", {\n    /** @hidden */\n    get: function get() {\n      this._compose();\n\n      return this._localMatrix;\n    },\n\n    /** @hidden */\n    set: function set(value) {\n      this._localMatrix.copyFrom(value);\n\n      this._needToDecompose = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current object class name.\r\n   * @return the class name\r\n   */\n\n  Bone.prototype.getClassName = function () {\n    return \"Bone\";\n  }; // Members\n\n  /**\r\n   * Gets the parent skeleton\r\n   * @returns a skeleton\r\n   */\n\n\n  Bone.prototype.getSkeleton = function () {\n    return this._skeleton;\n  };\n  /**\r\n   * Gets parent bone\r\n   * @returns a bone or null if the bone is the root of the bone hierarchy\r\n   */\n\n\n  Bone.prototype.getParent = function () {\n    return this._parent;\n  };\n  /**\r\n   * Returns an array containing the root bones\r\n   * @returns an array containing the root bones\r\n   */\n\n\n  Bone.prototype.getChildren = function () {\n    return this.children;\n  };\n  /**\r\n   * Gets the node index in matrix array generated for rendering\r\n   * @returns the node index\r\n   */\n\n\n  Bone.prototype.getIndex = function () {\n    return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\n  };\n  /**\r\n   * Sets the parent bone\r\n   * @param parent defines the parent (can be null if the bone is the root)\r\n   * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n   */\n\n\n  Bone.prototype.setParent = function (parent, updateDifferenceMatrix) {\n    if (updateDifferenceMatrix === void 0) {\n      updateDifferenceMatrix = true;\n    }\n\n    if (this._parent === parent) {\n      return;\n    }\n\n    if (this._parent) {\n      var index = this._parent.children.indexOf(this);\n\n      if (index !== -1) {\n        this._parent.children.splice(index, 1);\n      }\n    }\n\n    this._parent = parent;\n\n    if (this._parent) {\n      this._parent.children.push(this);\n    }\n\n    if (updateDifferenceMatrix) {\n      this._updateDifferenceMatrix();\n    }\n\n    this.markAsDirty();\n  };\n  /**\r\n   * Gets the local matrix\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getLocalMatrix = function () {\n    this._compose();\n\n    return this._localMatrix;\n  };\n  /**\r\n   * Gets the base matrix (initial matrix which remains unchanged)\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getBaseMatrix = function () {\n    return this._baseMatrix;\n  };\n  /**\r\n   * Gets the rest pose matrix\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getRestPose = function () {\n    return this._restPose;\n  };\n  /**\r\n   * Sets the rest pose matrix\r\n   * @param matrix the local-space rest pose to set for this bone\r\n   */\n\n\n  Bone.prototype.setRestPose = function (matrix) {\n    this._restPose.copyFrom(matrix);\n  };\n  /**\r\n   * Gets the bind pose matrix\r\n   * @returns the bind pose matrix\r\n   */\n\n\n  Bone.prototype.getBindPose = function () {\n    return this._bindPose;\n  };\n  /**\r\n   * Sets the bind pose matrix\r\n   * @param matrix the local-space bind pose to set for this bone\r\n   */\n\n\n  Bone.prototype.setBindPose = function (matrix) {\n    this._bindPose.copyFrom(matrix);\n  };\n  /**\r\n   * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\r\n   */\n\n\n  Bone.prototype.getWorldMatrix = function () {\n    return this._worldTransform;\n  };\n  /**\r\n   * Sets the local matrix to rest pose matrix\r\n   */\n\n\n  Bone.prototype.returnToRest = function () {\n    if (this._skeleton._numBonesWithLinkedTransformNode > 0) {\n      this.updateMatrix(this._restPose, false, false);\n    } else {\n      this.updateMatrix(this._restPose, false, true);\n    }\n  };\n  /**\r\n   * Gets the inverse of the absolute transform matrix.\r\n   * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getInvertedAbsoluteTransform = function () {\n    return this._invertedAbsoluteTransform;\n  };\n  /**\r\n   * Gets the absolute transform matrix (ie base matrix * parent world matrix)\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getAbsoluteTransform = function () {\n    return this._absoluteTransform;\n  };\n  /**\r\n   * Links with the given transform node.\r\n   * The local matrix of this bone is copied from the transform node every frame.\r\n   * @param transformNode defines the transform node to link to\r\n   */\n\n\n  Bone.prototype.linkTransformNode = function (transformNode) {\n    if (this._linkedTransformNode) {\n      this._skeleton._numBonesWithLinkedTransformNode--;\n    }\n\n    this._linkedTransformNode = transformNode;\n\n    if (this._linkedTransformNode) {\n      this._skeleton._numBonesWithLinkedTransformNode++;\n    }\n  }; // Properties (matches AbstractMesh properties)\n\n  /**\r\n   * Gets the node used to drive the bone's transformation\r\n   * @returns a transform node or null\r\n   */\n\n\n  Bone.prototype.getTransformNode = function () {\n    return this._linkedTransformNode;\n  };\n\n  Object.defineProperty(Bone.prototype, \"position\", {\n    /** Gets or sets current position (in local space) */\n    get: function get() {\n      this._decompose();\n\n      return this._localPosition;\n    },\n    set: function set(newPosition) {\n      this._decompose();\n\n      this._localPosition.copyFrom(newPosition);\n\n      this._markAsDirtyAndCompose();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"rotation\", {\n    /** Gets or sets current rotation (in local space) */\n    get: function get() {\n      return this.getRotation();\n    },\n    set: function set(newRotation) {\n      this.setRotation(newRotation);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"rotationQuaternion\", {\n    /** Gets or sets current rotation quaternion (in local space) */\n    get: function get() {\n      this._decompose();\n\n      return this._localRotation;\n    },\n    set: function set(newRotation) {\n      this.setRotationQuaternion(newRotation);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"scaling\", {\n    /** Gets or sets current scaling (in local space) */\n    get: function get() {\n      return this.getScale();\n    },\n    set: function set(newScaling) {\n      this.setScale(newScaling);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"animationPropertiesOverride\", {\n    /**\r\n     * Gets the animation properties override\r\n     */\n    get: function get() {\n      return this._skeleton.animationPropertiesOverride;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  Bone.prototype._decompose = function () {\n    if (!this._needToDecompose) {\n      return;\n    }\n\n    this._needToDecompose = false;\n\n    if (!this._localScaling) {\n      this._localScaling = Vector3.Zero();\n      this._localRotation = Quaternion.Zero();\n      this._localPosition = Vector3.Zero();\n    }\n\n    this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\n  };\n\n  Bone.prototype._compose = function () {\n    if (!this._needToCompose) {\n      return;\n    }\n\n    if (!this._localScaling) {\n      this._needToCompose = false;\n      return;\n    }\n\n    this._needToCompose = false;\n    Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\n  };\n  /**\r\n   * Update the base and local matrices\r\n   * @param matrix defines the new base or local matrix\r\n   * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n   * @param updateLocalMatrix defines if the local matrix should be updated\r\n   */\n\n\n  Bone.prototype.updateMatrix = function (matrix, updateDifferenceMatrix, updateLocalMatrix) {\n    if (updateDifferenceMatrix === void 0) {\n      updateDifferenceMatrix = true;\n    }\n\n    if (updateLocalMatrix === void 0) {\n      updateLocalMatrix = true;\n    }\n\n    this._baseMatrix.copyFrom(matrix);\n\n    if (updateDifferenceMatrix) {\n      this._updateDifferenceMatrix();\n    }\n\n    if (updateLocalMatrix) {\n      this._needToCompose = false; // in case there was a pending compose\n\n      this._localMatrix.copyFrom(matrix);\n\n      this._markAsDirtyAndDecompose();\n    } else {\n      this.markAsDirty();\n    }\n  };\n  /** @hidden */\n\n\n  Bone.prototype._updateDifferenceMatrix = function (rootMatrix, updateChildren) {\n    if (updateChildren === void 0) {\n      updateChildren = true;\n    }\n\n    if (!rootMatrix) {\n      rootMatrix = this._baseMatrix;\n    }\n\n    if (this._parent) {\n      rootMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\n    } else {\n      this._absoluteTransform.copyFrom(rootMatrix);\n    }\n\n    this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\n\n    if (updateChildren) {\n      for (var index = 0; index < this.children.length; index++) {\n        this.children[index]._updateDifferenceMatrix();\n      }\n    }\n\n    this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;\n  };\n  /**\r\n   * Flag the bone as dirty (Forcing it to update everything)\r\n   */\n\n\n  Bone.prototype.markAsDirty = function () {\n    this._currentRenderId++;\n    this._childUpdateId++;\n\n    this._skeleton._markAsDirty();\n  };\n  /** @hidden */\n\n\n  Bone.prototype._markAsDirtyAndCompose = function () {\n    this.markAsDirty();\n    this._needToCompose = true;\n  };\n\n  Bone.prototype._markAsDirtyAndDecompose = function () {\n    this.markAsDirty();\n    this._needToDecompose = true;\n  };\n  /**\r\n   * Translate the bone in local or world space\r\n   * @param vec The amount to translate the bone\r\n   * @param space The space that the translation is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.translate = function (vec, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lm = this.getLocalMatrix();\n\n    if (space == Space.LOCAL) {\n      lm.addAtIndex(12, vec.x);\n      lm.addAtIndex(13, vec.y);\n      lm.addAtIndex(14, vec.z);\n    } else {\n      var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (mesh) {\n        wm = mesh.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._tmpMats[0];\n      var tvec = Bone._tmpVecs[0];\n\n      if (this._parent) {\n        if (mesh && wm) {\n          tmat.copyFrom(this._parent.getAbsoluteTransform());\n          tmat.multiplyToRef(wm, tmat);\n        } else {\n          tmat.copyFrom(this._parent.getAbsoluteTransform());\n        }\n      } else {\n        Matrix.IdentityToRef(tmat);\n      }\n\n      tmat.setTranslationFromFloats(0, 0, 0);\n      tmat.invert();\n      Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\n      lm.addAtIndex(12, tvec.x);\n      lm.addAtIndex(13, tvec.y);\n      lm.addAtIndex(14, tvec.z);\n    }\n\n    this._markAsDirtyAndDecompose();\n  };\n  /**\r\n   * Set the postion of the bone in local or world space\r\n   * @param position The position to set the bone\r\n   * @param space The space that the position is in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   */\n\n\n  Bone.prototype.setPosition = function (position, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lm = this.getLocalMatrix();\n\n    if (space == Space.LOCAL) {\n      lm.setTranslationFromFloats(position.x, position.y, position.z);\n    } else {\n      var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (mesh) {\n        wm = mesh.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._tmpMats[0];\n      var vec = Bone._tmpVecs[0];\n\n      if (this._parent) {\n        if (mesh && wm) {\n          tmat.copyFrom(this._parent.getAbsoluteTransform());\n          tmat.multiplyToRef(wm, tmat);\n        } else {\n          tmat.copyFrom(this._parent.getAbsoluteTransform());\n        }\n\n        tmat.invert();\n      } else {\n        Matrix.IdentityToRef(tmat);\n      }\n\n      Vector3.TransformCoordinatesToRef(position, tmat, vec);\n      lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\n    }\n\n    this._markAsDirtyAndDecompose();\n  };\n  /**\r\n   * Set the absolute position of the bone (world space)\r\n   * @param position The position to set the bone\r\n   * @param mesh The mesh that this bone is attached to\r\n   */\n\n\n  Bone.prototype.setAbsolutePosition = function (position, mesh) {\n    this.setPosition(position, Space.WORLD, mesh);\n  };\n  /**\r\n   * Scale the bone on the x, y and z axes (in local space)\r\n   * @param x The amount to scale the bone on the x axis\r\n   * @param y The amount to scale the bone on the y axis\r\n   * @param z The amount to scale the bone on the z axis\r\n   * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n   */\n\n\n  Bone.prototype.scale = function (x, y, z, scaleChildren) {\n    if (scaleChildren === void 0) {\n      scaleChildren = false;\n    }\n\n    var locMat = this.getLocalMatrix(); // Apply new scaling on top of current local matrix\n\n    var scaleMat = Bone._tmpMats[0];\n    Matrix.ScalingToRef(x, y, z, scaleMat);\n    scaleMat.multiplyToRef(locMat, locMat); // Invert scaling matrix and apply the inverse to all children\n\n    scaleMat.invert();\n\n    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n      var child = _a[_i];\n      var cm = child.getLocalMatrix();\n      cm.multiplyToRef(scaleMat, cm);\n      cm.multiplyAtIndex(12, x);\n      cm.multiplyAtIndex(13, y);\n      cm.multiplyAtIndex(14, z);\n\n      child._markAsDirtyAndDecompose();\n    }\n\n    this._markAsDirtyAndDecompose();\n\n    if (scaleChildren) {\n      for (var _b = 0, _c = this.children; _b < _c.length; _b++) {\n        var child = _c[_b];\n        child.scale(x, y, z, scaleChildren);\n      }\n    }\n  };\n  /**\r\n   * Set the bone scaling in local space\r\n   * @param scale defines the scaling vector\r\n   */\n\n\n  Bone.prototype.setScale = function (scale) {\n    this._decompose();\n\n    this._localScaling.copyFrom(scale);\n\n    this._markAsDirtyAndCompose();\n  };\n  /**\r\n   * Gets the current scaling in local space\r\n   * @returns the current scaling vector\r\n   */\n\n\n  Bone.prototype.getScale = function () {\n    this._decompose();\n\n    return this._localScaling;\n  };\n  /**\r\n   * Gets the current scaling in local space and stores it in a target vector\r\n   * @param result defines the target vector\r\n   */\n\n\n  Bone.prototype.getScaleToRef = function (result) {\n    this._decompose();\n\n    result.copyFrom(this._localScaling);\n  };\n  /**\r\n   * Set the yaw, pitch, and roll of the bone in local or world space\r\n   * @param yaw The rotation of the bone on the y axis\r\n   * @param pitch The rotation of the bone on the x axis\r\n   * @param roll The rotation of the bone on the z axis\r\n   * @param space The space that the axes of rotation are in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   */\n\n\n  Bone.prototype.setYawPitchRoll = function (yaw, pitch, roll, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._tmpQuat;\n      Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\n      this.setRotationQuaternion(quat, space, mesh);\n      return;\n    }\n\n    var rotMatInv = Bone._tmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\n      return;\n    }\n\n    var rotMat = Bone._tmpMats[1];\n    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, mesh);\n  };\n  /**\r\n   * Add a rotation to the bone on an axis in local or world space\r\n   * @param axis The axis to rotate the bone on\r\n   * @param amount The amount to rotate the bone\r\n   * @param space The space that the axis is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.rotate = function (axis, amount, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var rmat = Bone._tmpMats[0];\n    rmat.setTranslationFromFloats(0, 0, 0);\n    Matrix.RotationAxisToRef(axis, amount, rmat);\n\n    this._rotateWithMatrix(rmat, space, mesh);\n  };\n  /**\r\n   * Set the rotation of the bone to a particular axis angle in local or world space\r\n   * @param axis The axis to rotate the bone on\r\n   * @param angle The angle that the bone should be rotated to\r\n   * @param space The space that the axis is in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   */\n\n\n  Bone.prototype.setAxisAngle = function (axis, angle, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._tmpQuat;\n      Quaternion.RotationAxisToRef(axis, angle, quat);\n      this.setRotationQuaternion(quat, space, mesh);\n      return;\n    }\n\n    var rotMatInv = Bone._tmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\n      return;\n    }\n\n    var rotMat = Bone._tmpMats[1];\n    Matrix.RotationAxisToRef(axis, angle, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, mesh);\n  };\n  /**\r\n   * Set the euler rotation of the bone in local or world space\r\n   * @param rotation The euler rotation that the bone should be set to\r\n   * @param space The space that the rotation is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.setRotation = function (rotation, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, mesh);\n  };\n  /**\r\n   * Set the quaternion rotation of the bone in local or world space\r\n   * @param quat The quaternion rotation that the bone should be set to\r\n   * @param space The space that the rotation is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.setRotationQuaternion = function (quat, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      this._decompose();\n\n      this._localRotation.copyFrom(quat);\n\n      this._markAsDirtyAndCompose();\n\n      return;\n    }\n\n    var rotMatInv = Bone._tmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\n      return;\n    }\n\n    var rotMat = Bone._tmpMats[1];\n    Matrix.FromQuaternionToRef(quat, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, mesh);\n  };\n  /**\r\n   * Set the rotation matrix of the bone in local or world space\r\n   * @param rotMat The rotation matrix that the bone should be set to\r\n   * @param space The space that the rotation is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.setRotationMatrix = function (rotMat, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._tmpQuat;\n      Quaternion.FromRotationMatrixToRef(rotMat, quat);\n      this.setRotationQuaternion(quat, space, mesh);\n      return;\n    }\n\n    var rotMatInv = Bone._tmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\n      return;\n    }\n\n    var rotMat2 = Bone._tmpMats[1];\n    rotMat2.copyFrom(rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat2);\n\n    this._rotateWithMatrix(rotMat2, space, mesh);\n  };\n\n  Bone.prototype._rotateWithMatrix = function (rmat, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lmat = this.getLocalMatrix();\n    var lx = lmat.m[12];\n    var ly = lmat.m[13];\n    var lz = lmat.m[14];\n    var parent = this.getParent();\n    var parentScale = Bone._tmpMats[3];\n    var parentScaleInv = Bone._tmpMats[4];\n\n    if (parent && space == Space.WORLD) {\n      if (mesh) {\n        parentScale.copyFrom(mesh.getWorldMatrix());\n        parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\n      } else {\n        parentScale.copyFrom(parent.getAbsoluteTransform());\n      }\n\n      parentScaleInv.copyFrom(parentScale);\n      parentScaleInv.invert();\n      lmat.multiplyToRef(parentScale, lmat);\n      lmat.multiplyToRef(rmat, lmat);\n      lmat.multiplyToRef(parentScaleInv, lmat);\n    } else {\n      if (space == Space.WORLD && mesh) {\n        parentScale.copyFrom(mesh.getWorldMatrix());\n        parentScaleInv.copyFrom(parentScale);\n        parentScaleInv.invert();\n        lmat.multiplyToRef(parentScale, lmat);\n        lmat.multiplyToRef(rmat, lmat);\n        lmat.multiplyToRef(parentScaleInv, lmat);\n      } else {\n        lmat.multiplyToRef(rmat, lmat);\n      }\n    }\n\n    lmat.setTranslationFromFloats(lx, ly, lz);\n    this.computeAbsoluteTransforms();\n\n    this._markAsDirtyAndDecompose();\n  };\n\n  Bone.prototype._getNegativeRotationToRef = function (rotMatInv, mesh) {\n    var scaleMatrix = Bone._tmpMats[2];\n    rotMatInv.copyFrom(this.getAbsoluteTransform());\n\n    if (mesh) {\n      rotMatInv.multiplyToRef(mesh.getWorldMatrix(), rotMatInv);\n      Matrix.ScalingToRef(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z, scaleMatrix);\n    }\n\n    rotMatInv.invert();\n\n    if (isNaN(rotMatInv.m[0])) {\n      // Matrix failed to invert.\n      // This can happen if scale is zero for example.\n      return false;\n    }\n\n    scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\n    rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\n    return true;\n  };\n  /**\r\n   * Get the position of the bone in local or world space\r\n   * @param space The space that the returned position is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   * @returns The position of the bone\r\n   */\n\n\n  Bone.prototype.getPosition = function (space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var pos = Vector3.Zero();\n    this.getPositionToRef(space, mesh, pos);\n    return pos;\n  };\n  /**\r\n   * Copy the position of the bone to a vector3 in local or world space\r\n   * @param space The space that the returned position is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   * @param result The vector3 to copy the position to\r\n   */\n\n\n  Bone.prototype.getPositionToRef = function (space, mesh, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space == Space.LOCAL) {\n      var lm = this.getLocalMatrix();\n      result.x = lm.m[12];\n      result.y = lm.m[13];\n      result.z = lm.m[14];\n    } else {\n      var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (mesh) {\n        wm = mesh.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._tmpMats[0];\n\n      if (mesh && wm) {\n        tmat.copyFrom(this.getAbsoluteTransform());\n        tmat.multiplyToRef(wm, tmat);\n      } else {\n        tmat = this.getAbsoluteTransform();\n      }\n\n      result.x = tmat.m[12];\n      result.y = tmat.m[13];\n      result.z = tmat.m[14];\n    }\n  };\n  /**\r\n   * Get the absolute position of the bone (world space)\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @returns The absolute position of the bone\r\n   */\n\n\n  Bone.prototype.getAbsolutePosition = function (mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var pos = Vector3.Zero();\n    this.getPositionToRef(Space.WORLD, mesh, pos);\n    return pos;\n  };\n  /**\r\n   * Copy the absolute position of the bone (world space) to the result param\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @param result The vector3 to copy the absolute position to\r\n   */\n\n\n  Bone.prototype.getAbsolutePositionToRef = function (mesh, result) {\n    this.getPositionToRef(Space.WORLD, mesh, result);\n  };\n  /**\r\n   * Compute the absolute transforms of this bone and its children\r\n   */\n\n\n  Bone.prototype.computeAbsoluteTransforms = function () {\n    this._compose();\n\n    if (this._parent) {\n      this._localMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\n    } else {\n      this._absoluteTransform.copyFrom(this._localMatrix);\n\n      var poseMatrix = this._skeleton.getPoseMatrix();\n\n      if (poseMatrix) {\n        this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\n      }\n    }\n\n    var children = this.children;\n    var len = children.length;\n\n    for (var i = 0; i < len; i++) {\n      children[i].computeAbsoluteTransforms();\n    }\n  };\n  /**\r\n   * Get the world direction from an axis that is in the local space of the bone\r\n   * @param localAxis The local direction that is used to compute the world direction\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @returns The world direction\r\n   */\n\n\n  Bone.prototype.getDirection = function (localAxis, mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getDirectionToRef(localAxis, mesh, result);\n    return result;\n  };\n  /**\r\n   * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n   * @param localAxis The local direction that is used to compute the world direction\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @param result The vector3 that the world direction will be copied to\r\n   */\n\n\n  Bone.prototype.getDirectionToRef = function (localAxis, mesh, result) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (mesh) {\n      wm = mesh.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var mat = Bone._tmpMats[0];\n    mat.copyFrom(this.getAbsoluteTransform());\n\n    if (mesh && wm) {\n      mat.multiplyToRef(wm, mat);\n    }\n\n    Vector3.TransformNormalToRef(localAxis, mat, result);\n    result.normalize();\n  };\n  /**\r\n   * Get the euler rotation of the bone in local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @returns The euler rotation\r\n   */\n\n\n  Bone.prototype.getRotation = function (space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getRotationToRef(space, mesh, result);\n    return result;\n  };\n  /**\r\n   * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @param result The vector3 that the rotation should be copied to\r\n   */\n\n\n  Bone.prototype.getRotationToRef = function (space, mesh, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var quat = Bone._tmpQuat;\n    this.getRotationQuaternionToRef(space, mesh, quat);\n    quat.toEulerAnglesToRef(result);\n  };\n  /**\r\n   * Get the quaternion rotation of the bone in either local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @returns The quaternion rotation\r\n   */\n\n\n  Bone.prototype.getRotationQuaternion = function (space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Quaternion.Identity();\n    this.getRotationQuaternionToRef(space, mesh, result);\n    return result;\n  };\n  /**\r\n   * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @param result The quaternion that the rotation should be copied to\r\n   */\n\n\n  Bone.prototype.getRotationQuaternionToRef = function (space, mesh, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    if (space == Space.LOCAL) {\n      this._decompose();\n\n      result.copyFrom(this._localRotation);\n    } else {\n      var mat = Bone._tmpMats[0];\n      var amat = this.getAbsoluteTransform();\n\n      if (mesh) {\n        amat.multiplyToRef(mesh.getWorldMatrix(), mat);\n      } else {\n        mat.copyFrom(amat);\n      }\n\n      mat.multiplyAtIndex(0, this._scalingDeterminant);\n      mat.multiplyAtIndex(1, this._scalingDeterminant);\n      mat.multiplyAtIndex(2, this._scalingDeterminant);\n      mat.decompose(undefined, result, undefined);\n    }\n  };\n  /**\r\n   * Get the rotation matrix of the bone in local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @returns The rotation matrix\r\n   */\n\n\n  Bone.prototype.getRotationMatrix = function (space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var result = Matrix.Identity();\n    this.getRotationMatrixToRef(space, mesh, result);\n    return result;\n  };\n  /**\r\n   * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @param result The quaternion that the rotation should be copied to\r\n   */\n\n\n  Bone.prototype.getRotationMatrixToRef = function (space, mesh, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space == Space.LOCAL) {\n      this.getLocalMatrix().getRotationMatrixToRef(result);\n    } else {\n      var mat = Bone._tmpMats[0];\n      var amat = this.getAbsoluteTransform();\n\n      if (mesh) {\n        amat.multiplyToRef(mesh.getWorldMatrix(), mat);\n      } else {\n        mat.copyFrom(amat);\n      }\n\n      mat.multiplyAtIndex(0, this._scalingDeterminant);\n      mat.multiplyAtIndex(1, this._scalingDeterminant);\n      mat.multiplyAtIndex(2, this._scalingDeterminant);\n      mat.getRotationMatrixToRef(result);\n    }\n  };\n  /**\r\n   * Get the world position of a point that is in the local space of the bone\r\n   * @param position The local position\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @returns The world position\r\n   */\n\n\n  Bone.prototype.getAbsolutePositionFromLocal = function (position, mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getAbsolutePositionFromLocalToRef(position, mesh, result);\n    return result;\n  };\n  /**\r\n   * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n   * @param position The local position\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @param result The vector3 that the world position should be copied to\r\n   */\n\n\n  Bone.prototype.getAbsolutePositionFromLocalToRef = function (position, mesh, result) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (mesh) {\n      wm = mesh.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var tmat = Bone._tmpMats[0];\n\n    if (mesh && wm) {\n      tmat.copyFrom(this.getAbsoluteTransform());\n      tmat.multiplyToRef(wm, tmat);\n    } else {\n      tmat = this.getAbsoluteTransform();\n    }\n\n    Vector3.TransformCoordinatesToRef(position, tmat, result);\n  };\n  /**\r\n   * Get the local position of a point that is in world space\r\n   * @param position The world position\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @returns The local position\r\n   */\n\n\n  Bone.prototype.getLocalPositionFromAbsolute = function (position, mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getLocalPositionFromAbsoluteToRef(position, mesh, result);\n    return result;\n  };\n  /**\r\n   * Get the local position of a point that is in world space and copy it to the result param\r\n   * @param position The world position\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @param result The vector3 that the local position should be copied to\r\n   */\n\n\n  Bone.prototype.getLocalPositionFromAbsoluteToRef = function (position, mesh, result) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (mesh) {\n      wm = mesh.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var tmat = Bone._tmpMats[0];\n    tmat.copyFrom(this.getAbsoluteTransform());\n\n    if (mesh && wm) {\n      tmat.multiplyToRef(wm, tmat);\n    }\n\n    tmat.invert();\n    Vector3.TransformCoordinatesToRef(position, tmat, result);\n  };\n  /**\r\n   * Set the current local matrix as the restPose for this bone.\r\n   */\n\n\n  Bone.prototype.setCurrentPoseAsRest = function () {\n    this.setRestPose(this.getLocalMatrix());\n  };\n\n  Bone._tmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);\n  Bone._tmpQuat = Quaternion.Identity();\n  Bone._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n  return Bone;\n}(Node);\n\nexport { Bone };","map":null,"metadata":{},"sourceType":"module"}