{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { Logger } from \"../Misc/logger\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\nimport { BoxBuilder } from \"../Meshes/Builders/boxBuilder\";\nimport { LinesBuilder } from \"../Meshes/Builders/linesBuilder\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { PivotTools } from \"../Misc/pivotTools\";\nimport { Color3 } from '../Maths/math.color';\nimport \"../Meshes/Builders/boxBuilder\";\nimport { Epsilon } from '../Maths/math.constants';\n/**\r\n * Bounding box gizmo\r\n */\n\nvar BoundingBoxGizmo =\n/** @class */\nfunction (_super) {\n  __extends(BoundingBoxGizmo, _super);\n  /**\r\n   * Creates an BoundingBoxGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param color The color of the gizmo\r\n   */\n\n\n  function BoundingBoxGizmo(color, gizmoLayer) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._boundingDimensions = new Vector3(1, 1, 1);\n    _this._renderObserver = null;\n    _this._pointerObserver = null;\n    _this._scaleDragSpeed = 0.2;\n    _this._tmpQuaternion = new Quaternion();\n    _this._tmpVector = new Vector3(0, 0, 0);\n    _this._tmpRotationMatrix = new Matrix();\n    /**\r\n     * If child meshes should be ignored when calculating the boudning box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\r\n     */\n\n    _this.ignoreChildren = false;\n    /**\r\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\r\n     */\n\n    _this.includeChildPredicate = null;\n    /**\r\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\r\n     */\n\n    _this.rotationSphereSize = 0.1;\n    /**\r\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\r\n     */\n\n    _this.scaleBoxSize = 0.1;\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\n\n    _this.fixedDragMeshScreenSize = false;\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\n\n    _this.fixedDragMeshBoundsSize = false;\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\r\n     */\n\n    _this.fixedDragMeshScreenSizeDistanceFactor = 10;\n    /**\r\n     * Fired when a rotation sphere or scale box is dragged\r\n     */\n\n    _this.onDragStartObservable = new Observable();\n    /**\r\n     * Fired when a scale box is dragged\r\n     */\n\n    _this.onScaleBoxDragObservable = new Observable();\n    /**\r\n      * Fired when a scale box drag is ended\r\n     */\n\n    _this.onScaleBoxDragEndObservable = new Observable();\n    /**\r\n     * Fired when a rotation sphere is dragged\r\n     */\n\n    _this.onRotationSphereDragObservable = new Observable();\n    /**\r\n     * Fired when a rotation sphere drag is ended\r\n     */\n\n    _this.onRotationSphereDragEndObservable = new Observable();\n    /**\r\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\r\n     */\n\n    _this.scalePivot = null;\n    _this._existingMeshScale = new Vector3(); // Dragging\n\n    _this._dragMesh = null;\n    _this.pointerDragBehavior = new PointerDragBehavior(); // Do not update the gizmo's scale so it has a fixed size to the object its attached to\n\n    _this.updateScale = false;\n    _this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene); // Create Materials\n\n    _this.coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this.coloredMaterial.disableLighting = true;\n    _this.hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this.hoverColoredMaterial.disableLighting = true; // Build bounding box out of lines\n\n    _this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._lineBoundingBox.rotationQuaternion = new Quaternion();\n    var lines = [];\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(_this._boundingDimensions.x, 0, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.forEach(function (l) {\n      l.color = color;\n      l.position.addInPlace(new Vector3(-_this._boundingDimensions.x / 2, -_this._boundingDimensions.y / 2, -_this._boundingDimensions.z / 2));\n      l.isPickable = false;\n\n      _this._lineBoundingBox.addChild(l);\n    });\n\n    _this._rootMesh.addChild(_this._lineBoundingBox);\n\n    _this.setColor(color); // Create rotation spheres\n\n\n    _this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._rotateSpheresParent.rotationQuaternion = new Quaternion();\n\n    var _loop_1 = function _loop_1(i_1) {\n      var sphere = SphereBuilder.CreateSphere(\"\", {\n        diameter: 1\n      }, gizmoLayer.utilityLayerScene);\n      sphere.rotationQuaternion = new Quaternion();\n      sphere.material = this_1.coloredMaterial; // Drag behavior\n\n      _dragBehavior = new PointerDragBehavior({});\n      _dragBehavior.moveAttached = false;\n      _dragBehavior.updateDragPlane = false;\n      sphere.addBehavior(_dragBehavior);\n      var startingTurnDirection = new Vector3(1, 0, 0);\n      var totalTurnAmountOfDrag = 0;\n\n      _dragBehavior.onDragStartObservable.add(function () {\n        startingTurnDirection.copyFrom(sphere.forward);\n        totalTurnAmountOfDrag = 0;\n      });\n\n      _dragBehavior.onDragObservable.add(function (event) {\n        _this.onRotationSphereDragObservable.notifyObservers({});\n\n        if (_this.attachedMesh) {\n          var originalParent = _this.attachedMesh.parent;\n\n          if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n            Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n            return;\n          }\n\n          PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);\n\n          var worldDragDirection = startingTurnDirection; // Project the world right on to the drag plane\n\n          var toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\n          var dragAxis = worldDragDirection.subtract(toSub).normalizeToNew(); // project drag delta on to the resulting drag axis and rotate based on that\n\n          var projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length()); // Make rotation relative to size of mesh.\n\n          projectDist = projectDist / _this._boundingDimensions.length() * _this._anchorMesh.scaling.length(); // Rotate based on axis\n\n          if (!_this.attachedMesh.rotationQuaternion) {\n            _this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.attachedMesh.rotation.y, _this.attachedMesh.rotation.x, _this.attachedMesh.rotation.z);\n          }\n\n          if (!_this._anchorMesh.rotationQuaternion) {\n            _this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._anchorMesh.rotation.y, _this._anchorMesh.rotation.x, _this._anchorMesh.rotation.z);\n          } // Do not allow the object to turn more than a full circle\n\n\n          totalTurnAmountOfDrag += projectDist;\n\n          if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\n            if (i_1 >= 8) {\n              Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, _this._tmpQuaternion);\n            } else if (i_1 >= 4) {\n              Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, _this._tmpQuaternion);\n            } else {\n              Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, _this._tmpQuaternion);\n            } // Rotate around center of bounding box\n\n\n            _this._anchorMesh.addChild(_this.attachedMesh);\n\n            _this._anchorMesh.rotationQuaternion.multiplyToRef(_this._tmpQuaternion, _this._anchorMesh.rotationQuaternion);\n\n            _this._anchorMesh.removeChild(_this.attachedMesh);\n\n            _this.attachedMesh.setParent(originalParent);\n          }\n\n          _this.updateBoundingBox();\n\n          PivotTools._RestorePivotPoint(_this.attachedMesh);\n        }\n\n        _this._updateDummy();\n      }); // Selection/deselection\n\n\n      _dragBehavior.onDragStartObservable.add(function () {\n        _this.onDragStartObservable.notifyObservers({});\n\n        _this._selectNode(sphere);\n      });\n\n      _dragBehavior.onDragEndObservable.add(function () {\n        _this.onRotationSphereDragEndObservable.notifyObservers({});\n\n        _this._selectNode(null);\n\n        _this._updateDummy();\n      });\n\n      this_1._rotateSpheresParent.addChild(sphere);\n    };\n\n    var this_1 = this,\n        _dragBehavior;\n\n    for (var i_1 = 0; i_1 < 12; i_1++) {\n      _loop_1(i_1);\n    }\n\n    _this._rootMesh.addChild(_this._rotateSpheresParent); // Create scale cubes\n\n\n    _this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._scaleBoxesParent.rotationQuaternion = new Quaternion();\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        var _loop_2 = function _loop_2() {\n          // create box for relevant axis\n          var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            return \"continue\";\n          }\n\n          var box = BoxBuilder.CreateBox(\"\", {\n            size: 1\n          }, gizmoLayer.utilityLayerScene);\n          box.material = this_2.coloredMaterial;\n          box.metadata = zeroAxisCount === 2; // None homogenous scale handle\n          // Dragging logic\n\n          var dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\n          _dragBehavior = new PointerDragBehavior({\n            dragAxis: dragAxis\n          });\n          _dragBehavior.updateDragPlane = false;\n          _dragBehavior.moveAttached = false;\n          box.addBehavior(_dragBehavior);\n\n          _dragBehavior.onDragObservable.add(function (event) {\n            _this.onScaleBoxDragObservable.notifyObservers({});\n\n            if (_this.attachedMesh) {\n              var originalParent = _this.attachedMesh.parent;\n\n              if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n                return;\n              }\n\n              PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);\n\n              var relativeDragDistance = event.dragDistance / _this._boundingDimensions.length() * _this._anchorMesh.scaling.length();\n\n              var deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\n\n              if (zeroAxisCount === 2) {\n                // scale on 1 axis when using the anchor box in the face middle\n                deltaScale.x *= Math.abs(dragAxis.x);\n                deltaScale.y *= Math.abs(dragAxis.y);\n                deltaScale.z *= Math.abs(dragAxis.z);\n              }\n\n              deltaScale.scaleInPlace(_this._scaleDragSpeed);\n\n              _this.updateBoundingBox();\n\n              if (_this.scalePivot) {\n                _this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(_this._tmpRotationMatrix); // Move anchor to desired pivot point (Bottom left corner + dimension/2)\n\n\n                _this._boundingDimensions.scaleToRef(0.5, _this._tmpVector);\n\n                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);\n\n                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);\n\n                _this._boundingDimensions.multiplyToRef(_this.scalePivot, _this._tmpVector);\n\n                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);\n\n                _this._anchorMesh.position.addInPlace(_this._tmpVector);\n              } else {\n                // Scale from the position of the opposite corner\n                box.absolutePosition.subtractToRef(_this._anchorMesh.position, _this._tmpVector);\n\n                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);\n              }\n\n              _this._anchorMesh.addChild(_this.attachedMesh);\n\n              _this._anchorMesh.scaling.addInPlace(deltaScale);\n\n              if (_this._anchorMesh.scaling.x < 0 || _this._anchorMesh.scaling.y < 0 || _this._anchorMesh.scaling.z < 0) {\n                _this._anchorMesh.scaling.subtractInPlace(deltaScale);\n              }\n\n              _this._anchorMesh.removeChild(_this.attachedMesh);\n\n              _this.attachedMesh.setParent(originalParent);\n\n              PivotTools._RestorePivotPoint(_this.attachedMesh);\n            }\n\n            _this._updateDummy();\n          }); // Selection/deselection\n\n\n          _dragBehavior.onDragStartObservable.add(function () {\n            _this.onDragStartObservable.notifyObservers({});\n\n            _this._selectNode(box);\n          });\n\n          _dragBehavior.onDragEndObservable.add(function () {\n            _this.onScaleBoxDragEndObservable.notifyObservers({});\n\n            _this._selectNode(null);\n\n            _this._updateDummy();\n          });\n\n          this_2._scaleBoxesParent.addChild(box);\n        };\n\n        var this_2 = this,\n            _dragBehavior;\n\n        for (var k = 0; k < 3; k++) {\n          _loop_2();\n        }\n      }\n    }\n\n    _this._rootMesh.addChild(_this._scaleBoxesParent); // Hover color change\n\n\n    var pointerIds = new Array();\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      if (!pointerIds[pointerInfo.event.pointerId]) {\n        _this._rotateSpheresParent.getChildMeshes().concat(_this._scaleBoxesParent.getChildMeshes()).forEach(function (mesh) {\n          if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\n            pointerIds[pointerInfo.event.pointerId] = mesh;\n            mesh.material = _this.hoverColoredMaterial;\n          }\n        });\n      } else {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {\n          pointerIds[pointerInfo.event.pointerId].material = _this.coloredMaterial;\n          delete pointerIds[pointerInfo.event.pointerId];\n        }\n      }\n    }); // Update bounding box positions\n\n    _this._renderObserver = _this.gizmoLayer.originalScene.onBeforeRenderObservable.add(function () {\n      // Only update the bouding box if scaling has changed\n      if (_this.attachedMesh && !_this._existingMeshScale.equals(_this.attachedMesh.scaling)) {\n        _this.updateBoundingBox();\n      } else if (_this.fixedDragMeshScreenSize || _this.fixedDragMeshBoundsSize) {\n        _this._updateRotationSpheres();\n\n        _this._updateScaleBoxes();\n      } // If dragg mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\n\n\n      if (_this._dragMesh && _this.attachedMesh && _this.pointerDragBehavior.dragging) {\n        _this._lineBoundingBox.position.rotateByQuaternionToRef(_this._rootMesh.rotationQuaternion, _this._tmpVector);\n\n        _this.attachedMesh.setAbsolutePosition(_this._dragMesh.position.add(_this._tmpVector.scale(-1)));\n      }\n    });\n\n    _this.updateBoundingBox();\n\n    return _this;\n  }\n  /**\r\n   * Sets the color of the bounding box gizmo\r\n   * @param color the color to set\r\n   */\n\n\n  BoundingBoxGizmo.prototype.setColor = function (color) {\n    this.coloredMaterial.emissiveColor = color;\n    this.hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\n\n    this._lineBoundingBox.getChildren().forEach(function (l) {\n      if (l.color) {\n        l.color = color;\n      }\n    });\n  };\n\n  BoundingBoxGizmo.prototype._attachedNodeChanged = function (value) {\n    var _this = this;\n\n    if (value) {\n      // Reset anchor mesh to match attached mesh's scale\n      // This is needed to avoid invalid box/sphere position on first drag\n      PivotTools._RemoveAndStorePivotPoint(value);\n\n      var originalParent = value.parent;\n\n      this._anchorMesh.addChild(value);\n\n      this._anchorMesh.removeChild(value);\n\n      value.setParent(originalParent);\n\n      PivotTools._RestorePivotPoint(value);\n\n      this.updateBoundingBox();\n      value.getChildMeshes(false).forEach(function (m) {\n        m.markAsDirty(\"scaling\");\n      });\n      this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(function () {\n        _this._updateDummy();\n      });\n    }\n  };\n\n  BoundingBoxGizmo.prototype._selectNode = function (selectedMesh) {\n    this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(function (m) {\n      m.isVisible = !selectedMesh || m == selectedMesh;\n    });\n  };\n  /**\r\n   * Updates the bounding box information for the Gizmo\r\n   */\n\n\n  BoundingBoxGizmo.prototype.updateBoundingBox = function () {\n    if (this.attachedMesh) {\n      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh); // Store original parent\n\n\n      var originalParent = this.attachedMesh.parent;\n      this.attachedMesh.setParent(null); // Store original skelton override mesh\n\n      var originalSkeletonOverrideMesh = null;\n\n      if (this.attachedMesh.skeleton) {\n        originalSkeletonOverrideMesh = this.attachedMesh.skeleton.overrideMesh;\n        this.attachedMesh.skeleton.overrideMesh = null;\n      }\n\n      this._update(); // Rotate based on axis\n\n\n      if (!this.attachedMesh.rotationQuaternion) {\n        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n      }\n\n      if (!this._anchorMesh.rotationQuaternion) {\n        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n      }\n\n      this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion); // Store original position and reset mesh to origin before computing the bounding box\n\n\n      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n\n      this._tmpVector.copyFrom(this.attachedMesh.position);\n\n      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\n      this.attachedMesh.position.set(0, 0, 0); // Update bounding dimensions/positions\n\n      var boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\n      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions); // Update gizmo to match bounding box scaling and rotation\n      // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\n      // The position of the gizmo is then set to the attachedMesh in gizmo._update\n\n      this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\n\n      this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n\n      this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\n\n      this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\n\n      this._lineBoundingBox.computeWorldMatrix();\n\n      this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition); // Restore position/rotation values\n\n\n      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\n      this.attachedMesh.position.copyFrom(this._tmpVector); // Restore original parent\n\n      this.attachedMesh.setParent(originalParent); // Restore original skeleton override mesh\n\n      if (this.attachedMesh.skeleton) {\n        this.attachedMesh.skeleton.overrideMesh = originalSkeletonOverrideMesh;\n      }\n    }\n\n    this._updateRotationSpheres();\n\n    this._updateScaleBoxes();\n\n    if (this.attachedMesh) {\n      this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\n\n      PivotTools._RestorePivotPoint(this.attachedMesh);\n    }\n  };\n\n  BoundingBoxGizmo.prototype._updateRotationSpheres = function () {\n    var rotateSpheres = this._rotateSpheresParent.getChildMeshes();\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 2; j++) {\n        for (var k = 0; k < 2; k++) {\n          var index = i * 4 + j * 2 + k;\n\n          if (i == 0) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (i == 1) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (i == 2) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n            rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n            var distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n            rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n          } else if (this.fixedDragMeshBoundsSize) {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);\n          } else {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\n          }\n        }\n      }\n    }\n  };\n\n  BoundingBoxGizmo.prototype._updateScaleBoxes = function () {\n    var scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n\n    var index = 0;\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        for (var k = 0; k < 3; k++) {\n          var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n\n          if (scaleBoxes[index]) {\n            scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\n            scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n\n            if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n              scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n              var distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n              scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n            } else if (this.fixedDragMeshBoundsSize) {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);\n            } else {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\n            }\n          }\n\n          index++;\n        }\n      }\n    }\n  };\n  /**\r\n   * Enables rotation on the specified axis and disables rotation on the others\r\n   * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\r\n   */\n\n\n  BoundingBoxGizmo.prototype.setEnabledRotationAxis = function (axis) {\n    this._rotateSpheresParent.getChildMeshes().forEach(function (m, i) {\n      if (i < 4) {\n        m.setEnabled(axis.indexOf(\"x\") != -1);\n      } else if (i < 8) {\n        m.setEnabled(axis.indexOf(\"y\") != -1);\n      } else {\n        m.setEnabled(axis.indexOf(\"z\") != -1);\n      }\n    });\n  };\n  /**\r\n   * Enables/disables scaling\r\n   * @param enable if scaling should be enabled\r\n   * @param homogeneousScaling defines if scaling should only be homogeneous\r\n   */\n\n\n  BoundingBoxGizmo.prototype.setEnabledScaling = function (enable, homogeneousScaling) {\n    if (homogeneousScaling === void 0) {\n      homogeneousScaling = false;\n    }\n\n    this._scaleBoxesParent.getChildMeshes().forEach(function (m, i) {\n      var enableMesh = enable; // Disable heterogenous scale handles if requested.\n\n      if (homogeneousScaling && m.metadata === true) {\n        enableMesh = false;\n      }\n\n      m.setEnabled(enableMesh);\n    });\n  };\n\n  BoundingBoxGizmo.prototype._updateDummy = function () {\n    if (this._dragMesh) {\n      this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\n\n      this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\n\n      this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);\n    }\n  };\n  /**\r\n   * Enables a pointer drag behavior on the bounding box of the gizmo\r\n   */\n\n\n  BoundingBoxGizmo.prototype.enableDragBehavior = function () {\n    this._dragMesh = Mesh.CreateBox(\"dummy\", 1, this.gizmoLayer.utilityLayerScene);\n    this._dragMesh.visibility = 0;\n    this._dragMesh.rotationQuaternion = new Quaternion();\n    this.pointerDragBehavior.useObjectOrientationForDragging = false;\n\n    this._dragMesh.addBehavior(this.pointerDragBehavior);\n  };\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n\n  BoundingBoxGizmo.prototype.dispose = function () {\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\n\n    this._lineBoundingBox.dispose();\n\n    this._rotateSpheresParent.dispose();\n\n    this._scaleBoxesParent.dispose();\n\n    if (this._dragMesh) {\n      this._dragMesh.dispose();\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\r\n   * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\r\n   * @returns the bounding box mesh with the passed in mesh as a child\r\n   */\n\n\n  BoundingBoxGizmo.MakeNotPickableAndWrapInBoundingBox = function (mesh) {\n    var makeNotPickable = function makeNotPickable(root) {\n      root.isPickable = false;\n      root.getChildMeshes().forEach(function (c) {\n        makeNotPickable(c);\n      });\n    };\n\n    makeNotPickable(mesh); // Reset position to get boudning box from origin with no rotation\n\n    if (!mesh.rotationQuaternion) {\n      mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\n    }\n\n    var oldPos = mesh.position.clone();\n    var oldRot = mesh.rotationQuaternion.clone();\n    mesh.rotationQuaternion.set(0, 0, 0, 1);\n    mesh.position.set(0, 0, 0); // Update bounding dimensions/positions\n\n    var box = BoxBuilder.CreateBox(\"box\", {\n      size: 1\n    }, mesh.getScene());\n    var boundingMinMax = mesh.getHierarchyBoundingVectors();\n    boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling); // Adjust scale to avoid undefined behavior when adding child\n\n    if (box.scaling.y === 0) {\n      box.scaling.y = Epsilon;\n    }\n\n    if (box.scaling.x === 0) {\n      box.scaling.x = Epsilon;\n    }\n\n    if (box.scaling.z === 0) {\n      box.scaling.z = Epsilon;\n    }\n\n    box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2); // Restore original positions\n\n    mesh.addChild(box);\n    mesh.rotationQuaternion.copyFrom(oldRot);\n    mesh.position.copyFrom(oldPos); // Reverse parenting\n\n    mesh.removeChild(box);\n    box.addChild(mesh);\n    box.visibility = 0;\n    return box;\n  };\n  /**\r\n   * CustomMeshes are not supported by this gizmo\r\n   * @param mesh The mesh to replace the default mesh of the gizmo\r\n   */\n\n\n  BoundingBoxGizmo.prototype.setCustomMesh = function (mesh) {\n    Logger.Error(\"Custom meshes are not supported on this gizmo\");\n  };\n\n  return BoundingBoxGizmo;\n}(Gizmo);\n\nexport { BoundingBoxGizmo };","map":null,"metadata":{},"sourceType":"module"}