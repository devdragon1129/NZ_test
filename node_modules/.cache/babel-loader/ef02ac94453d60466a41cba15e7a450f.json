{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { SerializationHelper, serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\nimport { Color3 } from '../../Maths/math.color';\nimport { MaterialFlags } from \"../materialFlags\";\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\nimport { Scalar } from \"../../Maths/math.scalar\";\n/**\r\n * Define the code related to the sub surface parameters of the pbr material.\r\n */\n\nvar PBRSubSurfaceConfiguration =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new istance of sub surface configuration.\r\n   * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n   * @param markScenePrePassDirty Callback to flag the scene as prepass dirty\r\n   * @param scene The scene\r\n   */\n  function PBRSubSurfaceConfiguration(markAllSubMeshesAsTexturesDirty, markScenePrePassDirty, scene) {\n    this._isRefractionEnabled = false;\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\n\n    this.isRefractionEnabled = false;\n    this._isTranslucencyEnabled = false;\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\n\n    this.isTranslucencyEnabled = false;\n    this._isScatteringEnabled = false;\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\n\n    this.isScatteringEnabled = false;\n    this._scatteringDiffusionProfileIndex = 0;\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitionning between diffuse and refraction.\r\n     */\n\n    this.refractionIntensity = 1;\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is addded to the diffuse part of the material.\r\n     */\n\n    this.translucencyIntensity = 1;\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\n\n    this.useAlbedoToTintRefraction = false;\n    this._thicknessTexture = null;\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\n\n    this.thicknessTexture = null;\n    this._refractionTexture = null;\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\n\n    this.refractionTexture = null;\n    this._indexOfRefraction = 1.5;\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\n\n    this.indexOfRefraction = 1.5;\n    this._volumeIndexOfRefraction = -1.0;\n    this._invertRefractionY = false;\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\n\n    this.invertRefractionY = false;\n    this._linkRefractionWithTransparency = false;\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting aginst not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\n\n    this.linkRefractionWithTransparency = false;\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\n\n    this.minimumThickness = 0;\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\n\n    this.maximumThickness = 1;\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\n\n    this.tintColor = Color3.White();\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\n\n    this.tintColorAtDistance = 1;\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\n\n    this.diffusionDistance = Color3.White();\n    this._useMaskFromThicknessTexture = false;\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * * the green channel is the translucency intensity.\r\n     * * the blue channel is the scattering intensity.\r\n     * * the alpha channel is the refraction intensity.\r\n     */\n\n    this.useMaskFromThicknessTexture = false;\n    this._useMaskFromThicknessTextureGltf = false;\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture. This variation\r\n     * matches the channel-packing that is used by glTF.\r\n     * * the red channel is the transmission/translucency intensity.\r\n     * * the green channel is the thickness.\r\n     */\n\n    this.useMaskFromThicknessTextureGltf = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\n    this._internalMarkScenePrePassDirty = markScenePrePassDirty;\n    this._scene = scene;\n  }\n\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"scatteringDiffusionProfile\", {\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\n    get: function get() {\n      if (!this._scene.subSurfaceConfiguration) {\n        return null;\n      }\n\n      return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\n    },\n    set: function set(c) {\n      if (!this._scene.enableSubSurfaceForPrePass()) {\n        // Not supported\n        return;\n      } // addDiffusionProfile automatically checks for doubles\n\n\n      if (c) {\n        this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", {\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\n    get: function get() {\n      if (this._volumeIndexOfRefraction >= 1.0) {\n        return this._volumeIndexOfRefraction;\n      }\n\n      return this._indexOfRefraction;\n    },\n    set: function set(value) {\n      if (value >= 1.0) {\n        this._volumeIndexOfRefraction = value;\n      } else {\n        this._volumeIndexOfRefraction = -1.0;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  PBRSubSurfaceConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n  /** @hidden */\n\n\n  PBRSubSurfaceConfiguration.prototype._markScenePrePassDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n\n    this._internalMarkScenePrePassDirty();\n  };\n  /**\r\n   * Gets wehter the submesh is ready to be used or not.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - boolean indicating that the submesh is ready or not.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n          if (!this._thicknessTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        var refractionTexture = this._getRefractionTexture(scene);\n\n        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n          if (!refractionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene to the material belongs to.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.prepareDefines = function (defines, scene) {\n    if (defines._areTexturesDirty) {\n      defines.SUBSURFACE = false;\n      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\n      defines.SS_SCATTERING = this._isScatteringEnabled;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n\n      if (this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled) {\n        defines.SUBSURFACE = true;\n\n        if (defines._areTexturesDirty) {\n          if (scene.texturesEnabled) {\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n              MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\n            }\n          }\n        }\n\n        defines.SS_MASK_FROM_THICKNESS_TEXTURE = this._useMaskFromThicknessTexture;\n        defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = this._useMaskFromThicknessTextureGltf;\n      }\n\n      if (this._isRefractionEnabled) {\n        if (scene.texturesEnabled) {\n          var refractionTexture = this._getRefractionTexture(scene);\n\n          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n            defines.SS_REFRACTION = true;\n            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\n            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\n            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\n            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\n            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\n            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Binds the material data.\r\n   * @param uniformBuffer defines the Uniform buffer to fill in.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @param engine defines the engine the material belongs to.\r\n   * @param isFrozen defines whether the material is frozen or not.\r\n   * @param lodBasedMicrosurface defines whether the material relies on lod based microsurface or not.\r\n   * @param realTimeFiltering defines whether the textures should be filtered on the fly.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, engine, isFrozen, lodBasedMicrosurface, realTimeFiltering) {\n    var refractionTexture = this._getRefractionTexture(scene);\n\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\n        MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\n      }\n\n      uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness, this.maximumThickness - this.minimumThickness);\n\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\n        var depth = 1.0;\n\n        if (!refractionTexture.isCube) {\n          if (refractionTexture.depth) {\n            depth = refractionTexture.depth;\n          }\n        }\n\n        var width = refractionTexture.getSize().width;\n        var refractionIor = this.volumeIndexOfRefraction;\n        uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\n        uniformBuffer.updateFloat3(\"vRefractionMicrosurfaceInfos\", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset);\n\n        if (realTimeFiltering) {\n          uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\n        }\n      }\n\n      if (this.isScatteringEnabled) {\n        uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\n      }\n\n      uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\n      uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, this.tintColorAtDistance);\n      uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\n      }\n\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        if (lodBasedMicrosurface) {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\n        } else {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\n        }\n      }\n    }\n  };\n  /**\r\n   * Unbinds the material from the mesh.\r\n   * @param activeEffect defines the effect that should be unbound from.\r\n   * @returns true if unbound, otherwise false\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.unbind = function (activeEffect) {\n    if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      activeEffect.setTexture(\"refractionSampler\", null);\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns the texture used for refraction or null if none is used.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n   * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype._getRefractionTexture = function (scene) {\n    if (this._refractionTexture) {\n      return this._refractionTexture;\n    }\n\n    if (this._isRefractionEnabled) {\n      return scene.environmentTexture;\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"disableAlphaBlending\", {\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\n    get: function get() {\n      return this.isRefractionEnabled && this._linkRefractionWithTransparency;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Fills the list of render target textures.\r\n   * @param renderTargets the list of render targets to update\r\n   */\n\n  PBRSubSurfaceConfiguration.prototype.fillRenderTargetTextures = function (renderTargets) {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      renderTargets.push(this._refractionTexture);\n    }\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param texture - Base texture to use.\r\n   * @returns - Boolean specifying if a texture is used in the material.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.hasTexture = function (texture) {\n    if (this._thicknessTexture === texture) {\n      return true;\n    }\n\n    if (this._refractionTexture === texture) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Gets a boolean indicating that current material needs to register RTT\r\n   * @returns true if this uses a render target otherwise false.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.hasRenderTargetTextures = function () {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns an array of the actively used textures.\r\n   * @param activeTextures Array of BaseTextures\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._thicknessTexture) {\n      activeTextures.push(this._thicknessTexture);\n    }\n\n    if (this._refractionTexture) {\n      activeTextures.push(this._refractionTexture);\n    }\n  };\n  /**\r\n   * Returns the animatable textures.\r\n   * @param animatables Array of animatable textures.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\n      animatables.push(this._thicknessTexture);\n    }\n\n    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n      animatables.push(this._refractionTexture);\n    }\n  };\n  /**\r\n   * Disposes the resources of the material.\r\n   * @param forceDisposeTextures - Forces the disposal of all textures.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._thicknessTexture) {\n        this._thicknessTexture.dispose();\n      }\n\n      if (this._refractionTexture) {\n        this._refractionTexture.dispose();\n      }\n    }\n  };\n  /**\r\n  * Get the current class name of the texture useful for serialization or dynamic coding.\r\n  * @returns \"PBRSubSurfaceConfiguration\"\r\n  */\n\n\n  PBRSubSurfaceConfiguration.prototype.getClassName = function () {\n    return \"PBRSubSurfaceConfiguration\";\n  };\n  /**\r\n   * Add fallbacks to the effect fallbacks list.\r\n   * @param defines defines the Base texture to use.\r\n   * @param fallbacks defines the current fallback list.\r\n   * @param currentRank defines the current fallback rank.\r\n   * @returns the new fallback rank.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.AddFallbacks = function (defines, fallbacks, currentRank) {\n    if (defines.SS_SCATTERING) {\n      fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\n    }\n\n    if (defines.SS_TRANSLUCENCY) {\n      fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\n    }\n\n    return currentRank;\n  };\n  /**\r\n   * Add the required uniforms to the current list.\r\n   * @param uniforms defines the current uniform list.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.AddUniforms = function (uniforms) {\n    uniforms.push(\"vDiffusionDistance\", \"vTintColor\", \"vSubSurfaceIntensity\", \"vRefractionMicrosurfaceInfos\", \"vRefractionFilteringInfo\", \"vRefractionInfos\", \"vThicknessInfos\", \"vThicknessParam\", \"refractionMatrix\", \"thicknessMatrix\", \"scatteringDiffusionProfile\");\n  };\n  /**\r\n   * Add the required samplers to the current list.\r\n   * @param samplers defines the current sampler list.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.AddSamplers = function (samplers) {\n    samplers.push(\"thicknessSampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\n  };\n  /**\r\n   * Add the required uniforms to the current buffer.\r\n   * @param uniformBuffer defines the current uniform buffer.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\n    uniformBuffer.addUniform(\"vRefractionMicrosurfaceInfos\", 3);\n    uniformBuffer.addUniform(\"vRefractionFilteringInfo\", 2);\n    uniformBuffer.addUniform(\"vRefractionInfos\", 4);\n    uniformBuffer.addUniform(\"refractionMatrix\", 16);\n    uniformBuffer.addUniform(\"vThicknessInfos\", 2);\n    uniformBuffer.addUniform(\"thicknessMatrix\", 16);\n    uniformBuffer.addUniform(\"vThicknessParam\", 2);\n    uniformBuffer.addUniform(\"vDiffusionDistance\", 3);\n    uniformBuffer.addUniform(\"vTintColor\", 4);\n    uniformBuffer.addUniform(\"vSubSurfaceIntensity\", 3);\n    uniformBuffer.addUniform(\"scatteringDiffusionProfile\", 1);\n  };\n  /**\r\n   * Makes a duplicate of the current configuration into another one.\r\n   * @param configuration define the config where to copy the info\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.copyTo = function (configuration) {\n    SerializationHelper.Clone(function () {\n      return configuration;\n    }, this);\n  };\n  /**\r\n   * Serializes this Sub Surface configuration.\r\n   * @returns - An object with the serialized config.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Parses a anisotropy Configuration from a serialized object.\r\n   * @param source - Serialized object.\r\n   * @param scene Defines the scene we are parsing for\r\n   * @param rootUrl Defines the rootUrl to load from\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.parse = function (source, scene, rootUrl) {\n    var _this = this;\n\n    SerializationHelper.Parse(function () {\n      return _this;\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isRefractionEnabled\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isTranslucencyEnabled\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markScenePrePassDirty\")], PBRSubSurfaceConfiguration.prototype, \"isScatteringEnabled\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_scatteringDiffusionProfileIndex\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"refractionIntensity\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensity\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintRefraction\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"thicknessTexture\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"indexOfRefraction\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_volumeIndexOfRefraction\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", null);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"invertRefractionY\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"linkRefractionWithTransparency\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"minimumThickness\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"maximumThickness\", void 0);\n\n  __decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"tintColor\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"tintColorAtDistance\", void 0);\n\n  __decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"diffusionDistance\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTextureGltf\", void 0);\n\n  return PBRSubSurfaceConfiguration;\n}();\n\nexport { PBRSubSurfaceConfiguration };","map":null,"metadata":{},"sourceType":"module"}