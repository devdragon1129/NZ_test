{"ast":null,"code":"import { Scalar } from './math.scalar';\nimport { ToLinearSpace, ToGammaSpace } from './math.constants';\nimport { ArrayTools } from '../Misc/arrayTools';\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * Class used to hold a RBG color\r\n */\n\nvar Color3 =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Color3 object from red, green, blue values, all between 0 and 1\r\n   * @param r defines the red component (between 0 and 1, default is 0)\r\n   * @param g defines the green component (between 0 and 1, default is 0)\r\n   * @param b defines the blue component (between 0 and 1, default is 0)\r\n   */\n  function Color3(\n  /**\r\n   * Defines the red component (between 0 and 1, default is 0)\r\n   */\n  r,\n  /**\r\n   * Defines the green component (between 0 and 1, default is 0)\r\n   */\n  g,\n  /**\r\n   * Defines the blue component (between 0 and 1, default is 0)\r\n   */\n  b) {\n    if (r === void 0) {\n      r = 0;\n    }\n\n    if (g === void 0) {\n      g = 0;\n    }\n\n    if (b === void 0) {\n      b = 0;\n    }\n\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n  /**\r\n   * Creates a string with the Color3 current values\r\n   * @returns the string representation of the Color3 object\r\n   */\n\n\n  Color3.prototype.toString = function () {\n    return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n  };\n  /**\r\n   * Returns the string \"Color3\"\r\n   * @returns \"Color3\"\r\n   */\n\n\n  Color3.prototype.getClassName = function () {\n    return \"Color3\";\n  };\n  /**\r\n   * Compute the Color3 hash code\r\n   * @returns an unique number that can be used to hash Color3 objects\r\n   */\n\n\n  Color3.prototype.getHashCode = function () {\n    var hash = this.r * 255 | 0;\n    hash = hash * 397 ^ (this.g * 255 | 0);\n    hash = hash * 397 ^ (this.b * 255 | 0);\n    return hash;\n  }; // Operators\n\n  /**\r\n   * Stores in the given array from the given starting index the red, green, blue values as successive elements\r\n   * @param array defines the array where to store the r,g,b components\r\n   * @param index defines an optional index in the target array to define where to start storing values\r\n   * @returns the current Color3 object\r\n   */\n\n\n  Color3.prototype.toArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    array[index] = this.r;\n    array[index + 1] = this.g;\n    array[index + 2] = this.b;\n    return this;\n  };\n  /**\r\n   * Update the current color with values stored in an array from the starting index of the given array\r\n   * @param array defines the source array\r\n   * @param offset defines an offset in the source array\r\n   * @returns the current Color3 object\r\n   */\n\n\n  Color3.prototype.fromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    Color3.FromArrayToRef(array, offset, this);\n    return this;\n  };\n  /**\r\n   * Returns a new Color4 object from the current Color3 and the given alpha\r\n   * @param alpha defines the alpha component on the new Color4 object (default is 1)\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color3.prototype.toColor4 = function (alpha) {\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n\n    return new Color4(this.r, this.g, this.b, alpha);\n  };\n  /**\r\n   * Returns a new array populated with 3 numeric elements : red, green and blue values\r\n   * @returns the new array\r\n   */\n\n\n  Color3.prototype.asArray = function () {\n    var result = new Array();\n    this.toArray(result, 0);\n    return result;\n  };\n  /**\r\n   * Returns the luminance value\r\n   * @returns a float value\r\n   */\n\n\n  Color3.prototype.toLuminance = function () {\n    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n  };\n  /**\r\n   * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\r\n   * @param otherColor defines the second operand\r\n   * @returns the new Color3 object\r\n   */\n\n\n  Color3.prototype.multiply = function (otherColor) {\n    return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n  };\n  /**\r\n   * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\r\n   * @param otherColor defines the second operand\r\n   * @param result defines the Color3 object where to store the result\r\n   * @returns the current Color3\r\n   */\n\n\n  Color3.prototype.multiplyToRef = function (otherColor, result) {\n    result.r = this.r * otherColor.r;\n    result.g = this.g * otherColor.g;\n    result.b = this.b * otherColor.b;\n    return this;\n  };\n  /**\r\n   * Determines equality between Color3 objects\r\n   * @param otherColor defines the second operand\r\n   * @returns true if the rgb values are equal to the given ones\r\n   */\n\n\n  Color3.prototype.equals = function (otherColor) {\n    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n  };\n  /**\r\n   * Determines equality between the current Color3 object and a set of r,b,g values\r\n   * @param r defines the red component to check\r\n   * @param g defines the green component to check\r\n   * @param b defines the blue component to check\r\n   * @returns true if the rgb values are equal to the given ones\r\n   */\n\n\n  Color3.prototype.equalsFloats = function (r, g, b) {\n    return this.r === r && this.g === g && this.b === b;\n  };\n  /**\r\n   * Multiplies in place each rgb value by scale\r\n   * @param scale defines the scaling factor\r\n   * @returns the updated Color3\r\n   */\n\n\n  Color3.prototype.scale = function (scale) {\n    return new Color3(this.r * scale, this.g * scale, this.b * scale);\n  };\n  /**\r\n   * Multiplies the rgb values by scale and stores the result into \"result\"\r\n   * @param scale defines the scaling factor\r\n   * @param result defines the Color3 object where to store the result\r\n   * @returns the unmodified current Color3\r\n   */\n\n\n  Color3.prototype.scaleToRef = function (scale, result) {\n    result.r = this.r * scale;\n    result.g = this.g * scale;\n    result.b = this.b * scale;\n    return this;\n  };\n  /**\r\n   * Scale the current Color3 values by a factor and add the result to a given Color3\r\n   * @param scale defines the scale factor\r\n   * @param result defines color to store the result into\r\n   * @returns the unmodified current Color3\r\n   */\n\n\n  Color3.prototype.scaleAndAddToRef = function (scale, result) {\n    result.r += this.r * scale;\n    result.g += this.g * scale;\n    result.b += this.b * scale;\n    return this;\n  };\n  /**\r\n   * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n   * @param min defines minimum clamping value (default is 0)\r\n   * @param max defines maximum clamping value (default is 1)\r\n   * @param result defines color to store the result into\r\n   * @returns the original Color3\r\n   */\n\n\n  Color3.prototype.clampToRef = function (min, max, result) {\n    if (min === void 0) {\n      min = 0;\n    }\n\n    if (max === void 0) {\n      max = 1;\n    }\n\n    result.r = Scalar.Clamp(this.r, min, max);\n    result.g = Scalar.Clamp(this.g, min, max);\n    result.b = Scalar.Clamp(this.b, min, max);\n    return this;\n  };\n  /**\r\n   * Creates a new Color3 set with the added values of the current Color3 and of the given one\r\n   * @param otherColor defines the second operand\r\n   * @returns the new Color3\r\n   */\n\n\n  Color3.prototype.add = function (otherColor) {\n    return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n  };\n  /**\r\n   * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\r\n   * @param otherColor defines the second operand\r\n   * @param result defines Color3 object to store the result into\r\n   * @returns the unmodified current Color3\r\n   */\n\n\n  Color3.prototype.addToRef = function (otherColor, result) {\n    result.r = this.r + otherColor.r;\n    result.g = this.g + otherColor.g;\n    result.b = this.b + otherColor.b;\n    return this;\n  };\n  /**\r\n   * Returns a new Color3 set with the subtracted values of the given one from the current Color3\r\n   * @param otherColor defines the second operand\r\n   * @returns the new Color3\r\n   */\n\n\n  Color3.prototype.subtract = function (otherColor) {\n    return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n  };\n  /**\r\n   * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\r\n   * @param otherColor defines the second operand\r\n   * @param result defines Color3 object to store the result into\r\n   * @returns the unmodified current Color3\r\n   */\n\n\n  Color3.prototype.subtractToRef = function (otherColor, result) {\n    result.r = this.r - otherColor.r;\n    result.g = this.g - otherColor.g;\n    result.b = this.b - otherColor.b;\n    return this;\n  };\n  /**\r\n   * Copy the current object\r\n   * @returns a new Color3 copied the current one\r\n   */\n\n\n  Color3.prototype.clone = function () {\n    return new Color3(this.r, this.g, this.b);\n  };\n  /**\r\n   * Copies the rgb values from the source in the current Color3\r\n   * @param source defines the source Color3 object\r\n   * @returns the updated Color3 object\r\n   */\n\n\n  Color3.prototype.copyFrom = function (source) {\n    this.r = source.r;\n    this.g = source.g;\n    this.b = source.b;\n    return this;\n  };\n  /**\r\n   * Updates the Color3 rgb values from the given floats\r\n   * @param r defines the red component to read from\r\n   * @param g defines the green component to read from\r\n   * @param b defines the blue component to read from\r\n   * @returns the current Color3 object\r\n   */\n\n\n  Color3.prototype.copyFromFloats = function (r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    return this;\n  };\n  /**\r\n   * Updates the Color3 rgb values from the given floats\r\n   * @param r defines the red component to read from\r\n   * @param g defines the green component to read from\r\n   * @param b defines the blue component to read from\r\n   * @returns the current Color3 object\r\n   */\n\n\n  Color3.prototype.set = function (r, g, b) {\n    return this.copyFromFloats(r, g, b);\n  };\n  /**\r\n   * Compute the Color3 hexadecimal code as a string\r\n   * @returns a string containing the hexadecimal representation of the Color3 object\r\n   */\n\n\n  Color3.prototype.toHexString = function () {\n    var intR = this.r * 255 | 0;\n    var intG = this.g * 255 | 0;\n    var intB = this.b * 255 | 0;\n    return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n  };\n  /**\r\n   * Computes a new Color3 converted from the current one to linear space\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.prototype.toLinearSpace = function () {\n    var convertedColor = new Color3();\n    this.toLinearSpaceToRef(convertedColor);\n    return convertedColor;\n  };\n  /**\r\n   * Converts current color in rgb space to HSV values\r\n   * @returns a new color3 representing the HSV values\r\n   */\n\n\n  Color3.prototype.toHSV = function () {\n    var result = new Color3();\n    this.toHSVToRef(result);\n    return result;\n  };\n  /**\r\n   * Converts current color in rgb space to HSV values\r\n   * @param result defines the Color3 where to store the HSV values\r\n   */\n\n\n  Color3.prototype.toHSVToRef = function (result) {\n    var r = this.r;\n    var g = this.g;\n    var b = this.b;\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var h = 0;\n    var s = 0;\n    var v = max;\n    var dm = max - min;\n\n    if (max !== 0) {\n      s = dm / max;\n    }\n\n    if (max != min) {\n      if (max == r) {\n        h = (g - b) / dm;\n\n        if (g < b) {\n          h += 6;\n        }\n      } else if (max == g) {\n        h = (b - r) / dm + 2;\n      } else if (max == b) {\n        h = (r - g) / dm + 4;\n      }\n\n      h *= 60;\n    }\n\n    result.r = h;\n    result.g = s;\n    result.b = v;\n  };\n  /**\r\n   * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\r\n   * @param convertedColor defines the Color3 object where to store the linear space version\r\n   * @returns the unmodified Color3\r\n   */\n\n\n  Color3.prototype.toLinearSpaceToRef = function (convertedColor) {\n    convertedColor.r = Math.pow(this.r, ToLinearSpace);\n    convertedColor.g = Math.pow(this.g, ToLinearSpace);\n    convertedColor.b = Math.pow(this.b, ToLinearSpace);\n    return this;\n  };\n  /**\r\n   * Computes a new Color3 converted from the current one to gamma space\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.prototype.toGammaSpace = function () {\n    var convertedColor = new Color3();\n    this.toGammaSpaceToRef(convertedColor);\n    return convertedColor;\n  };\n  /**\r\n   * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\r\n   * @param convertedColor defines the Color3 object where to store the gamma space version\r\n   * @returns the unmodified Color3\r\n   */\n\n\n  Color3.prototype.toGammaSpaceToRef = function (convertedColor) {\n    convertedColor.r = Math.pow(this.r, ToGammaSpace);\n    convertedColor.g = Math.pow(this.g, ToGammaSpace);\n    convertedColor.b = Math.pow(this.b, ToGammaSpace);\n    return this;\n  };\n  /**\r\n   * Convert Hue, saturation and value to a Color3 (RGB)\r\n   * @param hue defines the hue\r\n   * @param saturation defines the saturation\r\n   * @param value defines the value\r\n   * @param result defines the Color3 where to store the RGB values\r\n   */\n\n\n  Color3.HSVtoRGBToRef = function (hue, saturation, value, result) {\n    var chroma = value * saturation;\n    var h = hue / 60;\n    var x = chroma * (1 - Math.abs(h % 2 - 1));\n    var r = 0;\n    var g = 0;\n    var b = 0;\n\n    if (h >= 0 && h <= 1) {\n      r = chroma;\n      g = x;\n    } else if (h >= 1 && h <= 2) {\n      r = x;\n      g = chroma;\n    } else if (h >= 2 && h <= 3) {\n      g = chroma;\n      b = x;\n    } else if (h >= 3 && h <= 4) {\n      g = x;\n      b = chroma;\n    } else if (h >= 4 && h <= 5) {\n      r = x;\n      b = chroma;\n    } else if (h >= 5 && h <= 6) {\n      r = chroma;\n      b = x;\n    }\n\n    var m = value - chroma;\n    result.set(r + m, g + m, b + m);\n  };\n  /**\r\n   * Creates a new Color3 from the string containing valid hexadecimal values\r\n   * @param hex defines a string containing valid hexadecimal values\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.FromHexString = function (hex) {\n    if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\n      return new Color3(0, 0, 0);\n    }\n\n    var r = parseInt(hex.substring(1, 3), 16);\n    var g = parseInt(hex.substring(3, 5), 16);\n    var b = parseInt(hex.substring(5, 7), 16);\n    return Color3.FromInts(r, g, b);\n  };\n  /**\r\n   * Creates a new Color3 from the starting index of the given array\r\n   * @param array defines the source array\r\n   * @param offset defines an offset in the source array\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.FromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n  };\n  /**\r\n   * Creates a new Color3 from the starting index element of the given array\r\n   * @param array defines the source array to read from\r\n   * @param offset defines the offset in the source array\r\n   * @param result defines the target Color3 object\r\n   */\n\n\n  Color3.FromArrayToRef = function (array, offset, result) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    result.r = array[offset];\n    result.g = array[offset + 1];\n    result.b = array[offset + 2];\n  };\n  /**\r\n   * Creates a new Color3 from integer values (< 256)\r\n   * @param r defines the red component to read from (value between 0 and 255)\r\n   * @param g defines the green component to read from (value between 0 and 255)\r\n   * @param b defines the blue component to read from (value between 0 and 255)\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.FromInts = function (r, g, b) {\n    return new Color3(r / 255.0, g / 255.0, b / 255.0);\n  };\n  /**\r\n   * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n   * @param start defines the start Color3 value\r\n   * @param end defines the end Color3 value\r\n   * @param amount defines the gradient value between start and end\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Lerp = function (start, end, amount) {\n    var result = new Color3(0.0, 0.0, 0.0);\n    Color3.LerpToRef(start, end, amount, result);\n    return result;\n  };\n  /**\r\n   * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n   * @param left defines the start value\r\n   * @param right defines the end value\r\n   * @param amount defines the gradient factor\r\n   * @param result defines the Color3 object where to store the result\r\n   */\n\n\n  Color3.LerpToRef = function (left, right, amount, result) {\n    result.r = left.r + (right.r - left.r) * amount;\n    result.g = left.g + (right.g - left.g) * amount;\n    result.b = left.b + (right.b - left.b) * amount;\n  };\n  /**\r\n   * Returns a Color3 value containing a red color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Red = function () {\n    return new Color3(1, 0, 0);\n  };\n  /**\r\n   * Returns a Color3 value containing a green color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Green = function () {\n    return new Color3(0, 1, 0);\n  };\n  /**\r\n   * Returns a Color3 value containing a blue color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Blue = function () {\n    return new Color3(0, 0, 1);\n  };\n  /**\r\n   * Returns a Color3 value containing a black color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Black = function () {\n    return new Color3(0, 0, 0);\n  };\n\n  Object.defineProperty(Color3, \"BlackReadOnly\", {\n    /**\r\n      * Gets a Color3 value containing a black color that must not be updated\r\n      */\n    get: function get() {\n      return Color3._BlackReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns a Color3 value containing a white color\r\n   * @returns a new Color3 object\r\n   */\n\n  Color3.White = function () {\n    return new Color3(1, 1, 1);\n  };\n  /**\r\n   * Returns a Color3 value containing a purple color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Purple = function () {\n    return new Color3(0.5, 0, 0.5);\n  };\n  /**\r\n   * Returns a Color3 value containing a magenta color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Magenta = function () {\n    return new Color3(1, 0, 1);\n  };\n  /**\r\n   * Returns a Color3 value containing a yellow color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Yellow = function () {\n    return new Color3(1, 1, 0);\n  };\n  /**\r\n   * Returns a Color3 value containing a gray color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Gray = function () {\n    return new Color3(0.5, 0.5, 0.5);\n  };\n  /**\r\n   * Returns a Color3 value containing a teal color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Teal = function () {\n    return new Color3(0, 1.0, 1.0);\n  };\n  /**\r\n   * Returns a Color3 value containing a random color\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color3.Random = function () {\n    return new Color3(Math.random(), Math.random(), Math.random());\n  }; // Statics\n\n\n  Color3._BlackReadOnly = Color3.Black();\n  return Color3;\n}();\n\nexport { Color3 };\n/**\r\n * Class used to hold a RBGA color\r\n */\n\nvar Color4 =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Color4 object from red, green, blue values, all between 0 and 1\r\n   * @param r defines the red component (between 0 and 1, default is 0)\r\n   * @param g defines the green component (between 0 and 1, default is 0)\r\n   * @param b defines the blue component (between 0 and 1, default is 0)\r\n   * @param a defines the alpha component (between 0 and 1, default is 1)\r\n   */\n  function Color4(\n  /**\r\n   * Defines the red component (between 0 and 1, default is 0)\r\n   */\n  r,\n  /**\r\n   * Defines the green component (between 0 and 1, default is 0)\r\n   */\n  g,\n  /**\r\n   * Defines the blue component (between 0 and 1, default is 0)\r\n   */\n  b,\n  /**\r\n   * Defines the alpha component (between 0 and 1, default is 1)\r\n   */\n  a) {\n    if (r === void 0) {\n      r = 0;\n    }\n\n    if (g === void 0) {\n      g = 0;\n    }\n\n    if (b === void 0) {\n      b = 0;\n    }\n\n    if (a === void 0) {\n      a = 1;\n    }\n\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  } // Operators\n\n  /**\r\n   * Adds in place the given Color4 values to the current Color4 object\r\n   * @param right defines the second operand\r\n   * @returns the current updated Color4 object\r\n   */\n\n\n  Color4.prototype.addInPlace = function (right) {\n    this.r += right.r;\n    this.g += right.g;\n    this.b += right.b;\n    this.a += right.a;\n    return this;\n  };\n  /**\r\n   * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\r\n   * @returns the new array\r\n   */\n\n\n  Color4.prototype.asArray = function () {\n    var result = new Array();\n    this.toArray(result, 0);\n    return result;\n  };\n  /**\r\n   * Stores from the starting index in the given array the Color4 successive values\r\n   * @param array defines the array where to store the r,g,b components\r\n   * @param index defines an optional index in the target array to define where to start storing values\r\n   * @returns the current Color4 object\r\n   */\n\n\n  Color4.prototype.toArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    array[index] = this.r;\n    array[index + 1] = this.g;\n    array[index + 2] = this.b;\n    array[index + 3] = this.a;\n    return this;\n  };\n  /**\r\n   * Update the current color with values stored in an array from the starting index of the given array\r\n   * @param array defines the source array\r\n   * @param offset defines an offset in the source array\r\n   * @returns the current Color4 object\r\n   */\n\n\n  Color4.prototype.fromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    Color4.FromArrayToRef(array, offset, this);\n    return this;\n  };\n  /**\r\n   * Determines equality between Color4 objects\r\n   * @param otherColor defines the second operand\r\n   * @returns true if the rgba values are equal to the given ones\r\n   */\n\n\n  Color4.prototype.equals = function (otherColor) {\n    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\n  };\n  /**\r\n   * Creates a new Color4 set with the added values of the current Color4 and of the given one\r\n   * @param right defines the second operand\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.prototype.add = function (right) {\n    return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n  };\n  /**\r\n   * Creates a new Color4 set with the subtracted values of the given one from the current Color4\r\n   * @param right defines the second operand\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.prototype.subtract = function (right) {\n    return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n  };\n  /**\r\n   * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\r\n   * @param right defines the second operand\r\n   * @param result defines the Color4 object where to store the result\r\n   * @returns the current Color4 object\r\n   */\n\n\n  Color4.prototype.subtractToRef = function (right, result) {\n    result.r = this.r - right.r;\n    result.g = this.g - right.g;\n    result.b = this.b - right.b;\n    result.a = this.a - right.a;\n    return this;\n  };\n  /**\r\n   * Creates a new Color4 with the current Color4 values multiplied by scale\r\n   * @param scale defines the scaling factor to apply\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.prototype.scale = function (scale) {\n    return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n  };\n  /**\r\n   * Multiplies the current Color4 values by scale and stores the result in \"result\"\r\n   * @param scale defines the scaling factor to apply\r\n   * @param result defines the Color4 object where to store the result\r\n   * @returns the current unmodified Color4\r\n   */\n\n\n  Color4.prototype.scaleToRef = function (scale, result) {\n    result.r = this.r * scale;\n    result.g = this.g * scale;\n    result.b = this.b * scale;\n    result.a = this.a * scale;\n    return this;\n  };\n  /**\r\n   * Scale the current Color4 values by a factor and add the result to a given Color4\r\n   * @param scale defines the scale factor\r\n   * @param result defines the Color4 object where to store the result\r\n   * @returns the unmodified current Color4\r\n   */\n\n\n  Color4.prototype.scaleAndAddToRef = function (scale, result) {\n    result.r += this.r * scale;\n    result.g += this.g * scale;\n    result.b += this.b * scale;\n    result.a += this.a * scale;\n    return this;\n  };\n  /**\r\n   * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n   * @param min defines minimum clamping value (default is 0)\r\n   * @param max defines maximum clamping value (default is 1)\r\n   * @param result defines color to store the result into.\r\n   * @returns the cuurent Color4\r\n   */\n\n\n  Color4.prototype.clampToRef = function (min, max, result) {\n    if (min === void 0) {\n      min = 0;\n    }\n\n    if (max === void 0) {\n      max = 1;\n    }\n\n    result.r = Scalar.Clamp(this.r, min, max);\n    result.g = Scalar.Clamp(this.g, min, max);\n    result.b = Scalar.Clamp(this.b, min, max);\n    result.a = Scalar.Clamp(this.a, min, max);\n    return this;\n  };\n  /**\r\n    * Multipy an Color4 value by another and return a new Color4 object\r\n    * @param color defines the Color4 value to multiply by\r\n    * @returns a new Color4 object\r\n    */\n\n\n  Color4.prototype.multiply = function (color) {\n    return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n  };\n  /**\r\n   * Multipy a Color4 value by another and push the result in a reference value\r\n   * @param color defines the Color4 value to multiply by\r\n   * @param result defines the Color4 to fill the result in\r\n   * @returns the result Color4\r\n   */\n\n\n  Color4.prototype.multiplyToRef = function (color, result) {\n    result.r = this.r * color.r;\n    result.g = this.g * color.g;\n    result.b = this.b * color.b;\n    result.a = this.a * color.a;\n    return result;\n  };\n  /**\r\n   * Creates a string with the Color4 current values\r\n   * @returns the string representation of the Color4 object\r\n   */\n\n\n  Color4.prototype.toString = function () {\n    return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n  };\n  /**\r\n   * Returns the string \"Color4\"\r\n   * @returns \"Color4\"\r\n   */\n\n\n  Color4.prototype.getClassName = function () {\n    return \"Color4\";\n  };\n  /**\r\n   * Compute the Color4 hash code\r\n   * @returns an unique number that can be used to hash Color4 objects\r\n   */\n\n\n  Color4.prototype.getHashCode = function () {\n    var hash = this.r * 255 | 0;\n    hash = hash * 397 ^ (this.g * 255 | 0);\n    hash = hash * 397 ^ (this.b * 255 | 0);\n    hash = hash * 397 ^ (this.a * 255 | 0);\n    return hash;\n  };\n  /**\r\n   * Creates a new Color4 copied from the current one\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.prototype.clone = function () {\n    return new Color4(this.r, this.g, this.b, this.a);\n  };\n  /**\r\n   * Copies the given Color4 values into the current one\r\n   * @param source defines the source Color4 object\r\n   * @returns the current updated Color4 object\r\n   */\n\n\n  Color4.prototype.copyFrom = function (source) {\n    this.r = source.r;\n    this.g = source.g;\n    this.b = source.b;\n    this.a = source.a;\n    return this;\n  };\n  /**\r\n   * Copies the given float values into the current one\r\n   * @param r defines the red component to read from\r\n   * @param g defines the green component to read from\r\n   * @param b defines the blue component to read from\r\n   * @param a defines the alpha component to read from\r\n   * @returns the current updated Color4 object\r\n   */\n\n\n  Color4.prototype.copyFromFloats = function (r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this;\n  };\n  /**\r\n   * Copies the given float values into the current one\r\n   * @param r defines the red component to read from\r\n   * @param g defines the green component to read from\r\n   * @param b defines the blue component to read from\r\n   * @param a defines the alpha component to read from\r\n   * @returns the current updated Color4 object\r\n   */\n\n\n  Color4.prototype.set = function (r, g, b, a) {\n    return this.copyFromFloats(r, g, b, a);\n  };\n  /**\r\n   * Compute the Color4 hexadecimal code as a string\r\n   * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\r\n   * @returns a string containing the hexadecimal representation of the Color4 object\r\n   */\n\n\n  Color4.prototype.toHexString = function (returnAsColor3) {\n    if (returnAsColor3 === void 0) {\n      returnAsColor3 = false;\n    }\n\n    var intR = this.r * 255 | 0;\n    var intG = this.g * 255 | 0;\n    var intB = this.b * 255 | 0;\n\n    if (returnAsColor3) {\n      return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n    }\n\n    var intA = this.a * 255 | 0;\n    return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);\n  };\n  /**\r\n   * Computes a new Color4 converted from the current one to linear space\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.prototype.toLinearSpace = function () {\n    var convertedColor = new Color4();\n    this.toLinearSpaceToRef(convertedColor);\n    return convertedColor;\n  };\n  /**\r\n   * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\r\n   * @param convertedColor defines the Color4 object where to store the linear space version\r\n   * @returns the unmodified Color4\r\n   */\n\n\n  Color4.prototype.toLinearSpaceToRef = function (convertedColor) {\n    convertedColor.r = Math.pow(this.r, ToLinearSpace);\n    convertedColor.g = Math.pow(this.g, ToLinearSpace);\n    convertedColor.b = Math.pow(this.b, ToLinearSpace);\n    convertedColor.a = this.a;\n    return this;\n  };\n  /**\r\n   * Computes a new Color4 converted from the current one to gamma space\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.prototype.toGammaSpace = function () {\n    var convertedColor = new Color4();\n    this.toGammaSpaceToRef(convertedColor);\n    return convertedColor;\n  };\n  /**\r\n   * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\r\n   * @param convertedColor defines the Color4 object where to store the gamma space version\r\n   * @returns the unmodified Color4\r\n   */\n\n\n  Color4.prototype.toGammaSpaceToRef = function (convertedColor) {\n    convertedColor.r = Math.pow(this.r, ToGammaSpace);\n    convertedColor.g = Math.pow(this.g, ToGammaSpace);\n    convertedColor.b = Math.pow(this.b, ToGammaSpace);\n    convertedColor.a = this.a;\n    return this;\n  }; // Statics\n\n  /**\r\n   * Creates a new Color4 from the string containing valid hexadecimal values\r\n   * @param hex defines a string containing valid hexadecimal values\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.FromHexString = function (hex) {\n    if (hex.substring(0, 1) !== \"#\" || hex.length !== 9) {\n      return new Color4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    var r = parseInt(hex.substring(1, 3), 16);\n    var g = parseInt(hex.substring(3, 5), 16);\n    var b = parseInt(hex.substring(5, 7), 16);\n    var a = parseInt(hex.substring(7, 9), 16);\n    return Color4.FromInts(r, g, b, a);\n  };\n  /**\r\n   * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n   * @param left defines the start value\r\n   * @param right defines the end value\r\n   * @param amount defines the gradient factor\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.Lerp = function (left, right, amount) {\n    var result = new Color4(0.0, 0.0, 0.0, 0.0);\n    Color4.LerpToRef(left, right, amount, result);\n    return result;\n  };\n  /**\r\n   * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n   * @param left defines the start value\r\n   * @param right defines the end value\r\n   * @param amount defines the gradient factor\r\n   * @param result defines the Color4 object where to store data\r\n   */\n\n\n  Color4.LerpToRef = function (left, right, amount, result) {\n    result.r = left.r + (right.r - left.r) * amount;\n    result.g = left.g + (right.g - left.g) * amount;\n    result.b = left.b + (right.b - left.b) * amount;\n    result.a = left.a + (right.a - left.a) * amount;\n  };\n  /**\r\n   * Creates a new Color4 from a Color3 and an alpha value\r\n   * @param color3 defines the source Color3 to read from\r\n   * @param alpha defines the alpha component (1.0 by default)\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.FromColor3 = function (color3, alpha) {\n    if (alpha === void 0) {\n      alpha = 1.0;\n    }\n\n    return new Color4(color3.r, color3.g, color3.b, alpha);\n  };\n  /**\r\n   * Creates a new Color4 from the starting index element of the given array\r\n   * @param array defines the source array to read from\r\n   * @param offset defines the offset in the source array\r\n   * @returns a new Color4 object\r\n   */\n\n\n  Color4.FromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n  };\n  /**\r\n   * Creates a new Color4 from the starting index element of the given array\r\n   * @param array defines the source array to read from\r\n   * @param offset defines the offset in the source array\r\n   * @param result defines the target Color4 object\r\n   */\n\n\n  Color4.FromArrayToRef = function (array, offset, result) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    result.r = array[offset];\n    result.g = array[offset + 1];\n    result.b = array[offset + 2];\n    result.a = array[offset + 3];\n  };\n  /**\r\n   * Creates a new Color3 from integer values (< 256)\r\n   * @param r defines the red component to read from (value between 0 and 255)\r\n   * @param g defines the green component to read from (value between 0 and 255)\r\n   * @param b defines the blue component to read from (value between 0 and 255)\r\n   * @param a defines the alpha component to read from (value between 0 and 255)\r\n   * @returns a new Color3 object\r\n   */\n\n\n  Color4.FromInts = function (r, g, b, a) {\n    return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n  };\n  /**\r\n   * Check the content of a given array and convert it to an array containing RGBA data\r\n   * If the original array was already containing count * 4 values then it is returned directly\r\n   * @param colors defines the array to check\r\n   * @param count defines the number of RGBA data to expect\r\n   * @returns an array containing count * 4 values (RGBA)\r\n   */\n\n\n  Color4.CheckColors4 = function (colors, count) {\n    // Check if color3 was used\n    if (colors.length === count * 3) {\n      var colors4 = [];\n\n      for (var index = 0; index < colors.length; index += 3) {\n        var newIndex = index / 3 * 4;\n        colors4[newIndex] = colors[index];\n        colors4[newIndex + 1] = colors[index + 1];\n        colors4[newIndex + 2] = colors[index + 2];\n        colors4[newIndex + 3] = 1.0;\n      }\n\n      return colors4;\n    }\n\n    return colors;\n  };\n\n  return Color4;\n}();\n\nexport { Color4 };\n/**\r\n * @hidden\r\n */\n\nvar TmpColors =\n/** @class */\nfunction () {\n  function TmpColors() {}\n\n  TmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);\n  TmpColors.Color4 = ArrayTools.BuildArray(3, function () {\n    return new Color4(0, 0, 0, 0);\n  });\n  return TmpColors;\n}();\n\nexport { TmpColors };\n_TypeStore.RegisteredTypes[\"BABYLON.Color3\"] = Color3;\n_TypeStore.RegisteredTypes[\"BABYLON.Color4\"] = Color4;","map":null,"metadata":{},"sourceType":"module"}