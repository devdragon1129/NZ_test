{"ast":null,"code":"import { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\nimport { Animation } from \"../../Animations/animation\";\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n */\n\nvar FramingBehavior =\n/** @class */\nfunction () {\n  function FramingBehavior() {\n    this._mode = FramingBehavior.FitFrustumSidesMode;\n    this._radiusScale = 1.0;\n    this._positionScale = 0.5;\n    this._defaultElevation = 0.3;\n    this._elevationReturnTime = 1500;\n    this._elevationReturnWaitTime = 1000;\n    this._zoomStopsAnimation = false;\n    this._framingTime = 1500;\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\n\n    this.autoCorrectCameraLimitsAndSensibility = true;\n    this._isPointerDown = false;\n    this._lastInteractionTime = -Infinity; // Framing control\n\n    this._animatables = new Array();\n    this._betaIsAnimating = false;\n  }\n\n  Object.defineProperty(FramingBehavior.prototype, \"name\", {\n    /**\r\n     * Gets the name of the behavior.\r\n     */\n    get: function get() {\n      return \"Framing\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"mode\", {\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\n    get: function get() {\n      return this._mode;\n    },\n\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\n    set: function set(mode) {\n      this._mode = mode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"radiusScale\", {\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\n    get: function get() {\n      return this._radiusScale;\n    },\n\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\n    set: function set(radius) {\n      this._radiusScale = radius;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"positionScale\", {\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\n    get: function get() {\n      return this._positionScale;\n    },\n\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\n    set: function set(scale) {\n      this._positionScale = scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"defaultElevation\", {\n    /**\r\n    * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n    * behaviour is triggered, in radians.\r\n    */\n    get: function get() {\n      return this._defaultElevation;\n    },\n\n    /**\r\n    * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n    * behaviour is triggered, in radians.\r\n    */\n    set: function set(elevation) {\n      this._defaultElevation = elevation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"elevationReturnTime\", {\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\n    get: function get() {\n      return this._elevationReturnTime;\n    },\n\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\n    set: function set(speed) {\n      this._elevationReturnTime = speed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"elevationReturnWaitTime\", {\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\n    get: function get() {\n      return this._elevationReturnWaitTime;\n    },\n\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\n    set: function set(time) {\n      this._elevationReturnWaitTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"zoomStopsAnimation\", {\n    /**\r\n    * Gets the flag that indicates if user zooming should stop animation.\r\n    */\n    get: function get() {\n      return this._zoomStopsAnimation;\n    },\n\n    /**\r\n    * Sets the flag that indicates if user zooming should stop animation.\r\n    */\n    set: function set(flag) {\n      this._zoomStopsAnimation = flag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"framingTime\", {\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n    */\n    get: function get() {\n      return this._framingTime;\n    },\n\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n    */\n    set: function set(time) {\n      this._framingTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initializes the behavior.\r\n   */\n\n  FramingBehavior.prototype.init = function () {// Do notihng\n  };\n  /**\r\n   * Attaches the behavior to its arc rotate camera.\r\n   * @param camera Defines the camera to attach the behavior to\r\n   */\n\n\n  FramingBehavior.prototype.attach = function (camera) {\n    var _this = this;\n\n    this._attachedCamera = camera;\n\n    var scene = this._attachedCamera.getScene();\n\n    FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        _this._isPointerDown = true;\n        return;\n      }\n\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        _this._isPointerDown = false;\n      }\n    });\n    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {\n      if (mesh) {\n        _this.zoomOnMesh(mesh);\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\n      // Stop the animation if there is user interaction and the animation should stop for this interaction\n      _this._applyUserInteraction(); // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\n      // back to the default position after a given timeout\n\n\n      _this._maintainCameraAboveGround();\n    });\n  };\n  /**\r\n   * Detaches the behavior from its current arc rotate camera.\r\n   */\n\n\n  FramingBehavior.prototype.detach = function () {\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    var scene = this._attachedCamera.getScene();\n\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n\n    this._attachedCamera = null;\n  };\n  /**\r\n   * Targets the given mesh and updates zoom level accordingly.\r\n   * @param mesh  The mesh to target.\r\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n   */\n\n\n  FramingBehavior.prototype.zoomOnMesh = function (mesh, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    mesh.computeWorldMatrix(true);\n    var boundingBox = mesh.getBoundingInfo().boundingBox;\n    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\r\n   * Targets the given mesh with its children and updates zoom level accordingly.\r\n   * @param mesh  The mesh to target.\r\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n   */\n\n\n  FramingBehavior.prototype.zoomOnMeshHierarchy = function (mesh, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    mesh.computeWorldMatrix(true);\n    var boundingBox = mesh.getHierarchyBoundingVectors(true);\n    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\r\n   * Targets the given meshes with their children and updates zoom level accordingly.\r\n   * @param meshes  The mesh to target.\r\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n   */\n\n\n  FramingBehavior.prototype.zoomOnMeshesHierarchy = function (meshes, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    for (var i = 0; i < meshes.length; i++) {\n      var boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\n      Vector3.CheckExtends(boundingInfo.min, min, max);\n      Vector3.CheckExtends(boundingInfo.max, min, max);\n    }\n\n    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\r\n   * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n   * @param minimumWorld Determines the smaller position of the bounding box extend\r\n   * @param maximumWorld Determines the bigger position of the bounding box extend\r\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n   */\n\n\n  FramingBehavior.prototype.zoomOnBoundingInfo = function (minimumWorld, maximumWorld, focusOnOriginXZ, onAnimationEnd) {\n    var _this = this;\n\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    var zoomTarget;\n\n    if (!this._attachedCamera) {\n      return;\n    } // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\n\n\n    var bottom = minimumWorld.y;\n    var top = maximumWorld.y;\n    var zoomTargetY = bottom + (top - bottom) * this._positionScale;\n    var radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\n\n    if (focusOnOriginXZ) {\n      zoomTarget = new Vector3(0, zoomTargetY, 0);\n    } else {\n      var centerWorld = minimumWorld.add(radiusWorld);\n      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\n    }\n\n    if (!this._vectorTransition) {\n      this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\n    }\n\n    this._betaIsAnimating = true;\n    var animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    } // sets the radius and lower radius bounds\n    // Small delta ensures camera is not always at lower zoom limit.\n\n\n    var radius = 0;\n\n    if (this._mode === FramingBehavior.FitFrustumSidesMode) {\n      var position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n\n      if (this.autoCorrectCameraLimitsAndSensibility) {\n        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\n      }\n\n      radius = position;\n    } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n\n      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\n        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\n      }\n    } // Set sensibilities\n\n\n    if (this.autoCorrectCameraLimitsAndSensibility) {\n      var extend = maximumWorld.subtract(minimumWorld).length();\n      this._attachedCamera.panningSensibility = 5000 / extend;\n      this._attachedCamera.wheelPrecision = 100 / radius;\n    } // transition to new radius\n\n\n    if (!this._radiusTransition) {\n      this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n    }\n\n    animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, function () {\n      _this.stopAllAnimations();\n\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n\n      if (_this._attachedCamera && _this._attachedCamera.useInputToRestoreState) {\n        _this._attachedCamera.storeState();\n      }\n    });\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  };\n  /**\r\n   * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n   * @param mesh The mesh on which to base the calculation. mesh boundingInfo used to estimate necessary\r\n   *\t\t\t  frustum width.\r\n   * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n   *\t\t to fully enclose the mesh in the viewing frustum.\r\n   */\n\n\n  FramingBehavior.prototype._calculateLowerRadiusFromModelBoundingSphere = function (minimumWorld, maximumWorld) {\n    var size = maximumWorld.subtract(minimumWorld);\n    var boxVectorGlobalDiagonal = size.length();\n\n    var frustumSlope = this._getFrustumSlope(); // Formula for setting distance\n    // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\n\n\n    var radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5; // Horizon distance\n\n    var radius = radiusWithoutFraming * this._radiusScale;\n    var distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\n    var distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\n    var distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\n    var camera = this._attachedCamera;\n\n    if (!camera) {\n      return 0;\n    }\n\n    if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      // Don't exceed the requested limit\n      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\n    } // Don't exceed the upper radius limit\n\n\n    if (camera.upperRadiusLimit) {\n      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\n    }\n\n    return distance;\n  };\n  /**\r\n   * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n   * is automatically returned to its default position (expected to be above ground plane).\r\n   */\n\n\n  FramingBehavior.prototype._maintainCameraAboveGround = function () {\n    var _this = this;\n\n    if (this._elevationReturnTime < 0) {\n      return;\n    }\n\n    var timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\n    var defaultBeta = Math.PI * 0.5 - this._defaultElevation;\n    var limitBeta = Math.PI * 0.5; // Bring the camera back up if below the ground plane\n\n    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\n      this._betaIsAnimating = true; //Transition to new position\n\n      this.stopAllAnimations();\n\n      if (!this._betaTransition) {\n        this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n      }\n\n      var animatabe = Animation.TransitionTo(\"beta\", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, function () {\n        _this._clearAnimationLocks();\n\n        _this.stopAllAnimations();\n      });\n\n      if (animatabe) {\n        this._animatables.push(animatabe);\n      }\n    }\n  };\n  /**\r\n   * Returns the frustum slope based on the canvas ratio and camera FOV\r\n   * @returns The frustum slope represented as a Vector2 with X and Y slopes\r\n   */\n\n\n  FramingBehavior.prototype._getFrustumSlope = function () {\n    // Calculate the viewport ratio\n    // Aspect Ratio is Height/Width.\n    var camera = this._attachedCamera;\n\n    if (!camera) {\n      return Vector2.Zero();\n    }\n\n    var engine = camera.getScene().getEngine();\n    var aspectRatio = engine.getAspectRatio(camera); // Camera FOV is the vertical field of view (top-bottom) in radians.\n    // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\n\n    var frustumSlopeY = Math.tan(camera.fov / 2); // Slope of the frustum left/right planes in view space, relative to the forward vector.\n    // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\n    // along the forward vector.\n\n    var frustumSlopeX = frustumSlopeY * aspectRatio;\n    return new Vector2(frustumSlopeX, frustumSlopeY);\n  };\n  /**\r\n   * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n   */\n\n\n  FramingBehavior.prototype._clearAnimationLocks = function () {\n    this._betaIsAnimating = false;\n  };\n  /**\r\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n   */\n\n\n  FramingBehavior.prototype._applyUserInteraction = function () {\n    if (this.isUserIsMoving) {\n      this._lastInteractionTime = PrecisionDate.Now;\n      this.stopAllAnimations();\n\n      this._clearAnimationLocks();\n    }\n  };\n  /**\r\n   * Stops and removes all animations that have been applied to the camera\r\n   */\n\n\n  FramingBehavior.prototype.stopAllAnimations = function () {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n\n    while (this._animatables.length) {\n      if (this._animatables[0]) {\n        this._animatables[0].onAnimationEnd = null;\n\n        this._animatables[0].stop();\n      }\n\n      this._animatables.shift();\n    }\n  };\n\n  Object.defineProperty(FramingBehavior.prototype, \"isUserIsMoving\", {\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\n    get: function get() {\n      if (!this._attachedCamera) {\n        return false;\n      }\n\n      return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * The easing function used by animations\r\n   */\n\n  FramingBehavior.EasingFunction = new ExponentialEase();\n  /**\r\n   * The easing mode used by animations\r\n   */\n\n  FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT; // Statics\n\n  /**\r\n   * The camera can move all the way towards the mesh.\r\n   */\n\n  FramingBehavior.IgnoreBoundsSizeMode = 0;\n  /**\r\n   * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n   */\n\n  FramingBehavior.FitFrustumSidesMode = 1;\n  return FramingBehavior;\n}();\n\nexport { FramingBehavior };","map":null,"metadata":{},"sourceType":"module"}