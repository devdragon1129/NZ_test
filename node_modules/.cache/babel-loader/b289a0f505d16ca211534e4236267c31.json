{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\nimport { StringDictionary } from \"./stringDictionary\"; // Mainly based on these 2 articles :\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\n\n/**\r\n * Defines the potential axis of a Joystick\r\n */\n\nexport var JoystickAxis;\n\n(function (JoystickAxis) {\n  /** X axis */\n  JoystickAxis[JoystickAxis[\"X\"] = 0] = \"X\";\n  /** Y axis */\n\n  JoystickAxis[JoystickAxis[\"Y\"] = 1] = \"Y\";\n  /** Z axis */\n\n  JoystickAxis[JoystickAxis[\"Z\"] = 2] = \"Z\";\n})(JoystickAxis || (JoystickAxis = {}));\n/**\r\n * Class used to define virtual joystick (used in touch mode)\r\n */\n\n\nvar VirtualJoystick =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new virtual joystick\r\n   * @param leftJoystick defines that the joystick is for left hand (false by default)\r\n   * @param customizations Defines the options we want to customize the VirtualJoystick\r\n   */\n  function VirtualJoystick(leftJoystick, customizations) {\n    var _this = this;\n\n    var options = __assign(__assign({}, VirtualJoystick._GetDefaultOptions()), customizations);\n\n    if (leftJoystick) {\n      this._leftJoystick = true;\n    } else {\n      this._leftJoystick = false;\n    }\n\n    VirtualJoystick._globalJoystickIndex++; // By default left & right arrow keys are moving the X\n    // and up & down keys are moving the Y\n\n    this._axisTargetedByLeftAndRight = JoystickAxis.X;\n    this._axisTargetedByUpAndDown = JoystickAxis.Y;\n    this.reverseLeftRight = false;\n    this.reverseUpDown = false; // collections of pointers\n\n    this._touches = new StringDictionary();\n    this.deltaPosition = Vector3.Zero();\n    this._joystickSensibility = 25;\n    this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n\n    this._onResize = function (evt) {\n      VirtualJoystick.vjCanvasWidth = window.innerWidth;\n      VirtualJoystick.vjCanvasHeight = window.innerHeight;\n\n      if (VirtualJoystick.Canvas) {\n        VirtualJoystick.Canvas.width = VirtualJoystick.vjCanvasWidth;\n        VirtualJoystick.Canvas.height = VirtualJoystick.vjCanvasHeight;\n      }\n\n      VirtualJoystick.halfWidth = VirtualJoystick.vjCanvasWidth / 2;\n    }; // injecting a canvas element on top of the canvas 3D game\n\n\n    if (!VirtualJoystick.Canvas) {\n      window.addEventListener(\"resize\", this._onResize, false);\n      VirtualJoystick.Canvas = document.createElement(\"canvas\");\n      VirtualJoystick.vjCanvasWidth = window.innerWidth;\n      VirtualJoystick.vjCanvasHeight = window.innerHeight;\n      VirtualJoystick.Canvas.width = window.innerWidth;\n      VirtualJoystick.Canvas.height = window.innerHeight;\n      VirtualJoystick.Canvas.style.width = \"100%\";\n      VirtualJoystick.Canvas.style.height = \"100%\";\n      VirtualJoystick.Canvas.style.position = \"absolute\";\n      VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\n      VirtualJoystick.Canvas.style.top = \"0px\";\n      VirtualJoystick.Canvas.style.left = \"0px\";\n      VirtualJoystick.Canvas.style.zIndex = \"5\";\n      VirtualJoystick.Canvas.style.msTouchAction = \"none\";\n      VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\n      // Support for jQuery PEP polyfill\n\n      VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\n      var context = VirtualJoystick.Canvas.getContext('2d');\n\n      if (!context) {\n        throw new Error(\"Unable to create canvas for virtual joystick\");\n      }\n\n      VirtualJoystick.vjCanvasContext = context;\n      VirtualJoystick.vjCanvasContext.strokeStyle = \"#ffffff\";\n      VirtualJoystick.vjCanvasContext.lineWidth = 2;\n      document.body.appendChild(VirtualJoystick.Canvas);\n    }\n\n    VirtualJoystick.halfWidth = VirtualJoystick.Canvas.width / 2;\n    this.pressed = false;\n    this.limitToContainer = options.limitToContainer; // default joystick color\n\n    this._joystickColor = options.color; // default joystick size\n\n    this.containerSize = options.containerSize;\n    this.puckSize = options.puckSize;\n\n    if (options.position) {\n      this.setPosition(options.position.x, options.position.y);\n    }\n\n    if (options.puckImage) {\n      this.setPuckImage(options.puckImage);\n    }\n\n    if (options.containerImage) {\n      this.setContainerImage(options.containerImage);\n    }\n\n    if (options.alwaysVisible) {\n      VirtualJoystick._alwaysVisibleSticks++;\n    } // must come after position potentially set\n\n\n    this.alwaysVisible = options.alwaysVisible;\n    this._joystickPointerID = -1; // current joystick position\n\n    this._joystickPointerPos = new Vector2(0, 0);\n    this._joystickPreviousPointerPos = new Vector2(0, 0); // origin joystick position\n\n    this._joystickPointerStartPos = new Vector2(0, 0);\n    this._deltaJoystickVector = new Vector2(0, 0);\n\n    this._onPointerDownHandlerRef = function (evt) {\n      _this._onPointerDown(evt);\n    };\n\n    this._onPointerMoveHandlerRef = function (evt) {\n      _this._onPointerMove(evt);\n    };\n\n    this._onPointerUpHandlerRef = function (evt) {\n      _this._onPointerUp(evt);\n    };\n\n    VirtualJoystick.Canvas.addEventListener('pointerdown', this._onPointerDownHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener('pointermove', this._onPointerMoveHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener('pointerup', this._onPointerUpHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener('pointerout', this._onPointerUpHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"contextmenu\", function (evt) {\n      evt.preventDefault(); // Disables system menu\n    }, false);\n    requestAnimationFrame(function () {\n      _this._drawVirtualJoystick();\n    });\n  }\n\n  VirtualJoystick._GetDefaultOptions = function () {\n    return {\n      puckSize: 40,\n      containerSize: 60,\n      color: \"cyan\",\n      puckImage: undefined,\n      containerImage: undefined,\n      position: undefined,\n      alwaysVisible: false,\n      limitToContainer: false\n    };\n  };\n  /**\r\n   * Defines joystick sensibility (ie. the ratio beteen a physical move and virtual joystick position change)\r\n   * @param newJoystickSensibility defines the new sensibility\r\n   */\n\n\n  VirtualJoystick.prototype.setJoystickSensibility = function (newJoystickSensibility) {\n    this._joystickSensibility = newJoystickSensibility;\n    this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n  };\n\n  VirtualJoystick.prototype._onPointerDown = function (e) {\n    var positionOnScreenCondition;\n    e.preventDefault();\n\n    if (this._leftJoystick === true) {\n      positionOnScreenCondition = e.clientX < VirtualJoystick.halfWidth;\n    } else {\n      positionOnScreenCondition = e.clientX > VirtualJoystick.halfWidth;\n    }\n\n    if (positionOnScreenCondition && this._joystickPointerID < 0) {\n      // First contact will be dedicated to the virtual joystick\n      this._joystickPointerID = e.pointerId;\n\n      if (this._joystickPosition) {\n        this._joystickPointerStartPos = this._joystickPosition.clone();\n        this._joystickPointerPos = this._joystickPosition.clone();\n        this._joystickPreviousPointerPos = this._joystickPosition.clone(); // in case the user only clicks down && doesn't move:\n        // this ensures the delta is properly set\n\n        this._onPointerMove(e);\n      } else {\n        this._joystickPointerStartPos.x = e.clientX;\n        this._joystickPointerStartPos.y = e.clientY;\n        this._joystickPointerPos = this._joystickPointerStartPos.clone();\n        this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\n      }\n\n      this._deltaJoystickVector.x = 0;\n      this._deltaJoystickVector.y = 0;\n      this.pressed = true;\n\n      this._touches.add(e.pointerId.toString(), e);\n    } else {\n      // You can only trigger the action buttons with a joystick declared\n      if (VirtualJoystick._globalJoystickIndex < 2 && this._action) {\n        this._action();\n\n        this._touches.add(e.pointerId.toString(), {\n          x: e.clientX,\n          y: e.clientY,\n          prevX: e.clientX,\n          prevY: e.clientY\n        });\n      }\n    }\n  };\n\n  VirtualJoystick.prototype._onPointerMove = function (e) {\n    // If the current pointer is the one associated to the joystick (first touch contact)\n    if (this._joystickPointerID == e.pointerId) {\n      // limit to container if need be\n      if (this.limitToContainer) {\n        var vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\n        var distance = vector.length();\n\n        if (distance > this.containerSize) {\n          vector.scaleInPlace(this.containerSize / distance);\n        }\n\n        this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\n        this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\n      } else {\n        this._joystickPointerPos.x = e.clientX;\n        this._joystickPointerPos.y = e.clientY;\n      } // create delta vector\n\n\n      this._deltaJoystickVector = this._joystickPointerPos.clone();\n      this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos); // if a joystick is always visible, there will be clipping issues if\n      // you drag the puck from one over the container of the other\n\n      if (0 < VirtualJoystick._alwaysVisibleSticks) {\n        if (this._leftJoystick) {\n          this._joystickPointerPos.x = Math.min(VirtualJoystick.halfWidth, this._joystickPointerPos.x);\n        } else {\n          this._joystickPointerPos.x = Math.max(VirtualJoystick.halfWidth, this._joystickPointerPos.x);\n        }\n      }\n\n      var directionLeftRight = this.reverseLeftRight ? -1 : 1;\n      var deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;\n\n      switch (this._axisTargetedByLeftAndRight) {\n        case JoystickAxis.X:\n          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n\n        case JoystickAxis.Y:\n          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n\n        case JoystickAxis.Z:\n          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n      }\n\n      var directionUpDown = this.reverseUpDown ? 1 : -1;\n      var deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;\n\n      switch (this._axisTargetedByUpAndDown) {\n        case JoystickAxis.X:\n          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n\n        case JoystickAxis.Y:\n          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n\n        case JoystickAxis.Z:\n          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n      }\n    } else {\n      var data = this._touches.get(e.pointerId.toString());\n\n      if (data) {\n        data.x = e.clientX;\n        data.y = e.clientY;\n      }\n    }\n  };\n\n  VirtualJoystick.prototype._onPointerUp = function (e) {\n    if (this._joystickPointerID == e.pointerId) {\n      this._clearPreviousDraw();\n\n      this._joystickPointerID = -1;\n      this.pressed = false;\n    } else {\n      var touch = this._touches.get(e.pointerId.toString());\n\n      if (touch) {\n        VirtualJoystick.vjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n      }\n    }\n\n    this._deltaJoystickVector.x = 0;\n    this._deltaJoystickVector.y = 0;\n\n    this._touches.remove(e.pointerId.toString());\n  };\n  /**\r\n   * Change the color of the virtual joystick\r\n   * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\r\n   */\n\n\n  VirtualJoystick.prototype.setJoystickColor = function (newColor) {\n    this._joystickColor = newColor;\n  };\n\n  Object.defineProperty(VirtualJoystick.prototype, \"containerSize\", {\n    get: function get() {\n      return this._joystickContainerSize;\n    },\n\n    /**\r\n     * Size of the joystick's container\r\n     */\n    set: function set(newSize) {\n      this._joystickContainerSize = newSize;\n      this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\n      this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VirtualJoystick.prototype, \"puckSize\", {\n    get: function get() {\n      return this._joystickPuckSize;\n    },\n\n    /**\r\n     * Size of the joystick's puck\r\n     */\n    set: function set(newSize) {\n      this._joystickPuckSize = newSize;\n      this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\n      this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Clears the set position of the joystick\r\n   */\n\n  VirtualJoystick.prototype.clearPosition = function () {\n    this.alwaysVisible = false;\n    this._joystickPosition = null;\n  };\n\n  Object.defineProperty(VirtualJoystick.prototype, \"alwaysVisible\", {\n    get: function get() {\n      return this._alwaysVisible;\n    },\n\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\n    set: function set(value) {\n      if (this._alwaysVisible === value) {\n        return;\n      }\n\n      if (value && this._joystickPosition) {\n        VirtualJoystick._alwaysVisibleSticks++;\n        this._alwaysVisible = true;\n      } else {\n        VirtualJoystick._alwaysVisibleSticks--;\n        this._alwaysVisible = false;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n  * Sets the constant position of the Joystick container\r\n  * @param x X axis coordinate\r\n  * @param y Y axis coordinate\r\n  */\n\n  VirtualJoystick.prototype.setPosition = function (x, y) {\n    // just in case position is moved while the container is visible\n    if (this._joystickPointerStartPos) {\n      this._clearPreviousDraw();\n    }\n\n    this._joystickPosition = new Vector2(x, y);\n  };\n  /**\r\n   * Defines a callback to call when the joystick is touched\r\n   * @param action defines the callback\r\n   */\n\n\n  VirtualJoystick.prototype.setActionOnTouch = function (action) {\n    this._action = action;\n  };\n  /**\r\n   * Defines which axis you'd like to control for left & right\r\n   * @param axis defines the axis to use\r\n   */\n\n\n  VirtualJoystick.prototype.setAxisForLeftRight = function (axis) {\n    switch (axis) {\n      case JoystickAxis.X:\n      case JoystickAxis.Y:\n      case JoystickAxis.Z:\n        this._axisTargetedByLeftAndRight = axis;\n        break;\n\n      default:\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\n        break;\n    }\n  };\n  /**\r\n   * Defines which axis you'd like to control for up & down\r\n   * @param axis defines the axis to use\r\n   */\n\n\n  VirtualJoystick.prototype.setAxisForUpDown = function (axis) {\n    switch (axis) {\n      case JoystickAxis.X:\n      case JoystickAxis.Y:\n      case JoystickAxis.Z:\n        this._axisTargetedByUpAndDown = axis;\n        break;\n\n      default:\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\n        break;\n    }\n  };\n  /**\r\n   * Clears the canvas from the previous puck / container draw\r\n   */\n\n\n  VirtualJoystick.prototype._clearPreviousDraw = function () {\n    var jp = this._joystickPosition || this._joystickPointerStartPos; // clear container pixels\n\n    VirtualJoystick.vjCanvasContext.clearRect(jp.x - this._clearContainerSizeOffset, jp.y - this._clearContainerSizeOffset, this._clearContainerSize, this._clearContainerSize); // clear puck pixels\n\n    VirtualJoystick.vjCanvasContext.clearRect(this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset, this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset, this._clearPuckSize, this._clearPuckSize);\n  };\n  /**\r\n   * Loads `urlPath` to be used for the container's image\r\n   * @param urlPath defines the urlPath of an image to use\r\n   */\n\n\n  VirtualJoystick.prototype.setContainerImage = function (urlPath) {\n    var _this = this;\n\n    var image = new Image();\n    image.src = urlPath;\n\n    image.onload = function () {\n      return _this._containerImage = image;\n    };\n  };\n  /**\r\n   * Loads `urlPath` to be used for the puck's image\r\n   * @param urlPath defines the urlPath of an image to use\r\n   */\n\n\n  VirtualJoystick.prototype.setPuckImage = function (urlPath) {\n    var _this = this;\n\n    var image = new Image();\n    image.src = urlPath;\n\n    image.onload = function () {\n      return _this._puckImage = image;\n    };\n  };\n  /**\r\n   * Draws the Virtual Joystick's container\r\n   */\n\n\n  VirtualJoystick.prototype._drawContainer = function () {\n    var jp = this._joystickPosition || this._joystickPointerStartPos;\n\n    this._clearPreviousDraw();\n\n    if (this._containerImage) {\n      VirtualJoystick.vjCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\n    } else {\n      // outer container\n      VirtualJoystick.vjCanvasContext.beginPath();\n      VirtualJoystick.vjCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick.vjCanvasContext.lineWidth = 2;\n      VirtualJoystick.vjCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\n      VirtualJoystick.vjCanvasContext.stroke();\n      VirtualJoystick.vjCanvasContext.closePath(); // inner container\n\n      VirtualJoystick.vjCanvasContext.beginPath();\n      VirtualJoystick.vjCanvasContext.lineWidth = 6;\n      VirtualJoystick.vjCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick.vjCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\n      VirtualJoystick.vjCanvasContext.stroke();\n      VirtualJoystick.vjCanvasContext.closePath();\n    }\n  };\n  /**\r\n   * Draws the Virtual Joystick's puck\r\n   */\n\n\n  VirtualJoystick.prototype._drawPuck = function () {\n    if (this._puckImage) {\n      VirtualJoystick.vjCanvasContext.drawImage(this._puckImage, this._joystickPointerPos.x - this.puckSize, this._joystickPointerPos.y - this.puckSize, this.puckSize * 2, this.puckSize * 2);\n    } else {\n      VirtualJoystick.vjCanvasContext.beginPath();\n      VirtualJoystick.vjCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick.vjCanvasContext.lineWidth = 2;\n      VirtualJoystick.vjCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\n      VirtualJoystick.vjCanvasContext.stroke();\n      VirtualJoystick.vjCanvasContext.closePath();\n    }\n  };\n\n  VirtualJoystick.prototype._drawVirtualJoystick = function () {\n    var _this = this;\n\n    if (this.alwaysVisible) {\n      this._drawContainer();\n    }\n\n    if (this.pressed) {\n      this._touches.forEach(function (key, touch) {\n        if (touch.pointerId === _this._joystickPointerID) {\n          if (!_this.alwaysVisible) {\n            _this._drawContainer();\n          }\n\n          _this._drawPuck(); // store current pointer for next clear\n\n\n          _this._joystickPreviousPointerPos = _this._joystickPointerPos.clone();\n        } else {\n          VirtualJoystick.vjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n          VirtualJoystick.vjCanvasContext.beginPath();\n          VirtualJoystick.vjCanvasContext.fillStyle = \"white\";\n          VirtualJoystick.vjCanvasContext.beginPath();\n          VirtualJoystick.vjCanvasContext.strokeStyle = \"red\";\n          VirtualJoystick.vjCanvasContext.lineWidth = 6;\n          VirtualJoystick.vjCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\n          VirtualJoystick.vjCanvasContext.stroke();\n          VirtualJoystick.vjCanvasContext.closePath();\n          touch.prevX = touch.x;\n          touch.prevY = touch.y;\n        }\n      });\n    }\n\n    requestAnimationFrame(function () {\n      _this._drawVirtualJoystick();\n    });\n  };\n  /**\r\n   * Release internal HTML canvas\r\n   */\n\n\n  VirtualJoystick.prototype.releaseCanvas = function () {\n    if (VirtualJoystick.Canvas) {\n      VirtualJoystick.Canvas.removeEventListener('pointerdown', this._onPointerDownHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener('pointermove', this._onPointerMoveHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener('pointerup', this._onPointerUpHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener('pointerout', this._onPointerUpHandlerRef);\n      window.removeEventListener(\"resize\", this._onResize);\n      document.body.removeChild(VirtualJoystick.Canvas);\n      VirtualJoystick.Canvas = null;\n    }\n  }; // Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\n\n\n  VirtualJoystick._globalJoystickIndex = 0;\n  VirtualJoystick._alwaysVisibleSticks = 0;\n  return VirtualJoystick;\n}();\n\nexport { VirtualJoystick };","map":null,"metadata":{},"sourceType":"module"}