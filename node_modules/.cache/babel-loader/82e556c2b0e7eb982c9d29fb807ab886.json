{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/how_to/dynamictexture\r\n */\n\nvar DynamicTexture =\n/** @class */\nfunction (_super) {\n  __extends(DynamicTexture, _super);\n  /**\r\n   * Creates a DynamicTexture\r\n   * @param name defines the name of the texture\r\n   * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n   * @param scene defines the scene where you want the texture\r\n   * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n   * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n   * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n   */\n\n\n  function DynamicTexture(name, options, scene, generateMipMaps, samplingMode, format, invertY) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format) || this;\n\n    _this.name = name;\n    _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    _this._generateMipMaps = generateMipMaps;\n\n    var engine = _this._getEngine();\n\n    if (!engine) {\n      return _this;\n    }\n\n    if (options.getContext) {\n      _this._canvas = options;\n      _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n    } else {\n      _this._canvas = CanvasGenerator.CreateCanvas(1, 1);\n\n      if (options.width || options.width === 0) {\n        _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n      } else {\n        _this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\n      }\n    }\n\n    var textureSize = _this.getSize();\n\n    _this._canvas.width = textureSize.width;\n    _this._canvas.height = textureSize.height;\n    _this._context = _this._canvas.getContext(\"2d\");\n    return _this;\n  }\n  /**\r\n   * Get the current class name of the texture useful for serialization or dynamic coding.\r\n   * @returns \"DynamicTexture\"\r\n   */\n\n\n  DynamicTexture.prototype.getClassName = function () {\n    return \"DynamicTexture\";\n  };\n\n  Object.defineProperty(DynamicTexture.prototype, \"canRescale\", {\n    /**\r\n     * Gets the current state of canRescale\r\n     */\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DynamicTexture.prototype._recreate = function (textureSize) {\n    this._canvas.width = textureSize.width;\n    this._canvas.height = textureSize.height;\n    this.releaseInternalTexture();\n    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\n  };\n  /**\r\n   * Scales the texture\r\n   * @param ratio the scale factor to apply to both width and height\r\n   */\n\n\n  DynamicTexture.prototype.scale = function (ratio) {\n    var textureSize = this.getSize();\n    textureSize.width *= ratio;\n    textureSize.height *= ratio;\n\n    this._recreate(textureSize);\n  };\n  /**\r\n   * Resizes the texture\r\n   * @param width the new width\r\n   * @param height the new height\r\n   */\n\n\n  DynamicTexture.prototype.scaleTo = function (width, height) {\n    var textureSize = this.getSize();\n    textureSize.width = width;\n    textureSize.height = height;\n\n    this._recreate(textureSize);\n  };\n  /**\r\n   * Gets the context of the canvas used by the texture\r\n   * @returns the canvas context of the dynamic texture\r\n   */\n\n\n  DynamicTexture.prototype.getContext = function () {\n    return this._context;\n  };\n  /**\r\n   * Clears the texture\r\n   */\n\n\n  DynamicTexture.prototype.clear = function () {\n    var size = this.getSize();\n\n    this._context.fillRect(0, 0, size.width, size.height);\n  };\n  /**\r\n   * Updates the texture\r\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n   * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n   */\n\n\n  DynamicTexture.prototype.update = function (invertY, premulAlpha) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n\n    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, premulAlpha, this._format || undefined);\n  };\n  /**\r\n   * Draws text onto the texture\r\n   * @param text defines the text to be drawn\r\n   * @param x defines the placement of the text from the left\r\n   * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n   * @param font defines the font to be used with font-style, font-size, font-name\r\n   * @param color defines the color used for the text\r\n   * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n   * @param update defines whether texture is immediately update (default is true)\r\n   */\n\n\n  DynamicTexture.prototype.drawText = function (text, x, y, font, color, clearColor, invertY, update) {\n    if (update === void 0) {\n      update = true;\n    }\n\n    var size = this.getSize();\n\n    if (clearColor) {\n      this._context.fillStyle = clearColor;\n\n      this._context.fillRect(0, 0, size.width, size.height);\n    }\n\n    this._context.font = font;\n\n    if (x === null || x === undefined) {\n      var textSize = this._context.measureText(text);\n\n      x = (size.width - textSize.width) / 2;\n    }\n\n    if (y === null || y === undefined) {\n      var fontSize = parseInt(font.replace(/\\D/g, ''));\n      y = size.height / 2 + fontSize / 3.65;\n    }\n\n    this._context.fillStyle = color || \"\";\n\n    this._context.fillText(text, x, y);\n\n    if (update) {\n      this.update(invertY);\n    }\n  };\n  /**\r\n   * Clones the texture\r\n   * @returns the clone of the texture.\r\n   */\n\n\n  DynamicTexture.prototype.clone = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this;\n    }\n\n    var textureSize = this.getSize();\n    var newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // Dynamic Texture\n\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    return newTexture;\n  };\n  /**\r\n   * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n   * @returns a serialized dynamic texture object\r\n   */\n\n\n  DynamicTexture.prototype.serialize = function () {\n    var scene = this.getScene();\n\n    if (scene && !scene.isReady()) {\n      Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\n    }\n\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this._IsCanvasElement(this._canvas)) {\n      serializationObject.base64String = this._canvas.toDataURL();\n    }\n\n    serializationObject.invertY = this._invertY;\n    serializationObject.samplingMode = this.samplingMode;\n    return serializationObject;\n  };\n\n  DynamicTexture.prototype._IsCanvasElement = function (canvas) {\n    return canvas.toDataURL !== undefined;\n  };\n  /** @hidden */\n\n\n  DynamicTexture.prototype._rebuild = function () {\n    this.update();\n  };\n\n  return DynamicTexture;\n}(Texture);\n\nexport { DynamicTexture };","map":null,"metadata":{},"sourceType":"module"}