{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Tools } from \"./tools\";\n/**\r\n * This can help with recording videos from BabylonJS.\r\n * This is based on the available WebRTC functionalities of the browser.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_video\r\n */\n\nvar VideoRecorder =\n/** @class */\nfunction () {\n  /**\r\n   * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\r\n   * @param engine Defines the BabylonJS Engine you wish to record.\r\n   * @param options Defines options that can be used to customize the capture.\r\n   */\n  function VideoRecorder(engine, options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    if (!VideoRecorder.IsSupported(engine)) {\n      throw \"Your browser does not support recording so far.\";\n    }\n\n    var canvas = engine.getRenderingCanvas();\n\n    if (!canvas) {\n      throw \"The babylon engine must have a canvas to be recorded\";\n    }\n\n    this._canvas = canvas;\n    this._canvas.isRecording = false;\n    this._options = __assign(__assign({}, VideoRecorder._defaultOptions), options);\n\n    var stream = this._canvas.captureStream(this._options.fps);\n\n    if (this._options.audioTracks) {\n      for (var _i = 0, _a = this._options.audioTracks; _i < _a.length; _i++) {\n        var track = _a[_i];\n        stream.addTrack(track);\n      }\n    }\n\n    this._mediaRecorder = new MediaRecorder(stream, {\n      mimeType: this._options.mimeType\n    });\n    this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);\n    this._mediaRecorder.onerror = this._handleError.bind(this);\n    this._mediaRecorder.onstop = this._handleStop.bind(this);\n  }\n  /**\r\n   * Returns whether or not the VideoRecorder is available in your browser.\r\n   * @param engine Defines the Babylon Engine.\r\n   * @returns true if supported otherwise false.\r\n   */\n\n\n  VideoRecorder.IsSupported = function (engine) {\n    var canvas = engine.getRenderingCanvas();\n    return !!canvas && typeof canvas.captureStream === \"function\";\n  };\n\n  Object.defineProperty(VideoRecorder.prototype, \"isRecording\", {\n    /**\r\n     * True when a recording is already in progress.\r\n     */\n    get: function get() {\n      return !!this._canvas && this._canvas.isRecording;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Stops the current recording before the default capture timeout passed in the startRecording function.\r\n   */\n\n  VideoRecorder.prototype.stopRecording = function () {\n    if (!this._canvas || !this._mediaRecorder) {\n      return;\n    }\n\n    if (!this.isRecording) {\n      return;\n    }\n\n    this._canvas.isRecording = false;\n\n    this._mediaRecorder.stop();\n  };\n  /**\r\n   * Starts recording the canvas for a max duration specified in parameters.\r\n   * @param fileName Defines the name of the file to be downloaded when the recording stop.\r\n   * If null no automatic download will start and you can rely on the promise to get the data back.\r\n   * @param maxDuration Defines the maximum recording time in seconds.\r\n   * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\r\n   * @return A promise callback at the end of the recording with the video data in Blob.\r\n   */\n\n\n  VideoRecorder.prototype.startRecording = function (fileName, maxDuration) {\n    var _this = this;\n\n    if (fileName === void 0) {\n      fileName = \"babylonjs.webm\";\n    }\n\n    if (maxDuration === void 0) {\n      maxDuration = 7;\n    }\n\n    if (!this._canvas || !this._mediaRecorder) {\n      throw \"Recorder has already been disposed\";\n    }\n\n    if (this.isRecording) {\n      throw \"Recording already in progress\";\n    }\n\n    if (maxDuration > 0) {\n      setTimeout(function () {\n        _this.stopRecording();\n      }, maxDuration * 1000);\n    }\n\n    this._fileName = fileName;\n    this._recordedChunks = [];\n    this._resolve = null;\n    this._reject = null;\n    this._canvas.isRecording = true;\n\n    this._mediaRecorder.start(this._options.recordChunckSize);\n\n    return new Promise(function (resolve, reject) {\n      _this._resolve = resolve;\n      _this._reject = reject;\n    });\n  };\n  /**\r\n   * Releases internal resources used during the recording.\r\n   */\n\n\n  VideoRecorder.prototype.dispose = function () {\n    this._canvas = null;\n    this._mediaRecorder = null;\n    this._recordedChunks = [];\n    this._fileName = null;\n    this._resolve = null;\n    this._reject = null;\n  };\n\n  VideoRecorder.prototype._handleDataAvailable = function (event) {\n    if (event.data.size > 0) {\n      this._recordedChunks.push(event.data);\n    }\n  };\n\n  VideoRecorder.prototype._handleError = function (event) {\n    this.stopRecording();\n\n    if (this._reject) {\n      this._reject(event.error);\n    } else {\n      throw new event.error();\n    }\n  };\n\n  VideoRecorder.prototype._handleStop = function () {\n    this.stopRecording();\n    var superBuffer = new Blob(this._recordedChunks);\n\n    if (this._resolve) {\n      this._resolve(superBuffer);\n    }\n\n    window.URL.createObjectURL(superBuffer);\n\n    if (this._fileName) {\n      Tools.Download(superBuffer, this._fileName);\n    }\n  };\n\n  VideoRecorder._defaultOptions = {\n    mimeType: \"video/webm\",\n    fps: 25,\n    recordChunckSize: 3000\n  };\n  return VideoRecorder;\n}();\n\nexport { VideoRecorder };","map":null,"metadata":{},"sourceType":"module"}