{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { MaterialHelper } from '../../../materialHelper';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport \"../../../../Shaders/ShadersInclude/bonesDeclaration\";\nimport \"../../../../Shaders/ShadersInclude/bonesVertex\";\n/**\r\n * Block used to add support for vertex skinning (bones)\r\n */\n\nvar BonesBlock =\n/** @class */\nfunction (_super) {\n  __extends(BonesBlock, _super);\n  /**\r\n   * Creates a new BonesBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function BonesBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Vertex) || this;\n\n    _this.registerInput(\"matricesIndices\", NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this.registerInput(\"matricesWeights\", NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this.registerInput(\"matricesIndicesExtra\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n\n    _this.registerInput(\"matricesWeightsExtra\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n\n    _this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix);\n\n    _this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Matrix);\n\n    return _this;\n  }\n  /**\r\n   * Initialize the block and prepare the context for build\r\n   * @param state defines the state that will be used for the build\r\n   */\n\n\n  BonesBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"boneSampler\");\n\n    state._excludeVariableName(\"boneTextureWidth\");\n\n    state._excludeVariableName(\"mBones\");\n\n    state._excludeVariableName(\"BonesPerMesh\");\n  };\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  BonesBlock.prototype.getClassName = function () {\n    return \"BonesBlock\";\n  };\n\n  Object.defineProperty(BonesBlock.prototype, \"matricesIndices\", {\n    /**\r\n     * Gets the matrix indices input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BonesBlock.prototype, \"matricesWeights\", {\n    /**\r\n     * Gets the matrix weights input component\r\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BonesBlock.prototype, \"matricesIndicesExtra\", {\n    /**\r\n     * Gets the extra matrix indices input component\r\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BonesBlock.prototype, \"matricesWeightsExtra\", {\n    /**\r\n     * Gets the extra matrix weights input component\r\n     */\n    get: function get() {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BonesBlock.prototype, \"world\", {\n    /**\r\n     * Gets the world input component\r\n     */\n    get: function get() {\n      return this._inputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BonesBlock.prototype, \"output\", {\n    /**\r\n     * Gets the output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  BonesBlock.prototype.autoConfigure = function (material) {\n    if (!this.matricesIndices.isConnected) {\n      var matricesIndicesInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"matricesIndices\";\n      });\n\n      if (!matricesIndicesInput) {\n        matricesIndicesInput = new InputBlock(\"matricesIndices\");\n        matricesIndicesInput.setAsAttribute(\"matricesIndices\");\n      }\n\n      matricesIndicesInput.output.connectTo(this.matricesIndices);\n    }\n\n    if (!this.matricesWeights.isConnected) {\n      var matricesWeightsInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"matricesWeights\";\n      });\n\n      if (!matricesWeightsInput) {\n        matricesWeightsInput = new InputBlock(\"matricesWeights\");\n        matricesWeightsInput.setAsAttribute(\"matricesWeights\");\n      }\n\n      matricesWeightsInput.output.connectTo(this.matricesWeights);\n    }\n\n    if (!this.world.isConnected) {\n      var worldInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.World;\n      });\n\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n\n      worldInput.output.connectTo(this.world);\n    }\n  };\n\n  BonesBlock.prototype.provideFallbacks = function (mesh, fallbacks) {\n    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      fallbacks.addCPUSkinningFallback(0, mesh);\n    }\n  };\n\n  BonesBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    MaterialHelper.BindBonesParameters(mesh, effect);\n  };\n\n  BonesBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areAttributesDirty) {\n      return;\n    }\n\n    MaterialHelper.PrepareDefinesForBones(mesh, defines);\n  };\n\n  BonesBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state); // Register for compilation fallbacks\n\n\n    state.sharedData.blocksWithFallbacks.push(this); // Register for binding\n\n    state.sharedData.bindableBlocks.push(this); // Register for defines\n\n    state.sharedData.blocksWithDefines.push(this); // Register internal uniforms and samplers\n\n    state.uniforms.push(\"boneTextureWidth\");\n    state.uniforms.push(\"mBones\");\n    state.samplers.push(\"boneSampler\"); // Emit code\n\n    var comments = \"//\" + this.name;\n\n    state._emitFunctionFromInclude(\"bonesDeclaration\", comments, {\n      removeAttributes: true,\n      removeUniforms: false,\n      removeVaryings: true,\n      removeIfDef: false\n    });\n\n    var influenceVariablename = state._getFreeVariableName(\"influence\");\n\n    state.compilationString += state._emitCodeFromInclude(\"bonesVertex\", comments, {\n      replaceStrings: [{\n        search: /finalWorld=finalWorld\\*influence;/,\n        replace: \"\"\n      }, {\n        search: /influence/gm,\n        replace: influenceVariablename\n      }]\n    });\n    var output = this._outputs[0];\n    var worldInput = this.world;\n    state.compilationString += \"#if NUM_BONE_INFLUENCERS>0\\r\\n\";\n    state.compilationString += this._declareOutput(output, state) + (\" = \" + worldInput.associatedVariableName + \" * \" + influenceVariablename + \";\\r\\n\");\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += this._declareOutput(output, state) + (\" = \" + worldInput.associatedVariableName + \";\\r\\n\");\n    state.compilationString += \"#endif\\r\\n\";\n    return this;\n  };\n\n  return BonesBlock;\n}(NodeMaterialBlock);\n\nexport { BonesBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.BonesBlock\"] = BonesBlock;","map":null,"metadata":{},"sourceType":"module"}