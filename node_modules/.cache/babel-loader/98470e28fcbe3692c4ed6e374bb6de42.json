{"ast":null,"code":"import _classCallCheck from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _toConsumableArray from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { urlClean, logger } from '@0xsequence/utils';\nimport { ethers } from 'ethers';\nimport { JsonRpcProvider } from '@ethersproject/providers';\n\nfunction isNetworkConfig(cand) {\n  return cand && cand.chainId !== undefined && cand.name !== undefined && cand.rpcUrl !== undefined && cand.relayer !== undefined;\n}\n\nvar getNetworkId = function getNetworkId(chainId) {\n  if (typeof chainId === 'number') {\n    return chainId;\n  }\n\n  if (chainId.chainId) {\n    return chainId.chainId;\n  }\n\n  return ethers.BigNumber.from(chainId).toNumber();\n};\n\nvar maybeNetworkId = function maybeNetworkId(chainId) {\n  if (!chainId) return undefined;\n  return getNetworkId(chainId);\n};\n\nvar getAuthNetwork = function getAuthNetwork(networks) {\n  if (!networks || networks.length === 0) return undefined;\n  if (networks[0] && networks[0].isAuthChain) return networks[0];\n  if (networks.length > 1 && networks[1].isAuthChain) return networks[1];\n  return undefined;\n};\n\nvar isValidNetworkConfig = function isValidNetworkConfig(networkConfig) {\n  var raise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var skipRelayerCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!networkConfig) throw new Error(\"invalid network config: empty config\");\n  var configs = [];\n\n  if (Array.isArray(networkConfig)) {\n    configs.push.apply(configs, _toConsumableArray(networkConfig));\n  } else {\n    configs.push(networkConfig);\n  }\n\n  if (configs.length === 0) {\n    if (raise) throw new Error(\"invalid network config: empty config\");\n    return false;\n  } // Ensure distinct chainId configs\n\n\n  var chainIds = configs.map(function (c) {\n    return c.chainId;\n  }).sort();\n  var dupes = chainIds.filter(function (c, i) {\n    return chainIds.indexOf(c) !== i;\n  });\n\n  if (dupes.length > 0) {\n    if (raise) throw new Error(\"invalid network config: duplicate chainIds \".concat(dupes));\n    return false;\n  } // Downcase all network names\n\n\n  configs.forEach(function (c) {\n    return c.name = c.name.toLowerCase();\n  }); // Ensure distinct network names\n\n  var names = configs.map(function (c) {\n    return c.name;\n  }).sort();\n  var nameDupes = names.filter(function (c, i) {\n    return names.indexOf(c) !== i;\n  });\n\n  if (nameDupes.length > 0) {\n    if (raise) throw new Error(\"invalid network config: duplicate network names \".concat(nameDupes));\n    return false;\n  } // Ensure rpcUrl or provider is specified\n  // Ensure relayerUrl or relayer is specified\n  // Ensure one default chain\n  // Ensure one auth chain\n\n\n  var defaultChain = false;\n  var authChain = false;\n\n  for (var i = 0; i < configs.length; i++) {\n    var c = configs[i];\n\n    if ((!c.rpcUrl || c.rpcUrl === '') && !c.provider) {\n      if (raise) throw new Error(\"invalid network config for chainId \".concat(c.chainId, \": rpcUrl or provider must be provided\"));\n      return false;\n    }\n\n    if (!skipRelayerCheck) {\n      if (!c.relayer) {\n        if (raise) throw new Error(\"invalid network config for chainId \".concat(c.chainId, \": relayer must be provided\"));\n        return false;\n      }\n    }\n\n    if (c.isDefaultChain) {\n      if (defaultChain) {\n        if (raise) throw new Error(\"invalid network config for chainId \".concat(c.chainId, \": DefaultChain is already set by another config\"));\n        return false;\n      }\n\n      defaultChain = true;\n    }\n\n    if (c.isAuthChain) {\n      if (authChain) {\n        if (raise) throw new Error(\"invalid network config for chainId \".concat(c.chainId, \": AuthChain is already set by another config\"));\n      }\n\n      authChain = true;\n    }\n  }\n\n  if (!defaultChain) {\n    if (raise) throw new Error(\"invalid network config: DefaultChain must be set\");\n    return false;\n  }\n\n  if (!authChain) {\n    if (raise) throw new Error(\"invalid network config: AuthChain must be set\");\n    return false;\n  }\n\n  return true;\n};\n\nvar ensureValidNetworks = function ensureValidNetworks(networks) {\n  var skipRelayerCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  isValidNetworkConfig(networks, true, skipRelayerCheck);\n  return networks;\n};\n\nvar ensureUniqueNetworks = function ensureUniqueNetworks(networks) {\n  var raise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var chainIds = networks.map(function (c) {\n    return c.chainId;\n  }).sort();\n  var dupes = chainIds.filter(function (c, i) {\n    return chainIds.indexOf(c) !== i;\n  });\n\n  if (dupes.length > 0) {\n    if (raise) throw new Error(\"invalid network config: duplicate chainIds \".concat(dupes));\n    return false;\n  }\n\n  return true;\n}; // sortNetworks orders the network config list by: defaultChain, authChain, ..rest by chainId ascending numbers\n\n\nvar sortNetworks = function sortNetworks(networks, defaultChainId) {\n  if (!networks) return [];\n  var config = networks.sort(function (a, b) {\n    if (a.chainId === b.chainId) return 0;\n    return a.chainId < b.chainId ? -1 : 1;\n  }); // Set defaultChainId if passed to set default chain\n\n  if (defaultChainId) {\n    var found = false;\n    networks.forEach(function (n) {\n      n.isDefaultChain = false;\n\n      if (n.name === defaultChainId || n.chainId === defaultChainId) {\n        found = true;\n        n.isDefaultChain = true;\n      }\n    });\n\n    if (!found) {\n      throw new Error(\"unable to set default network as chain '\".concat(defaultChainId, \"' does not exist\"));\n    }\n  } // // AuthChain goes first\n  // const authConfigIdx = config.findIndex(c => c.isAuthChain)\n  // if (authConfigIdx > 0) config.splice(0, 0, config.splice(authConfigIdx, 1)[0])\n  // // DefaultChain goes second\n  // const defaultConfigIdx = config.findIndex(c => c.isDefaultChain && c.isAuthChain !== true)\n  // if (defaultConfigIdx > 0) config.splice(1, 0, config.splice(defaultConfigIdx, 1)[0])\n  // DefaultChain goes first\n\n\n  var defaultConfigIdx = config.findIndex(function (c) {\n    return c.isDefaultChain;\n  });\n  if (defaultConfigIdx > 0) config.splice(0, 0, config.splice(defaultConfigIdx, 1)[0]); // AuthChain goes second\n\n  var authConfigIdx = config.findIndex(function (c) {\n    return c.isAuthChain && c.isDefaultChain !== true;\n  });\n  if (authConfigIdx > 0) config.splice(1, 0, config.splice(authConfigIdx, 1)[0]);\n  return config;\n};\n\nvar updateNetworkConfig = function updateNetworkConfig(src, dest) {\n  if (!src || !dest) return;\n\n  if (!src.chainId && !src.name) {\n    throw new Error('failed to update network config: source config is missing chainId or name');\n  }\n\n  if (src.chainId !== dest.chainId && src.name !== dest.name) {\n    throw new Error('failed to update network config: one of chainId or name must match');\n  }\n\n  if (src.rpcUrl) {\n    dest.rpcUrl = src.rpcUrl;\n    dest.provider = undefined;\n  }\n\n  if (src.provider) {\n    dest.provider = src.provider;\n  }\n\n  if (src.relayer) {\n    dest.relayer = src.relayer;\n  }\n\n  if (src.ensAddress) {\n    dest.ensAddress = src.ensAddress;\n  } // NOTE: we do not set default or auth chain from here\n  // if (src.isDefaultChain) {\n  //   dest.isDefaultChain = src.isDefaultChain\n  // }\n  // if (src.isAuthChain) {\n  //   dest.isAuthChain = src.isAuthChain\n  // }\n\n};\n\nvar createNetworkConfig = function createNetworkConfig(networks, defaultChainId, vars) {\n  var config = [];\n\n  if (typeof networks === 'function' && vars) {\n    config = networks(vars);\n  } else {\n    config = networks;\n  }\n\n  if (defaultChainId) {\n    config.forEach(function (n) {\n      return n.isDefaultChain = false;\n    });\n    var mainNetwork = config.filter(function (n) {\n      return n.chainId === defaultChainId;\n    });\n\n    if (!mainNetwork || mainNetwork.length === 0) {\n      throw new Error(\"defaultChainId \".concat(defaultChainId, \" cannot be found in network list\"));\n    } else {\n      mainNetwork[0].isDefaultChain = true;\n    }\n  }\n\n  return ensureValidNetworks(sortNetworks(config));\n};\n\nvar findNetworkConfig = function findNetworkConfig(networks, chainId) {\n  if (typeof chainId === 'string') {\n    if (chainId.startsWith('0x')) {\n      var id = ethers.BigNumber.from(chainId).toNumber();\n      return networks.find(function (n) {\n        return n.chainId === id;\n      });\n    } else {\n      return networks.find(function (n) {\n        return n.name === chainId;\n      });\n    }\n  } else if (typeof chainId === 'number') {\n    return networks.find(function (n) {\n      return n.chainId === chainId;\n    });\n  } else if (chainId.chainId) {\n    return networks.find(function (n) {\n      return n.chainId === chainId.chainId;\n    });\n  } else {\n    return undefined;\n  }\n};\n\nvar checkNetworkConfig = function checkNetworkConfig(network, networkId) {\n  if (!network) return false;\n  if (network.name === networkId) return true;\n  if (network.chainId === networkId) return true;\n  return false;\n};\n\nvar networksIndex = function networksIndex(networks) {\n  var index = {};\n\n  for (var i = 0; i < networks.length; i++) {\n    index[networks[i].name] = networks[i];\n  }\n\n  return index;\n};\n\nvar mainnetNetworks = createNetworkConfig(function (vars) {\n  return [{\n    title: 'Ethereum',\n    name: 'mainnet',\n    chainId: 1,\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n    rpcUrl: urlClean(\"\".concat(vars.baseRpcUrl, \"/mainnet\")),\n    relayer: {\n      url: urlClean(\"\".concat(vars.baseRelayerUrl, \"/mainnet\"))\n    },\n    isDefaultChain: true\n  }, {\n    title: 'Matic',\n    name: 'matic',\n    chainId: 137,\n    rpcUrl: 'https://rpc-mainnet.matic.network',\n    relayer: {\n      url: urlClean(\"\".concat(vars.baseRelayerUrl, \"/matic\"))\n    },\n    isAuthChain: true\n  }];\n}, 1, {\n  baseRpcUrl: 'https://nodes.sequence.app',\n  baseRelayerUrl: 'https://relayers.sequence.app'\n});\nvar testnetNetworks = createNetworkConfig(function (vars) {\n  return [{\n    name: 'rinkeby',\n    chainId: 4,\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n    rpcUrl: urlClean(\"\".concat(vars.baseRpcUrl, \"/rinkeby\")),\n    relayer: {\n      url: urlClean(\"\".concat(vars.baseRelayerUrl, \"/rinkeby\"))\n    },\n    isDefaultChain: true\n  }, {\n    name: 'goerli',\n    chainId: 5,\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n    rpcUrl: urlClean(\"\".concat(vars.baseRpcUrl, \"/goerli\")),\n    relayer: {\n      url: urlClean(\"\".concat(vars.baseRelayerUrl, \"/goerli\"))\n    },\n    isAuthChain: true\n  } // {\n  //   name: 'ropsten',\n  //   chainId: 3,\n  //   ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n  //   rpcUrl: '',\n  //   // relayer: null\n  // },\n  // {\n  //   name: 'kovan',\n  //   chainId: 42,\n  //   rpcUrl: '',\n  //   relayer: null\n  // },\n  // {\n  //   name: 'mumbai',\n  //   chainId: 80001,\n  //   rpcUrl: 'https://rpc-mumbai.matic.today',\n  //   relayer: null\n  // }\n  ];\n}, undefined, {\n  baseRpcUrl: 'https://nodes.sequence.app',\n  baseRelayerUrl: 'https://relayers.sequence.app'\n}); // export const mainnetNetworksIndex = networksIndex(mainnetNetworks)\n// export const testnetNetworksIndex = networksIndex(testnetNetworks)\n// WalletContext is the module addresses deployed on a network, aka the context / environment\n// of the Sequence Smart Wallet system on Ethereum.\n// sequenceContext are the deployed addresses of modules available on public networks.\n\nvar sequenceContext = {\n  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',\n  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',\n  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',\n  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',\n  sequenceUtils: '0xd130B43062D875a4B7aF3f8fc036Bc6e9D3E1B3E'\n};\nvar JsonRpcVersion = '2.0';\n\nvar JsonRpcRouter = /*#__PURE__*/function () {\n  function JsonRpcRouter(middlewares, sender) {\n    _classCallCheck(this, JsonRpcRouter);\n\n    this.sender = void 0;\n    this.handler = void 0;\n    this.sender = sender;\n\n    if (middlewares) {\n      this.setMiddleware(middlewares);\n    }\n  }\n\n  _createClass(JsonRpcRouter, [{\n    key: \"setMiddleware\",\n    value: function setMiddleware(middlewares) {\n      this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender.sendAsync);\n    }\n  }, {\n    key: \"sendAsync\",\n    value: function sendAsync(request, callback, chainId) {\n      try {\n        this.handler(request, callback, chainId);\n      } catch (err) {\n        callback(err, undefined);\n      }\n    } // createWeb3Provider(network?: Networkish): EthersWeb3Provider {\n    //   return new EthersWeb3Provider(this.sender, network)\n    // }\n\n  }]);\n\n  return JsonRpcRouter;\n}();\n\nvar createJsonRpcMiddlewareStack = function createJsonRpcMiddlewareStack(middlewares, handler) {\n  if (middlewares.length === 0) return handler;\n\n  var toMiddleware = function toMiddleware(v) {\n    if (v.sendAsyncMiddleware) {\n      return v.sendAsyncMiddleware;\n    } else {\n      return v;\n    }\n  };\n\n  var chain;\n  chain = toMiddleware(middlewares[middlewares.length - 1])(handler);\n\n  for (var i = middlewares.length - 2; i >= 0; i--) {\n    chain = toMiddleware(middlewares[i])(chain);\n  }\n\n  return chain;\n};\n\nfunction isJsonRpcProvider(cand) {\n  return cand !== undefined && cand.send !== undefined && cand.constructor.defaultUrl !== undefined && cand.detectNetwork !== undefined && cand.getSigner !== undefined && cand.perform !== undefined;\n}\n\nfunction isJsonRpcHandler(cand) {\n  return cand !== undefined && cand.sendAsync !== undefined;\n}\n\nvar _nextId = 0;\n\nvar JsonRpcSender = function JsonRpcSender(provider, defaultChainId) {\n  var _this = this;\n\n  _classCallCheck(this, JsonRpcSender);\n\n  this.send = void 0;\n  this.request = void 0;\n  this.defaultChainId = void 0;\n\n  this.sendAsync = function (request, callback, chainId) {\n    _this.send(request.method, request.params, chainId || _this.defaultChainId).then(function (r) {\n      callback(undefined, {\n        jsonrpc: '2.0',\n        id: request.id,\n        result: r\n      });\n    }).catch(function (e) {\n      callback(e, undefined);\n    });\n  };\n\n  this.defaultChainId = defaultChainId;\n\n  if (isJsonRpcProvider(provider)) {\n    // we can ignore defaultChainId for JsonRpcProviders as they are already chain-bound\n    this.send = provider.send.bind(provider);\n  } else if (isJsonRpcHandler(provider)) {\n    this.send = function (method, params, chainId) {\n      return new Promise(function (resolve, reject) {\n        provider.sendAsync({\n          // TODO: really shouldn't have to set these here?\n          jsonrpc: JsonRpcVersion,\n          id: ++_nextId,\n          method: method,\n          params: params\n        }, function (error, response) {\n          if (error) {\n            reject(error);\n          } else if (response) {\n            resolve(response.result);\n          } else {\n            resolve(undefined);\n          }\n        }, chainId || _this.defaultChainId);\n      });\n    };\n  } else {\n    this.send = provider;\n  }\n\n  this.request = function (request, chainId) {\n    return _this.send(request.method, request.params, chainId);\n  };\n};\n\nvar JsonRpcExternalProvider = function JsonRpcExternalProvider(provider) {\n  var _this2 = this;\n\n  _classCallCheck(this, JsonRpcExternalProvider);\n\n  this.provider = provider;\n\n  this.sendAsync = function (request, callback) {\n    _this2.provider.send(request.method, request.params).then(function (r) {\n      callback(undefined, {\n        jsonrpc: '2.0',\n        id: request.id,\n        result: r\n      });\n    }).catch(function (e) {\n      callback(e, undefined);\n    });\n  };\n\n  this.send = this.sendAsync;\n};\n\nvar AllowProvider = /*#__PURE__*/function () {\n  function AllowProvider(isAllowedFunc) {\n    _classCallCheck(this, AllowProvider);\n\n    this.sendAsyncMiddleware = void 0;\n    this.isAllowedFunc = void 0;\n\n    if (isAllowedFunc) {\n      this.isAllowedFunc = isAllowedFunc;\n    } else {\n      this.isAllowedFunc = function (request) {\n        return true;\n      };\n    }\n\n    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);\n  }\n\n  _createClass(AllowProvider, [{\n    key: \"setIsAllowedFunc\",\n    value: function setIsAllowedFunc(fn) {\n      this.isAllowedFunc = fn;\n      this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);\n    }\n  }]);\n\n  return AllowProvider;\n}();\n\nvar allowProviderMiddleware = function allowProviderMiddleware(isAllowed) {\n  return function (next) {\n    return function (request, callback, chainId) {\n      // ensure precondition is met or do not allow the request to continue\n      if (!isAllowed(request)) {\n        throw new Error('allowProvider middleware precondition is unmet.');\n      } // request is allowed. keep going..\n\n\n      next(request, callback, chainId);\n    };\n  };\n};\n\nvar CachedProvider = /*#__PURE__*/function () {\n  function CachedProvider(defaultChainId) {\n    var _this3 = this;\n\n    _classCallCheck(this, CachedProvider);\n\n    this.cachableJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', 'sequence_getWalletContext', 'sequence_getNetworks'];\n    this.cache = void 0;\n    this.onUpdateCallback = void 0;\n    this.defaultChainId = void 0;\n\n    this.sendAsyncMiddleware = function (next) {\n      return function (request, callback, chainId) {\n        // Respond early with cached result\n        if (_this3.cachableJsonRpcMethods.includes(request.method)) {\n          var key = _this3.cacheKey(request.method, request.params, chainId || _this3.defaultChainId);\n\n          var result = _this3.getCacheValue(key);\n\n          if (result && result !== '') {\n            callback(undefined, {\n              jsonrpc: '2.0',\n              id: request.id,\n              result: result\n            });\n            return;\n          }\n        } // Continue down the handler chain\n\n\n        next(request, function (error, response, chainId) {\n          // Store result in cache and continue\n          if (_this3.cachableJsonRpcMethods.includes(request.method)) {\n            if (response && response.result) {\n              var _key = _this3.cacheKey(request.method, request.params, chainId || _this3.defaultChainId);\n\n              _this3.setCacheValue(_key, response.result);\n            }\n          } // Exec next handler\n\n\n          callback(error, response);\n        }, chainId || _this3.defaultChainId);\n      };\n    };\n\n    this.cacheKey = function (method, params, chainId) {\n      var key = '';\n\n      if (chainId) {\n        key = \"\".concat(chainId, \":\").concat(method, \":\");\n      } else {\n        key = \":\".concat(method, \":\");\n      }\n\n      if (!params || params.length === 0) {\n        return key + '[]';\n      }\n\n      return key + JSON.stringify(params);\n    };\n\n    this.getCache = function () {\n      return _this3.cache;\n    };\n\n    this.setCache = function (cache) {\n      _this3.cache = cache;\n\n      if (_this3.onUpdateCallback) {\n        _this3.onUpdateCallback();\n      }\n    };\n\n    this.getCacheValue = function (key) {\n      return _this3.cache[key];\n    };\n\n    this.setCacheValue = function (key, value) {\n      _this3.cache[key] = value;\n\n      if (_this3.onUpdateCallback) {\n        _this3.onUpdateCallback(key, value);\n      }\n    };\n\n    this.clearCache = function () {\n      _this3.cache = {};\n    };\n\n    this.cache = {};\n    this.defaultChainId = defaultChainId;\n  }\n\n  _createClass(CachedProvider, [{\n    key: \"onUpdate\",\n    value: function onUpdate(callback) {\n      this.onUpdateCallback = callback;\n    }\n  }]);\n\n  return CachedProvider;\n}();\n\nvar EagerProvider = function EagerProvider(props) {\n  var _this4 = this;\n\n  _classCallCheck(this, EagerProvider);\n\n  this.props = void 0;\n\n  this.sendAsyncMiddleware = function (next) {\n    return function (request, callback, chainId) {\n      var id = request.id,\n          method = request.method;\n\n      switch (method) {\n        case 'net_version':\n          if (_this4.props.chainId) {\n            callback(undefined, {\n              jsonrpc: '2.0',\n              id: id,\n              result: \"\".concat(_this4.props.chainId)\n            });\n            return;\n          }\n\n          break;\n\n        case 'eth_chainId':\n          if (_this4.props.chainId) {\n            callback(undefined, {\n              jsonrpc: '2.0',\n              id: id,\n              result: ethers.utils.hexlify(_this4.props.chainId)\n            });\n            return;\n          }\n\n          break;\n\n        case 'eth_accounts':\n          if (_this4.props.accountAddress) {\n            callback(undefined, {\n              jsonrpc: '2.0',\n              id: id,\n              result: [ethers.utils.getAddress(_this4.props.accountAddress)]\n            });\n            return;\n          }\n\n          break;\n\n        case 'sequence_getWalletContext':\n          if (_this4.props.walletContext) {\n            callback(undefined, {\n              jsonrpc: '2.0',\n              id: id,\n              result: _this4.props.walletContext\n            });\n            return;\n          }\n\n          break;\n      }\n\n      next(request, callback, chainId);\n    };\n  };\n\n  this.props = props;\n};\n\nvar exceptionProviderMiddleware = function exceptionProviderMiddleware(next) {\n  return function (request, callback, chainId) {\n    next(request, function (error, response) {\n      if (!error && response && response.error) {\n        if (typeof response.error === 'string') {\n          throw new Error(response.error);\n        } else {\n          throw new Error(response.error.data);\n        }\n      }\n\n      callback(error, response);\n    }, chainId);\n  };\n};\n\nvar loggingProviderMiddleware = function loggingProviderMiddleware(next) {\n  return function (request, callback, chainId) {\n    var chainIdLabel = chainId ? \" chainId:\".concat(chainId) : '';\n    console.log(\"[provider request]\".concat(chainIdLabel, \" id:\").concat(request.id, \" method:\").concat(request.method, \" params:\"), request.params);\n    next(request, function (error, response) {\n      if (error) {\n        console.warn(\"[provider response]\".concat(chainIdLabel, \" id:\").concat(request.id, \" method:\").concat(request.method, \" params:\"), request.params, \"error:\", error);\n      } else {\n        console.log(\"[provider response]\".concat(chainIdLabel, \" id:\").concat(request.id, \" method:\").concat(request.method, \" params:\"), request.params, \"response:\", response);\n      }\n\n      callback(error, response);\n    }, chainId);\n  };\n};\n\nvar networkProviderMiddleware = function networkProviderMiddleware(getChainId) {\n  return function (next) {\n    return function (request, callback, chainId) {\n      var networkChainId = getChainId(request);\n      var id = request.id,\n          method = request.method;\n\n      switch (method) {\n        case 'net_version':\n          callback(undefined, {\n            jsonrpc: '2.0',\n            id: id,\n            result: \"\".concat(networkChainId)\n          });\n          return;\n\n        case 'eth_chainId':\n          callback(undefined, {\n            jsonrpc: '2.0',\n            id: id,\n            result: ethers.utils.hexlify(networkChainId)\n          });\n          return;\n      } // request is allowed. keep going..\n\n\n      next(request, callback, chainId);\n    };\n  };\n};\n\nvar SignerJsonRpcMethods = ['personal_sign', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v4', 'eth_sendTransaction', 'eth_sendRawTransaction', 'sequence_getWalletContext', 'sequence_getWalletConfig', 'sequence_getWalletState', 'sequence_getNetworks', 'sequence_updateConfig', 'sequence_publishConfig', 'sequence_estimateGasLimits', 'sequence_gasRefundOptions', 'sequence_getNonce', 'sequence_relay'];\n\nvar SigningProvider = function SigningProvider(provider) {\n  var _this5 = this;\n\n  _classCallCheck(this, SigningProvider);\n\n  this.provider = void 0;\n\n  this.sendAsyncMiddleware = function (next) {\n    return function (request, callback, chainId) {\n      // Forward signing requests to the signing provider\n      if (SignerJsonRpcMethods.includes(request.method)) {\n        _this5.provider.sendAsync(request, callback, chainId);\n\n        return;\n      } // Continue to next handler\n\n\n      next(request, callback, chainId);\n    };\n  };\n\n  this.provider = provider;\n};\n\nvar PublicProvider = /*#__PURE__*/function () {\n  function PublicProvider(rpcUrl) {\n    var _this6 = this;\n\n    _classCallCheck(this, PublicProvider);\n\n    this.privateJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts'].concat(SignerJsonRpcMethods);\n    this.provider = void 0;\n    this.rpcUrl = void 0;\n\n    this.sendAsyncMiddleware = function (next) {\n      return function (request, callback) {\n        // When provider is configured, send non-private methods to our local public provider\n        if (_this6.provider && !_this6.privateJsonRpcMethods.includes(request.method)) {\n          _this6.provider.send(request.method, request.params).then(function (r) {\n            callback(undefined, {\n              jsonrpc: '2.0',\n              id: request.id,\n              result: r\n            });\n          }).catch(function (e) {\n            return callback(e);\n          });\n\n          return;\n        } // Continue to next handler\n\n\n        logger.debug('[public-provider] sending request to signer window', request.method);\n        next(request, callback);\n      };\n    };\n\n    if (rpcUrl) {\n      this.setRpcUrl(rpcUrl);\n    }\n  }\n\n  _createClass(PublicProvider, [{\n    key: \"getRpcUrl\",\n    value: function getRpcUrl() {\n      return this.rpcUrl;\n    }\n  }, {\n    key: \"setRpcUrl\",\n    value: function setRpcUrl(rpcUrl) {\n      if (!rpcUrl || rpcUrl === '') {\n        this.rpcUrl = undefined;\n        this.provider = undefined;\n      } else {\n        this.rpcUrl = rpcUrl;\n        this.provider = new JsonRpcProvider(rpcUrl);\n      }\n    }\n  }]);\n\n  return PublicProvider;\n}();\n\nexport { AllowProvider, CachedProvider, EagerProvider, JsonRpcExternalProvider, JsonRpcRouter, JsonRpcSender, JsonRpcVersion, PublicProvider, SigningProvider, allowProviderMiddleware, checkNetworkConfig, createJsonRpcMiddlewareStack, createNetworkConfig, ensureUniqueNetworks, ensureValidNetworks, exceptionProviderMiddleware, findNetworkConfig, getAuthNetwork, getNetworkId, isJsonRpcHandler, isJsonRpcProvider, isNetworkConfig, isValidNetworkConfig, loggingProviderMiddleware, mainnetNetworks, maybeNetworkId, networkProviderMiddleware, networksIndex, sequenceContext, sortNetworks, testnetNetworks, updateNetworkConfig };","map":null,"metadata":{},"sourceType":"module"}