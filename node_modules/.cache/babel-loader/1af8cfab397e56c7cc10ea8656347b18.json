{"ast":null,"code":"import { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { Color3, Color4 } from '../Maths/math.color';\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { SerializationHelper } from \"../Misc/decorators\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { AnimationKeyInterpolation } from './animationKey';\nimport { AnimationRange } from './animationRange';\nimport { Node } from \"../node\";\nimport { Size } from '../Maths/math.size';\nimport { WebRequest } from '../Misc/webRequest';\n/**\r\n * @hidden\r\n */\n\nvar _IAnimationState =\n/** @class */\nfunction () {\n  function _IAnimationState() {}\n\n  return _IAnimationState;\n}();\n\nexport { _IAnimationState };\n/**\r\n * Class used to store any kind of animation\r\n */\n\nvar Animation =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the animation\r\n   * @param name Name of the animation\r\n   * @param targetProperty Property to animate\r\n   * @param framePerSecond The frames per second of the animation\r\n   * @param dataType The data type of the animation\r\n   * @param loopMode The loop mode of the animation\r\n   * @param enableBlending Specifies if blending should be enabled\r\n   */\n  function Animation(\n  /**Name of the animation */\n  name,\n  /**Property to animate */\n  targetProperty,\n  /**The frames per second of the animation */\n  framePerSecond,\n  /**The data type of the animation */\n  dataType,\n  /**The loop mode of the animation */\n  loopMode,\n  /**Specifies if blending should be enabled */\n  enableBlending) {\n    this.name = name;\n    this.targetProperty = targetProperty;\n    this.framePerSecond = framePerSecond;\n    this.dataType = dataType;\n    this.loopMode = loopMode;\n    this.enableBlending = enableBlending;\n    /**\r\n     * @hidden Internal use only\r\n     */\n\n    this._runtimeAnimations = new Array();\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\n\n    this._events = new Array();\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\n\n    this.blendingSpeed = 0.01;\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\n\n    this._ranges = {};\n    this.targetPropertyPath = targetProperty.split(\".\");\n    this.dataType = dataType;\n    this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\n  }\n  /**\r\n   * @hidden Internal use\r\n   */\n\n\n  Animation._PrepareAnimation = function (name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {\n    var dataType = undefined;\n\n    if (!isNaN(parseFloat(from)) && isFinite(from)) {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (from instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else if (from instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (from instanceof Vector2) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR2;\n    } else if (from instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (from instanceof Color4) {\n      dataType = Animation.ANIMATIONTYPE_COLOR4;\n    } else if (from instanceof Size) {\n      dataType = Animation.ANIMATIONTYPE_SIZE;\n    }\n\n    if (dataType == undefined) {\n      return null;\n    }\n\n    var animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\n    var keys = [{\n      frame: 0,\n      value: from\n    }, {\n      frame: totalFrame,\n      value: to\n    }];\n    animation.setKeys(keys);\n\n    if (easingFunction !== undefined) {\n      animation.setEasingFunction(easingFunction);\n    }\n\n    return animation;\n  };\n  /**\r\n   * Sets up an animation\r\n   * @param property The property to animate\r\n   * @param animationType The animation type to apply\r\n   * @param framePerSecond The frames per second of the animation\r\n   * @param easingFunction The easing function used in the animation\r\n   * @returns The created animation\r\n   */\n\n\n  Animation.CreateAnimation = function (property, animationType, framePerSecond, easingFunction) {\n    var animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setEasingFunction(easingFunction);\n    return animation;\n  };\n  /**\r\n   * Create and start an animation on a node\r\n   * @param name defines the name of the global animation that will be run on all nodes\r\n   * @param node defines the root node where the animation will take place\r\n   * @param targetProperty defines property to animate\r\n   * @param framePerSecond defines the number of frame per second yo use\r\n   * @param totalFrame defines the number of frames in total\r\n   * @param from defines the initial value\r\n   * @param to defines the final value\r\n   * @param loopMode defines which loop mode you want to use (off by default)\r\n   * @param easingFunction defines the easing function to use (linear by default)\r\n   * @param onAnimationEnd defines the callback to call when animation end\r\n   * @returns the animatable created for this animation\r\n   */\n\n\n  Animation.CreateAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    return node.getScene().beginDirectAnimation(node, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\r\n   * Create and start an animation on a node and its descendants\r\n   * @param name defines the name of the global animation that will be run on all nodes\r\n   * @param node defines the root node where the animation will take place\r\n   * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n   * @param targetProperty defines property to animate\r\n   * @param framePerSecond defines the number of frame per second to use\r\n   * @param totalFrame defines the number of frames in total\r\n   * @param from defines the initial value\r\n   * @param to defines the final value\r\n   * @param loopMode defines which loop mode you want to use (off by default)\r\n   * @param easingFunction defines the easing function to use (linear by default)\r\n   * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n   * @returns the list of animatables created for all nodes\r\n   * @example https://www.babylonjs-playground.com/#MH0VLI\r\n   */\n\n\n  Animation.CreateAndStartHierarchyAnimation = function (name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    var scene = node.getScene();\n    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\r\n   * Creates a new animation, merges it with the existing animations and starts it\r\n   * @param name Name of the animation\r\n   * @param node Node which contains the scene that begins the animations\r\n   * @param targetProperty Specifies which property to animate\r\n   * @param framePerSecond The frames per second of the animation\r\n   * @param totalFrame The total number of frames\r\n   * @param from The frame at the beginning of the animation\r\n   * @param to The frame at the end of the animation\r\n   * @param loopMode Specifies the loop mode of the animation\r\n   * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n   * @param onAnimationEnd Callback to run once the animation is complete\r\n   * @returns Nullable animation\r\n   */\n\n\n  Animation.CreateMergeAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    node.animations.push(animation);\n    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\r\n   * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n   * @param sourceAnimation defines the Animation containing keyframes to convert\r\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n   * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n   * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n   * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n   * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n   */\n\n\n  Animation.MakeAnimationAdditive = function (sourceAnimation, referenceFrame, range, cloneOriginal, clonedName) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    if (cloneOriginal === void 0) {\n      cloneOriginal = false;\n    }\n\n    var animation = sourceAnimation;\n\n    if (cloneOriginal) {\n      animation = sourceAnimation.clone();\n      animation.name = clonedName || animation.name;\n    }\n\n    if (!animation._keys.length) {\n      return animation;\n    }\n\n    referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\n    var startIndex = 0;\n    var firstKey = animation._keys[0];\n    var endIndex = animation._keys.length - 1;\n    var lastKey = animation._keys[endIndex];\n    var valueStore = {\n      referenceValue: firstKey.value,\n      referencePosition: TmpVectors.Vector3[0],\n      referenceQuaternion: TmpVectors.Quaternion[0],\n      referenceScaling: TmpVectors.Vector3[1],\n      keyPosition: TmpVectors.Vector3[2],\n      keyQuaternion: TmpVectors.Quaternion[1],\n      keyScaling: TmpVectors.Vector3[3]\n    };\n    var referenceFound = false;\n    var from = firstKey.frame;\n    var to = lastKey.frame;\n\n    if (range) {\n      var rangeValue = animation.getRange(range);\n\n      if (rangeValue) {\n        from = rangeValue.from;\n        to = rangeValue.to;\n      }\n    }\n\n    var fromKeyFound = firstKey.frame === from;\n    var toKeyFound = lastKey.frame === to; // There's only one key, so use it\n\n    if (animation._keys.length === 1) {\n      var value = animation._getKeyValue(animation._keys[0]);\n\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    } // Reference frame is before the first frame, so just use the first frame\n    else if (referenceFrame <= firstKey.frame) {\n      var value = animation._getKeyValue(firstKey.value);\n\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    } // Reference frame is after the last frame, so just use the last frame\n    else if (referenceFrame >= lastKey.frame) {\n      var value = animation._getKeyValue(lastKey.value);\n\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    } // Find key bookends, create them if they don't exist\n\n\n    var index = 0;\n\n    while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {\n      var currentKey = animation._keys[index];\n      var nextKey = animation._keys[index + 1]; // If reference frame wasn't found yet, check if we can interpolate to it\n\n      if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\n        var value = void 0;\n\n        if (referenceFrame === currentKey.frame) {\n          value = animation._getKeyValue(currentKey.value);\n        } else if (referenceFrame === nextKey.frame) {\n          value = animation._getKeyValue(nextKey.value);\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n          value = animation._interpolate(referenceFrame, animationState);\n        }\n\n        valueStore.referenceValue = value.clone ? value.clone() : value;\n        referenceFound = true;\n      } // If from key wasn't found yet, check if we can interpolate to it\n\n\n      if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\n        if (from === currentKey.frame) {\n          startIndex = index;\n        } else if (from === nextKey.frame) {\n          startIndex = index + 1;\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n\n          var value = animation._interpolate(from, animationState);\n\n          var key = {\n            frame: from,\n            value: value.clone ? value.clone() : value\n          };\n\n          animation._keys.splice(index + 1, 0, key);\n\n          startIndex = index + 1;\n        }\n\n        fromKeyFound = true;\n      } // If to key wasn't found yet, check if we can interpolate to it\n\n\n      if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\n        if (to === currentKey.frame) {\n          endIndex = index;\n        } else if (to === nextKey.frame) {\n          endIndex = index + 1;\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n\n          var value = animation._interpolate(to, animationState);\n\n          var key = {\n            frame: to,\n            value: value.clone ? value.clone() : value\n          };\n\n          animation._keys.splice(index + 1, 0, key);\n\n          endIndex = index + 1;\n        }\n\n        toKeyFound = true;\n      }\n\n      index++;\n    } // Conjugate the quaternion\n\n\n    if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\n      valueStore.referenceValue.normalize().conjugateInPlace();\n    } // Decompose matrix and conjugate the quaternion\n    else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\n      valueStore.referenceQuaternion.normalize().conjugateInPlace();\n    } // Subtract the reference value from all of the key values\n\n\n    for (var index = startIndex; index <= endIndex; index++) {\n      var key = animation._keys[index]; // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\n\n      if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\n        continue;\n      }\n\n      switch (animation.dataType) {\n        case Animation.ANIMATIONTYPE_MATRIX:\n          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\n          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\n          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\n          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\n          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          valueStore.referenceValue.multiplyToRef(key.value, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_VECTOR2:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.value.subtractToRef(valueStore.referenceValue, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_SIZE:\n          key.value.width -= valueStore.referenceValue.width;\n          key.value.height -= valueStore.referenceValue.height;\n          break;\n\n        default:\n          key.value -= valueStore.referenceValue;\n      }\n    }\n\n    return animation;\n  };\n  /**\r\n   * Transition property of an host to the target Value\r\n   * @param property The property to transition\r\n   * @param targetValue The target Value of the property\r\n   * @param host The object where the property to animate belongs\r\n   * @param scene Scene used to run the animation\r\n   * @param frameRate Framerate (in frame/s) to use\r\n   * @param transition The transition type we want to use\r\n   * @param duration The duration of the animation, in milliseconds\r\n   * @param onAnimationEnd Callback trigger at the end of the animation\r\n   * @returns Nullable animation\r\n   */\n\n\n  Animation.TransitionTo = function (property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd) {\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    if (duration <= 0) {\n      host[property] = targetValue;\n\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n\n      return null;\n    }\n\n    var endFrame = frameRate * (duration / 1000);\n    transition.setKeys([{\n      frame: 0,\n      value: host[property].clone ? host[property].clone() : host[property]\n    }, {\n      frame: endFrame,\n      value: targetValue\n    }]);\n\n    if (!host.animations) {\n      host.animations = [];\n    }\n\n    host.animations.push(transition);\n    var animation = scene.beginAnimation(host, 0, endFrame, false);\n    animation.onAnimationEnd = onAnimationEnd;\n    return animation;\n  };\n\n  Object.defineProperty(Animation.prototype, \"runtimeAnimations\", {\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\n    get: function get() {\n      return this._runtimeAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animation.prototype, \"hasRunningRuntimeAnimations\", {\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\n    get: function get() {\n      for (var _i = 0, _a = this._runtimeAnimations; _i < _a.length; _i++) {\n        var runtimeAnimation = _a[_i];\n\n        if (!runtimeAnimation.isStopped) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\r\n   * Converts the animation to a string\r\n   * @param fullDetails support for multiple levels of logging within scene loading\r\n   * @returns String form of the animation\r\n   */\n\n  Animation.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\n    ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\n    ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\n    ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      var first = true;\n\n      for (var name in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n\n        ret += name;\n      }\n\n      ret += \"}\";\n    }\n\n    return ret;\n  };\n  /**\r\n   * Add an event to this animation\r\n   * @param event Event to add\r\n   */\n\n\n  Animation.prototype.addEvent = function (event) {\n    this._events.push(event);\n\n    this._events.sort(function (a, b) {\n      return a.frame - b.frame;\n    });\n  };\n  /**\r\n   * Remove all events found at the given frame\r\n   * @param frame The frame to remove events from\r\n   */\n\n\n  Animation.prototype.removeEvents = function (frame) {\n    for (var index = 0; index < this._events.length; index++) {\n      if (this._events[index].frame === frame) {\n        this._events.splice(index, 1);\n\n        index--;\n      }\n    }\n  };\n  /**\r\n   * Retrieves all the events from the animation\r\n   * @returns Events from the animation\r\n   */\n\n\n  Animation.prototype.getEvents = function () {\n    return this._events;\n  };\n  /**\r\n   * Creates an animation range\r\n   * @param name Name of the animation range\r\n   * @param from Starting frame of the animation range\r\n   * @param to Ending frame of the animation\r\n   */\n\n\n  Animation.prototype.createRange = function (name, from, to) {\n    // check name not already in use; could happen for bones after serialized\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n    }\n  };\n  /**\r\n   * Deletes an animation range by name\r\n   * @param name Name of the animation range to delete\r\n   * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n   */\n\n\n  Animation.prototype.deleteRange = function (name, deleteFrames) {\n    if (deleteFrames === void 0) {\n      deleteFrames = true;\n    }\n\n    var range = this._ranges[name];\n\n    if (!range) {\n      return;\n    }\n\n    if (deleteFrames) {\n      var from = range.from;\n      var to = range.to; // this loop MUST go high to low for multiple splices to work\n\n      for (var key = this._keys.length - 1; key >= 0; key--) {\n        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\n          this._keys.splice(key, 1);\n        }\n      }\n    }\n\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  };\n  /**\r\n   * Gets the animation range by name, or null if not defined\r\n   * @param name Name of the animation range\r\n   * @returns Nullable animation range\r\n   */\n\n\n  Animation.prototype.getRange = function (name) {\n    return this._ranges[name];\n  };\n  /**\r\n   * Gets the key frames from the animation\r\n   * @returns The key frames of the animation\r\n   */\n\n\n  Animation.prototype.getKeys = function () {\n    return this._keys;\n  };\n  /**\r\n   * Gets the highest frame rate of the animation\r\n   * @returns Highest frame rate of the animation\r\n   */\n\n\n  Animation.prototype.getHighestFrame = function () {\n    var ret = 0;\n\n    for (var key = 0, nKeys = this._keys.length; key < nKeys; key++) {\n      if (ret < this._keys[key].frame) {\n        ret = this._keys[key].frame;\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * Gets the easing function of the animation\r\n   * @returns Easing function of the animation\r\n   */\n\n\n  Animation.prototype.getEasingFunction = function () {\n    return this._easingFunction;\n  };\n  /**\r\n   * Sets the easing function of the animation\r\n   * @param easingFunction A custom mathematical formula for animation\r\n   */\n\n\n  Animation.prototype.setEasingFunction = function (easingFunction) {\n    this._easingFunction = easingFunction;\n  };\n  /**\r\n   * Interpolates a scalar linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated scalar value\r\n   */\n\n\n  Animation.prototype.floatInterpolateFunction = function (startValue, endValue, gradient) {\n    return Scalar.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a scalar cubically\r\n   * @param startValue Start value of the animation curve\r\n   * @param outTangent End tangent of the animation\r\n   * @param endValue End value of the animation curve\r\n   * @param inTangent Start tangent of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated scalar value\r\n   */\n\n\n  Animation.prototype.floatInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\r\n   * Interpolates a quaternion using a spherical linear interpolation\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated quaternion value\r\n   */\n\n\n  Animation.prototype.quaternionInterpolateFunction = function (startValue, endValue, gradient) {\n    return Quaternion.Slerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a quaternion cubically\r\n   * @param startValue Start value of the animation curve\r\n   * @param outTangent End tangent of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param inTangent Start tangent of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated quaternion value\r\n   */\n\n\n  Animation.prototype.quaternionInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\n  };\n  /**\r\n   * Interpolates a Vector3 linearl\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated scalar value\r\n   */\n\n\n  Animation.prototype.vector3InterpolateFunction = function (startValue, endValue, gradient) {\n    return Vector3.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a Vector3 cubically\r\n   * @param startValue Start value of the animation curve\r\n   * @param outTangent End tangent of the animation\r\n   * @param endValue End value of the animation curve\r\n   * @param inTangent Start tangent of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns InterpolatedVector3 value\r\n   */\n\n\n  Animation.prototype.vector3InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\r\n   * Interpolates a Vector2 linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Vector2 value\r\n   */\n\n\n  Animation.prototype.vector2InterpolateFunction = function (startValue, endValue, gradient) {\n    return Vector2.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a Vector2 cubically\r\n   * @param startValue Start value of the animation curve\r\n   * @param outTangent End tangent of the animation\r\n   * @param endValue End value of the animation curve\r\n   * @param inTangent Start tangent of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Vector2 value\r\n   */\n\n\n  Animation.prototype.vector2InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\r\n   * Interpolates a size linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Size value\r\n   */\n\n\n  Animation.prototype.sizeInterpolateFunction = function (startValue, endValue, gradient) {\n    return Size.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a Color3 linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Color3 value\r\n   */\n\n\n  Animation.prototype.color3InterpolateFunction = function (startValue, endValue, gradient) {\n    return Color3.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a Color4 linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Color3 value\r\n   */\n\n\n  Animation.prototype.color4InterpolateFunction = function (startValue, endValue, gradient) {\n    return Color4.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * @hidden Internal use only\r\n   */\n\n\n  Animation.prototype._getKeyValue = function (value) {\n    if (typeof value === \"function\") {\n      return value();\n    }\n\n    return value;\n  };\n  /**\r\n   * @hidden Internal use only\r\n   */\n\n\n  Animation.prototype._interpolate = function (currentFrame, state) {\n    if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\n      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\n    }\n\n    var keys = this._keys;\n\n    if (keys.length === 1) {\n      return this._getKeyValue(keys[0].value);\n    }\n\n    var startKeyIndex = state.key;\n\n    if (keys[startKeyIndex].frame >= currentFrame) {\n      while (startKeyIndex - 1 >= 0 && keys[startKeyIndex].frame >= currentFrame) {\n        startKeyIndex--;\n      }\n    }\n\n    for (var key = startKeyIndex; key < keys.length; key++) {\n      var endKey = keys[key + 1];\n\n      if (endKey.frame >= currentFrame) {\n        state.key = key;\n        var startKey = keys[key];\n\n        var startValue = this._getKeyValue(startKey.value);\n\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\n          return startValue;\n        }\n\n        var endValue = this._getKeyValue(endKey.value);\n\n        var useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\n        var frameDelta = endKey.frame - startKey.frame; // gradient : percent of currentFrame between the frame inf and the frame sup\n\n        var gradient = (currentFrame - startKey.frame) / frameDelta; // check for easingFunction and correction of gradient\n\n        var easingFunction = this.getEasingFunction();\n\n        if (easingFunction != null) {\n          gradient = easingFunction.ease(gradient);\n        }\n\n        switch (this.dataType) {\n          // Float\n          case Animation.ANIMATIONTYPE_FLOAT:\n            var floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\n\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return floatValue;\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return state.offsetValue * state.repeatCount + floatValue;\n            }\n\n            break;\n          // Quaternion\n\n          case Animation.ANIMATIONTYPE_QUATERNION:\n            var quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\n\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return quatValue;\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\n            }\n\n            return quatValue;\n          // Vector3\n\n          case Animation.ANIMATIONTYPE_VECTOR3:\n            var vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\n\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return vec3Value;\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return vec3Value.add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Vector2\n\n          case Animation.ANIMATIONTYPE_VECTOR2:\n            var vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\n\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return vec2Value;\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return vec2Value.add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Size\n\n          case Animation.ANIMATIONTYPE_SIZE:\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return this.sizeInterpolateFunction(startValue, endValue, gradient);\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Color3\n\n          case Animation.ANIMATIONTYPE_COLOR3:\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return this.color3InterpolateFunction(startValue, endValue, gradient);\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return this.color3InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Color4\n\n          case Animation.ANIMATIONTYPE_COLOR4:\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return this.color4InterpolateFunction(startValue, endValue, gradient);\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return this.color4InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Matrix\n\n          case Animation.ANIMATIONTYPE_MATRIX:\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                if (Animation.AllowMatricesInterpolation) {\n                  return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\n                }\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return startValue;\n            }\n\n          default:\n            break;\n        }\n\n        break;\n      }\n    }\n\n    return this._getKeyValue(keys[keys.length - 1].value);\n  };\n  /**\r\n   * Defines the function to use to interpolate matrices\r\n   * @param startValue defines the start matrix\r\n   * @param endValue defines the end matrix\r\n   * @param gradient defines the gradient between both matrices\r\n   * @param result defines an optional target matrix where to store the interpolation\r\n   * @returns the interpolated matrix\r\n   */\n\n\n  Animation.prototype.matrixInterpolateFunction = function (startValue, endValue, gradient, result) {\n    if (Animation.AllowMatrixDecomposeForInterpolation) {\n      if (result) {\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n      }\n\n      return Matrix.DecomposeLerp(startValue, endValue, gradient);\n    }\n\n    if (result) {\n      Matrix.LerpToRef(startValue, endValue, gradient, result);\n      return result;\n    }\n\n    return Matrix.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Makes a copy of the animation\r\n   * @returns Cloned animation\r\n   */\n\n\n  Animation.prototype.clone = function () {\n    var clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\n    clone.enableBlending = this.enableBlending;\n    clone.blendingSpeed = this.blendingSpeed;\n\n    if (this._keys) {\n      clone.setKeys(this._keys);\n    }\n\n    if (this._ranges) {\n      clone._ranges = {};\n\n      for (var name in this._ranges) {\n        var range = this._ranges[name];\n\n        if (!range) {\n          continue;\n        }\n\n        clone._ranges[name] = range.clone();\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * Sets the key frames of the animation\r\n   * @param values The animation key frames to set\r\n   */\n\n\n  Animation.prototype.setKeys = function (values) {\n    this._keys = values.slice(0);\n  };\n  /**\r\n   * Serializes the animation to an object\r\n   * @returns Serialized object\r\n   */\n\n\n  Animation.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.property = this.targetProperty;\n    serializationObject.framePerSecond = this.framePerSecond;\n    serializationObject.dataType = this.dataType;\n    serializationObject.loopBehavior = this.loopMode;\n    serializationObject.enableBlending = this.enableBlending;\n    serializationObject.blendingSpeed = this.blendingSpeed;\n    var dataType = this.dataType;\n    serializationObject.keys = [];\n    var keys = this.getKeys();\n\n    for (var index = 0; index < keys.length; index++) {\n      var animationKey = keys[index];\n      var key = {};\n      key.frame = animationKey.frame;\n\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          key.values = [animationKey.value];\n\n          if (animationKey.inTangent !== undefined) {\n            key.values.push(animationKey.inTangent);\n          }\n\n          if (animationKey.outTangent !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            key.values.push(animationKey.outTangent);\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n        case Animation.ANIMATIONTYPE_MATRIX:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.values = animationKey.value.asArray();\n\n          if (animationKey.inTangent != undefined) {\n            key.values.push(animationKey.inTangent.asArray());\n          }\n\n          if (animationKey.outTangent != undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            key.values.push(animationKey.outTangent.asArray());\n          }\n\n          break;\n      }\n\n      serializationObject.keys.push(key);\n    }\n\n    serializationObject.ranges = [];\n\n    for (var name in this._ranges) {\n      var source = this._ranges[name];\n\n      if (!source) {\n        continue;\n      }\n\n      var range = {};\n      range.name = name;\n      range.from = source.from;\n      range.to = source.to;\n      serializationObject.ranges.push(range);\n    }\n\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  Animation._UniversalLerp = function (left, right, amount) {\n    var constructor = left.constructor;\n\n    if (constructor.Lerp) {\n      // Lerp supported\n      return constructor.Lerp(left, right, amount);\n    } else if (constructor.Slerp) {\n      // Slerp supported\n      return constructor.Slerp(left, right, amount);\n    } else if (left.toFixed) {\n      // Number\n      return left * (1.0 - amount) + amount * right;\n    } else {\n      // Blending not supported\n      return right;\n    }\n  };\n  /**\r\n   * Parses an animation object and creates an animation\r\n   * @param parsedAnimation Parsed animation object\r\n   * @returns Animation object\r\n   */\n\n\n  Animation.Parse = function (parsedAnimation) {\n    var animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\n    var dataType = parsedAnimation.dataType;\n    var keys = [];\n    var data;\n    var index;\n\n    if (parsedAnimation.enableBlending) {\n      animation.enableBlending = parsedAnimation.enableBlending;\n    }\n\n    if (parsedAnimation.blendingSpeed) {\n      animation.blendingSpeed = parsedAnimation.blendingSpeed;\n    }\n\n    for (index = 0; index < parsedAnimation.keys.length; index++) {\n      var key = parsedAnimation.keys[index];\n      var inTangent;\n      var outTangent;\n\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          data = key.values[0];\n\n          if (key.values.length >= 1) {\n            inTangent = key.values[1];\n          }\n\n          if (key.values.length >= 2) {\n            outTangent = key.values[2];\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          data = Quaternion.FromArray(key.values);\n\n          if (key.values.length >= 8) {\n            var _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\n\n            if (!_inTangent.equals(Quaternion.Zero())) {\n              inTangent = _inTangent;\n            }\n          }\n\n          if (key.values.length >= 12) {\n            var _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\n\n            if (!_outTangent.equals(Quaternion.Zero())) {\n              outTangent = _outTangent;\n            }\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_MATRIX:\n          data = Matrix.FromArray(key.values);\n          break;\n\n        case Animation.ANIMATIONTYPE_COLOR3:\n          data = Color3.FromArray(key.values);\n          break;\n\n        case Animation.ANIMATIONTYPE_COLOR4:\n          data = Color4.FromArray(key.values);\n          break;\n\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        default:\n          data = Vector3.FromArray(key.values);\n          break;\n      }\n\n      var keyData = {};\n      keyData.frame = key.frame;\n      keyData.value = data;\n\n      if (inTangent != undefined) {\n        keyData.inTangent = inTangent;\n      }\n\n      if (outTangent != undefined) {\n        keyData.outTangent = outTangent;\n      }\n\n      keys.push(keyData);\n    }\n\n    animation.setKeys(keys);\n\n    if (parsedAnimation.ranges) {\n      for (index = 0; index < parsedAnimation.ranges.length; index++) {\n        data = parsedAnimation.ranges[index];\n        animation.createRange(data.name, data.from, data.to);\n      }\n    }\n\n    return animation;\n  };\n  /**\r\n   * Appends the serialized animations from the source animations\r\n   * @param source Source containing the animations\r\n   * @param destination Target to store the animations\r\n   */\n\n\n  Animation.AppendSerializedAnimations = function (source, destination) {\n    SerializationHelper.AppendSerializedAnimations(source, destination);\n  };\n  /**\r\n   * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n   * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n   * @param url defines the url to load from\r\n   * @returns a promise that will resolve to the new animation or an array of animations\r\n   */\n\n\n  Animation.ParseFromFileAsync = function (name, url) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n\n            if (serializationObject.length) {\n              var output = new Array();\n\n              for (var _i = 0, serializationObject_1 = serializationObject; _i < serializationObject_1.length; _i++) {\n                var serializedAnimation = serializationObject_1[_i];\n                output.push(_this.Parse(serializedAnimation));\n              }\n\n              resolve(output);\n            } else {\n              var output = _this.Parse(serializationObject);\n\n              if (name) {\n                output.name = name;\n              }\n\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the animation\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\r\n   * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n   * @param snippetId defines the snippet to load\r\n   * @returns a promise that will resolve to the new animation or a new array of animations\r\n   */\n\n\n  Animation.CreateFromSnippetAsync = function (snippetId) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n\n            if (snippet.animations) {\n              var serializationObject = JSON.parse(snippet.animations);\n              var output = new Array();\n\n              for (var _i = 0, serializationObject_2 = serializationObject; _i < serializationObject_2.length; _i++) {\n                var serializedAnimation = serializationObject_2[_i];\n                output.push(_this.Parse(serializedAnimation));\n              }\n\n              resolve(output);\n            } else {\n              var serializationObject = JSON.parse(snippet.animation);\n\n              var output = _this.Parse(serializationObject);\n\n              output.snippetId = snippetId;\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /**\r\n   * Use matrix interpolation instead of using direct key value when animating matrices\r\n   */\n\n\n  Animation.AllowMatricesInterpolation = false;\n  /**\r\n   * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n   */\n\n  Animation.AllowMatrixDecomposeForInterpolation = true;\n  /** Define the Url to load snippets */\n\n  Animation.SnippetUrl = \"https://snippet.babylonjs.com\"; // Statics\n\n  /**\r\n   * Float animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_FLOAT = 0;\n  /**\r\n   * Vector3 animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_VECTOR3 = 1;\n  /**\r\n   * Quaternion animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_QUATERNION = 2;\n  /**\r\n   * Matrix animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_MATRIX = 3;\n  /**\r\n   * Color3 animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_COLOR3 = 4;\n  /**\r\n   * Color3 animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_COLOR4 = 7;\n  /**\r\n   * Vector2 animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_VECTOR2 = 5;\n  /**\r\n   * Size animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_SIZE = 6;\n  /**\r\n   * Relative Loop Mode\r\n   */\n\n  Animation.ANIMATIONLOOPMODE_RELATIVE = 0;\n  /**\r\n   * Cycle Loop Mode\r\n   */\n\n  Animation.ANIMATIONLOOPMODE_CYCLE = 1;\n  /**\r\n   * Constant Loop Mode\r\n   */\n\n  Animation.ANIMATIONLOOPMODE_CONSTANT = 2;\n  return Animation;\n}();\n\nexport { Animation };\n_TypeStore.RegisteredTypes[\"BABYLON.Animation\"] = Animation;\n\nNode._AnimationRangeFactory = function (name, from, to) {\n  return new AnimationRange(name, from, to);\n};","map":null,"metadata":{},"sourceType":"module"}