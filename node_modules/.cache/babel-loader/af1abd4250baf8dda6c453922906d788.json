{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nvar planeIdProvider = 0;\n/**\r\n * The plane detector is used to detect planes in the real world when in AR\r\n * For more information see https://github.com/immersive-web/real-world-geometry/\r\n */\n\nvar WebXRPlaneDetector =\n/** @class */\nfunction (_super) {\n  __extends(WebXRPlaneDetector, _super);\n  /**\r\n   * construct a new Plane Detector\r\n   * @param _xrSessionManager an instance of xr Session manager\r\n   * @param _options configuration to use when constructing this feature\r\n   */\n\n\n  function WebXRPlaneDetector(_xrSessionManager, _options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._detectedPlanes = [];\n    _this._enabled = false;\n    _this._lastFrameDetected = new Set();\n    /**\r\n     * Observers registered here will be executed when a new plane was added to the session\r\n     */\n\n    _this.onPlaneAddedObservable = new Observable();\n    /**\r\n     * Observers registered here will be executed when a plane is no longer detected in the session\r\n     */\n\n    _this.onPlaneRemovedObservable = new Observable();\n    /**\r\n     * Observers registered here will be executed when an existing plane updates (for example - expanded)\r\n     * This can execute N times every frame\r\n     */\n\n    _this.onPlaneUpdatedObservable = new Observable();\n    _this.xrNativeFeatureName = \"plane-detection\";\n\n    if (_this._xrSessionManager.session) {\n      _this._init();\n    } else {\n      _this._xrSessionManager.onXRSessionInit.addOnce(function () {\n        _this._init();\n      });\n    }\n\n    return _this;\n  }\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRPlaneDetector.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    if (!this._options.doNotRemovePlanesOnSessionEnded) {\n      while (this._detectedPlanes.length) {\n        var toRemove = this._detectedPlanes.pop();\n\n        if (toRemove) {\n          this.onPlaneRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRPlaneDetector.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onPlaneAddedObservable.clear();\n    this.onPlaneRemovedObservable.clear();\n    this.onPlaneUpdatedObservable.clear();\n  };\n  /**\r\n   * Check if the needed objects are defined.\r\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n   */\n\n\n  WebXRPlaneDetector.prototype.isCompatible = function () {\n    return typeof XRPlane !== \"undefined\";\n  };\n\n  WebXRPlaneDetector.prototype._onXRFrame = function (frame) {\n    var _this = this;\n\n    if (!this.attached || !this._enabled || !frame) {\n      return;\n    } // const timestamp = this.xrSessionManager.currentTimestamp;\n\n\n    var detectedPlanes = frame.worldInformation.detectedPlanes;\n\n    if (detectedPlanes) {\n      var toRemove = this._detectedPlanes.filter(function (plane) {\n        return !detectedPlanes.has(plane.xrPlane);\n      }).map(function (plane) {\n        return _this._detectedPlanes.indexOf(plane);\n      });\n\n      var idxTracker_1 = 0;\n      toRemove.forEach(function (index) {\n        var plane = _this._detectedPlanes.splice(index - idxTracker_1, 1)[0];\n\n        _this.onPlaneRemovedObservable.notifyObservers(plane);\n\n        idxTracker_1++;\n      }); // now check for new ones\n\n      detectedPlanes.forEach(function (xrPlane) {\n        if (!_this._lastFrameDetected.has(xrPlane)) {\n          var newPlane = {\n            id: planeIdProvider++,\n            xrPlane: xrPlane,\n            polygonDefinition: []\n          };\n\n          var plane = _this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);\n\n          _this._detectedPlanes.push(plane);\n\n          _this.onPlaneAddedObservable.notifyObservers(plane);\n        } else {\n          // updated?\n          if (xrPlane.lastChangedTime === _this._xrSessionManager.currentTimestamp) {\n            var index = _this.findIndexInPlaneArray(xrPlane);\n\n            var plane = _this._detectedPlanes[index];\n\n            _this._updatePlaneWithXRPlane(xrPlane, plane, frame);\n\n            _this.onPlaneUpdatedObservable.notifyObservers(plane);\n          }\n        }\n      });\n      this._lastFrameDetected = detectedPlanes;\n    }\n  };\n\n  WebXRPlaneDetector.prototype._init = function () {\n    var _this = this;\n\n    var _a, _b;\n\n    var internalInit = function internalInit() {\n      _this._enabled = true;\n\n      if (_this._detectedPlanes.length) {\n        _this._detectedPlanes.length = 0;\n      }\n    };\n\n    if (!this._xrSessionManager.session.updateWorldTrackingState) {\n      // check if this was enabled by a flag\n      var alreadyEnabled = (_b = (_a = this._xrSessionManager.session.worldTrackingState) === null || _a === void 0 ? void 0 : _a.planeDetectionState) === null || _b === void 0 ? void 0 : _b.enabled;\n\n      if (alreadyEnabled) {\n        internalInit();\n      } // fail silently\n\n\n      return;\n    }\n\n    this._xrSessionManager.session.updateWorldTrackingState({\n      planeDetectionState: {\n        enabled: true\n      }\n    });\n\n    internalInit();\n  };\n\n  WebXRPlaneDetector.prototype._updatePlaneWithXRPlane = function (xrPlane, plane, xrFrame) {\n    var _this = this;\n\n    plane.polygonDefinition = xrPlane.polygon.map(function (xrPoint) {\n      var rightHandedSystem = _this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;\n      return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);\n    }); // matrix\n\n    var pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);\n\n    if (pose) {\n      var mat = plane.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n\n      plane.transformationMatrix = mat;\n\n      if (this._options.worldParentNode) {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n\n    return plane;\n  };\n  /**\r\n   * avoiding using Array.find for global support.\r\n   * @param xrPlane the plane to find in the array\r\n   */\n\n\n  WebXRPlaneDetector.prototype.findIndexInPlaneArray = function (xrPlane) {\n    for (var i = 0; i < this._detectedPlanes.length; ++i) {\n      if (this._detectedPlanes[i].xrPlane === xrPlane) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRPlaneDetector.Name = WebXRFeatureName.PLANE_DETECTION;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRPlaneDetector.Version = 1;\n  return WebXRPlaneDetector;\n}(WebXRAbstractFeature);\n\nexport { WebXRPlaneDetector }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRPlaneDetector.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRPlaneDetector(xrSessionManager, options);\n  };\n}, WebXRPlaneDetector.Version);","map":null,"metadata":{},"sourceType":"module"}