{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators\";\nimport { Color3 } from \"../../Maths/math.color\";\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial\";\n/**\r\n * The Physically based simple base material of BJS.\r\n *\r\n * This enables better naming and convention enforcements on top of the pbrMaterial.\r\n * It is used as the base class for both the specGloss and metalRough conventions.\r\n */\n\nvar PBRBaseSimpleMaterial =\n/** @class */\nfunction (_super) {\n  __extends(PBRBaseSimpleMaterial, _super);\n  /**\r\n   * Instantiates a new PBRMaterial instance.\r\n   *\r\n   * @param name The material name\r\n   * @param scene The scene the material will be use in.\r\n   */\n\n\n  function PBRBaseSimpleMaterial(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\n\n\n    _this.maxSimultaneousLights = 4;\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     */\n\n    _this.disableLighting = false;\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\n\n    _this.invertNormalMapX = false;\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\n\n    _this.invertNormalMapY = false;\n    /**\r\n     * Emissivie color used to self-illuminate the model.\r\n     */\n\n    _this.emissiveColor = new Color3(0, 0, 0);\n    /**\r\n     * Occlusion Channel Strenght.\r\n     */\n\n    _this.occlusionStrength = 1.0;\n    /**\r\n     * If true, the light map contains occlusion information instead of lighting info.\r\n     */\n\n    _this.useLightmapAsShadowmap = false;\n    _this._useAlphaFromAlbedoTexture = true;\n    _this._useAmbientInGrayScale = true;\n    return _this;\n  }\n\n  Object.defineProperty(PBRBaseSimpleMaterial.prototype, \"doubleSided\", {\n    /**\r\n     * Gets the current double sided mode.\r\n     */\n    get: function get() {\n      return this._twoSidedLighting;\n    },\n\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\n    set: function set(value) {\n      if (this._twoSidedLighting === value) {\n        return;\n      }\n\n      this._twoSidedLighting = value;\n      this.backFaceCulling = !value;\n\n      this._markAllSubMeshesAsTexturesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  PBRBaseSimpleMaterial.prototype.getClassName = function () {\n    return \"PBRBaseSimpleMaterial\";\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], PBRBaseSimpleMaterial.prototype, \"maxSimultaneousLights\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], PBRBaseSimpleMaterial.prototype, \"disableLighting\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectionTexture\")], PBRBaseSimpleMaterial.prototype, \"environmentTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRBaseSimpleMaterial.prototype, \"invertNormalMapX\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRBaseSimpleMaterial.prototype, \"invertNormalMapY\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_bumpTexture\")], PBRBaseSimpleMaterial.prototype, \"normalTexture\", void 0);\n\n  __decorate([serializeAsColor3(\"emissive\"), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRBaseSimpleMaterial.prototype, \"emissiveColor\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRBaseSimpleMaterial.prototype, \"emissiveTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTextureStrength\")], PBRBaseSimpleMaterial.prototype, \"occlusionStrength\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTexture\")], PBRBaseSimpleMaterial.prototype, \"occlusionTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_alphaCutOff\")], PBRBaseSimpleMaterial.prototype, \"alphaCutOff\", void 0);\n\n  __decorate([serialize()], PBRBaseSimpleMaterial.prototype, \"doubleSided\", null);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)], PBRBaseSimpleMaterial.prototype, \"lightmapTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRBaseSimpleMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\n\n  return PBRBaseSimpleMaterial;\n}(PBRBaseMaterial);\n\nexport { PBRBaseSimpleMaterial };","map":null,"metadata":{},"sourceType":"module"}