{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\nimport { _DevTools } from '../Misc/devTools';\n/**\r\n * Class used to control physics engine\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\n\nvar PhysicsEngine =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Physics Engine\r\n   * @param gravity defines the gravity vector used by the simulation\r\n   * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n   */\n  function PhysicsEngine(gravity, _physicsPlugin) {\n    if (_physicsPlugin === void 0) {\n      _physicsPlugin = PhysicsEngine.DefaultPluginFactory();\n    }\n\n    this._physicsPlugin = _physicsPlugin;\n    this._impostors = [];\n    this._joints = [];\n    this._subTimeStep = 0;\n\n    if (!this._physicsPlugin.isSupported()) {\n      throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \" + \"Please make sure it is included.\");\n    }\n\n    gravity = gravity || new Vector3(0, -9.807, 0);\n    this.setGravity(gravity);\n    this.setTimeStep();\n  }\n  /**\r\n   * Factory used to create the default physics plugin.\r\n   * @returns The default physics plugin\r\n   */\n\n\n  PhysicsEngine.DefaultPluginFactory = function () {\n    throw _DevTools.WarnImport(\"CannonJSPlugin\");\n  };\n  /**\r\n   * Sets the gravity vector used by the simulation\r\n   * @param gravity defines the gravity vector to use\r\n   */\n\n\n  PhysicsEngine.prototype.setGravity = function (gravity) {\n    this.gravity = gravity;\n\n    this._physicsPlugin.setGravity(this.gravity);\n  };\n  /**\r\n   * Set the time step of the physics engine.\r\n   * Default is 1/60.\r\n   * To slow it down, enter 1/600 for example.\r\n   * To speed it up, 1/30\r\n   * @param newTimeStep defines the new timestep to apply to this world.\r\n   */\n\n\n  PhysicsEngine.prototype.setTimeStep = function (newTimeStep) {\n    if (newTimeStep === void 0) {\n      newTimeStep = 1 / 60;\n    }\n\n    this._physicsPlugin.setTimeStep(newTimeStep);\n  };\n  /**\r\n   * Get the time step of the physics engine.\r\n   * @returns the current time step\r\n   */\n\n\n  PhysicsEngine.prototype.getTimeStep = function () {\n    return this._physicsPlugin.getTimeStep();\n  };\n  /**\r\n   * Set the sub time step of the physics engine.\r\n   * Default is 0 meaning there is no sub steps\r\n   * To increase physics resolution precision, set a small value (like 1 ms)\r\n   * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n   */\n\n\n  PhysicsEngine.prototype.setSubTimeStep = function (subTimeStep) {\n    if (subTimeStep === void 0) {\n      subTimeStep = 0;\n    }\n\n    this._subTimeStep = subTimeStep;\n  };\n  /**\r\n   * Get the sub time step of the physics engine.\r\n   * @returns the current sub time step\r\n   */\n\n\n  PhysicsEngine.prototype.getSubTimeStep = function () {\n    return this._subTimeStep;\n  };\n  /**\r\n   * Release all resources\r\n   */\n\n\n  PhysicsEngine.prototype.dispose = function () {\n    this._impostors.forEach(function (impostor) {\n      impostor.dispose();\n    });\n\n    this._physicsPlugin.dispose();\n  };\n  /**\r\n   * Gets the name of the current physics plugin\r\n   * @returns the name of the plugin\r\n   */\n\n\n  PhysicsEngine.prototype.getPhysicsPluginName = function () {\n    return this._physicsPlugin.name;\n  };\n  /**\r\n   * Adding a new impostor for the impostor tracking.\r\n   * This will be done by the impostor itself.\r\n   * @param impostor the impostor to add\r\n   */\n\n\n  PhysicsEngine.prototype.addImpostor = function (impostor) {\n    impostor.uniqueId = this._impostors.push(impostor); //if no parent, generate the body\n\n    if (!impostor.parent) {\n      this._physicsPlugin.generatePhysicsBody(impostor);\n    }\n  };\n  /**\r\n   * Remove an impostor from the engine.\r\n   * This impostor and its mesh will not longer be updated by the physics engine.\r\n   * @param impostor the impostor to remove\r\n   */\n\n\n  PhysicsEngine.prototype.removeImpostor = function (impostor) {\n    var index = this._impostors.indexOf(impostor);\n\n    if (index > -1) {\n      var removed = this._impostors.splice(index, 1); //Is it needed?\n\n\n      if (removed.length) {\n        this.getPhysicsPlugin().removePhysicsBody(impostor);\n      }\n    }\n  };\n  /**\r\n   * Add a joint to the physics engine\r\n   * @param mainImpostor defines the main impostor to which the joint is added.\r\n   * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\r\n   * @param joint defines the joint that will connect both impostors.\r\n   */\n\n\n  PhysicsEngine.prototype.addJoint = function (mainImpostor, connectedImpostor, joint) {\n    var impostorJoint = {\n      mainImpostor: mainImpostor,\n      connectedImpostor: connectedImpostor,\n      joint: joint\n    };\n    joint.physicsPlugin = this._physicsPlugin;\n\n    this._joints.push(impostorJoint);\n\n    this._physicsPlugin.generateJoint(impostorJoint);\n  };\n  /**\r\n   * Removes a joint from the simulation\r\n   * @param mainImpostor defines the impostor used with the joint\r\n   * @param connectedImpostor defines the other impostor connected to the main one by the joint\r\n   * @param joint defines the joint to remove\r\n   */\n\n\n  PhysicsEngine.prototype.removeJoint = function (mainImpostor, connectedImpostor, joint) {\n    var matchingJoints = this._joints.filter(function (impostorJoint) {\n      return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;\n    });\n\n    if (matchingJoints.length) {\n      this._physicsPlugin.removeJoint(matchingJoints[0]); //TODO remove it from the list as well\n\n    }\n  };\n  /**\r\n   * Called by the scene. No need to call it.\r\n   * @param delta defines the timespam between frames\r\n   */\n\n\n  PhysicsEngine.prototype._step = function (delta) {\n    var _this = this; //check if any mesh has no body / requires an update\n\n\n    this._impostors.forEach(function (impostor) {\n      if (impostor.isBodyInitRequired()) {\n        _this._physicsPlugin.generatePhysicsBody(impostor);\n      }\n    });\n\n    if (delta > 0.1) {\n      delta = 0.1;\n    } else if (delta <= 0) {\n      delta = 1.0 / 60.0;\n    }\n\n    this._physicsPlugin.executeStep(delta, this._impostors);\n  };\n  /**\r\n   * Gets the current plugin used to run the simulation\r\n   * @returns current plugin\r\n   */\n\n\n  PhysicsEngine.prototype.getPhysicsPlugin = function () {\n    return this._physicsPlugin;\n  };\n  /**\r\n   * Gets the list of physic impostors\r\n   * @returns an array of PhysicsImpostor\r\n   */\n\n\n  PhysicsEngine.prototype.getImpostors = function () {\n    return this._impostors;\n  };\n  /**\r\n   * Gets the impostor for a physics enabled object\r\n   * @param object defines the object impersonated by the impostor\r\n   * @returns the PhysicsImpostor or null if not found\r\n   */\n\n\n  PhysicsEngine.prototype.getImpostorForPhysicsObject = function (object) {\n    for (var i = 0; i < this._impostors.length; ++i) {\n      if (this._impostors[i].object === object) {\n        return this._impostors[i];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets the impostor for a physics body object\r\n   * @param body defines physics body used by the impostor\r\n   * @returns the PhysicsImpostor or null if not found\r\n   */\n\n\n  PhysicsEngine.prototype.getImpostorWithPhysicsBody = function (body) {\n    for (var i = 0; i < this._impostors.length; ++i) {\n      if (this._impostors[i].physicsBody === body) {\n        return this._impostors[i];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Does a raycast in the physics world\r\n   * @param from when should the ray start?\r\n   * @param to when should the ray end?\r\n   * @returns PhysicsRaycastResult\r\n   */\n\n\n  PhysicsEngine.prototype.raycast = function (from, to) {\n    return this._physicsPlugin.raycast(from, to);\n  };\n  /**\r\n   * Global value used to control the smallest number supported by the simulation\r\n   */\n\n\n  PhysicsEngine.Epsilon = 0.001;\n  return PhysicsEngine;\n}();\n\nexport { PhysicsEngine };","map":null,"metadata":{},"sourceType":"module"}