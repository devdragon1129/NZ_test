{"ast":null,"code":"import { connect } from 'react-redux';\nimport { isLoadingType } from 'decentraland-dapps/dist/modules/loading/selectors';\nimport { getAddress } from 'decentraland-dapps/dist/modules/wallet/selectors';\nimport { mintCollectionItemsRequest, MINT_COLLECTION_ITEMS_REQUEST } from 'modules/collection/actions';\nimport { getCollection, getLoading } from 'modules/collection/selectors';\nimport { getCollectionItems } from 'modules/item/selectors';\nimport { canMintItem, UNSYNCED_STATES } from 'modules/item/utils';\nimport { getAuthorizedItems, getStatusByItemId } from 'modules/item/selectors';\nimport MintItemsModal from './MintItemsModal';\n\nvar mapState = function mapState(state, ownProps) {\n  var _ownProps$metadata = ownProps.metadata,\n      collectionId = _ownProps$metadata.collectionId,\n      itemIds = _ownProps$metadata.itemIds;\n\n  if (!collectionId && (!itemIds || itemIds.length === 0)) {\n    throw new Error('Invalid collection id or items id to mint');\n  }\n\n  var ethAddress = getAddress(state);\n  var collection;\n  var items;\n  var totalCollectionItems;\n\n  if (collectionId) {\n    items = getCollectionItems(state, collectionId);\n    totalCollectionItems = items.length;\n  } else {\n    var allItems = getAuthorizedItems(state);\n    items = allItems.filter(function (item) {\n      return itemIds.includes(item.id);\n    });\n    collectionId = items[0].collectionId;\n    totalCollectionItems = allItems.filter(function (item) {\n      return item.collectionId === collectionId;\n    }).length;\n  }\n\n  collection = getCollection(state, collectionId);\n\n  var hasUnsyncedItems = function hasUnsyncedItems(items) {\n    return items.some(function (item) {\n      return UNSYNCED_STATES.has(getStatusByItemId(state)[item.id]);\n    });\n  };\n\n  return {\n    items: items.filter(function (item) {\n      return canMintItem(collection, item, ethAddress);\n    }),\n    isLoading: isLoadingType(getLoading(state), MINT_COLLECTION_ITEMS_REQUEST),\n    ethAddress: ethAddress,\n    collection: collection,\n    totalCollectionItems: totalCollectionItems,\n    hasUnsyncedItems: hasUnsyncedItems\n  };\n};\n\nvar mapDispatch = function mapDispatch(dispatch) {\n  return {\n    onMint: function onMint(collection, items) {\n      return dispatch(mintCollectionItemsRequest(collection, items));\n    }\n  };\n};\n\nexport default connect(mapState, mapDispatch)(MintItemsModal);","map":{"version":3,"sources":["/opt/work/NZ_test/src/components/Modals/MintItemsModal/MintItemsModal.container.ts"],"names":["connect","isLoadingType","getAddress","mintCollectionItemsRequest","MINT_COLLECTION_ITEMS_REQUEST","getCollection","getLoading","getCollectionItems","canMintItem","UNSYNCED_STATES","getAuthorizedItems","getStatusByItemId","MintItemsModal","mapState","state","ownProps","metadata","collectionId","itemIds","length","Error","ethAddress","collection","items","totalCollectionItems","allItems","filter","item","includes","id","hasUnsyncedItems","some","has","isLoading","mapDispatch","dispatch","onMint"],"mappings":"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","sourcesContent":["import { connect } from 'react-redux'\nimport { isLoadingType } from 'decentraland-dapps/dist/modules/loading/selectors'\nimport { getAddress } from 'decentraland-dapps/dist/modules/wallet/selectors'\nimport { RootState } from 'modules/common/types'\nimport { Item } from 'modules/item/types'\nimport { mintCollectionItemsRequest, MINT_COLLECTION_ITEMS_REQUEST } from 'modules/collection/actions'\nimport { getCollection, getLoading } from 'modules/collection/selectors'\nimport { getCollectionItems } from 'modules/item/selectors'\nimport { Collection } from 'modules/collection/types'\nimport { canMintItem, UNSYNCED_STATES } from 'modules/item/utils'\nimport { getAuthorizedItems, getStatusByItemId } from 'modules/item/selectors'\nimport { MapStateProps, MapDispatchProps, MapDispatch, OwnProps } from './MintItemsModal.types'\nimport MintItemsModal from './MintItemsModal'\n\nconst mapState = (state: RootState, ownProps: OwnProps): MapStateProps => {\n  let { collectionId, itemIds } = ownProps.metadata\n\n  if (!collectionId && (!itemIds || itemIds.length === 0)) {\n    throw new Error('Invalid collection id or items id to mint')\n  }\n\n  const ethAddress = getAddress(state)\n  let collection: Collection\n  let items: Item[]\n  let totalCollectionItems: number\n\n  if (collectionId) {\n    items = getCollectionItems(state, collectionId)\n    totalCollectionItems = items.length\n  } else {\n    const allItems = getAuthorizedItems(state)\n    items = allItems.filter(item => itemIds.includes(item.id))\n    collectionId = items[0].collectionId\n    totalCollectionItems = allItems.filter(item => item.collectionId === collectionId).length\n  }\n\n  collection = getCollection(state, collectionId)!\n\n  const hasUnsyncedItems = (items: Item[]) => items.some(item => UNSYNCED_STATES.has(getStatusByItemId(state)[item.id]))\n\n  return {\n    items: items.filter(item => canMintItem(collection, item, ethAddress)),\n    isLoading: isLoadingType(getLoading(state), MINT_COLLECTION_ITEMS_REQUEST),\n    ethAddress,\n    collection,\n    totalCollectionItems,\n    hasUnsyncedItems\n  }\n}\n\nconst mapDispatch = (dispatch: MapDispatch): MapDispatchProps => ({\n  onMint: (collection, items) => dispatch(mintCollectionItemsRequest(collection, items))\n})\n\nexport default connect(mapState, mapDispatch)(MintItemsModal)\n"]},"metadata":{},"sourceType":"module"}