{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Vector4 } from \"../Maths/math.vector\";\nimport { Color3, Color4 } from \"../Maths/math.color\";\nimport { Condition, ValueCondition } from \"./condition\";\nimport { Action } from \"./action\";\nimport { DoNothingAction } from \"./directActions\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"../Misc/logger\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\nimport { _TypeStore } from \"../Misc/typeStore\";\nimport { AbstractActionManager } from './abstractActionManager';\n/**\r\n * Action Manager manages all events to be triggered on a given mesh or the global scene.\r\n * A single scene can have many Action Managers to handle predefined actions on specific meshes.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n */\n\nvar ActionManager =\n/** @class */\nfunction (_super) {\n  __extends(ActionManager, _super);\n  /**\r\n   * Creates a new action manager\r\n   * @param scene defines the hosting scene\r\n   */\n\n\n  function ActionManager(scene) {\n    var _this = _super.call(this) || this;\n\n    _this._scene = scene || EngineStore.LastCreatedScene;\n    scene.actionManagers.push(_this);\n    return _this;\n  } // Methods\n\n  /**\r\n   * Releases all associated resources\r\n   */\n\n\n  ActionManager.prototype.dispose = function () {\n    var index = this._scene.actionManagers.indexOf(this);\n\n    for (var i = 0; i < this.actions.length; i++) {\n      var action = this.actions[i];\n      ActionManager.Triggers[action.trigger]--;\n\n      if (ActionManager.Triggers[action.trigger] === 0) {\n        delete ActionManager.Triggers[action.trigger];\n      }\n    }\n\n    if (index > -1) {\n      this._scene.actionManagers.splice(index, 1);\n    }\n  };\n  /**\r\n   * Gets hosting scene\r\n   * @returns the hosting scene\r\n   */\n\n\n  ActionManager.prototype.getScene = function () {\n    return this._scene;\n  };\n  /**\r\n   * Does this action manager handles actions of any of the given triggers\r\n   * @param triggers defines the triggers to be tested\r\n   * @return a boolean indicating whether one (or more) of the triggers is handled\r\n   */\n\n\n  ActionManager.prototype.hasSpecificTriggers = function (triggers) {\n    for (var index = 0; index < this.actions.length; index++) {\n      var action = this.actions[index];\n\n      if (triggers.indexOf(action.trigger) > -1) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Does this action manager handles actions of any of the given triggers. This function takes two arguments for\r\n   * speed.\r\n   * @param triggerA defines the trigger to be tested\r\n   * @param triggerB defines the trigger to be tested\r\n   * @return a boolean indicating whether one (or more) of the triggers is handled\r\n   */\n\n\n  ActionManager.prototype.hasSpecificTriggers2 = function (triggerA, triggerB) {\n    for (var index = 0; index < this.actions.length; index++) {\n      var action = this.actions[index];\n\n      if (triggerA == action.trigger || triggerB == action.trigger) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Does this action manager handles actions of a given trigger\r\n   * @param trigger defines the trigger to be tested\r\n   * @param parameterPredicate defines an optional predicate to filter triggers by parameter\r\n   * @return whether the trigger is handled\r\n   */\n\n\n  ActionManager.prototype.hasSpecificTrigger = function (trigger, parameterPredicate) {\n    for (var index = 0; index < this.actions.length; index++) {\n      var action = this.actions[index];\n\n      if (action.trigger === trigger) {\n        if (parameterPredicate) {\n          if (parameterPredicate(action.getTriggerParameter())) {\n            return true;\n          }\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(ActionManager.prototype, \"hasPointerTriggers\", {\n    /**\r\n     * Does this action manager has pointer triggers\r\n     */\n    get: function get() {\n      for (var index = 0; index < this.actions.length; index++) {\n        var action = this.actions[index];\n\n        if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ActionManager.prototype, \"hasPickTriggers\", {\n    /**\r\n     * Does this action manager has pick triggers\r\n     */\n    get: function get() {\n      for (var index = 0; index < this.actions.length; index++) {\n        var action = this.actions[index];\n\n        if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Registers an action to this action manager\r\n   * @param action defines the action to be registered\r\n   * @return the action amended (prepared) after registration\r\n   */\n\n  ActionManager.prototype.registerAction = function (action) {\n    if (action.trigger === ActionManager.OnEveryFrameTrigger) {\n      if (this.getScene().actionManager !== this) {\n        Logger.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\");\n        return null;\n      }\n    }\n\n    this.actions.push(action);\n\n    if (ActionManager.Triggers[action.trigger]) {\n      ActionManager.Triggers[action.trigger]++;\n    } else {\n      ActionManager.Triggers[action.trigger] = 1;\n    }\n\n    action._actionManager = this;\n\n    action._prepare();\n\n    return action;\n  };\n  /**\r\n   * Unregisters an action to this action manager\r\n   * @param action defines the action to be unregistered\r\n   * @return a boolean indicating whether the action has been unregistered\r\n   */\n\n\n  ActionManager.prototype.unregisterAction = function (action) {\n    var index = this.actions.indexOf(action);\n\n    if (index !== -1) {\n      this.actions.splice(index, 1);\n      ActionManager.Triggers[action.trigger] -= 1;\n\n      if (ActionManager.Triggers[action.trigger] === 0) {\n        delete ActionManager.Triggers[action.trigger];\n      }\n\n      action._actionManager = null;\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Process a specific trigger\r\n   * @param trigger defines the trigger to process\r\n   * @param evt defines the event details to be processed\r\n   */\n\n\n  ActionManager.prototype.processTrigger = function (trigger, evt) {\n    for (var index = 0; index < this.actions.length; index++) {\n      var action = this.actions[index];\n\n      if (action.trigger === trigger) {\n        if (evt) {\n          if (trigger === ActionManager.OnKeyUpTrigger || trigger === ActionManager.OnKeyDownTrigger) {\n            var parameter = action.getTriggerParameter();\n\n            if (parameter && parameter !== evt.sourceEvent.keyCode) {\n              if (!parameter.toLowerCase) {\n                continue;\n              }\n\n              var lowerCase = parameter.toLowerCase();\n\n              if (lowerCase !== evt.sourceEvent.key) {\n                var unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;\n                var actualkey = String.fromCharCode(unicode).toLowerCase();\n\n                if (actualkey !== lowerCase) {\n                  continue;\n                }\n              }\n            }\n          }\n        }\n\n        action._executeCurrent(evt);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  ActionManager.prototype._getEffectiveTarget = function (target, propertyPath) {\n    var properties = propertyPath.split(\".\");\n\n    for (var index = 0; index < properties.length - 1; index++) {\n      target = target[properties[index]];\n    }\n\n    return target;\n  };\n  /** @hidden */\n\n\n  ActionManager.prototype._getProperty = function (propertyPath) {\n    var properties = propertyPath.split(\".\");\n    return properties[properties.length - 1];\n  };\n  /**\r\n   * Serialize this manager to a JSON object\r\n   * @param name defines the property name to store this manager\r\n   * @returns a JSON representation of this manager\r\n   */\n\n\n  ActionManager.prototype.serialize = function (name) {\n    var root = {\n      children: new Array(),\n      name: name,\n      type: 3,\n      properties: new Array() // Empty for root but required\n\n    };\n\n    for (var i = 0; i < this.actions.length; i++) {\n      var triggerObject = {\n        type: 0,\n        children: new Array(),\n        name: ActionManager.GetTriggerName(this.actions[i].trigger),\n        properties: new Array()\n      };\n      var triggerOptions = this.actions[i].triggerOptions;\n\n      if (triggerOptions && typeof triggerOptions !== \"number\") {\n        if (triggerOptions.parameter instanceof Node) {\n          triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));\n        } else {\n          var parameter = {};\n          DeepCopier.DeepCopy(triggerOptions.parameter, parameter, [\"mesh\"]);\n\n          if (triggerOptions.parameter && triggerOptions.parameter.mesh) {\n            parameter._meshId = triggerOptions.parameter.mesh.id;\n          }\n\n          triggerObject.properties.push({\n            name: \"parameter\",\n            targetType: null,\n            value: parameter\n          });\n        }\n      } // Serialize child action, recursively\n\n\n      this.actions[i].serialize(triggerObject); // Add serialized trigger\n\n      root.children.push(triggerObject);\n    }\n\n    return root;\n  };\n  /**\r\n   * Creates a new ActionManager from a JSON data\r\n   * @param parsedActions defines the JSON data to read from\r\n   * @param object defines the hosting mesh\r\n   * @param scene defines the hosting scene\r\n   */\n\n\n  ActionManager.Parse = function (parsedActions, object, scene) {\n    var actionManager = new ActionManager(scene);\n\n    if (object === null) {\n      scene.actionManager = actionManager;\n    } else {\n      object.actionManager = actionManager;\n    } // instanciate a new object\n\n\n    var instanciate = function instanciate(name, params) {\n      var internalClassType = _TypeStore.GetClass(\"BABYLON.\" + name);\n\n      if (internalClassType) {\n        var newInstance = Object.create(internalClassType.prototype);\n        newInstance.constructor.apply(newInstance, params);\n        return newInstance;\n      }\n    };\n\n    var parseParameter = function parseParameter(name, value, target, propertyPath) {\n      if (propertyPath === null) {\n        // String, boolean or float\n        var floatValue = parseFloat(value);\n\n        if (value === \"true\" || value === \"false\") {\n          return value === \"true\";\n        } else {\n          return isNaN(floatValue) ? value : floatValue;\n        }\n      }\n\n      var effectiveTarget = propertyPath.split(\".\");\n      var values = value.split(\",\"); // Get effective Target\n\n      for (var i = 0; i < effectiveTarget.length; i++) {\n        target = target[effectiveTarget[i]];\n      } // Return appropriate value with its type\n\n\n      if (typeof target === \"boolean\") {\n        return values[0] === \"true\";\n      }\n\n      if (typeof target === \"string\") {\n        return values[0];\n      } // Parameters with multiple values such as Vector3 etc.\n\n\n      var split = new Array();\n\n      for (var i = 0; i < values.length; i++) {\n        split.push(parseFloat(values[i]));\n      }\n\n      if (target instanceof Vector3) {\n        return Vector3.FromArray(split);\n      }\n\n      if (target instanceof Vector4) {\n        return Vector4.FromArray(split);\n      }\n\n      if (target instanceof Color3) {\n        return Color3.FromArray(split);\n      }\n\n      if (target instanceof Color4) {\n        return Color4.FromArray(split);\n      }\n\n      return parseFloat(values[0]);\n    }; // traverse graph per trigger\n\n\n    var traverse = function traverse(parsedAction, trigger, condition, action, combineArray) {\n      if (combineArray === void 0) {\n        combineArray = null;\n      }\n\n      if (parsedAction.detached) {\n        return;\n      }\n\n      var parameters = new Array();\n      var target = null;\n      var propertyPath = null;\n      var combine = parsedAction.combine && parsedAction.combine.length > 0; // Parameters\n\n      if (parsedAction.type === 2) {\n        parameters.push(actionManager);\n      } else {\n        parameters.push(trigger);\n      }\n\n      if (combine) {\n        var actions = new Array();\n\n        for (var j = 0; j < parsedAction.combine.length; j++) {\n          traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);\n        }\n\n        parameters.push(actions);\n      } else {\n        for (var i = 0; i < parsedAction.properties.length; i++) {\n          var value = parsedAction.properties[i].value;\n          var name = parsedAction.properties[i].name;\n          var targetType = parsedAction.properties[i].targetType;\n\n          if (name === \"target\") {\n            if (targetType !== null && targetType === \"SceneProperties\") {\n              value = target = scene;\n            } else {\n              value = target = scene.getNodeByName(value);\n            }\n          } else if (name === \"parent\") {\n            value = scene.getNodeByName(value);\n          } else if (name === \"sound\") {\n            // Can not externalize to component, so only checks for the presence off the API.\n            if (scene.getSoundByName) {\n              value = scene.getSoundByName(value);\n            }\n          } else if (name !== \"propertyPath\") {\n            if (parsedAction.type === 2 && name === \"operator\") {\n              value = ValueCondition[value];\n            } else {\n              value = parseParameter(name, value, target, name === \"value\" ? propertyPath : null);\n            }\n          } else {\n            propertyPath = value;\n          }\n\n          parameters.push(value);\n        }\n      }\n\n      if (combineArray === null) {\n        parameters.push(condition);\n      } else {\n        parameters.push(null);\n      } // If interpolate value action\n\n\n      if (parsedAction.name === \"InterpolateValueAction\") {\n        var param = parameters[parameters.length - 2];\n        parameters[parameters.length - 1] = param;\n        parameters[parameters.length - 2] = condition;\n      } // Action or condition(s) and not CombineAction\n\n\n      var newAction = instanciate(parsedAction.name, parameters);\n\n      if (newAction instanceof Condition && condition !== null) {\n        var nothing = new DoNothingAction(trigger, condition);\n\n        if (action) {\n          action.then(nothing);\n        } else {\n          actionManager.registerAction(nothing);\n        }\n\n        action = nothing;\n      }\n\n      if (combineArray === null) {\n        if (newAction instanceof Condition) {\n          condition = newAction;\n          newAction = action;\n        } else {\n          condition = null;\n\n          if (action) {\n            action.then(newAction);\n          } else {\n            actionManager.registerAction(newAction);\n          }\n        }\n      } else {\n        combineArray.push(newAction);\n      }\n\n      for (var i = 0; i < parsedAction.children.length; i++) {\n        traverse(parsedAction.children[i], trigger, condition, newAction, null);\n      }\n    }; // triggers\n\n\n    for (var i = 0; i < parsedActions.children.length; i++) {\n      var triggerParams;\n      var trigger = parsedActions.children[i];\n\n      if (trigger.properties.length > 0) {\n        var param = trigger.properties[0].value;\n        var value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);\n\n        if (value._meshId) {\n          value.mesh = scene.getMeshByID(value._meshId);\n        }\n\n        triggerParams = {\n          trigger: ActionManager[trigger.name],\n          parameter: value\n        };\n      } else {\n        triggerParams = ActionManager[trigger.name];\n      }\n\n      for (var j = 0; j < trigger.children.length; j++) {\n        if (!trigger.detached) {\n          traverse(trigger.children[j], triggerParams, null, null);\n        }\n      }\n    }\n  };\n  /**\r\n   * Get a trigger name by index\r\n   * @param trigger defines the trigger index\r\n   * @returns a trigger name\r\n   */\n\n\n  ActionManager.GetTriggerName = function (trigger) {\n    switch (trigger) {\n      case 0:\n        return \"NothingTrigger\";\n\n      case 1:\n        return \"OnPickTrigger\";\n\n      case 2:\n        return \"OnLeftPickTrigger\";\n\n      case 3:\n        return \"OnRightPickTrigger\";\n\n      case 4:\n        return \"OnCenterPickTrigger\";\n\n      case 5:\n        return \"OnPickDownTrigger\";\n\n      case 6:\n        return \"OnPickUpTrigger\";\n\n      case 7:\n        return \"OnLongPressTrigger\";\n\n      case 8:\n        return \"OnPointerOverTrigger\";\n\n      case 9:\n        return \"OnPointerOutTrigger\";\n\n      case 10:\n        return \"OnEveryFrameTrigger\";\n\n      case 11:\n        return \"OnIntersectionEnterTrigger\";\n\n      case 12:\n        return \"OnIntersectionExitTrigger\";\n\n      case 13:\n        return \"OnKeyDownTrigger\";\n\n      case 14:\n        return \"OnKeyUpTrigger\";\n\n      case 15:\n        return \"OnPickOutTrigger\";\n\n      default:\n        return \"\";\n    }\n  };\n  /**\r\n   * Nothing\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n\n  ActionManager.NothingTrigger = 0;\n  /**\r\n   * On pick\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnPickTrigger = 1;\n  /**\r\n   * On left pick\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnLeftPickTrigger = 2;\n  /**\r\n   * On right pick\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnRightPickTrigger = 3;\n  /**\r\n   * On center pick\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnCenterPickTrigger = 4;\n  /**\r\n   * On pick down\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnPickDownTrigger = 5;\n  /**\r\n   * On double pick\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnDoublePickTrigger = 6;\n  /**\r\n   * On pick up\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnPickUpTrigger = 7;\n  /**\r\n   * On pick out.\r\n   * This trigger will only be raised if you also declared a OnPickDown\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnPickOutTrigger = 16;\n  /**\r\n   * On long press\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnLongPressTrigger = 8;\n  /**\r\n   * On pointer over\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnPointerOverTrigger = 9;\n  /**\r\n   * On pointer out\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnPointerOutTrigger = 10;\n  /**\r\n   * On every frame\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnEveryFrameTrigger = 11;\n  /**\r\n   * On intersection enter\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnIntersectionEnterTrigger = 12;\n  /**\r\n   * On intersection exit\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnIntersectionExitTrigger = 13;\n  /**\r\n   * On key down\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnKeyDownTrigger = 14;\n  /**\r\n   * On key up\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers\r\n   */\n\n  ActionManager.OnKeyUpTrigger = 15;\n  return ActionManager;\n}(AbstractActionManager);\n\nexport { ActionManager };","map":null,"metadata":{},"sourceType":"module"}