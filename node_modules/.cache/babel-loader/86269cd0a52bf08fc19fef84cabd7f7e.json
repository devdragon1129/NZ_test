{"ast":null,"code":"'use strict'; // @ts-ignore\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _awaitAsyncGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\n\nvar BufferList = require('bl/BufferList'); // @ts-ignore\n\n\nvar _require = require('rabin-wasm'),\n    create = _require.create;\n\nvar errcode = require('err-code');\n/**\n * @typedef {object} RabinOptions\n * @property {number} min\n * @property {number} max\n * @property {number} bits\n * @property {number} window\n * @property {number} polynomial\n */\n\n/**\n * @type {import('../types').Chunker}\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _rabinChunker = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, options) {\n    var min, max, avg, sizepow, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(options.minChunkSize && options.maxChunkSize && options.avgChunkSize)) {\n              _context.next = 6;\n              break;\n            }\n\n            avg = options.avgChunkSize;\n            min = options.minChunkSize;\n            max = options.maxChunkSize;\n            _context.next = 13;\n            break;\n\n          case 6:\n            if (options.avgChunkSize) {\n              _context.next = 10;\n              break;\n            }\n\n            throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n\n          case 10:\n            avg = options.avgChunkSize;\n            min = avg / 3;\n            max = avg + avg / 2;\n\n          case 13:\n            if (!(min < 16)) {\n              _context.next = 15;\n              break;\n            }\n\n            throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n\n          case 15:\n            if (max < min) {\n              max = min;\n            }\n\n            if (avg < min) {\n              avg = min;\n            }\n\n            sizepow = Math.floor(Math.log2(avg));\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 20;\n            _iterator = _asyncIterator(rabin(source, {\n              min: min,\n              max: max,\n              bits: sizepow,\n              window: options.window,\n              polynomial: options.polynomial\n            }));\n\n          case 22:\n            _context.next = 24;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 24:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 31;\n              break;\n            }\n\n            chunk = _step.value;\n            _context.next = 28;\n            return chunk;\n\n          case 28:\n            _iteratorAbruptCompletion = false;\n            _context.next = 22;\n            break;\n\n          case 31:\n            _context.next = 37;\n            break;\n\n          case 33:\n            _context.prev = 33;\n            _context.t0 = _context[\"catch\"](20);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 37:\n            _context.prev = 37;\n            _context.prev = 38;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 42;\n              break;\n            }\n\n            _context.next = 42;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 42:\n            _context.prev = 42;\n\n            if (!_didIteratorError) {\n              _context.next = 45;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 45:\n            return _context.finish(42);\n\n          case 46:\n            return _context.finish(37);\n\n          case 47:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[20, 33, 37, 47], [38,, 42, 46]]);\n  }));\n\n  function rabinChunker(_x, _x2) {\n    return _rabinChunker.apply(this, arguments);\n  }\n\n  return rabinChunker;\n}();\n/**\n * @param {AsyncIterable<Uint8Array>} source\n * @param {RabinOptions} options\n */\n\n\nfunction rabin(_x3, _x4) {\n  return _rabin.apply(this, arguments);\n}\n\nfunction _rabin() {\n  _rabin = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source, options) {\n    var r, buffers, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk, sizes, i, size, buf;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _awaitAsyncGenerator(create(options.bits, options.min, options.max, options.window));\n\n          case 2:\n            r = _context2.sent;\n            buffers = new BufferList();\n            _iteratorAbruptCompletion2 = false;\n            _didIteratorError2 = false;\n            _context2.prev = 6;\n            _iterator2 = _asyncIterator(source);\n\n          case 8:\n            _context2.next = 10;\n            return _awaitAsyncGenerator(_iterator2.next());\n\n          case 10:\n            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context2.sent).done)) {\n              _context2.next = 27;\n              break;\n            }\n\n            chunk = _step2.value;\n            buffers.append(chunk);\n            sizes = r.fingerprint(chunk);\n            i = 0;\n\n          case 15:\n            if (!(i < sizes.length)) {\n              _context2.next = 24;\n              break;\n            }\n\n            size = sizes[i];\n            buf = buffers.slice(0, size);\n            buffers.consume(size);\n            _context2.next = 21;\n            return buf;\n\n          case 21:\n            i++;\n            _context2.next = 15;\n            break;\n\n          case 24:\n            _iteratorAbruptCompletion2 = false;\n            _context2.next = 8;\n            break;\n\n          case 27:\n            _context2.next = 33;\n            break;\n\n          case 29:\n            _context2.prev = 29;\n            _context2.t0 = _context2[\"catch\"](6);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context2.t0;\n\n          case 33:\n            _context2.prev = 33;\n            _context2.prev = 34;\n\n            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n              _context2.next = 38;\n              break;\n            }\n\n            _context2.next = 38;\n            return _awaitAsyncGenerator(_iterator2.return());\n\n          case 38:\n            _context2.prev = 38;\n\n            if (!_didIteratorError2) {\n              _context2.next = 41;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 41:\n            return _context2.finish(38);\n\n          case 42:\n            return _context2.finish(33);\n\n          case 43:\n            if (!buffers.length) {\n              _context2.next = 46;\n              break;\n            }\n\n            _context2.next = 46;\n            return buffers.slice(0);\n\n          case 46:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[6, 29, 33, 43], [34,, 38, 42]]);\n  }));\n  return _rabin.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}