{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Tools } from \"../../Misc/tools\";\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n *\r\n * Tested on chrome (mobile) 80.\r\n */\n\nvar WebXRHitTest =\n/** @class */\nfunction (_super) {\n  __extends(WebXRHitTest, _super);\n  /**\r\n   * Creates a new instance of the hit test feature\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param options options to use when constructing this feature\r\n   */\n\n\n  function WebXRHitTest(_xrSessionManager,\n  /**\r\n   * options to use when constructing this feature\r\n   */\n  options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options;\n    _this._tmpMat = new Matrix();\n    _this._tmpPos = new Vector3();\n    _this._tmpQuat = new Quaternion();\n\n    _this.initHitTestSource = function (referenceSpace) {\n      if (!referenceSpace) {\n        return;\n      }\n\n      var offsetRay = new XRRay(_this.options.offsetRay || {});\n      var hitTestOptions = {\n        space: _this.options.useReferenceSpace ? referenceSpace : _this._xrSessionManager.viewerReferenceSpace,\n        offsetRay: offsetRay\n      };\n\n      if (_this.options.entityTypes) {\n        hitTestOptions.entityTypes = _this.options.entityTypes;\n      }\n\n      if (!hitTestOptions.space) {\n        Tools.Warn(\"waiting for viewer reference space to initialize\");\n        return;\n      }\n\n      _this._xrSessionManager.session.requestHitTestSource(hitTestOptions).then(function (hitTestSource) {\n        if (_this._xrHitTestSource) {\n          _this._xrHitTestSource.cancel();\n        }\n\n        _this._xrHitTestSource = hitTestSource;\n      });\n    };\n    /**\r\n     * When set to true, each hit test will have its own position/rotation objects\r\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\r\n     * the developers will clone them or copy them as they see fit.\r\n     */\n\n\n    _this.autoCloneTransformation = false;\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     * Note - this will be called when results come back from the device. It can be an empty array!!\r\n     */\n\n    _this.onHitTestResultObservable = new Observable();\n    /**\r\n     * Use this to temporarily pause hit test checks.\r\n     */\n\n    _this.paused = false;\n    _this.xrNativeFeatureName = \"hit-test\";\n    Tools.Warn(\"Hit test is an experimental and unstable feature.\");\n    return _this;\n  }\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHitTest.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    } // Feature enabled, but not available\n\n\n    if (!this._xrSessionManager.session.requestHitTestSource) {\n      return false;\n    }\n\n    if (!this.options.disablePermanentHitTest) {\n      if (this._xrSessionManager.referenceSpace) {\n        this.initHitTestSource(this._xrSessionManager.referenceSpace);\n      }\n\n      this._xrSessionManager.onXRReferenceSpaceChanged.add(this.initHitTestSource);\n    }\n\n    if (this.options.enableTransientHitTest) {\n      var offsetRay = new XRRay(this.options.transientOffsetRay || {});\n\n      this._xrSessionManager.session.requestHitTestSourceForTransientInput({\n        profile: \"generic-touchscreen\",\n        offsetRay: offsetRay,\n        entityTypes: this.options.entityTypes\n      }).then(function (hitSource) {\n        _this._transientXrHitTestSource = hitSource;\n      });\n    }\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHitTest.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    if (this._xrHitTestSource) {\n      this._xrHitTestSource.cancel();\n\n      this._xrHitTestSource = null;\n    }\n\n    this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this.initHitTestSource);\n\n    if (this._transientXrHitTestSource) {\n      this._transientXrHitTestSource.cancel();\n\n      this._transientXrHitTestSource = null;\n    }\n\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRHitTest.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onHitTestResultObservable.clear();\n  };\n\n  WebXRHitTest.prototype._onXRFrame = function (frame) {\n    var _this = this; // make sure we do nothing if (async) not attached\n\n\n    if (!this.attached || this.paused) {\n      return;\n    }\n\n    if (this._xrHitTestSource) {\n      var results = frame.getHitTestResults(this._xrHitTestSource);\n\n      this._processWebXRHitTestResult(results);\n    }\n\n    if (this._transientXrHitTestSource) {\n      var hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\n      hitTestResultsPerInputSource.forEach(function (resultsPerInputSource) {\n        _this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\n      });\n    }\n  };\n\n  WebXRHitTest.prototype._processWebXRHitTestResult = function (hitTestResults, inputSource) {\n    var _this = this;\n\n    var results = [];\n    hitTestResults.forEach(function (hitTestResult) {\n      var pose = hitTestResult.getPose(_this._xrSessionManager.referenceSpace);\n\n      if (!pose) {\n        return;\n      }\n\n      var pos = pose.transform.position;\n      var quat = pose.transform.orientation;\n\n      _this._tmpPos.set(pos.x, pos.y, pos.z);\n\n      _this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\n\n      Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, _this._tmpMat);\n\n      if (!_this._xrSessionManager.scene.useRightHandedSystem) {\n        _this._tmpPos.z *= -1;\n        _this._tmpQuat.z *= -1;\n        _this._tmpQuat.w *= -1;\n\n        _this._tmpMat.toggleModelMatrixHandInPlace();\n      }\n\n      var result = {\n        position: _this.autoCloneTransformation ? _this._tmpPos.clone() : _this._tmpPos,\n        rotationQuaternion: _this.autoCloneTransformation ? _this._tmpQuat.clone() : _this._tmpQuat,\n        transformationMatrix: _this.autoCloneTransformation ? _this._tmpMat.clone() : _this._tmpMat,\n        inputSource: inputSource,\n        isTransient: !!inputSource,\n        xrHitResult: hitTestResult\n      };\n      results.push(result);\n    });\n    this.onHitTestResultObservable.notifyObservers(results);\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRHitTest.Name = WebXRFeatureName.HIT_TEST;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRHitTest.Version = 2;\n  return WebXRHitTest;\n}(WebXRAbstractFeature);\n\nexport { WebXRHitTest }; //register the plugin versions\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTest.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRHitTest(xrSessionManager, options);\n  };\n}, WebXRHitTest.Version, false);","map":null,"metadata":{},"sourceType":"module"}