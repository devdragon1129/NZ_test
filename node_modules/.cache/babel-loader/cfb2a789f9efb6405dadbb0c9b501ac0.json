{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Matrix, Quaternion } from \"../Maths/math.vector\";\nimport { Camera } from \"../Cameras/camera\";\nimport { FreeCamera } from \"../Cameras/freeCamera\";\nimport { TargetCamera } from \"../Cameras/targetCamera\";\nimport { Viewport } from \"../Maths/math.viewport\";\nimport { Observable } from \"../Misc/observable\";\nimport { WebXRTrackingState } from \"./webXRTypes\";\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/how_to/webxr_camera\r\n */\n\nvar WebXRCamera =\n/** @class */\nfunction (_super) {\n  __extends(WebXRCamera, _super);\n  /**\r\n   * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n   * @param name the name of the camera\r\n   * @param scene the scene to add the camera to\r\n   * @param _xrSessionManager a constructed xr session manager\r\n   */\n\n\n  function WebXRCamera(name, scene, _xrSessionManager) {\n    var _this = _super.call(this, name, Vector3.Zero(), scene) || this;\n\n    _this._xrSessionManager = _xrSessionManager;\n    _this._firstFrame = false;\n    _this._referenceQuaternion = Quaternion.Identity();\n    _this._referencedPosition = new Vector3();\n    _this._xrInvPositionCache = new Vector3();\n    _this._xrInvQuaternionCache = Quaternion.Identity();\n    _this._trackingState = WebXRTrackingState.NOT_TRACKING;\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\n\n    _this.onBeforeCameraTeleport = new Observable();\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\n\n    _this.onAfterCameraTeleport = new Observable();\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\n\n    _this.onTrackingStateChanged = new Observable();\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\n\n    _this.compensateOnFirstFrame = true;\n    _this._rotate180 = new Quaternion(0, 1, 0, 0); // Initial camera configuration\n\n    _this.minZ = 0.1;\n    _this.rotationQuaternion = new Quaternion();\n    _this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\n    _this.updateUpVectorFromRotation = true;\n\n    _this._updateNumberOfRigCameras(1); // freeze projection matrix, which will be copied later\n\n\n    _this.freezeProjectionMatrix();\n\n    _this._xrSessionManager.onXRSessionInit.add(function () {\n      _this._referencedPosition.copyFromFloats(0, 0, 0);\n\n      _this._referenceQuaternion.copyFromFloats(0, 0, 0, 1); // first frame - camera's y position should be 0 for the correct offset\n\n\n      _this._firstFrame = _this.compensateOnFirstFrame;\n    }); // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\n    // applied to the rest of the elements using the referenceSpace object\n\n\n    _this._xrSessionManager.onXRFrameObservable.add(function (frame) {\n      if (_this._firstFrame) {\n        _this._updateFromXRSession();\n      }\n\n      _this._updateReferenceSpace();\n\n      _this._updateFromXRSession();\n    }, undefined, true);\n\n    return _this;\n  }\n\n  Object.defineProperty(WebXRCamera.prototype, \"trackingState\", {\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\n    get: function get() {\n      return this._trackingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRCamera.prototype._setTrackingState = function (newState) {\n    if (this._trackingState !== newState) {\n      this._trackingState = newState;\n      this.onTrackingStateChanged.notifyObservers(newState);\n    }\n  };\n\n  Object.defineProperty(WebXRCamera.prototype, \"realWorldHeight\", {\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     */\n    get: function get() {\n      var basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\n\n      if (basePose && basePose.transform) {\n        return basePose.transform.position.y;\n      } else {\n        return 0;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  WebXRCamera.prototype._updateForDualEyeDebugging = function\n    /*pupilDistance = 0.01*/\n  () {\n    // Create initial camera rigs\n    this._updateNumberOfRigCameras(2);\n\n    this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0); // this.rigCameras[0].position.x = -pupilDistance / 2;\n\n    this.rigCameras[0].outputRenderTarget = null;\n    this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0); // this.rigCameras[1].position.x = pupilDistance / 2;\n\n    this.rigCameras[1].outputRenderTarget = null;\n  };\n  /**\r\n   * Sets this camera's transformation based on a non-vr camera\r\n   * @param otherCamera the non-vr camera to copy the transformation from\r\n   * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n   */\n\n\n  WebXRCamera.prototype.setTransformationFromNonVRCamera = function (otherCamera, resetToBaseReferenceSpace) {\n    if (otherCamera === void 0) {\n      otherCamera = this.getScene().activeCamera;\n    }\n\n    if (resetToBaseReferenceSpace === void 0) {\n      resetToBaseReferenceSpace = true;\n    }\n\n    if (!otherCamera || otherCamera === this) {\n      return;\n    }\n\n    var mat = otherCamera.computeWorldMatrix();\n    mat.decompose(undefined, this.rotationQuaternion, this.position); // set the ground level\n\n    this.position.y = 0;\n    Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\n    this._firstFrame = true;\n\n    if (resetToBaseReferenceSpace) {\n      this._xrSessionManager.resetReferenceSpace();\n    }\n  };\n  /**\r\n   * Gets the current instance class name (\"WebXRCamera\").\r\n   * @returns the class name\r\n   */\n\n\n  WebXRCamera.prototype.getClassName = function () {\n    return \"WebXRCamera\";\n  };\n\n  WebXRCamera.prototype._updateFromXRSession = function () {\n    var _this = this;\n\n    var pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\n\n    if (!pose) {\n      this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\n\n      return;\n    } // Set the tracking state. if it didn't change it is a no-op\n\n\n    var trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\n\n    this._setTrackingState(trackingState);\n\n    if (pose.transform) {\n      var pos = pose.transform.position;\n\n      this._referencedPosition.set(pos.x, pos.y, pos.z);\n\n      var orientation_1 = pose.transform.orientation;\n\n      this._referenceQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);\n\n      if (!this._scene.useRightHandedSystem) {\n        this._referencedPosition.z *= -1;\n        this._referenceQuaternion.z *= -1;\n        this._referenceQuaternion.w *= -1;\n      }\n\n      if (this._firstFrame) {\n        this._firstFrame = false; // we have the XR reference, now use this to find the offset to get the camera to be\n        // in the right position\n        // set the height to correlate to the current height\n\n        this.position.y += this._referencedPosition.y; // avoid using the head rotation on the first frame.\n\n        this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\n      } else {\n        // update position and rotation as reference\n        this.rotationQuaternion.copyFrom(this._referenceQuaternion);\n        this.position.copyFrom(this._referencedPosition);\n      }\n    } // Update camera rigs\n\n\n    if (this.rigCameras.length !== pose.views.length) {\n      this._updateNumberOfRigCameras(pose.views.length);\n    }\n\n    pose.views.forEach(function (view, i) {\n      var currentRig = _this.rigCameras[i]; // update right and left, where applicable\n\n      if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\n        if (view.eye === \"right\") {\n          currentRig._isRightCamera = true;\n        } else if (view.eye === \"left\") {\n          currentRig._isLeftCamera = true;\n        }\n      } // Update view/projection matrix\n\n\n      var pos = view.transform.position;\n      var orientation = view.transform.orientation;\n      currentRig.position.set(pos.x, pos.y, pos.z);\n      currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n\n      if (!_this._scene.useRightHandedSystem) {\n        currentRig.position.z *= -1;\n        currentRig.rotationQuaternion.z *= -1;\n        currentRig.rotationQuaternion.w *= -1;\n      } else {\n        currentRig.rotationQuaternion.multiplyInPlace(_this._rotate180);\n      }\n\n      Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\n\n      if (!_this._scene.useRightHandedSystem) {\n        currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\n      } // first camera?\n\n\n      if (i === 0) {\n        _this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\n      } // Update viewport\n\n\n      if (_this._xrSessionManager.session.renderState.baseLayer) {\n        var viewport = _this._xrSessionManager.session.renderState.baseLayer.getViewport(view);\n\n        var width = _this._xrSessionManager.session.renderState.baseLayer.framebufferWidth;\n        var height = _this._xrSessionManager.session.renderState.baseLayer.framebufferHeight;\n        currentRig.viewport.width = viewport.width / width;\n        currentRig.viewport.height = viewport.height / height;\n        currentRig.viewport.x = viewport.x / width;\n        currentRig.viewport.y = viewport.y / height;\n      } // Set cameras to render to the session's render target\n\n\n      currentRig.outputRenderTarget = _this._xrSessionManager.getRenderTargetTextureForEye(view.eye);\n    });\n  };\n\n  WebXRCamera.prototype._updateNumberOfRigCameras = function (viewCount) {\n    if (viewCount === void 0) {\n      viewCount = 1;\n    }\n\n    while (this.rigCameras.length < viewCount) {\n      var newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\n      newCamera.minZ = 0.1;\n      newCamera.rotationQuaternion = new Quaternion();\n      newCamera.updateUpVectorFromRotation = true;\n      newCamera.isRigCamera = true;\n      newCamera.rigParent = this; // do not compute projection matrix, provided by XR\n\n      newCamera.freezeProjectionMatrix();\n      this.rigCameras.push(newCamera);\n    }\n\n    while (this.rigCameras.length > viewCount) {\n      var removedCamera = this.rigCameras.pop();\n\n      if (removedCamera) {\n        removedCamera.dispose();\n      }\n    }\n  };\n\n  WebXRCamera.prototype._updateReferenceSpace = function () {\n    // were position & rotation updated OUTSIDE of the xr update loop\n    if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\n      this.position.subtractToRef(this._referencedPosition, this._referencedPosition);\n\n      this._referenceQuaternion.conjugateInPlace();\n\n      this._referenceQuaternion.multiplyToRef(this.rotationQuaternion, this._referenceQuaternion);\n\n      this._updateReferenceSpaceOffset(this._referencedPosition, this._referenceQuaternion.normalize());\n    }\n  };\n\n  WebXRCamera.prototype._updateReferenceSpaceOffset = function (positionOffset, rotationOffset, ignoreHeight) {\n    if (ignoreHeight === void 0) {\n      ignoreHeight = false;\n    }\n\n    if (!this._xrSessionManager.referenceSpace || !this._xrSessionManager.currentFrame) {\n      return;\n    } // Compute the origin offset based on player position/orientation.\n\n\n    this._xrInvPositionCache.copyFrom(positionOffset);\n\n    if (rotationOffset) {\n      this._xrInvQuaternionCache.copyFrom(rotationOffset);\n    } else {\n      this._xrInvQuaternionCache.copyFromFloats(0, 0, 0, 1);\n    } // right handed system\n\n\n    if (!this._scene.useRightHandedSystem) {\n      this._xrInvPositionCache.z *= -1;\n      this._xrInvQuaternionCache.z *= -1;\n      this._xrInvQuaternionCache.w *= -1;\n    }\n\n    this._xrInvPositionCache.negateInPlace();\n\n    this._xrInvQuaternionCache.conjugateInPlace(); // transform point according to rotation with pivot\n\n\n    this._xrInvPositionCache.rotateByQuaternionToRef(this._xrInvQuaternionCache, this._xrInvPositionCache);\n\n    if (ignoreHeight) {\n      this._xrInvPositionCache.y = 0;\n    }\n\n    var transform = new XRRigidTransform({\n      x: this._xrInvPositionCache.x,\n      y: this._xrInvPositionCache.y,\n      z: this._xrInvPositionCache.z\n    }, {\n      x: this._xrInvQuaternionCache.x,\n      y: this._xrInvQuaternionCache.y,\n      z: this._xrInvQuaternionCache.z,\n      w: this._xrInvQuaternionCache.w\n    }); // Update offset reference to use a new originOffset with the teleported\n    // player position and orientation.\n    // This new offset needs to be applied to the base ref space.\n\n    var referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\n\n    var pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(referenceSpace);\n\n    if (pose) {\n      var pos = new Vector3(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);\n\n      if (!this._scene.useRightHandedSystem) {\n        pos.z *= -1;\n      }\n\n      this.position.subtractToRef(pos, pos);\n\n      if (!this._scene.useRightHandedSystem) {\n        pos.z *= -1;\n      }\n\n      pos.negateInPlace();\n      var transform2 = new XRRigidTransform({\n        x: pos.x,\n        y: pos.y,\n        z: pos.z\n      }); // Update offset reference to use a new originOffset with the teleported\n      // player position and orientation.\n      // This new offset needs to be applied to the base ref space.\n\n      this._xrSessionManager.referenceSpace = referenceSpace.getOffsetReferenceSpace(transform2);\n    }\n  };\n\n  return WebXRCamera;\n}(FreeCamera);\n\nexport { WebXRCamera };","map":null,"metadata":{},"sourceType":"module"}