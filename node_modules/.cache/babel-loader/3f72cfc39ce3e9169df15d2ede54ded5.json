{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable\";\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\nimport { Camera } from \"../../Cameras/camera\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Gamepad } from \"../../Gamepads/gamepad\";\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController\";\nimport { Node } from \"../../node\";\nimport { HemisphericLight } from \"../../Lights/hemisphericLight\";\nimport { Logger } from '../../Misc/logger';\nimport { VRMultiviewToSingleviewPostProcess } from '../../PostProcesses/vrMultiviewToSingleviewPostProcess'; // Side effect import to define the stereoscopic mode.\n\nimport \"../RigModes/webVRRigMode\"; // Side effect import to add webvr support to engine\n\nimport \"../../Engines/Extensions/engine.webVR\";\nimport { Tools } from '../../Misc/tools';\nNode.AddNodeConstructor(\"WebVRFreeCamera\", function (name, scene) {\n  return function () {\n    return new WebVRFreeCamera(name, Vector3.Zero(), scene);\n  };\n});\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", function (name, scene) {\n  return function () {\n    return new WebVRFreeCamera(name, Vector3.Zero(), scene);\n  };\n});\n/**\r\n * This represents a WebVR camera.\r\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\r\n * @example https://doc.babylonjs.com/how_to/webvr_camera\r\n */\n\nvar WebVRFreeCamera =\n/** @class */\nfunction (_super) {\n  __extends(WebVRFreeCamera, _super);\n  /**\r\n   * Instantiates a WebVRFreeCamera.\r\n   * @param name The name of the WebVRFreeCamera\r\n   * @param position The starting anchor position for the camera\r\n   * @param scene The scene the camera belongs to\r\n   * @param webVROptions a set of customizable options for the webVRCamera\r\n   */\n\n\n  function WebVRFreeCamera(name, position, scene, webVROptions) {\n    if (webVROptions === void 0) {\n      webVROptions = {};\n    }\n\n    var _this = _super.call(this, name, position, scene) || this;\n\n    _this.webVROptions = webVROptions;\n    /**\r\n     * @hidden\r\n     * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\r\n     */\n\n    _this._vrDevice = null;\n    /**\r\n     * The rawPose of the vrDevice.\r\n     */\n\n    _this.rawPose = null;\n    _this._specsVersion = \"1.1\";\n    _this._attached = false;\n    _this._descendants = []; // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\n\n    _this._deviceRoomPosition = Vector3.Zero();\n    /** @hidden */\n\n    _this._deviceRoomRotationQuaternion = Quaternion.Identity();\n    _this._standingMatrix = null;\n    /**\r\n     * Represents device position in babylon space.\r\n     */\n\n    _this.devicePosition = Vector3.Zero();\n    /**\r\n     * Represents device rotation in babylon space.\r\n     */\n\n    _this.deviceRotationQuaternion = Quaternion.Identity();\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\n\n    _this.deviceScaleFactor = 1;\n    _this._deviceToWorld = Matrix.Identity();\n    _this._worldToDevice = Matrix.Identity();\n    /**\r\n     * References to the webVR controllers for the vrDevice.\r\n     */\n\n    _this.controllers = [];\n    /**\r\n     * Emits an event when a controller is attached.\r\n     */\n\n    _this.onControllersAttachedObservable = new Observable();\n    /**\r\n     * Emits an event when a controller's mesh has been loaded;\r\n     */\n\n    _this.onControllerMeshLoadedObservable = new Observable();\n    /**\r\n     * Emits an event when the HMD's pose has been updated.\r\n     */\n\n    _this.onPoseUpdatedFromDeviceObservable = new Observable();\n    _this._poseSet = false;\n    /**\r\n     * If the rig cameras be used as parent instead of this camera.\r\n     */\n\n    _this.rigParenting = true;\n    _this._defaultHeight = undefined;\n\n    _this._detachIfAttached = function () {\n      var vrDisplay = _this.getEngine().getVRDevice();\n\n      if (vrDisplay && !vrDisplay.isPresenting) {\n        _this.detachControl();\n      }\n    };\n\n    _this._workingVector = Vector3.Zero();\n    _this._oneVector = Vector3.One();\n    _this._workingMatrix = Matrix.Identity();\n    _this._tmpMatrix = new Matrix();\n    _this._cache.position = Vector3.Zero();\n\n    if (webVROptions.defaultHeight) {\n      _this._defaultHeight = webVROptions.defaultHeight;\n      _this.position.y = _this._defaultHeight;\n    }\n\n    _this.minZ = 0.1; //legacy support - the compensation boolean was removed.\n\n    if (arguments.length === 5) {\n      _this.webVROptions = arguments[4];\n    } // default webVR options\n\n\n    if (_this.webVROptions.trackPosition == undefined) {\n      _this.webVROptions.trackPosition = true;\n    }\n\n    if (_this.webVROptions.controllerMeshes == undefined) {\n      _this.webVROptions.controllerMeshes = true;\n    }\n\n    if (_this.webVROptions.defaultLightingOnControllers == undefined) {\n      _this.webVROptions.defaultLightingOnControllers = true;\n    }\n\n    _this.rotationQuaternion = new Quaternion();\n\n    if (_this.webVROptions && _this.webVROptions.positionScale) {\n      _this.deviceScaleFactor = _this.webVROptions.positionScale;\n    } //enable VR\n\n\n    var engine = _this.getEngine();\n\n    _this._onVREnabled = function (success) {\n      if (success) {\n        _this.initControllers();\n      }\n    };\n\n    engine.onVRRequestPresentComplete.add(_this._onVREnabled);\n    engine.initWebVR().add(function (event) {\n      if (!event.vrDisplay || _this._vrDevice === event.vrDisplay) {\n        return;\n      }\n\n      _this._vrDevice = event.vrDisplay; //reset the rig parameters.\n\n      _this.setCameraRigMode(Camera.RIG_MODE_WEBVR, {\n        parentCamera: _this,\n        vrDisplay: _this._vrDevice,\n        frameData: _this._frameData,\n        specs: _this._specsVersion\n      });\n\n      if (_this._attached) {\n        _this.getEngine().enableVR(_this.webVROptions);\n      }\n    });\n\n    if (typeof VRFrameData !== \"undefined\") {\n      _this._frameData = new VRFrameData();\n    }\n\n    if (webVROptions.useMultiview) {\n      if (!_this.getScene().getEngine().getCaps().multiview) {\n        Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\n        _this._useMultiviewToSingleView = false;\n      } else {\n        _this._useMultiviewToSingleView = true;\n        _this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", _this, 1.0);\n      }\n    }\n    /**\r\n     * The idea behind the following lines:\r\n     * objects that have the camera as parent should actually have the rig cameras as a parent.\r\n     * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\r\n     * the second will not show it correctly.\r\n     *\r\n     * To solve this - each object that has the camera as parent will be added to a protected array.\r\n     * When the rig camera renders, it will take this array and set all of those to be its children.\r\n     * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\r\n     * Amazing!\r\n     */\n\n\n    scene.onBeforeCameraRenderObservable.add(function (camera) {\n      if (camera.parent === _this && _this.rigParenting) {\n        _this._descendants = _this.getDescendants(true, function (n) {\n          // don't take the cameras or the controllers!\n          var isController = _this.controllers.some(function (controller) {\n            return controller._mesh === n;\n          });\n\n          var isRigCamera = _this._rigCameras.indexOf(n) !== -1;\n          return !isController && !isRigCamera;\n        });\n\n        _this._descendants.forEach(function (node) {\n          node.parent = camera;\n        });\n      }\n    });\n    scene.onAfterCameraRenderObservable.add(function (camera) {\n      if (camera.parent === _this && _this.rigParenting) {\n        _this._descendants.forEach(function (node) {\n          node.parent = _this;\n        });\n      }\n    });\n    return _this;\n  }\n  /**\r\n   * Gets the device distance from the ground in meters.\r\n   * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\r\n   */\n\n\n  WebVRFreeCamera.prototype.deviceDistanceToRoomGround = function () {\n    if (this._standingMatrix) {\n      // Add standing matrix offset to get real offset from ground in room\n      this._standingMatrix.getTranslationToRef(this._workingVector);\n\n      return this._deviceRoomPosition.y + this._workingVector.y;\n    } //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\n\n\n    return this._defaultHeight || 0;\n  };\n  /**\r\n   * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n   * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\r\n   */\n\n\n  WebVRFreeCamera.prototype.useStandingMatrix = function (callback) {\n    var _this = this;\n\n    if (callback === void 0) {\n      callback = function callback(bool) {};\n    } // Use standing matrix if available\n\n\n    this.getEngine().initWebVRAsync().then(function (result) {\n      if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !_this.webVROptions.trackPosition) {\n        callback(false);\n      } else {\n        _this._standingMatrix = new Matrix();\n        Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, _this._standingMatrix);\n\n        if (!_this.getScene().useRightHandedSystem) {\n          if (_this._standingMatrix) {\n            _this._standingMatrix.toggleModelMatrixHandInPlace();\n          }\n        }\n\n        callback(true);\n      }\n    });\n  };\n  /**\r\n   * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n   * @returns A promise with a boolean set to if the standing matrix is supported.\r\n   */\n\n\n  WebVRFreeCamera.prototype.useStandingMatrixAsync = function () {\n    var _this = this;\n\n    return new Promise(function (res) {\n      _this.useStandingMatrix(function (supported) {\n        res(supported);\n      });\n    });\n  };\n  /**\r\n   * Disposes the camera\r\n   */\n\n\n  WebVRFreeCamera.prototype.dispose = function () {\n    this._detachIfAttached();\n\n    this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\n\n    if (this._updateCacheWhenTrackingDisabledObserver) {\n      this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Gets a vrController by name.\r\n   * @param name The name of the controller to retreive\r\n   * @returns the controller matching the name specified or null if not found\r\n   */\n\n\n  WebVRFreeCamera.prototype.getControllerByName = function (name) {\n    for (var _i = 0, _a = this.controllers; _i < _a.length; _i++) {\n      var gp = _a[_i];\n\n      if (gp.hand === name) {\n        return gp;\n      }\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(WebVRFreeCamera.prototype, \"leftController\", {\n    /**\r\n     * The controller corresponding to the users left hand.\r\n     */\n    get: function get() {\n      if (!this._leftController) {\n        this._leftController = this.getControllerByName(\"left\");\n      }\n\n      return this._leftController;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebVRFreeCamera.prototype, \"rightController\", {\n    /**\r\n     * The controller corresponding to the users right hand.\r\n     */\n    get: function get() {\n      if (!this._rightController) {\n        this._rightController = this.getControllerByName(\"right\");\n      }\n\n      return this._rightController;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Casts a ray forward from the vrCamera's gaze.\r\n   * @param length Length of the ray (default: 100)\r\n   * @returns the ray corresponding to the gaze\r\n   */\n\n  WebVRFreeCamera.prototype.getForwardRay = function (length) {\n    if (length === void 0) {\n      length = 100;\n    }\n\n    if (this.leftCamera) {\n      // Use left eye to avoid computation to compute center on every call\n      return _super.prototype.getForwardRay.call(this, length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\n    } else {\n      return _super.prototype.getForwardRay.call(this, length);\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Updates the camera based on device's frame data\r\n   */\n\n\n  WebVRFreeCamera.prototype._checkInputs = function () {\n    if (this._vrDevice && this._vrDevice.isPresenting) {\n      this._vrDevice.getFrameData(this._frameData);\n\n      this.updateFromDevice(this._frameData.pose);\n    }\n\n    _super.prototype._checkInputs.call(this);\n  };\n  /**\r\n   * Updates the poseControlled values based on the input device pose.\r\n   * @param poseData Pose coming from the device\r\n   */\n\n\n  WebVRFreeCamera.prototype.updateFromDevice = function (poseData) {\n    if (poseData && poseData.orientation && poseData.orientation.length === 4) {\n      this.rawPose = poseData;\n\n      this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\n\n      if (this.getScene().useRightHandedSystem) {\n        this._deviceRoomRotationQuaternion.z *= -1;\n        this._deviceRoomRotationQuaternion.w *= -1;\n      }\n\n      if (this.webVROptions.trackPosition && this.rawPose.position) {\n        this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\n\n        if (this.getScene().useRightHandedSystem) {\n          this._deviceRoomPosition.z *= -1;\n        }\n      }\n\n      this._poseSet = true;\n    }\n  };\n  /**\r\n   * WebVR's attach control will start broadcasting frames to the device.\r\n   * Note that in certain browsers (chrome for example) this function must be called\r\n   * within a user-interaction callback. Example:\r\n   * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\r\n   *\r\n   * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\r\n   */\n\n\n  WebVRFreeCamera.prototype.attachControl = function (noPreventDefault) {\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n\n    _super.prototype.attachControl.call(this, noPreventDefault);\n\n    this._attached = true;\n    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n\n    if (this._vrDevice) {\n      this.getEngine().enableVR(this.webVROptions);\n    }\n\n    var hostWindow = this._scene.getEngine().getHostWindow();\n\n    if (hostWindow) {\n      hostWindow.addEventListener('vrdisplaypresentchange', this._detachIfAttached);\n    }\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  WebVRFreeCamera.prototype.detachControl = function (ignored) {\n    this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\n    this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\n\n    _super.prototype.detachControl.call(this);\n\n    this._attached = false;\n    this.getEngine().disableVR();\n    window.removeEventListener('vrdisplaypresentchange', this._detachIfAttached);\n  };\n  /**\r\n   * @returns the name of this class\r\n   */\n\n\n  WebVRFreeCamera.prototype.getClassName = function () {\n    return \"WebVRFreeCamera\";\n  };\n  /**\r\n   * Calls resetPose on the vrDisplay\r\n   * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\r\n   */\n\n\n  WebVRFreeCamera.prototype.resetToCurrentRotation = function () {\n    //uses the vrDisplay's \"resetPose()\".\n    //pitch and roll won't be affected.\n    this._vrDevice.resetPose();\n  };\n  /**\r\n   * @hidden\r\n   * Updates the rig cameras (left and right eye)\r\n   */\n\n\n  WebVRFreeCamera.prototype._updateRigCameras = function () {\n    var camLeft = this._rigCameras[0];\n    var camRight = this._rigCameras[1];\n    camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n    camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n    camLeft.position.copyFrom(this._deviceRoomPosition);\n    camRight.position.copyFrom(this._deviceRoomPosition);\n  }; // Remove translation from 6dof headset if trackposition is set to false\n\n\n  WebVRFreeCamera.prototype._correctPositionIfNotTrackPosition = function (matrix, isViewMatrix) {\n    if (isViewMatrix === void 0) {\n      isViewMatrix = false;\n    }\n\n    if (this.rawPose && this.rawPose.position && !this.webVROptions.trackPosition) {\n      Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\n\n      if (!isViewMatrix) {\n        this._tmpMatrix.invert();\n      }\n\n      this._tmpMatrix.multiplyToRef(matrix, matrix);\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Updates the cached values of the camera\r\n   * @param ignoreParentClass ignores updating the parent class's cache (default: false)\r\n   */\n\n\n  WebVRFreeCamera.prototype._updateCache = function (ignoreParentClass) {\n    var _this = this;\n\n    if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\n      // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\n      if (!this.updateCacheCalled) {\n        // make sure it is only called once per loop. this.update() might cause an infinite loop.\n        this.updateCacheCalled = true;\n        this.update();\n      } // Set working vector to the device position in room space rotated by the new rotation\n\n\n      this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\n      Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector); // Subtract this vector from the current device position in world to get the translation for the device world matrix\n\n      this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\n      Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld); // Add translation from anchor position\n\n      this._deviceToWorld.getTranslationToRef(this._workingVector);\n\n      this._workingVector.addInPlace(this.position);\n\n      this._workingVector.subtractInPlace(this._cache.position);\n\n      this._deviceToWorld.setTranslation(this._workingVector); // Set an inverted matrix to be used when updating the camera\n\n\n      this._deviceToWorld.invertToRef(this._worldToDevice); // Update the gamepad to ensure the mesh is updated on the same frame as camera\n\n\n      this.controllers.forEach(function (controller) {\n        controller._deviceToWorld.copyFrom(_this._deviceToWorld);\n\n        _this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\n\n        controller.update();\n      });\n    }\n\n    if (!ignoreParentClass) {\n      _super.prototype._updateCache.call(this);\n    }\n\n    this.updateCacheCalled = false;\n  };\n  /**\r\n   * @hidden\r\n   * Get current device position in babylon world\r\n   */\n\n\n  WebVRFreeCamera.prototype._computeDevicePosition = function () {\n    Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\n  };\n  /**\r\n   * Updates the current device position and rotation in the babylon world\r\n   */\n\n\n  WebVRFreeCamera.prototype.update = function () {\n    this._computeDevicePosition(); // Get current device rotation in babylon world\n\n\n    Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\n\n    this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\n\n    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\n\n    if (this._poseSet) {\n      this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\n    }\n\n    _super.prototype.update.call(this);\n  };\n  /**\r\n   * @hidden\r\n   * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\r\n   * @returns an identity matrix\r\n   */\n\n\n  WebVRFreeCamera.prototype._getViewMatrix = function () {\n    return Matrix.Identity();\n  };\n  /**\r\n   * This function is called by the two RIG cameras.\r\n   * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\r\n   * @hidden\r\n   */\n\n\n  WebVRFreeCamera.prototype._getWebVRViewMatrix = function () {\n    // Update the parent camera prior to using a child camera to avoid desynchronization\n    var parentCamera = this._cameraRigParams[\"parentCamera\"];\n\n    parentCamera._updateCache(); //WebVR 1.1\n\n\n    var viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\n    Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\n\n    if (!this.getScene().useRightHandedSystem) {\n      this._webvrViewMatrix.toggleModelMatrixHandInPlace();\n    } // update the camera rotation matrix\n\n\n    this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\n\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint); // Computing target and final matrix\n\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget); // should the view matrix be updated with scale and position offset?\n\n    if (parentCamera.deviceScaleFactor !== 1) {\n      this._webvrViewMatrix.invert(); // scale the position, if set\n\n\n      if (parentCamera.deviceScaleFactor) {\n        this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\n\n        this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\n\n        this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\n      }\n\n      this._webvrViewMatrix.invert();\n    } // Remove translation from 6dof headset if trackposition is set to false\n\n\n    parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\n\n    parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix); // Compute global position\n\n\n    this._workingMatrix = this._workingMatrix || Matrix.Identity();\n\n    this._webvrViewMatrix.invertToRef(this._workingMatrix);\n\n    this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\n\n    this._workingMatrix.getTranslationToRef(this._globalPosition);\n\n    this._markSyncedWithParent();\n\n    return this._webvrViewMatrix;\n  };\n  /** @hidden */\n\n\n  WebVRFreeCamera.prototype._getWebVRProjectionMatrix = function () {\n    var parentCamera = this.parent;\n    parentCamera._vrDevice.depthNear = parentCamera.minZ;\n    parentCamera._vrDevice.depthFar = parentCamera.maxZ;\n    var projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\n    Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix); //babylon compatible matrix\n\n    if (!this.getScene().useRightHandedSystem) {\n      this._projectionMatrix.toggleProjectionMatrixHandInPlace();\n    }\n\n    return this._projectionMatrix;\n  };\n  /**\r\n   * Initializes the controllers and their meshes\r\n   */\n\n\n  WebVRFreeCamera.prototype.initControllers = function () {\n    var _this = this;\n\n    this.controllers = [];\n    var manager = this.getScene().gamepadManager;\n    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function (gamepad) {\n      if (gamepad.type === Gamepad.POSE_ENABLED) {\n        var webVrController = gamepad;\n\n        if (webVrController.defaultModel) {\n          webVrController.defaultModel.setEnabled(false);\n        }\n\n        if (webVrController.hand === \"right\") {\n          _this._rightController = null;\n        }\n\n        if (webVrController.hand === \"left\") {\n          _this._leftController = null;\n        }\n\n        var controllerIndex = _this.controllers.indexOf(webVrController);\n\n        if (controllerIndex !== -1) {\n          _this.controllers.splice(controllerIndex, 1);\n        }\n      }\n    });\n    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function (gamepad) {\n      if (gamepad.type === Gamepad.POSE_ENABLED) {\n        var webVrController_1 = gamepad;\n\n        if (!_this.webVROptions.trackPosition) {\n          webVrController_1._disableTrackPosition(new Vector3(webVrController_1.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25)); // Cache must be updated before rendering controllers to avoid them being one frame behind\n\n\n          if (!_this._updateCacheWhenTrackingDisabledObserver) {\n            _this._updateCacheWhenTrackingDisabledObserver = _this._scene.onBeforeRenderObservable.add(function () {\n              _this._updateCache();\n            });\n          }\n        }\n\n        webVrController_1.deviceScaleFactor = _this.deviceScaleFactor;\n\n        webVrController_1._deviceToWorld.copyFrom(_this._deviceToWorld);\n\n        _this._correctPositionIfNotTrackPosition(webVrController_1._deviceToWorld);\n\n        if (_this.webVROptions.controllerMeshes) {\n          if (webVrController_1.defaultModel) {\n            webVrController_1.defaultModel.setEnabled(true);\n          } else {\n            // Load the meshes\n            webVrController_1.initControllerMesh(_this.getScene(), function (loadedMesh) {\n              loadedMesh.scaling.scaleInPlace(_this.deviceScaleFactor);\n\n              _this.onControllerMeshLoadedObservable.notifyObservers(webVrController_1);\n\n              if (_this.webVROptions.defaultLightingOnControllers) {\n                if (!_this._lightOnControllers) {\n                  _this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), _this.getScene());\n                }\n\n                var activateLightOnSubMeshes_1 = function activateLightOnSubMeshes_1(mesh, light) {\n                  var children = mesh.getChildren();\n\n                  if (children && children.length !== 0) {\n                    children.forEach(function (mesh) {\n                      light.includedOnlyMeshes.push(mesh);\n                      activateLightOnSubMeshes_1(mesh, light);\n                    });\n                  }\n                };\n\n                _this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\n\n                activateLightOnSubMeshes_1(loadedMesh, _this._lightOnControllers);\n              }\n            });\n          }\n        }\n\n        webVrController_1.attachToPoseControlledCamera(_this); // since this is async - sanity check. Is the controller already stored?\n\n        if (_this.controllers.indexOf(webVrController_1) === -1) {\n          //add to the controllers array\n          _this.controllers.push(webVrController_1); // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\n          // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\n          // So we're overriding setting left & right manually to be sure\n\n\n          var firstViveWandDetected = false;\n\n          for (var i = 0; i < _this.controllers.length; i++) {\n            if (_this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\n              if (!firstViveWandDetected) {\n                firstViveWandDetected = true;\n                _this.controllers[i].hand = \"left\";\n              } else {\n                _this.controllers[i].hand = \"right\";\n              }\n            }\n          } //did we find enough controllers? Great! let the developer know.\n\n\n          if (_this.controllers.length >= 2) {\n            _this.onControllersAttachedObservable.notifyObservers(_this.controllers);\n          }\n        }\n      }\n    });\n  };\n\n  return WebVRFreeCamera;\n}(FreeCamera);\n\nexport { WebVRFreeCamera };","map":null,"metadata":{},"sourceType":"module"}