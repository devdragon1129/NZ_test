{"ast":null,"code":"import { Animation } from \"./animation\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport \"./animatable\";\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\n\nvar TargetedAnimation =\n/** @class */\nfunction () {\n  function TargetedAnimation() {}\n  /**\r\n   * Returns the string \"TargetedAnimation\"\r\n   * @returns \"TargetedAnimation\"\r\n   */\n\n\n  TargetedAnimation.prototype.getClassName = function () {\n    return \"TargetedAnimation\";\n  };\n  /**\r\n   * Serialize the object\r\n   * @returns the JSON object representing the current entity\r\n   */\n\n\n  TargetedAnimation.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.animation = this.animation.serialize();\n    serializationObject.targetId = this.target.id;\n    return serializationObject;\n  };\n\n  return TargetedAnimation;\n}();\n\nexport { TargetedAnimation };\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\n\nvar AnimationGroup =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new Animation Group.\r\n   * This helps managing several animations at once.\r\n   * @see https://doc.babylonjs.com/how_to/group\r\n   * @param name Defines the name of the group\r\n   * @param scene Defines the scene the group belongs to\r\n   */\n  function AnimationGroup(\n  /** The name of the animation group */\n  name, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this.name = name;\n    this._targetedAnimations = new Array();\n    this._animatables = new Array();\n    this._from = Number.MAX_VALUE;\n    this._to = -Number.MAX_VALUE;\n    this._speedRatio = 1;\n    this._loopAnimation = false;\n    this._isAdditive = false;\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\n\n    this.onAnimationEndObservable = new Observable();\n    /**\r\n     * Observer raised when one animation loops\r\n     */\n\n    this.onAnimationLoopObservable = new Observable();\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\n\n    this.onAnimationGroupLoopObservable = new Observable();\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\n\n    this.onAnimationGroupEndObservable = new Observable();\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\n\n    this.onAnimationGroupPauseObservable = new Observable();\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\n\n    this.onAnimationGroupPlayObservable = new Observable();\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.uniqueId = this._scene.getUniqueId();\n\n    this._scene.addAnimationGroup(this);\n  }\n\n  Object.defineProperty(AnimationGroup.prototype, \"from\", {\n    /**\r\n     * Gets the first frame\r\n     */\n    get: function get() {\n      return this._from;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"to\", {\n    /**\r\n     * Gets the last frame\r\n     */\n    get: function get() {\n      return this._to;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isStarted\", {\n    /**\r\n     * Define if the animations are started\r\n     */\n    get: function get() {\n      return this._isStarted;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isPlaying\", {\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\n    get: function get() {\n      return this._isStarted && !this._isPaused;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"speedRatio\", {\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\n    get: function get() {\n      return this._speedRatio;\n    },\n\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\n    set: function set(value) {\n      if (this._speedRatio === value) {\n        return;\n      }\n\n      this._speedRatio = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.speedRatio = this._speedRatio;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"loopAnimation\", {\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\n    get: function get() {\n      return this._loopAnimation;\n    },\n    set: function set(value) {\n      if (this._loopAnimation === value) {\n        return;\n      }\n\n      this._loopAnimation = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.loopAnimation = this._loopAnimation;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isAdditive\", {\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\n    get: function get() {\n      return this._isAdditive;\n    },\n    set: function set(value) {\n      if (this._isAdditive === value) {\n        return;\n      }\n\n      this._isAdditive = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.isAdditive = this._isAdditive;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"targetedAnimations\", {\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\n    get: function get() {\n      return this._targetedAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"animatables\", {\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\n    get: function get() {\n      return this._animatables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"children\", {\n    /**\r\n     * Gets the list of target animations\r\n     */\n    get: function get() {\n      return this._targetedAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Add an animation (with its target) in the group\r\n   * @param animation defines the animation we want to add\r\n   * @param target defines the target of the animation\r\n   * @returns the TargetedAnimation object\r\n   */\n\n  AnimationGroup.prototype.addTargetedAnimation = function (animation, target) {\n    var targetedAnimation = new TargetedAnimation();\n    targetedAnimation.animation = animation;\n    targetedAnimation.target = target;\n    var keys = animation.getKeys();\n\n    if (this._from > keys[0].frame) {\n      this._from = keys[0].frame;\n    }\n\n    if (this._to < keys[keys.length - 1].frame) {\n      this._to = keys[keys.length - 1].frame;\n    }\n\n    this._targetedAnimations.push(targetedAnimation);\n\n    return targetedAnimation;\n  };\n  /**\r\n   * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n   * It can add constant keys at begin or end\r\n   * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n   * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.normalize = function (beginFrame, endFrame) {\n    if (beginFrame === void 0) {\n      beginFrame = null;\n    }\n\n    if (endFrame === void 0) {\n      endFrame = null;\n    }\n\n    if (beginFrame == null) {\n      beginFrame = this._from;\n    }\n\n    if (endFrame == null) {\n      endFrame = this._to;\n    }\n\n    for (var index = 0; index < this._targetedAnimations.length; index++) {\n      var targetedAnimation = this._targetedAnimations[index];\n      var keys = targetedAnimation.animation.getKeys();\n      var startKey = keys[0];\n      var endKey = keys[keys.length - 1];\n\n      if (startKey.frame > beginFrame) {\n        var newKey = {\n          frame: beginFrame,\n          value: startKey.value,\n          inTangent: startKey.inTangent,\n          outTangent: startKey.outTangent,\n          interpolation: startKey.interpolation\n        };\n        keys.splice(0, 0, newKey);\n      }\n\n      if (endKey.frame < endFrame) {\n        var newKey = {\n          frame: endFrame,\n          value: endKey.value,\n          inTangent: endKey.inTangent,\n          outTangent: endKey.outTangent,\n          interpolation: endKey.interpolation\n        };\n        keys.push(newKey);\n      }\n    }\n\n    this._from = beginFrame;\n    this._to = endFrame;\n    return this;\n  };\n\n  AnimationGroup.prototype._processLoop = function (animatable, targetedAnimation, index) {\n    var _this = this;\n\n    animatable.onAnimationLoop = function () {\n      _this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n\n      if (_this._animationLoopFlags[index]) {\n        return;\n      }\n\n      _this._animationLoopFlags[index] = true;\n      _this._animationLoopCount++;\n\n      if (_this._animationLoopCount === _this._targetedAnimations.length) {\n        _this.onAnimationGroupLoopObservable.notifyObservers(_this);\n\n        _this._animationLoopCount = 0;\n        _this._animationLoopFlags = [];\n      }\n    };\n  };\n  /**\r\n   * Start all animations on given targets\r\n   * @param loop defines if animations must loop\r\n   * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n   * @param from defines the from key (optional)\r\n   * @param to defines the to key (optional)\r\n   * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n   * @returns the current animation group\r\n   */\n\n\n  AnimationGroup.prototype.start = function (loop, speedRatio, from, to, isAdditive) {\n    var _this = this;\n\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    if (speedRatio === void 0) {\n      speedRatio = 1;\n    }\n\n    if (this._isStarted || this._targetedAnimations.length === 0) {\n      return this;\n    }\n\n    this._loopAnimation = loop;\n    this._animationLoopCount = 0;\n    this._animationLoopFlags = [];\n\n    var _loop_1 = function _loop_1() {\n      var targetedAnimation = this_1._targetedAnimations[index];\n\n      var animatable = this_1._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this_1._from, to !== undefined ? to : this_1._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this_1._isAdditive);\n\n      animatable.onAnimationEnd = function () {\n        _this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n\n        _this._checkAnimationGroupEnded(animatable);\n      };\n\n      this_1._processLoop(animatable, targetedAnimation, index);\n\n      this_1._animatables.push(animatable);\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < this._targetedAnimations.length; index++) {\n      _loop_1();\n    }\n\n    this._speedRatio = speedRatio;\n\n    if (from !== undefined && to !== undefined) {\n      if (from < to && this._speedRatio < 0) {\n        var temp = to;\n        to = from;\n        from = temp;\n      } else if (from > to && this._speedRatio > 0) {\n        this._speedRatio = -speedRatio;\n      }\n    }\n\n    this._isStarted = true;\n    this._isPaused = false;\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  };\n  /**\r\n   * Pause all animations\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.pause = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    this._isPaused = true;\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.pause();\n    }\n\n    this.onAnimationGroupPauseObservable.notifyObservers(this);\n    return this;\n  };\n  /**\r\n   * Play all animations to initial state\r\n   * This function will start() the animations if they were not started or will restart() them if they were paused\r\n   * @param loop defines if animations must loop\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.play = function (loop) {\n    // only if all animatables are ready and exist\n    if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\n      if (loop !== undefined) {\n        this.loopAnimation = loop;\n      }\n\n      this.restart();\n    } else {\n      this.stop();\n      this.start(loop, this._speedRatio);\n    }\n\n    this._isPaused = false;\n    return this;\n  };\n  /**\r\n   * Reset all animations to initial state\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.reset = function () {\n    if (!this._isStarted) {\n      this.play();\n      this.goToFrame(0);\n      this.stop();\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.reset();\n    }\n\n    return this;\n  };\n  /**\r\n   * Restart animations from key 0\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.restart = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.restart();\n    }\n\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  };\n  /**\r\n   * Stop all animations\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.stop = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    var list = this._animatables.slice();\n\n    for (var index = 0; index < list.length; index++) {\n      list[index].stop();\n    }\n\n    this._isStarted = false;\n    return this;\n  };\n  /**\r\n   * Set animation weight for all animatables\r\n   * @param weight defines the weight to use\r\n   * @return the animationGroup\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\r\n   */\n\n\n  AnimationGroup.prototype.setWeightForAllAnimatables = function (weight) {\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.weight = weight;\n    }\n\n    return this;\n  };\n  /**\r\n   * Synchronize and normalize all animatables with a source animatable\r\n   * @param root defines the root animatable to synchronize with\r\n   * @return the animationGroup\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\r\n   */\n\n\n  AnimationGroup.prototype.syncAllAnimationsWith = function (root) {\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.syncWith(root);\n    }\n\n    return this;\n  };\n  /**\r\n   * Goes to a specific frame in this animation group\r\n   * @param frame the frame number to go to\r\n   * @return the animationGroup\r\n   */\n\n\n  AnimationGroup.prototype.goToFrame = function (frame) {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.goToFrame(frame);\n    }\n\n    return this;\n  };\n  /**\r\n   * Dispose all associated resources\r\n   */\n\n\n  AnimationGroup.prototype.dispose = function () {\n    this._targetedAnimations = [];\n    this._animatables = [];\n\n    var index = this._scene.animationGroups.indexOf(this);\n\n    if (index > -1) {\n      this._scene.animationGroups.splice(index, 1);\n    }\n\n    this.onAnimationEndObservable.clear();\n    this.onAnimationGroupEndObservable.clear();\n    this.onAnimationGroupPauseObservable.clear();\n    this.onAnimationGroupPlayObservable.clear();\n    this.onAnimationLoopObservable.clear();\n    this.onAnimationGroupLoopObservable.clear();\n  };\n\n  AnimationGroup.prototype._checkAnimationGroupEnded = function (animatable) {\n    // animatable should be taken out of the array\n    var idx = this._animatables.indexOf(animatable);\n\n    if (idx > -1) {\n      this._animatables.splice(idx, 1);\n    } // all animatables were removed? animation group ended!\n\n\n    if (this._animatables.length === 0) {\n      this._isStarted = false;\n      this.onAnimationGroupEndObservable.notifyObservers(this);\n    }\n  };\n  /**\r\n   * Clone the current animation group and returns a copy\r\n   * @param newName defines the name of the new group\r\n   * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n   * @returns the new aniamtion group\r\n   */\n\n\n  AnimationGroup.prototype.clone = function (newName, targetConverter) {\n    var newGroup = new AnimationGroup(newName || this.name, this._scene);\n\n    for (var _i = 0, _a = this._targetedAnimations; _i < _a.length; _i++) {\n      var targetAnimation = _a[_i];\n      newGroup.addTargetedAnimation(targetAnimation.animation.clone(), targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n    }\n\n    return newGroup;\n  };\n  /**\r\n   * Serializes the animationGroup to an object\r\n   * @returns Serialized object\r\n   */\n\n\n  AnimationGroup.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.from = this.from;\n    serializationObject.to = this.to;\n    serializationObject.targetedAnimations = [];\n\n    for (var targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n      var targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n      serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n    }\n\n    return serializationObject;\n  }; // Statics\n\n  /**\r\n   * Returns a new AnimationGroup object parsed from the source provided.\r\n   * @param parsedAnimationGroup defines the source\r\n   * @param scene defines the scene that will receive the animationGroup\r\n   * @returns a new AnimationGroup\r\n   */\n\n\n  AnimationGroup.Parse = function (parsedAnimationGroup, scene) {\n    var animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene);\n\n    for (var i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n      var targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n      var animation = Animation.Parse(targetedAnimation.animation);\n      var id = targetedAnimation.targetId;\n\n      if (targetedAnimation.animation.property === \"influence\") {\n        // morph target animation\n        var morphTarget = scene.getMorphTargetById(id);\n\n        if (morphTarget) {\n          animationGroup.addTargetedAnimation(animation, morphTarget);\n        }\n      } else {\n        var targetNode = scene.getNodeByID(id);\n\n        if (targetNode != null) {\n          animationGroup.addTargetedAnimation(animation, targetNode);\n        }\n      }\n    }\n\n    if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n      animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n    }\n\n    return animationGroup;\n  };\n  /**\r\n   * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n   * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n   * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n   * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n   * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n   * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n   */\n\n\n  AnimationGroup.MakeAnimationAdditive = function (sourceAnimationGroup, referenceFrame, range, cloneOriginal, clonedName) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    if (cloneOriginal === void 0) {\n      cloneOriginal = false;\n    }\n\n    var animationGroup = sourceAnimationGroup;\n\n    if (cloneOriginal) {\n      animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);\n    }\n\n    var targetedAnimations = animationGroup.targetedAnimations;\n\n    for (var index = 0; index < targetedAnimations.length; index++) {\n      var targetedAnimation = targetedAnimations[index];\n      Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);\n    }\n\n    animationGroup.isAdditive = true;\n    return animationGroup;\n  };\n  /**\r\n   * Returns the string \"AnimationGroup\"\r\n   * @returns \"AnimationGroup\"\r\n   */\n\n\n  AnimationGroup.prototype.getClassName = function () {\n    return \"AnimationGroup\";\n  };\n  /**\r\n   * Creates a detailled string about the object\r\n   * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n   * @returns a string representing the object\r\n   */\n\n\n  AnimationGroup.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n    ret += \", type: \" + this.getClassName();\n\n    if (fullDetails) {\n      ret += \", from: \" + this._from;\n      ret += \", to: \" + this._to;\n      ret += \", isStarted: \" + this._isStarted;\n      ret += \", speedRatio: \" + this._speedRatio;\n      ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n      ret += \", animatables length: \" + this._animatables;\n    }\n\n    return ret;\n  };\n\n  return AnimationGroup;\n}();\n\nexport { AnimationGroup };","map":null,"metadata":{},"sourceType":"module"}