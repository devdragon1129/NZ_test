{"ast":null,"code":"import { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\nimport { Animation } from \"@babylonjs/core/Animations/animation\";\nimport { Bone } from \"@babylonjs/core/Bones/bone\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton\";\nimport { Effect } from \"@babylonjs/core/Materials/effect\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { MultiMaterial } from \"@babylonjs/core/Materials/multiMaterial\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData\";\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight\";\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\nimport { GLTFFileLoader } from \"../glTFFileLoader\";\nimport { Constants } from '@babylonjs/core/Engines/constants';\n/**\r\n* Tokenizer. Used for shaders compatibility\r\n* Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n*/\n\nvar ETokenType;\n\n(function (ETokenType) {\n  ETokenType[ETokenType[\"IDENTIFIER\"] = 1] = \"IDENTIFIER\";\n  ETokenType[ETokenType[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n  ETokenType[ETokenType[\"END_OF_INPUT\"] = 3] = \"END_OF_INPUT\";\n})(ETokenType || (ETokenType = {}));\n\nvar Tokenizer =\n/** @class */\nfunction () {\n  function Tokenizer(toParse) {\n    this._pos = 0;\n    this.currentToken = ETokenType.UNKNOWN;\n    this.currentIdentifier = \"\";\n    this.currentString = \"\";\n    this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;\n    this._toParse = toParse;\n    this._maxPos = toParse.length;\n  }\n\n  Tokenizer.prototype.getNextToken = function () {\n    if (this.isEnd()) {\n      return ETokenType.END_OF_INPUT;\n    }\n\n    this.currentString = this.read();\n    this.currentToken = ETokenType.UNKNOWN;\n\n    if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\n      this.currentToken = ETokenType.IDENTIFIER;\n      this.currentIdentifier = this.currentString;\n\n      while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === \"_\")) {\n        this.currentIdentifier += this.currentString;\n        this.forward();\n      }\n    }\n\n    return this.currentToken;\n  };\n\n  Tokenizer.prototype.peek = function () {\n    return this._toParse[this._pos];\n  };\n\n  Tokenizer.prototype.read = function () {\n    return this._toParse[this._pos++];\n  };\n\n  Tokenizer.prototype.forward = function () {\n    this._pos++;\n  };\n\n  Tokenizer.prototype.isEnd = function () {\n    return this._pos >= this._maxPos;\n  };\n\n  return Tokenizer;\n}();\n/**\r\n* Values\r\n*/\n\n\nvar glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\nvar babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\nvar glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\nvar babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\n/**\r\n* Parse\r\n*/\n\nvar parseBuffers = function parseBuffers(parsedBuffers, gltfRuntime) {\n  for (var buf in parsedBuffers) {\n    var parsedBuffer = parsedBuffers[buf];\n    gltfRuntime.buffers[buf] = parsedBuffer;\n    gltfRuntime.buffersCount++;\n  }\n};\n\nvar parseShaders = function parseShaders(parsedShaders, gltfRuntime) {\n  for (var sha in parsedShaders) {\n    var parsedShader = parsedShaders[sha];\n    gltfRuntime.shaders[sha] = parsedShader;\n    gltfRuntime.shaderscount++;\n  }\n};\n\nvar parseObject = function parseObject(parsedObjects, runtimeProperty, gltfRuntime) {\n  for (var object in parsedObjects) {\n    var parsedObject = parsedObjects[object];\n    gltfRuntime[runtimeProperty][object] = parsedObject;\n  }\n};\n/**\r\n* Utils\r\n*/\n\n\nvar normalizeUVs = function normalizeUVs(buffer) {\n  if (!buffer) {\n    return;\n  }\n\n  for (var i = 0; i < buffer.length / 2; i++) {\n    buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\n  }\n};\n\nvar getAttribute = function getAttribute(attributeParameter) {\n  if (attributeParameter.semantic === \"NORMAL\") {\n    return \"normal\";\n  } else if (attributeParameter.semantic === \"POSITION\") {\n    return \"position\";\n  } else if (attributeParameter.semantic === \"JOINT\") {\n    return \"matricesIndices\";\n  } else if (attributeParameter.semantic === \"WEIGHT\") {\n    return \"matricesWeights\";\n  } else if (attributeParameter.semantic === \"COLOR\") {\n    return \"color\";\n  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\n    var channel = Number(attributeParameter.semantic.split(\"_\")[1]);\n    return \"uv\" + (channel === 0 ? \"\" : channel + 1);\n  }\n\n  return null;\n};\n/**\r\n* Loads and creates animations\r\n*/\n\n\nvar loadAnimations = function loadAnimations(gltfRuntime) {\n  for (var anim in gltfRuntime.animations) {\n    var animation = gltfRuntime.animations[anim];\n\n    if (!animation.channels || !animation.samplers) {\n      continue;\n    }\n\n    var lastAnimation = null;\n\n    for (var i = 0; i < animation.channels.length; i++) {\n      // Get parameters and load buffers\n      var channel = animation.channels[i];\n      var sampler = animation.samplers[channel.sampler];\n\n      if (!sampler) {\n        continue;\n      }\n\n      var inputData = null;\n      var outputData = null;\n\n      if (animation.parameters) {\n        inputData = animation.parameters[sampler.input];\n        outputData = animation.parameters[sampler.output];\n      } else {\n        inputData = sampler.input;\n        outputData = sampler.output;\n      }\n\n      var bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\n      var bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\n      var targetID = channel.target.id;\n      var targetNode = gltfRuntime.scene.getNodeByID(targetID);\n\n      if (targetNode === null) {\n        targetNode = gltfRuntime.scene.getNodeByName(targetID);\n      }\n\n      if (targetNode === null) {\n        Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetID + \" to attach to\");\n        continue;\n      }\n\n      var isBone = targetNode instanceof Bone; // Get target path (position, rotation or scaling)\n\n      var targetPath = channel.target.path;\n      var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\n\n      if (targetPathIndex !== -1) {\n        targetPath = babylonAnimationPaths[targetPathIndex];\n      } // Determine animation type\n\n\n      var animationType = Animation.ANIMATIONTYPE_MATRIX;\n\n      if (!isBone) {\n        if (targetPath === \"rotationQuaternion\") {\n          animationType = Animation.ANIMATIONTYPE_QUATERNION;\n          targetNode.rotationQuaternion = new Quaternion();\n        } else {\n          animationType = Animation.ANIMATIONTYPE_VECTOR3;\n        }\n      } // Create animation and key frames\n\n\n      var babylonAnimation = null;\n      var keys = [];\n      var arrayOffset = 0;\n      var modifyKey = false;\n\n      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\n        babylonAnimation = lastAnimation;\n        modifyKey = true;\n      }\n\n      if (!modifyKey) {\n        gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\n        babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\n        gltfRuntime.scene._blockEntityCollection = false;\n      } // For each frame\n\n\n      for (var j = 0; j < bufferInput.length; j++) {\n        var value = null;\n\n        if (targetPath === \"rotationQuaternion\") {\n          // VEC4\n          value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\n          arrayOffset += 4;\n        } else {\n          // Position and scaling are VEC3\n          value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\n          arrayOffset += 3;\n        }\n\n        if (isBone) {\n          var bone = targetNode;\n          var translation = Vector3.Zero();\n          var rotationQuaternion = new Quaternion();\n          var scaling = Vector3.Zero(); // Warning on decompose\n\n          var mat = bone.getBaseMatrix();\n\n          if (modifyKey && lastAnimation) {\n            mat = lastAnimation.getKeys()[j].value;\n          }\n\n          mat.decompose(scaling, rotationQuaternion, translation);\n\n          if (targetPath === \"position\") {\n            translation = value;\n          } else if (targetPath === \"rotationQuaternion\") {\n            rotationQuaternion = value;\n          } else {\n            scaling = value;\n          }\n\n          value = Matrix.Compose(scaling, rotationQuaternion, translation);\n        }\n\n        if (!modifyKey) {\n          keys.push({\n            frame: bufferInput[j],\n            value: value\n          });\n        } else if (lastAnimation) {\n          lastAnimation.getKeys()[j].value = value;\n        }\n      } // Finish\n\n\n      if (!modifyKey && babylonAnimation) {\n        babylonAnimation.setKeys(keys);\n        targetNode.animations.push(babylonAnimation);\n      }\n\n      lastAnimation = babylonAnimation;\n      gltfRuntime.scene.stopAnimation(targetNode);\n      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\n    }\n  }\n};\n/**\r\n* Returns the bones transformation matrix\r\n*/\n\n\nvar configureBoneTransformation = function configureBoneTransformation(node) {\n  var mat = null;\n\n  if (node.translation || node.rotation || node.scale) {\n    var scale = Vector3.FromArray(node.scale || [1, 1, 1]);\n    var rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\n    var position = Vector3.FromArray(node.translation || [0, 0, 0]);\n    mat = Matrix.Compose(scale, rotation, position);\n  } else {\n    mat = Matrix.FromArray(node.matrix);\n  }\n\n  return mat;\n};\n/**\r\n* Returns the parent bone\r\n*/\n\n\nvar getParentBone = function getParentBone(gltfRuntime, skins, jointName, newSkeleton) {\n  // Try to find\n  for (var i = 0; i < newSkeleton.bones.length; i++) {\n    if (newSkeleton.bones[i].name === jointName) {\n      return newSkeleton.bones[i];\n    }\n  } // Not found, search in gltf nodes\n\n\n  var nodes = gltfRuntime.nodes;\n\n  for (var nde in nodes) {\n    var node = nodes[nde];\n\n    if (!node.jointName) {\n      continue;\n    }\n\n    var children = node.children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = gltfRuntime.nodes[children[i]];\n\n      if (!child.jointName) {\n        continue;\n      }\n\n      if (child.jointName === jointName) {\n        var mat = configureBoneTransformation(node);\n        var bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\n        bone.id = nde;\n        return bone;\n      }\n    }\n  }\n\n  return null;\n};\n/**\r\n* Returns the appropriate root node\r\n*/\n\n\nvar getNodeToRoot = function getNodeToRoot(nodesToRoot, id) {\n  for (var i = 0; i < nodesToRoot.length; i++) {\n    var nodeToRoot = nodesToRoot[i];\n\n    for (var j = 0; j < nodeToRoot.node.children.length; j++) {\n      var child = nodeToRoot.node.children[j];\n\n      if (child === id) {\n        return nodeToRoot.bone;\n      }\n    }\n  }\n\n  return null;\n};\n/**\r\n* Returns the node with the joint name\r\n*/\n\n\nvar getJointNode = function getJointNode(gltfRuntime, jointName) {\n  var nodes = gltfRuntime.nodes;\n  var node = nodes[jointName];\n\n  if (node) {\n    return {\n      node: node,\n      id: jointName\n    };\n  }\n\n  for (var nde in nodes) {\n    node = nodes[nde];\n\n    if (node.jointName === jointName) {\n      return {\n        node: node,\n        id: nde\n      };\n    }\n  }\n\n  return null;\n};\n/**\r\n* Checks if a nodes is in joints\r\n*/\n\n\nvar nodeIsInJoints = function nodeIsInJoints(skins, id) {\n  for (var i = 0; i < skins.jointNames.length; i++) {\n    if (skins.jointNames[i] === id) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n* Fills the nodes to root for bones and builds hierarchy\r\n*/\n\n\nvar getNodesToRoot = function getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot) {\n  // Creates nodes for root\n  for (var nde in gltfRuntime.nodes) {\n    var node = gltfRuntime.nodes[nde];\n    var id = nde;\n\n    if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\n      continue;\n    } // Create node to root bone\n\n\n    var mat = configureBoneTransformation(node);\n    var bone = new Bone(node.name || \"\", newSkeleton, null, mat);\n    bone.id = id;\n    nodesToRoot.push({\n      bone: bone,\n      node: node,\n      id: id\n    });\n  } // Parenting\n\n\n  for (var i = 0; i < nodesToRoot.length; i++) {\n    var nodeToRoot = nodesToRoot[i];\n    var children = nodeToRoot.node.children;\n\n    for (var j = 0; j < children.length; j++) {\n      var child = null;\n\n      for (var k = 0; k < nodesToRoot.length; k++) {\n        if (nodesToRoot[k].id === children[j]) {\n          child = nodesToRoot[k];\n          break;\n        }\n      }\n\n      if (child) {\n        child.bone._parent = nodeToRoot.bone;\n        nodeToRoot.bone.children.push(child.bone);\n      }\n    }\n  }\n};\n/**\r\n* Imports a skeleton\r\n*/\n\n\nvar importSkeleton = function importSkeleton(gltfRuntime, skins, mesh, newSkeleton, id) {\n  if (!newSkeleton) {\n    newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\n  }\n\n  if (!skins.babylonSkeleton) {\n    return newSkeleton;\n  } // Find the root bones\n\n\n  var nodesToRoot = [];\n  var nodesToRootToAdd = [];\n  getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\n  newSkeleton.bones = []; // Joints\n\n  for (var i = 0; i < skins.jointNames.length; i++) {\n    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\n\n    if (!jointNode) {\n      continue;\n    }\n\n    var node = jointNode.node;\n\n    if (!node) {\n      Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\n      continue;\n    }\n\n    var id = jointNode.id; // Optimize, if the bone already exists...\n\n    var existingBone = gltfRuntime.scene.getBoneByID(id);\n\n    if (existingBone) {\n      newSkeleton.bones.push(existingBone);\n      continue;\n    } // Search for parent bone\n\n\n    var foundBone = false;\n    var parentBone = null;\n\n    for (var j = 0; j < i; j++) {\n      var jointNode_1 = getJointNode(gltfRuntime, skins.jointNames[j]);\n\n      if (!jointNode_1) {\n        continue;\n      }\n\n      var joint = jointNode_1.node;\n\n      if (!joint) {\n        Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\n        continue;\n      }\n\n      var children = joint.children;\n\n      if (!children) {\n        continue;\n      }\n\n      foundBone = false;\n\n      for (var k = 0; k < children.length; k++) {\n        if (children[k] === id) {\n          parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\n          foundBone = true;\n          break;\n        }\n      }\n\n      if (foundBone) {\n        break;\n      }\n    } // Create bone\n\n\n    var mat = configureBoneTransformation(node);\n\n    if (!parentBone && nodesToRoot.length > 0) {\n      parentBone = getNodeToRoot(nodesToRoot, id);\n\n      if (parentBone) {\n        if (nodesToRootToAdd.indexOf(parentBone) === -1) {\n          nodesToRootToAdd.push(parentBone);\n        }\n      }\n    }\n\n    var bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\n    bone.id = id;\n  } // Polish\n\n\n  var bones = newSkeleton.bones;\n  newSkeleton.bones = [];\n\n  for (var i = 0; i < skins.jointNames.length; i++) {\n    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\n\n    if (!jointNode) {\n      continue;\n    }\n\n    for (var j = 0; j < bones.length; j++) {\n      if (bones[j].id === jointNode.id) {\n        newSkeleton.bones.push(bones[j]);\n        break;\n      }\n    }\n  }\n\n  newSkeleton.prepare(); // Finish\n\n  for (var i = 0; i < nodesToRootToAdd.length; i++) {\n    newSkeleton.bones.push(nodesToRootToAdd[i]);\n  }\n\n  return newSkeleton;\n};\n/**\r\n* Imports a mesh and its geometries\r\n*/\n\n\nvar importMesh = function importMesh(gltfRuntime, node, meshes, id, newMesh) {\n  if (!newMesh) {\n    gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\n    newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\n    gltfRuntime.scene._blockEntityCollection = false;\n    newMesh.id = id;\n  }\n\n  if (!node.babylonNode) {\n    return newMesh;\n  }\n\n  var subMaterials = [];\n  var vertexData = null;\n  var verticesStarts = new Array();\n  var verticesCounts = new Array();\n  var indexStarts = new Array();\n  var indexCounts = new Array();\n\n  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n    var meshID = meshes[meshIndex];\n    var mesh = gltfRuntime.meshes[meshID];\n\n    if (!mesh) {\n      continue;\n    } // Positions, normals and UVs\n\n\n    for (var i = 0; i < mesh.primitives.length; i++) {\n      // Temporary vertex data\n      var tempVertexData = new VertexData();\n      var primitive = mesh.primitives[i];\n\n      if (primitive.mode !== 4) {// continue;\n      }\n\n      var attributes = primitive.attributes;\n      var accessor = null;\n      var buffer = null; // Set positions, normal and uvs\n\n      for (var semantic in attributes) {\n        // Link accessor and buffer view\n        accessor = gltfRuntime.accessors[attributes[semantic]];\n        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\n\n        if (semantic === \"NORMAL\") {\n          tempVertexData.normals = new Float32Array(buffer.length);\n          tempVertexData.normals.set(buffer);\n        } else if (semantic === \"POSITION\") {\n          if (GLTFFileLoader.HomogeneousCoordinates) {\n            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\n\n            for (var j = 0; j < buffer.length; j += 4) {\n              tempVertexData.positions[j] = buffer[j];\n              tempVertexData.positions[j + 1] = buffer[j + 1];\n              tempVertexData.positions[j + 2] = buffer[j + 2];\n            }\n          } else {\n            tempVertexData.positions = new Float32Array(buffer.length);\n            tempVertexData.positions.set(buffer);\n          }\n\n          verticesCounts.push(tempVertexData.positions.length);\n        } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\n          var channel = Number(semantic.split(\"_\")[1]);\n          var uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\n          var uvs = new Float32Array(buffer.length);\n          uvs.set(buffer);\n          normalizeUVs(uvs);\n          tempVertexData.set(uvs, uvKind);\n        } else if (semantic === \"JOINT\") {\n          tempVertexData.matricesIndices = new Float32Array(buffer.length);\n          tempVertexData.matricesIndices.set(buffer);\n        } else if (semantic === \"WEIGHT\") {\n          tempVertexData.matricesWeights = new Float32Array(buffer.length);\n          tempVertexData.matricesWeights.set(buffer);\n        } else if (semantic === \"COLOR\") {\n          tempVertexData.colors = new Float32Array(buffer.length);\n          tempVertexData.colors.set(buffer);\n        }\n      } // Indices\n\n\n      accessor = gltfRuntime.accessors[primitive.indices];\n\n      if (accessor) {\n        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\n        tempVertexData.indices = new Int32Array(buffer.length);\n        tempVertexData.indices.set(buffer);\n        indexCounts.push(tempVertexData.indices.length);\n      } else {\n        // Set indices on the fly\n        var indices = [];\n\n        for (var j = 0; j < tempVertexData.positions.length / 3; j++) {\n          indices.push(j);\n        }\n\n        tempVertexData.indices = new Int32Array(indices);\n        indexCounts.push(tempVertexData.indices.length);\n      }\n\n      if (!vertexData) {\n        vertexData = tempVertexData;\n      } else {\n        vertexData.merge(tempVertexData);\n      } // Sub material\n\n\n      var material_1 = gltfRuntime.scene.getMaterialByID(primitive.material);\n      subMaterials.push(material_1 === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material_1); // Update vertices start and index start\n\n      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\n      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\n    }\n  }\n\n  var material;\n  gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\n\n  if (subMaterials.length > 1) {\n    material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\n    material.subMaterials = subMaterials;\n  } else {\n    material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\n  }\n\n  if (subMaterials.length === 1) {\n    material = subMaterials[0];\n  }\n\n  if (!newMesh.material) {\n    newMesh.material = material;\n  } // Apply geometry\n\n\n  new Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);\n  newMesh.computeWorldMatrix(true);\n  gltfRuntime.scene._blockEntityCollection = false; // Apply submeshes\n\n  newMesh.subMeshes = [];\n  var index = 0;\n\n  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n    var meshID = meshes[meshIndex];\n    var mesh = gltfRuntime.meshes[meshID];\n\n    if (!mesh) {\n      continue;\n    }\n\n    for (var i = 0; i < mesh.primitives.length; i++) {\n      if (mesh.primitives[i].mode !== 4) {//continue;\n      }\n\n      SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\n      index++;\n    }\n  } // Finish\n\n\n  return newMesh;\n};\n/**\r\n* Configure node transformation from position, rotation and scaling\r\n*/\n\n\nvar configureNode = function configureNode(newNode, position, rotation, scaling) {\n  if (newNode.position) {\n    newNode.position = position;\n  }\n\n  if (newNode.rotationQuaternion || newNode.rotation) {\n    newNode.rotationQuaternion = rotation;\n  }\n\n  if (newNode.scaling) {\n    newNode.scaling = scaling;\n  }\n};\n/**\r\n* Configures node from transformation matrix\r\n*/\n\n\nvar configureNodeFromMatrix = function configureNodeFromMatrix(newNode, node, parent) {\n  if (node.matrix) {\n    var position = new Vector3(0, 0, 0);\n    var rotation = new Quaternion();\n    var scaling = new Vector3(0, 0, 0);\n    var mat = Matrix.FromArray(node.matrix);\n    mat.decompose(scaling, rotation, position);\n    configureNode(newNode, position, rotation, scaling);\n  } else if (node.translation && node.rotation && node.scale) {\n    configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\n  }\n\n  newNode.computeWorldMatrix(true);\n};\n/**\r\n* Imports a node\r\n*/\n\n\nvar importNode = function importNode(gltfRuntime, node, id, parent) {\n  var lastNode = null;\n\n  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\n    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\n      return null;\n    }\n  } // Meshes\n\n\n  if (node.skin) {\n    if (node.meshes) {\n      var skin = gltfRuntime.skins[node.skin];\n      var newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);\n      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonByID(node.skin);\n\n      if (newMesh.skeleton === null) {\n        newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton, node.skin);\n\n        if (!skin.babylonSkeleton) {\n          skin.babylonSkeleton = newMesh.skeleton;\n        }\n      }\n\n      lastNode = newMesh;\n    }\n  } else if (node.meshes) {\n    /**\r\n    * Improve meshes property\r\n    */\n    var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);\n    lastNode = newMesh;\n  } // Lights\n  else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\n    var light = gltfRuntime.lights[node.light];\n\n    if (light) {\n      if (light.type === \"ambient\") {\n        var ambienLight = light[light.type];\n        var hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        hemiLight.name = node.name || \"\";\n\n        if (ambienLight.color) {\n          hemiLight.diffuse = Color3.FromArray(ambienLight.color);\n        }\n\n        lastNode = hemiLight;\n      } else if (light.type === \"directional\") {\n        var directionalLight = light[light.type];\n        var dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        dirLight.name = node.name || \"\";\n\n        if (directionalLight.color) {\n          dirLight.diffuse = Color3.FromArray(directionalLight.color);\n        }\n\n        lastNode = dirLight;\n      } else if (light.type === \"point\") {\n        var pointLight = light[light.type];\n        var ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        ptLight.name = node.name || \"\";\n\n        if (pointLight.color) {\n          ptLight.diffuse = Color3.FromArray(pointLight.color);\n        }\n\n        lastNode = ptLight;\n      } else if (light.type === \"spot\") {\n        var spotLight = light[light.type];\n        var spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\n        spLight.name = node.name || \"\";\n\n        if (spotLight.color) {\n          spLight.diffuse = Color3.FromArray(spotLight.color);\n        }\n\n        if (spotLight.fallOfAngle) {\n          spLight.angle = spotLight.fallOfAngle;\n        }\n\n        if (spotLight.fallOffExponent) {\n          spLight.exponent = spotLight.fallOffExponent;\n        }\n\n        lastNode = spLight;\n      }\n    }\n  } // Cameras\n  else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\n    var camera = gltfRuntime.cameras[node.camera];\n\n    if (camera) {\n      gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\n\n      if (camera.type === \"orthographic\") {\n        var orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\n        orthoCamera.name = node.name || \"\";\n        orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n        orthoCamera.attachControl();\n        lastNode = orthoCamera;\n      } else if (camera.type === \"perspective\") {\n        var perspectiveCamera = camera[camera.type];\n        var persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\n        persCamera.name = node.name || \"\";\n        persCamera.attachControl();\n\n        if (!perspectiveCamera.aspectRatio) {\n          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\n        }\n\n        if (perspectiveCamera.znear && perspectiveCamera.zfar) {\n          persCamera.maxZ = perspectiveCamera.zfar;\n          persCamera.minZ = perspectiveCamera.znear;\n        }\n\n        lastNode = persCamera;\n      }\n\n      gltfRuntime.scene._blockEntityCollection = false;\n    }\n  } // Empty node\n\n\n  if (!node.jointName) {\n    if (node.babylonNode) {\n      return node.babylonNode;\n    } else if (lastNode === null) {\n      gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\n      var dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\n      gltfRuntime.scene._blockEntityCollection = false;\n      node.babylonNode = dummy;\n      lastNode = dummy;\n    }\n  }\n\n  if (lastNode !== null) {\n    if (node.matrix && lastNode instanceof Mesh) {\n      configureNodeFromMatrix(lastNode, node, parent);\n    } else {\n      var translation = node.translation || [0, 0, 0];\n      var rotation = node.rotation || [0, 0, 0, 1];\n      var scale = node.scale || [1, 1, 1];\n      configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\n    }\n\n    lastNode.updateCache(true);\n    node.babylonNode = lastNode;\n  }\n\n  return lastNode;\n};\n/**\r\n* Traverses nodes and creates them\r\n*/\n\n\nvar traverseNodes = function traverseNodes(gltfRuntime, id, parent, meshIncluded) {\n  if (meshIncluded === void 0) {\n    meshIncluded = false;\n  }\n\n  var node = gltfRuntime.nodes[id];\n  var newNode = null;\n\n  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\n    if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\n      meshIncluded = true;\n    } else {\n      meshIncluded = false;\n    }\n  } else {\n    meshIncluded = true;\n  }\n\n  if (!node.jointName && meshIncluded) {\n    newNode = importNode(gltfRuntime, node, id, parent);\n\n    if (newNode !== null) {\n      newNode.id = id;\n      newNode.parent = parent;\n    }\n  }\n\n  if (node.children) {\n    for (var i = 0; i < node.children.length; i++) {\n      traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\n    }\n  }\n};\n/**\r\n* do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n*/\n\n\nvar postLoad = function postLoad(gltfRuntime) {\n  // Nodes\n  var currentScene = gltfRuntime.currentScene;\n\n  if (currentScene) {\n    for (var i = 0; i < currentScene.nodes.length; i++) {\n      traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n    }\n  } else {\n    for (var thing in gltfRuntime.scenes) {\n      currentScene = gltfRuntime.scenes[thing];\n\n      for (var i = 0; i < currentScene.nodes.length; i++) {\n        traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n      }\n    }\n  } // Set animations\n\n\n  loadAnimations(gltfRuntime);\n\n  for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\n    var skeleton = gltfRuntime.scene.skeletons[i];\n    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\n  }\n};\n/**\r\n* onBind shaderrs callback to set uniforms and matrices\r\n*/\n\n\nvar onBindShaderMaterial = function onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) {\n  var materialValues = material.values || technique.parameters;\n\n  for (var unif in unTreatedUniforms) {\n    var uniform = unTreatedUniforms[unif];\n    var type = uniform.type;\n\n    if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\n      if (uniform.semantic && !uniform.source && !uniform.node) {\n        GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());\n      } else if (uniform.semantic && (uniform.source || uniform.node)) {\n        var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\n\n        if (source === null) {\n          source = gltfRuntime.scene.getNodeByID(uniform.source || uniform.node || \"\");\n        }\n\n        if (source === null) {\n          continue;\n        }\n\n        GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());\n      }\n    } else {\n      var value = materialValues[technique.uniforms[unif]];\n\n      if (!value) {\n        continue;\n      }\n\n      if (type === EParameterType.SAMPLER_2D) {\n        var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\n\n        if (texture === null || texture === undefined) {\n          continue;\n        }\n\n        shaderMaterial.getEffect().setTexture(unif, texture);\n      } else {\n        GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);\n      }\n    }\n  }\n\n  onSuccess(shaderMaterial);\n};\n/**\r\n* Prepare uniforms to send the only one time\r\n* Loads the appropriate textures\r\n*/\n\n\nvar prepareShaderMaterialUniforms = function prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) {\n  var materialValues = material.values || technique.parameters;\n  var techniqueUniforms = technique.uniforms;\n  /**\r\n  * Prepare values here (not matrices)\r\n  */\n\n  for (var unif in unTreatedUniforms) {\n    var uniform = unTreatedUniforms[unif];\n    var type = uniform.type;\n    var value = materialValues[techniqueUniforms[unif]];\n\n    if (value === undefined) {\n      // In case the value is the same for all materials\n      value = uniform.value;\n    }\n\n    if (!value) {\n      continue;\n    }\n\n    var onLoadTexture = function onLoadTexture(uniformName) {\n      return function (texture) {\n        if (uniform.value && uniformName) {\n          // Static uniform\n          shaderMaterial.setTexture(uniformName, texture);\n          delete unTreatedUniforms[uniformName];\n        }\n      };\n    }; // Texture (sampler2D)\n\n\n    if (type === EParameterType.SAMPLER_2D) {\n      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), function () {\n        return onLoadTexture(null);\n      });\n    } // Others\n    else {\n      if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\n        // Static uniform\n        delete unTreatedUniforms[unif];\n      }\n    }\n  }\n};\n/**\r\n* Shader compilation failed\r\n*/\n\n\nvar onShaderCompileError = function onShaderCompileError(program, shaderMaterial, onError) {\n  return function (effect, error) {\n    shaderMaterial.dispose(true);\n    onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\n  };\n};\n/**\r\n* Shader compilation success\r\n*/\n\n\nvar onShaderCompileSuccess = function onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) {\n  return function (_) {\n    prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\n\n    shaderMaterial.onBind = function (mesh) {\n      onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\n    };\n  };\n};\n/**\r\n* Returns the appropriate uniform if already handled by babylon\r\n*/\n\n\nvar parseShaderUniforms = function parseShaderUniforms(tokenizer, technique, unTreatedUniforms) {\n  for (var unif in technique.uniforms) {\n    var uniform = technique.uniforms[unif];\n    var uniformParameter = technique.parameters[uniform];\n\n    if (tokenizer.currentIdentifier === unif) {\n      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\n        var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\n\n        if (transformIndex !== -1) {\n          delete unTreatedUniforms[unif];\n          return babylonTransforms[transformIndex];\n        }\n      }\n    }\n  }\n\n  return tokenizer.currentIdentifier;\n};\n/**\r\n* All shaders loaded. Create materials one by one\r\n*/\n\n\nvar importMaterials = function importMaterials(gltfRuntime) {\n  // Create materials\n  for (var mat in gltfRuntime.materials) {\n    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, function (material) {}, function () {});\n  }\n};\n/**\r\n* Implementation of the base glTF spec\r\n* @hidden\r\n*/\n\n\nvar GLTFLoaderBase =\n/** @class */\nfunction () {\n  function GLTFLoaderBase() {}\n\n  GLTFLoaderBase.CreateRuntime = function (parsedData, scene, rootUrl) {\n    var gltfRuntime = {\n      extensions: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      meshes: {},\n      lights: {},\n      cameras: {},\n      nodes: {},\n      images: {},\n      textures: {},\n      shaders: {},\n      programs: {},\n      samplers: {},\n      techniques: {},\n      materials: {},\n      animations: {},\n      skins: {},\n      extensionsUsed: [],\n      scenes: {},\n      buffersCount: 0,\n      shaderscount: 0,\n      scene: scene,\n      rootUrl: rootUrl,\n      loadedBufferCount: 0,\n      loadedBufferViews: {},\n      loadedShaderCount: 0,\n      importOnlyMeshes: false,\n      dummyNodes: [],\n      forAssetContainer: false\n    }; // Parse\n\n    if (parsedData.extensions) {\n      parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\n    }\n\n    if (parsedData.extensionsUsed) {\n      parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\n    }\n\n    if (parsedData.buffers) {\n      parseBuffers(parsedData.buffers, gltfRuntime);\n    }\n\n    if (parsedData.bufferViews) {\n      parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\n    }\n\n    if (parsedData.accessors) {\n      parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\n    }\n\n    if (parsedData.meshes) {\n      parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\n    }\n\n    if (parsedData.lights) {\n      parseObject(parsedData.lights, \"lights\", gltfRuntime);\n    }\n\n    if (parsedData.cameras) {\n      parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\n    }\n\n    if (parsedData.nodes) {\n      parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\n    }\n\n    if (parsedData.images) {\n      parseObject(parsedData.images, \"images\", gltfRuntime);\n    }\n\n    if (parsedData.textures) {\n      parseObject(parsedData.textures, \"textures\", gltfRuntime);\n    }\n\n    if (parsedData.shaders) {\n      parseShaders(parsedData.shaders, gltfRuntime);\n    }\n\n    if (parsedData.programs) {\n      parseObject(parsedData.programs, \"programs\", gltfRuntime);\n    }\n\n    if (parsedData.samplers) {\n      parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\n    }\n\n    if (parsedData.techniques) {\n      parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\n    }\n\n    if (parsedData.materials) {\n      parseObject(parsedData.materials, \"materials\", gltfRuntime);\n    }\n\n    if (parsedData.animations) {\n      parseObject(parsedData.animations, \"animations\", gltfRuntime);\n    }\n\n    if (parsedData.skins) {\n      parseObject(parsedData.skins, \"skins\", gltfRuntime);\n    }\n\n    if (parsedData.scenes) {\n      gltfRuntime.scenes = parsedData.scenes;\n    }\n\n    if (parsedData.scene && parsedData.scenes) {\n      gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\n    }\n\n    return gltfRuntime;\n  };\n\n  GLTFLoaderBase.LoadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {\n    var buffer = gltfRuntime.buffers[id];\n\n    if (Tools.IsBase64(buffer.uri)) {\n      setTimeout(function () {\n        return onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri)));\n      });\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, function (data) {\n        return onSuccess(new Uint8Array(data));\n      }, onProgress, undefined, true, function (request) {\n        if (request) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  };\n\n  GLTFLoaderBase.LoadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {\n    var texture = gltfRuntime.textures[id];\n\n    if (!texture || !texture.source) {\n      onError(\"\");\n      return;\n    }\n\n    if (texture.babylonTexture) {\n      onSuccess(null);\n      return;\n    }\n\n    var source = gltfRuntime.images[texture.source];\n\n    if (Tools.IsBase64(source.uri)) {\n      setTimeout(function () {\n        return onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri)));\n      });\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + source.uri, function (data) {\n        return onSuccess(new Uint8Array(data));\n      }, undefined, undefined, true, function (request) {\n        if (request) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  };\n\n  GLTFLoaderBase.CreateTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {\n    var texture = gltfRuntime.textures[id];\n\n    if (texture.babylonTexture) {\n      onSuccess(texture.babylonTexture);\n      return;\n    }\n\n    var sampler = gltfRuntime.samplers[texture.sampler];\n    var createMipMaps = sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\n    var samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    var blob = buffer == null ? new Blob() : new Blob([buffer]);\n    var blobURL = URL.createObjectURL(blob);\n\n    var revokeBlobURL = function revokeBlobURL() {\n      return URL.revokeObjectURL(blobURL);\n    };\n\n    var newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\n\n    if (sampler.wrapS !== undefined) {\n      newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\n    }\n\n    if (sampler.wrapT !== undefined) {\n      newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\n    }\n\n    newTexture.name = id;\n    texture.babylonTexture = newTexture;\n    onSuccess(newTexture);\n  };\n\n  GLTFLoaderBase.LoadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {\n    var shader = gltfRuntime.shaders[id];\n\n    if (Tools.IsBase64(shader.uri)) {\n      var shaderString = atob(shader.uri.split(\",\")[1]);\n\n      if (onSuccess) {\n        onSuccess(shaderString);\n      }\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, function (request) {\n        if (request && onError) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  };\n\n  GLTFLoaderBase.LoadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {\n    var material = gltfRuntime.materials[id];\n\n    if (!material.technique) {\n      if (onError) {\n        onError(\"No technique found.\");\n      }\n\n      return;\n    }\n\n    var technique = gltfRuntime.techniques[material.technique];\n\n    if (!technique) {\n      gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\n      var defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\n      gltfRuntime.scene._blockEntityCollection = false;\n      defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\n      defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n      onSuccess(defaultMaterial);\n      return;\n    }\n\n    var program = gltfRuntime.programs[technique.program];\n    var states = technique.states;\n    var vertexShader = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\n    var pixelShader = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\n    var newVertexShader = \"\";\n    var newPixelShader = \"\";\n    var vertexTokenizer = new Tokenizer(vertexShader);\n    var pixelTokenizer = new Tokenizer(pixelShader);\n    var unTreatedUniforms = {};\n    var uniforms = [];\n    var attributes = [];\n    var samplers = []; // Fill uniform, sampler2D and attributes\n\n    for (var unif in technique.uniforms) {\n      var uniform = technique.uniforms[unif];\n      var uniformParameter = technique.parameters[uniform];\n      unTreatedUniforms[unif] = uniformParameter;\n\n      if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\n        var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\n\n        if (transformIndex !== -1) {\n          uniforms.push(babylonTransforms[transformIndex]);\n          delete unTreatedUniforms[unif];\n        } else {\n          uniforms.push(unif);\n        }\n      } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\n        samplers.push(unif);\n      } else {\n        uniforms.push(unif);\n      }\n    }\n\n    for (var attr in technique.attributes) {\n      var attribute = technique.attributes[attr];\n      var attributeParameter = technique.parameters[attribute];\n\n      if (attributeParameter.semantic) {\n        var name_1 = getAttribute(attributeParameter);\n\n        if (name_1) {\n          attributes.push(name_1);\n        }\n      }\n    } // Configure vertex shader\n\n\n    while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\n      var tokenType = vertexTokenizer.currentToken;\n\n      if (tokenType !== ETokenType.IDENTIFIER) {\n        newVertexShader += vertexTokenizer.currentString;\n        continue;\n      }\n\n      var foundAttribute = false;\n\n      for (var attr in technique.attributes) {\n        var attribute = technique.attributes[attr];\n        var attributeParameter = technique.parameters[attribute];\n\n        if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\n          newVertexShader += getAttribute(attributeParameter);\n          foundAttribute = true;\n          break;\n        }\n      }\n\n      if (foundAttribute) {\n        continue;\n      }\n\n      newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\n    } // Configure pixel shader\n\n\n    while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\n      var tokenType = pixelTokenizer.currentToken;\n\n      if (tokenType !== ETokenType.IDENTIFIER) {\n        newPixelShader += pixelTokenizer.currentString;\n        continue;\n      }\n\n      newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\n    } // Create shader material\n\n\n    var shaderPath = {\n      vertex: program.vertexShader + id,\n      fragment: program.fragmentShader + id\n    };\n    var options = {\n      attributes: attributes,\n      uniforms: uniforms,\n      samplers: samplers,\n      needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1\n    };\n    Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\n    Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\n    var shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\n    shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\n    shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\n    shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n\n    if (states && states.functions) {\n      var functions = states.functions;\n\n      if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\n        shaderMaterial.backFaceCulling = false;\n      }\n\n      var blendFunc = functions.blendFuncSeparate;\n\n      if (blendFunc) {\n        if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\n        } else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\n        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_ADD;\n        } else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\n        } else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\n        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\n        }\n      }\n    }\n  };\n\n  return GLTFLoaderBase;\n}();\n\nexport { GLTFLoaderBase };\n/**\r\n* glTF V1 Loader\r\n* @hidden\r\n*/\n\nvar GLTFLoader =\n/** @class */\nfunction () {\n  function GLTFLoader() {\n    this.state = null;\n  }\n\n  GLTFLoader.RegisterExtension = function (extension) {\n    if (GLTFLoader.Extensions[extension.name]) {\n      Tools.Error(\"Tool with the same name \\\"\" + extension.name + \"\\\" already exists\");\n      return;\n    }\n\n    GLTFLoader.Extensions[extension.name] = extension;\n  };\n\n  GLTFLoader.prototype.dispose = function () {// do nothing\n  };\n\n  GLTFLoader.prototype._importMeshAsync = function (meshesNames, scene, data, rootUrl, forAssetContainer, onSuccess, onProgress, onError) {\n    var _this = this;\n\n    scene.useRightHandedSystem = true;\n    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function (gltfRuntime) {\n      gltfRuntime.forAssetContainer = forAssetContainer;\n      gltfRuntime.importOnlyMeshes = true;\n\n      if (meshesNames === \"\") {\n        gltfRuntime.importMeshesNames = [];\n      } else if (typeof meshesNames === \"string\") {\n        gltfRuntime.importMeshesNames = [meshesNames];\n      } else if (meshesNames && !(meshesNames instanceof Array)) {\n        gltfRuntime.importMeshesNames = [meshesNames];\n      } else {\n        gltfRuntime.importMeshesNames = [];\n        Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\n      } // Create nodes\n\n\n      _this._createNodes(gltfRuntime);\n\n      var meshes = new Array();\n      var skeletons = new Array(); // Fill arrays of meshes and skeletons\n\n      for (var nde in gltfRuntime.nodes) {\n        var node = gltfRuntime.nodes[nde];\n\n        if (node.babylonNode instanceof AbstractMesh) {\n          meshes.push(node.babylonNode);\n        }\n      }\n\n      for (var skl in gltfRuntime.skins) {\n        var skin = gltfRuntime.skins[skl];\n\n        if (skin.babylonSkeleton instanceof Skeleton) {\n          skeletons.push(skin.babylonSkeleton);\n        }\n      } // Load buffers, shaders, materials, etc.\n\n\n      _this._loadBuffersAsync(gltfRuntime, function () {\n        _this._loadShadersAsync(gltfRuntime, function () {\n          importMaterials(gltfRuntime);\n          postLoad(gltfRuntime);\n\n          if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\n            onSuccess(meshes, skeletons);\n          }\n        });\n      }, onProgress);\n\n      if (GLTFFileLoader.IncrementalLoading && onSuccess) {\n        onSuccess(meshes, skeletons);\n      }\n    }, onError);\n    return true;\n  };\n  /**\r\n  * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n  * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n  * @param scene the scene the meshes should be added to\r\n  * @param forAssetContainer defines if the entities must be stored in the scene\r\n  * @param data gltf data containing information of the meshes in a loaded file\r\n  * @param rootUrl root url to load from\r\n  * @param onProgress event that fires when loading progress has occured\r\n  * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n  */\n\n\n  GLTFLoader.prototype.importMeshAsync = function (meshesNames, scene, forAssetContainer, data, rootUrl, onProgress) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._importMeshAsync(meshesNames, scene, data, rootUrl, forAssetContainer, function (meshes, skeletons) {\n        resolve({\n          meshes: meshes,\n          particleSystems: [],\n          skeletons: skeletons,\n          animationGroups: [],\n          lights: [],\n          transformNodes: [],\n          geometries: []\n        });\n      }, onProgress, function (message) {\n        reject(new Error(message));\n      });\n    });\n  };\n\n  GLTFLoader.prototype._loadAsync = function (scene, data, rootUrl, forAssetContainer, onSuccess, onProgress, onError) {\n    var _this = this;\n\n    scene.useRightHandedSystem = true;\n    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function (gltfRuntime) {\n      // Load runtime extensios\n      GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, function () {\n        // Create nodes\n        _this._createNodes(gltfRuntime); // Load buffers, shaders, materials, etc.\n\n\n        _this._loadBuffersAsync(gltfRuntime, function () {\n          _this._loadShadersAsync(gltfRuntime, function () {\n            importMaterials(gltfRuntime);\n            postLoad(gltfRuntime);\n\n            if (!GLTFFileLoader.IncrementalLoading) {\n              onSuccess();\n            }\n          });\n        });\n\n        if (GLTFFileLoader.IncrementalLoading) {\n          onSuccess();\n        }\n      }, onError);\n    }, onError);\n  };\n  /**\r\n  * Imports all objects from a loaded gltf file and adds them to the scene\r\n  * @param scene the scene the objects should be added to\r\n  * @param data gltf data containing information of the meshes in a loaded file\r\n  * @param rootUrl root url to load from\r\n  * @param onProgress event that fires when loading progress has occured\r\n  * @returns a promise which completes when objects have been loaded to the scene\r\n  */\n\n\n  GLTFLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._loadAsync(scene, data, rootUrl, false, function () {\n        resolve();\n      }, onProgress, function (message) {\n        reject(new Error(message));\n      });\n    });\n  };\n\n  GLTFLoader.prototype._loadShadersAsync = function (gltfRuntime, onload) {\n    var hasShaders = false;\n\n    var processShader = function processShader(sha, shader) {\n      GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, function (shaderString) {\n        if (shaderString instanceof ArrayBuffer) {\n          return;\n        }\n\n        gltfRuntime.loadedShaderCount++;\n\n        if (shaderString) {\n          Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\n        }\n\n        if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\n          onload();\n        }\n      }, function () {\n        Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\n      });\n    };\n\n    for (var sha in gltfRuntime.shaders) {\n      hasShaders = true;\n      var shader = gltfRuntime.shaders[sha];\n\n      if (shader) {\n        processShader.bind(this, sha, shader)();\n      } else {\n        Tools.Error(\"No shader named: \" + sha);\n      }\n    }\n\n    if (!hasShaders) {\n      onload();\n    }\n  };\n\n  GLTFLoader.prototype._loadBuffersAsync = function (gltfRuntime, onLoad, onProgress) {\n    var hasBuffers = false;\n\n    var processBuffer = function processBuffer(buf, buffer) {\n      GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, function (bufferView) {\n        gltfRuntime.loadedBufferCount++;\n\n        if (bufferView) {\n          if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\n            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\n          }\n\n          gltfRuntime.loadedBufferViews[buf] = bufferView;\n        }\n\n        if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\n          onLoad();\n        }\n      }, function () {\n        Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\n      });\n    };\n\n    for (var buf in gltfRuntime.buffers) {\n      hasBuffers = true;\n      var buffer = gltfRuntime.buffers[buf];\n\n      if (buffer) {\n        processBuffer.bind(this, buf, buffer)();\n      } else {\n        Tools.Error(\"No buffer named: \" + buf);\n      }\n    }\n\n    if (!hasBuffers) {\n      onLoad();\n    }\n  };\n\n  GLTFLoader.prototype._createNodes = function (gltfRuntime) {\n    var currentScene = gltfRuntime.currentScene;\n\n    if (currentScene) {\n      // Only one scene even if multiple scenes are defined\n      for (var i = 0; i < currentScene.nodes.length; i++) {\n        traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n      }\n    } else {\n      // Load all scenes\n      for (var thing in gltfRuntime.scenes) {\n        currentScene = gltfRuntime.scenes[thing];\n\n        for (var i = 0; i < currentScene.nodes.length; i++) {\n          traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n        }\n      }\n    }\n  };\n\n  GLTFLoader.Extensions = {};\n  return GLTFLoader;\n}();\n\nexport { GLTFLoader };\n/** @hidden */\n\nvar GLTFLoaderExtension =\n/** @class */\nfunction () {\n  function GLTFLoaderExtension(name) {\n    this._name = name;\n  }\n\n  Object.defineProperty(GLTFLoaderExtension.prototype, \"name\", {\n    get: function get() {\n      return this._name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n  * Defines an override for loading the runtime\r\n  * Return true to stop further extensions from loading the runtime\r\n  */\n\n  GLTFLoaderExtension.prototype.loadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {\n    return false;\n  };\n  /**\r\n   * Defines an onverride for creating gltf runtime\r\n   * Return true to stop further extensions from creating the runtime\r\n   */\n\n\n  GLTFLoaderExtension.prototype.loadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {\n    return false;\n  };\n  /**\r\n  * Defines an override for loading buffers\r\n  * Return true to stop further extensions from loading this buffer\r\n  */\n\n\n  GLTFLoaderExtension.prototype.loadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {\n    return false;\n  };\n  /**\r\n  * Defines an override for loading texture buffers\r\n  * Return true to stop further extensions from loading this texture data\r\n  */\n\n\n  GLTFLoaderExtension.prototype.loadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {\n    return false;\n  };\n  /**\r\n  * Defines an override for creating textures\r\n  * Return true to stop further extensions from loading this texture\r\n  */\n\n\n  GLTFLoaderExtension.prototype.createTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {\n    return false;\n  };\n  /**\r\n  * Defines an override for loading shader strings\r\n  * Return true to stop further extensions from loading this shader data\r\n  */\n\n\n  GLTFLoaderExtension.prototype.loadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {\n    return false;\n  };\n  /**\r\n  * Defines an override for loading materials\r\n  * Return true to stop further extensions from loading this material\r\n  */\n\n\n  GLTFLoaderExtension.prototype.loadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {\n    return false;\n  }; // ---------\n  // Utilities\n  // ---------\n\n\n  GLTFLoaderExtension.LoadRuntimeAsync = function (scene, data, rootUrl, onSuccess, onError) {\n    GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\n    }, function () {\n      setTimeout(function () {\n        if (!onSuccess) {\n          return;\n        }\n\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\n      });\n    });\n  };\n\n  GLTFLoaderExtension.LoadRuntimeExtensionsAsync = function (gltfRuntime, onSuccess, onError) {\n    GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\n    }, function () {\n      setTimeout(function () {\n        onSuccess();\n      });\n    });\n  };\n\n  GLTFLoaderExtension.LoadBufferAsync = function (gltfRuntime, id, onSuccess, onError, onProgress) {\n    GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\n    }, function () {\n      GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\n    });\n  };\n\n  GLTFLoaderExtension.LoadTextureAsync = function (gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension.LoadTextureBufferAsync(gltfRuntime, id, function (buffer) {\n      if (buffer) {\n        GLTFLoaderExtension.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n      }\n    }, onError);\n  };\n\n  GLTFLoaderExtension.LoadShaderStringAsync = function (gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\n    }, function () {\n      GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  };\n\n  GLTFLoaderExtension.LoadMaterialAsync = function (gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\n    }, function () {\n      GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  };\n\n  GLTFLoaderExtension.LoadTextureBufferAsync = function (gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\n    }, function () {\n      GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  };\n\n  GLTFLoaderExtension.CreateTextureAsync = function (gltfRuntime, id, buffer, onSuccess, onError) {\n    GLTFLoaderExtension.ApplyExtensions(function (loaderExtension) {\n      return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n    }, function () {\n      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n    });\n  };\n\n  GLTFLoaderExtension.ApplyExtensions = function (func, defaultFunc) {\n    for (var extensionName in GLTFLoader.Extensions) {\n      var loaderExtension = GLTFLoader.Extensions[extensionName];\n\n      if (func(loaderExtension)) {\n        return;\n      }\n    }\n\n    defaultFunc();\n  };\n\n  return GLTFLoaderExtension;\n}();\n\nexport { GLTFLoaderExtension };\n\nGLTFFileLoader._CreateGLTF1Loader = function () {\n  return new GLTFLoader();\n};","map":null,"metadata":{},"sourceType":"module"}