{"ast":null,"code":"import { Deferred } from \"@babylonjs/core/Misc/deferred\";\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup\";\nimport { Animation } from \"@babylonjs/core/Animations/animation\";\nimport { Bone } from \"@babylonjs/core/Bones/bone\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\nimport { Buffer, VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { MorphTarget } from \"@babylonjs/core/Morph/morphTarget\";\nimport { MorphTargetManager } from \"@babylonjs/core/Morph/morphTargetManager\";\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\nimport { AnimationKeyInterpolation } from '@babylonjs/core/Animations/animationKey';\nimport { LoadFileError } from '@babylonjs/core/Misc/fileTools';\nimport { Logger } from '@babylonjs/core/Misc/logger';\nimport { TmpVectors } from '@babylonjs/core/Maths/math.vector';\nimport { BoundingInfo } from '@babylonjs/core/Culling/boundingInfo';\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\n\nvar ArrayItem =\n/** @class */\nfunction () {\n  function ArrayItem() {}\n  /**\r\n   * Gets an item from the given array.\r\n   * @param context The context when loading the asset\r\n   * @param array The array to get the item from\r\n   * @param index The index to the array\r\n   * @returns The array item\r\n   */\n\n\n  ArrayItem.Get = function (context, array, index) {\n    if (!array || index == undefined || !array[index]) {\n      throw new Error(context + \": Failed to find index (\" + index + \")\");\n    }\n\n    return array[index];\n  };\n  /**\r\n   * Assign an `index` field to each item of the given array.\r\n   * @param array The array of items\r\n   */\n\n\n  ArrayItem.Assign = function (array) {\n    if (array) {\n      for (var index = 0; index < array.length; index++) {\n        array[index].index = index;\n      }\n    }\n  };\n\n  return ArrayItem;\n}();\n\nexport { ArrayItem };\n/**\r\n * The glTF 2.0 loader\r\n */\n\nvar GLTFLoader =\n/** @class */\nfunction () {\n  /** @hidden */\n  function GLTFLoader(parent) {\n    /** @hidden */\n    this._completePromises = new Array();\n    /** @hidden */\n\n    this._forAssetContainer = false;\n    /** Storage */\n\n    this._babylonLights = [];\n    /** @hidden */\n\n    this._disableInstancedMesh = 0;\n    this._disposed = false;\n    this._state = null;\n    this._extensions = new Array();\n    this._defaultBabylonMaterialData = {};\n    this._parent = parent;\n  }\n  /**\r\n   * Registers a loader extension.\r\n   * @param name The name of the loader extension.\r\n   * @param factory The factory function that creates the loader extension.\r\n   */\n\n\n  GLTFLoader.RegisterExtension = function (name, factory) {\n    if (GLTFLoader.UnregisterExtension(name)) {\n      Logger.Warn(\"Extension with the name '\" + name + \"' already exists\");\n    }\n\n    GLTFLoader._RegisteredExtensions[name] = {\n      factory: factory\n    };\n  };\n  /**\r\n   * Unregisters a loader extension.\r\n   * @param name The name of the loader extension.\r\n   * @returns A boolean indicating whether the extension has been unregistered\r\n   */\n\n\n  GLTFLoader.UnregisterExtension = function (name) {\n    if (!GLTFLoader._RegisteredExtensions[name]) {\n      return false;\n    }\n\n    delete GLTFLoader._RegisteredExtensions[name];\n    return true;\n  };\n\n  Object.defineProperty(GLTFLoader.prototype, \"state\", {\n    /**\r\n     * The loader state.\r\n     */\n    get: function get() {\n      return this._state;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"gltf\", {\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\n    get: function get() {\n      return this._gltf;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"bin\", {\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\n    get: function get() {\n      return this._bin;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"parent\", {\n    /**\r\n     * The parent file loader.\r\n     */\n    get: function get() {\n      return this._parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"babylonScene\", {\n    /**\r\n     * The Babylon scene when loading the asset.\r\n     */\n    get: function get() {\n      return this._babylonScene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFLoader.prototype, \"rootBabylonMesh\", {\n    /**\r\n     * The root Babylon mesh when loading the asset.\r\n     */\n    get: function get() {\n      return this._rootBabylonMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  GLTFLoader.prototype.dispose = function () {\n    if (this._disposed) {\n      return;\n    }\n\n    this._disposed = true;\n    this._completePromises.length = 0;\n\n    for (var name_1 in this._extensions) {\n      var extension = this._extensions[name_1];\n      extension.dispose && extension.dispose();\n      delete this._extensions[name_1];\n    }\n\n    this._gltf = null;\n    this._babylonScene = null;\n    this._rootBabylonMesh = null;\n\n    this._parent.dispose();\n  };\n  /** @hidden */\n\n\n  GLTFLoader.prototype.importMeshAsync = function (meshesNames, scene, forAssetContainer, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this._babylonScene = scene;\n      _this._rootUrl = rootUrl;\n      _this._fileName = fileName || \"scene\";\n      _this._forAssetContainer = forAssetContainer;\n\n      _this._loadData(data);\n\n      var nodes = null;\n\n      if (meshesNames) {\n        var nodeMap_1 = {};\n\n        if (_this._gltf.nodes) {\n          for (var _i = 0, _a = _this._gltf.nodes; _i < _a.length; _i++) {\n            var node = _a[_i];\n\n            if (node.name) {\n              nodeMap_1[node.name] = node.index;\n            }\n          }\n        }\n\n        var names = meshesNames instanceof Array ? meshesNames : [meshesNames];\n        nodes = names.map(function (name) {\n          var node = nodeMap_1[name];\n\n          if (node === undefined) {\n            throw new Error(\"Failed to find node '\" + name + \"'\");\n          }\n\n          return node;\n        });\n      }\n\n      return _this._loadAsync(nodes, function () {\n        return {\n          meshes: _this._getMeshes(),\n          particleSystems: [],\n          skeletons: _this._getSkeletons(),\n          animationGroups: _this._getAnimationGroups(),\n          lights: _this._babylonLights,\n          transformNodes: _this._getTransformNodes(),\n          geometries: _this._getGeometries()\n        };\n      });\n    });\n  };\n  /** @hidden */\n\n\n  GLTFLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this._babylonScene = scene;\n      _this._rootUrl = rootUrl;\n      _this._fileName = fileName || \"scene\";\n\n      _this._loadData(data);\n\n      return _this._loadAsync(null, function () {\n        return undefined;\n      });\n    });\n  };\n\n  GLTFLoader.prototype._loadAsync = function (nodes, resultFunc) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this._uniqueRootUrl = _this._rootUrl.indexOf(\"file:\") === -1 && _this._fileName ? _this._rootUrl : \"\" + _this._rootUrl + Date.now() + \"/\";\n\n      _this._loadExtensions();\n\n      _this._checkExtensions();\n\n      var loadingToReadyCounterName = GLTFLoaderState[GLTFLoaderState.LOADING] + \" => \" + GLTFLoaderState[GLTFLoaderState.READY];\n      var loadingToCompleteCounterName = GLTFLoaderState[GLTFLoaderState.LOADING] + \" => \" + GLTFLoaderState[GLTFLoaderState.COMPLETE];\n\n      _this._parent._startPerformanceCounter(loadingToReadyCounterName);\n\n      _this._parent._startPerformanceCounter(loadingToCompleteCounterName);\n\n      _this._setState(GLTFLoaderState.LOADING);\n\n      _this._extensionsOnLoading();\n\n      var promises = new Array(); // Block the marking of materials dirty until the scene is loaded.\n\n      var oldBlockMaterialDirtyMechanism = _this._babylonScene.blockMaterialDirtyMechanism;\n      _this._babylonScene.blockMaterialDirtyMechanism = true;\n\n      if (nodes) {\n        promises.push(_this.loadSceneAsync(\"/nodes\", {\n          nodes: nodes,\n          index: -1\n        }));\n      } else if (_this._gltf.scene != undefined || _this._gltf.scenes && _this._gltf.scenes[0]) {\n        var scene = ArrayItem.Get(\"/scene\", _this._gltf.scenes, _this._gltf.scene || 0);\n        promises.push(_this.loadSceneAsync(\"/scenes/\" + scene.index, scene));\n      }\n\n      if (_this.parent.loadAllMaterials && _this._gltf.materials) {\n        for (var m = 0; m < _this._gltf.materials.length; ++m) {\n          var material = _this._gltf.materials[m];\n          var context_1 = \"/materials/\" + m;\n          var babylonDrawMode = Material.TriangleFillMode;\n          promises.push(_this._loadMaterialAsync(context_1, material, null, babylonDrawMode, function (material) {}));\n        }\n      } // Restore the blocking of material dirty.\n\n\n      _this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\n\n      if (_this._parent.compileMaterials) {\n        promises.push(_this._compileMaterialsAsync());\n      }\n\n      if (_this._parent.compileShadowGenerators) {\n        promises.push(_this._compileShadowGeneratorsAsync());\n      }\n\n      var resultPromise = Promise.all(promises).then(function () {\n        if (_this._rootBabylonMesh) {\n          _this._rootBabylonMesh.setEnabled(true);\n        }\n\n        _this._extensionsOnReady();\n\n        _this._setState(GLTFLoaderState.READY);\n\n        _this._startAnimations();\n\n        return resultFunc();\n      });\n      resultPromise.then(function () {\n        _this._parent._endPerformanceCounter(loadingToReadyCounterName);\n\n        Tools.SetImmediate(function () {\n          if (!_this._disposed) {\n            Promise.all(_this._completePromises).then(function () {\n              _this._parent._endPerformanceCounter(loadingToCompleteCounterName);\n\n              _this._setState(GLTFLoaderState.COMPLETE);\n\n              _this._parent.onCompleteObservable.notifyObservers(undefined);\n\n              _this._parent.onCompleteObservable.clear();\n\n              _this.dispose();\n            }, function (error) {\n              _this._parent.onErrorObservable.notifyObservers(error);\n\n              _this._parent.onErrorObservable.clear();\n\n              _this.dispose();\n            });\n          }\n        });\n      });\n      return resultPromise;\n    }).catch(function (error) {\n      if (!_this._disposed) {\n        _this._parent.onErrorObservable.notifyObservers(error);\n\n        _this._parent.onErrorObservable.clear();\n\n        _this.dispose();\n      }\n\n      throw error;\n    });\n  };\n\n  GLTFLoader.prototype._loadData = function (data) {\n    this._gltf = data.json;\n\n    this._setupData();\n\n    if (data.bin) {\n      var buffers = this._gltf.buffers;\n\n      if (buffers && buffers[0] && !buffers[0].uri) {\n        var binaryBuffer = buffers[0];\n\n        if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\n          Logger.Warn(\"Binary buffer length (\" + binaryBuffer.byteLength + \") from JSON does not match chunk length (\" + data.bin.byteLength + \")\");\n        }\n\n        this._bin = data.bin;\n      } else {\n        Logger.Warn(\"Unexpected BIN chunk\");\n      }\n    }\n  };\n\n  GLTFLoader.prototype._setupData = function () {\n    ArrayItem.Assign(this._gltf.accessors);\n    ArrayItem.Assign(this._gltf.animations);\n    ArrayItem.Assign(this._gltf.buffers);\n    ArrayItem.Assign(this._gltf.bufferViews);\n    ArrayItem.Assign(this._gltf.cameras);\n    ArrayItem.Assign(this._gltf.images);\n    ArrayItem.Assign(this._gltf.materials);\n    ArrayItem.Assign(this._gltf.meshes);\n    ArrayItem.Assign(this._gltf.nodes);\n    ArrayItem.Assign(this._gltf.samplers);\n    ArrayItem.Assign(this._gltf.scenes);\n    ArrayItem.Assign(this._gltf.skins);\n    ArrayItem.Assign(this._gltf.textures);\n\n    if (this._gltf.nodes) {\n      var nodeParents = {};\n\n      for (var _i = 0, _a = this._gltf.nodes; _i < _a.length; _i++) {\n        var node = _a[_i];\n\n        if (node.children) {\n          for (var _b = 0, _c = node.children; _b < _c.length; _b++) {\n            var index = _c[_b];\n            nodeParents[index] = node.index;\n          }\n        }\n      }\n\n      var rootNode = this._createRootNode();\n\n      for (var _d = 0, _e = this._gltf.nodes; _d < _e.length; _d++) {\n        var node = _e[_d];\n        var parentIndex = nodeParents[node.index];\n        node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\n      }\n    }\n  };\n\n  GLTFLoader.prototype._loadExtensions = function () {\n    for (var name_2 in GLTFLoader._RegisteredExtensions) {\n      var extension = GLTFLoader._RegisteredExtensions[name_2].factory(this);\n\n      if (extension.name !== name_2) {\n        Logger.Warn(\"The name of the glTF loader extension instance does not match the registered name: \" + extension.name + \" !== \" + name_2);\n      }\n\n      this._extensions.push(extension);\n\n      this._parent.onExtensionLoadedObservable.notifyObservers(extension);\n    }\n\n    this._extensions.sort(function (a, b) {\n      return (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE);\n    });\n\n    this._parent.onExtensionLoadedObservable.clear();\n  };\n\n  GLTFLoader.prototype._checkExtensions = function () {\n    if (this._gltf.extensionsRequired) {\n      var _loop_1 = function _loop_1(name_3) {\n        var available = this_1._extensions.some(function (extension) {\n          return extension.name === name_3 && extension.enabled;\n        });\n\n        if (!available) {\n          throw new Error(\"Require extension \" + name_3 + \" is not available\");\n        }\n      };\n\n      var this_1 = this;\n\n      for (var _i = 0, _a = this._gltf.extensionsRequired; _i < _a.length; _i++) {\n        var name_3 = _a[_i];\n\n        _loop_1(name_3);\n      }\n    }\n  };\n\n  GLTFLoader.prototype._setState = function (state) {\n    this._state = state;\n    this.log(GLTFLoaderState[this._state]);\n  };\n\n  GLTFLoader.prototype._createRootNode = function () {\n    this._babylonScene._blockEntityCollection = this._forAssetContainer;\n    this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\n    this._babylonScene._blockEntityCollection = false;\n\n    this._rootBabylonMesh.setEnabled(false);\n\n    var rootNode = {\n      _babylonTransformNode: this._rootBabylonMesh,\n      index: -1\n    };\n\n    switch (this._parent.coordinateSystemMode) {\n      case GLTFLoaderCoordinateSystemMode.AUTO:\n        {\n          if (!this._babylonScene.useRightHandedSystem) {\n            rootNode.rotation = [0, 1, 0, 0];\n            rootNode.scale = [1, 1, -1];\n\n            GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\n          }\n\n          break;\n        }\n\n      case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED:\n        {\n          this._babylonScene.useRightHandedSystem = true;\n          break;\n        }\n\n      default:\n        {\n          throw new Error(\"Invalid coordinate system mode (\" + this._parent.coordinateSystemMode + \")\");\n        }\n    }\n\n    this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\n\n    return rootNode;\n  };\n  /**\r\n   * Loads a glTF scene.\r\n   * @param context The context when loading the asset\r\n   * @param scene The glTF scene property\r\n   * @returns A promise that resolves when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadSceneAsync = function (context, scene) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadSceneAsync(context, scene);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var promises = new Array();\n    this.logOpen(context + \" \" + (scene.name || \"\"));\n\n    if (scene.nodes) {\n      for (var _i = 0, _a = scene.nodes; _i < _a.length; _i++) {\n        var index = _a[_i];\n        var node = ArrayItem.Get(context + \"/nodes/\" + index, this._gltf.nodes, index);\n        promises.push(this.loadNodeAsync(\"/nodes/\" + node.index, node, function (babylonMesh) {\n          babylonMesh.parent = _this._rootBabylonMesh;\n        }));\n      }\n    } // Link all Babylon bones for each glTF node with the corresponding Babylon transform node.\n    // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\n\n\n    if (this._gltf.nodes) {\n      for (var _b = 0, _c = this._gltf.nodes; _b < _c.length; _b++) {\n        var node = _c[_b];\n\n        if (node._babylonTransformNode && node._babylonBones) {\n          for (var _d = 0, _e = node._babylonBones; _d < _e.length; _d++) {\n            var babylonBone = _e[_d];\n            babylonBone.linkTransformNode(node._babylonTransformNode);\n          }\n        }\n      }\n    }\n\n    promises.push(this._loadAnimationsAsync());\n    this.logClose();\n    return Promise.all(promises).then(function () {});\n  };\n\n  GLTFLoader.prototype._forEachPrimitive = function (node, callback) {\n    if (node._primitiveBabylonMeshes) {\n      for (var _i = 0, _a = node._primitiveBabylonMeshes; _i < _a.length; _i++) {\n        var babylonMesh = _a[_i];\n        callback(babylonMesh);\n      }\n    }\n  };\n\n  GLTFLoader.prototype._getGeometries = function () {\n    var geometries = new Array();\n    var nodes = this._gltf.nodes;\n\n    if (nodes) {\n      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n\n        this._forEachPrimitive(node, function (babylonMesh) {\n          var geometry = babylonMesh.geometry;\n\n          if (geometry && geometries.indexOf(geometry) === -1) {\n            geometries.push(geometry);\n          }\n        });\n      }\n    }\n\n    return geometries;\n  };\n\n  GLTFLoader.prototype._getMeshes = function () {\n    var meshes = new Array(); // Root mesh is always first.\n\n    meshes.push(this._rootBabylonMesh);\n    var nodes = this._gltf.nodes;\n\n    if (nodes) {\n      for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {\n        var node = nodes_2[_i];\n\n        this._forEachPrimitive(node, function (babylonMesh) {\n          meshes.push(babylonMesh);\n        });\n      }\n    }\n\n    return meshes;\n  };\n\n  GLTFLoader.prototype._getTransformNodes = function () {\n    var transformNodes = new Array();\n    var nodes = this._gltf.nodes;\n\n    if (nodes) {\n      for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {\n        var node = nodes_3[_i];\n\n        if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\n          transformNodes.push(node._babylonTransformNode);\n        }\n      }\n    }\n\n    return transformNodes;\n  };\n\n  GLTFLoader.prototype._getSkeletons = function () {\n    var skeletons = new Array();\n    var skins = this._gltf.skins;\n\n    if (skins) {\n      for (var _i = 0, skins_1 = skins; _i < skins_1.length; _i++) {\n        var skin = skins_1[_i];\n\n        if (skin._data) {\n          skeletons.push(skin._data.babylonSkeleton);\n        }\n      }\n    }\n\n    return skeletons;\n  };\n\n  GLTFLoader.prototype._getAnimationGroups = function () {\n    var animationGroups = new Array();\n    var animations = this._gltf.animations;\n\n    if (animations) {\n      for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {\n        var animation = animations_1[_i];\n\n        if (animation._babylonAnimationGroup) {\n          animationGroups.push(animation._babylonAnimationGroup);\n        }\n      }\n    }\n\n    return animationGroups;\n  };\n\n  GLTFLoader.prototype._startAnimations = function () {\n    switch (this._parent.animationStartMode) {\n      case GLTFLoaderAnimationStartMode.NONE:\n        {\n          // do nothing\n          break;\n        }\n\n      case GLTFLoaderAnimationStartMode.FIRST:\n        {\n          var babylonAnimationGroups = this._getAnimationGroups();\n\n          if (babylonAnimationGroups.length !== 0) {\n            babylonAnimationGroups[0].start(true);\n          }\n\n          break;\n        }\n\n      case GLTFLoaderAnimationStartMode.ALL:\n        {\n          var babylonAnimationGroups = this._getAnimationGroups();\n\n          for (var _i = 0, babylonAnimationGroups_1 = babylonAnimationGroups; _i < babylonAnimationGroups_1.length; _i++) {\n            var babylonAnimationGroup = babylonAnimationGroups_1[_i];\n            babylonAnimationGroup.start(true);\n          }\n\n          break;\n        }\n\n      default:\n        {\n          Logger.Error(\"Invalid animation start mode (\" + this._parent.animationStartMode + \")\");\n          return;\n        }\n    }\n  };\n  /**\r\n   * Loads a glTF node.\r\n   * @param context The context when loading the asset\r\n   * @param node The glTF node property\r\n   * @param assign A function called synchronously after parsing the glTF properties\r\n   * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (node._babylonTransformNode) {\n      throw new Error(context + \": Invalid recursive node hierarchy\");\n    }\n\n    var promises = new Array();\n    this.logOpen(context + \" \" + (node.name || \"\"));\n\n    var loadNode = function loadNode(babylonTransformNode) {\n      GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\n\n      GLTFLoader._LoadTransform(node, babylonTransformNode);\n\n      if (node.camera != undefined) {\n        var camera = ArrayItem.Get(context + \"/camera\", _this._gltf.cameras, node.camera);\n        promises.push(_this.loadCameraAsync(\"/cameras/\" + camera.index, camera, function (babylonCamera) {\n          babylonCamera.parent = babylonTransformNode;\n        }));\n      }\n\n      if (node.children) {\n        for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n          var index = _a[_i];\n          var childNode = ArrayItem.Get(context + \"/children/\" + index, _this._gltf.nodes, index);\n          promises.push(_this.loadNodeAsync(\"/nodes/\" + childNode.index, childNode, function (childBabylonMesh) {\n            childBabylonMesh.parent = babylonTransformNode;\n          }));\n        }\n      }\n\n      assign(babylonTransformNode);\n    };\n\n    if (node.mesh == undefined) {\n      var nodeName = node.name || \"node\" + node.index;\n      this._babylonScene._blockEntityCollection = this._forAssetContainer;\n      node._babylonTransformNode = new TransformNode(nodeName, this._babylonScene);\n      this._babylonScene._blockEntityCollection = false;\n      loadNode(node._babylonTransformNode);\n    } else {\n      var mesh = ArrayItem.Get(context + \"/mesh\", this._gltf.meshes, node.mesh);\n      promises.push(this._loadMeshAsync(\"/meshes/\" + mesh.index, node, mesh, loadNode));\n    }\n\n    this.logClose();\n    return Promise.all(promises).then(function () {\n      _this._forEachPrimitive(node, function (babylonMesh) {\n        if (babylonMesh.geometry && babylonMesh.geometry.useBoundingInfoFromGeometry) {\n          // simply apply the world matrices to the bounding info - the extends are already ok\n          babylonMesh._updateBoundingInfo();\n        } else {\n          babylonMesh.refreshBoundingInfo(true);\n        }\n      });\n\n      return node._babylonTransformNode;\n    });\n  };\n\n  GLTFLoader.prototype._loadMeshAsync = function (context, node, mesh, assign) {\n    var primitives = mesh.primitives;\n\n    if (!primitives || !primitives.length) {\n      throw new Error(context + \": Primitives are missing\");\n    }\n\n    if (primitives[0].index == undefined) {\n      ArrayItem.Assign(primitives);\n    }\n\n    var promises = new Array();\n    this.logOpen(context + \" \" + (mesh.name || \"\"));\n    var name = node.name || \"node\" + node.index;\n\n    if (primitives.length === 1) {\n      var primitive = mesh.primitives[0];\n      promises.push(this._loadMeshPrimitiveAsync(context + \"/primitives/\" + primitive.index, name, node, mesh, primitive, function (babylonMesh) {\n        node._babylonTransformNode = babylonMesh;\n        node._primitiveBabylonMeshes = [babylonMesh];\n      }));\n    } else {\n      this._babylonScene._blockEntityCollection = this._forAssetContainer;\n      node._babylonTransformNode = new TransformNode(name, this._babylonScene);\n      this._babylonScene._blockEntityCollection = false;\n      node._primitiveBabylonMeshes = [];\n\n      for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {\n        var primitive = primitives_1[_i];\n        promises.push(this._loadMeshPrimitiveAsync(context + \"/primitives/\" + primitive.index, name + \"_primitive\" + primitive.index, node, mesh, primitive, function (babylonMesh) {\n          babylonMesh.parent = node._babylonTransformNode;\n\n          node._primitiveBabylonMeshes.push(babylonMesh);\n        }));\n      }\n    }\n\n    if (node.skin != undefined) {\n      var skin = ArrayItem.Get(context + \"/skin\", this._gltf.skins, node.skin);\n      promises.push(this._loadSkinAsync(\"/skins/\" + skin.index, node, skin));\n    }\n\n    assign(node._babylonTransformNode);\n    this.logClose();\n    return Promise.all(promises).then(function () {\n      return node._babylonTransformNode;\n    });\n  };\n  /**\r\n   * @hidden Define this method to modify the default behavior when loading data for mesh primitives.\r\n   * @param context The context when loading the asset\r\n   * @param name The mesh name when loading the asset\r\n   * @param node The glTF node when loading the asset\r\n   * @param mesh The glTF mesh when loading the asset\r\n   * @param primitive The glTF mesh primitive property\r\n   * @param assign A function called synchronously after parsing the glTF properties\r\n   * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\r\n   */\n\n\n  GLTFLoader.prototype._loadMeshPrimitiveAsync = function (context, name, node, mesh, primitive, assign) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    this.logOpen(\"\" + context);\n    var shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\n    var babylonAbstractMesh;\n    var promise;\n\n    if (shouldInstance && primitive._instanceData) {\n      babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);\n      promise = primitive._instanceData.promise;\n    } else {\n      var promises = new Array();\n      this._babylonScene._blockEntityCollection = this._forAssetContainer;\n      var babylonMesh_1 = new Mesh(name, this._babylonScene);\n      this._babylonScene._blockEntityCollection = false;\n      babylonMesh_1.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n\n      this._createMorphTargets(context, node, mesh, primitive, babylonMesh_1);\n\n      promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh_1).then(function (babylonGeometry) {\n        return _this._loadMorphTargetsAsync(context, primitive, babylonMesh_1, babylonGeometry).then(function () {\n          _this._babylonScene._blockEntityCollection = _this._forAssetContainer;\n          babylonGeometry.applyToMesh(babylonMesh_1);\n          _this._babylonScene._blockEntityCollection = false;\n        });\n      }));\n\n      var babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n\n      if (primitive.material == undefined) {\n        var babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\n\n        if (!babylonMaterial) {\n          babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\n\n          this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n\n          this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\n        }\n\n        babylonMesh_1.material = babylonMaterial;\n      } else {\n        var material = ArrayItem.Get(context + \"/material\", this._gltf.materials, primitive.material);\n        promises.push(this._loadMaterialAsync(\"/materials/\" + material.index, material, babylonMesh_1, babylonDrawMode, function (babylonMaterial) {\n          babylonMesh_1.material = babylonMaterial;\n        }));\n      }\n\n      promise = Promise.all(promises);\n\n      if (shouldInstance) {\n        primitive._instanceData = {\n          babylonSourceMesh: babylonMesh_1,\n          promise: promise\n        };\n      }\n\n      babylonAbstractMesh = babylonMesh_1;\n    }\n\n    GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\n\n    this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\n\n    assign(babylonAbstractMesh);\n    this.logClose();\n    return promise.then(function () {\n      return babylonAbstractMesh;\n    });\n  };\n\n  GLTFLoader.prototype._loadVertexDataAsync = function (context, primitive, babylonMesh) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var attributes = primitive.attributes;\n\n    if (!attributes) {\n      throw new Error(context + \": Attributes are missing\");\n    }\n\n    var promises = new Array();\n    var babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\n\n    if (primitive.indices == undefined) {\n      babylonMesh.isUnIndexed = true;\n    } else {\n      var accessor = ArrayItem.Get(context + \"/indices\", this._gltf.accessors, primitive.indices);\n      promises.push(this._loadIndicesAccessorAsync(\"/accessors/\" + accessor.index, accessor).then(function (data) {\n        babylonGeometry.setIndices(data);\n      }));\n    }\n\n    var loadAttribute = function loadAttribute(attribute, kind, callback) {\n      if (attributes[attribute] == undefined) {\n        return;\n      }\n\n      babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n\n      if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n        babylonMesh._delayInfo.push(kind);\n      }\n\n      var accessor = ArrayItem.Get(context + \"/attributes/\" + attribute, _this._gltf.accessors, attributes[attribute]);\n      promises.push(_this._loadVertexAccessorAsync(\"/accessors/\" + accessor.index, accessor, kind).then(function (babylonVertexBuffer) {\n        if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !_this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\n          var mmin = accessor.min,\n              mmax = accessor.max;\n\n          if (mmin !== undefined && mmax !== undefined) {\n            var min = TmpVectors.Vector3[0],\n                max = TmpVectors.Vector3[1];\n            min.copyFromFloats.apply(min, mmin);\n            max.copyFromFloats.apply(max, mmax);\n            babylonGeometry._boundingInfo = new BoundingInfo(min, max);\n            babylonGeometry.useBoundingInfoFromGeometry = true;\n          }\n        }\n\n        babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\n      }));\n\n      if (kind == VertexBuffer.MatricesIndicesExtraKind) {\n        babylonMesh.numBoneInfluencers = 8;\n      }\n\n      if (callback) {\n        callback(accessor);\n      }\n    };\n\n    loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n    loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n    loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n    loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n    loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n    loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n    loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n    loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\n    loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\n    loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, function (accessor) {\n      if (accessor.type === \"VEC4\"\n      /* VEC4 */\n      ) {\n        babylonMesh.hasVertexAlpha = true;\n      }\n    });\n    return Promise.all(promises).then(function () {\n      return babylonGeometry;\n    });\n  };\n\n  GLTFLoader.prototype._createMorphTargets = function (context, node, mesh, primitive, babylonMesh) {\n    if (!primitive.targets) {\n      return;\n    }\n\n    if (node._numMorphTargets == undefined) {\n      node._numMorphTargets = primitive.targets.length;\n    } else if (primitive.targets.length !== node._numMorphTargets) {\n      throw new Error(context + \": Primitives do not have the same number of targets\");\n    }\n\n    var targetNames = mesh.extras ? mesh.extras.targetNames : null;\n    babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\n\n    for (var index = 0; index < primitive.targets.length; index++) {\n      var weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\n      var name_4 = targetNames ? targetNames[index] : \"morphTarget\" + index;\n      babylonMesh.morphTargetManager.addTarget(new MorphTarget(name_4, weight, babylonMesh.getScene())); // TODO: tell the target whether it has positions, normals, tangents\n    }\n  };\n\n  GLTFLoader.prototype._loadMorphTargetsAsync = function (context, primitive, babylonMesh, babylonGeometry) {\n    if (!primitive.targets) {\n      return Promise.resolve();\n    }\n\n    var promises = new Array();\n    var morphTargetManager = babylonMesh.morphTargetManager;\n\n    for (var index = 0; index < morphTargetManager.numTargets; index++) {\n      var babylonMorphTarget = morphTargetManager.getTarget(index);\n      promises.push(this._loadMorphTargetVertexDataAsync(context + \"/targets/\" + index, babylonGeometry, primitive.targets[index], babylonMorphTarget));\n    }\n\n    return Promise.all(promises).then(function () {});\n  };\n\n  GLTFLoader.prototype._loadMorphTargetVertexDataAsync = function (context, babylonGeometry, attributes, babylonMorphTarget) {\n    var _this = this;\n\n    var promises = new Array();\n\n    var loadAttribute = function loadAttribute(attribute, kind, setData) {\n      if (attributes[attribute] == undefined) {\n        return;\n      }\n\n      var babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\n\n      if (!babylonVertexBuffer) {\n        return;\n      }\n\n      var accessor = ArrayItem.Get(context + \"/\" + attribute, _this._gltf.accessors, attributes[attribute]);\n      promises.push(_this._loadFloatAccessorAsync(\"/accessors/\" + accessor.index, accessor).then(function (data) {\n        setData(babylonVertexBuffer, data);\n      }));\n    };\n\n    loadAttribute(\"POSITION\", VertexBuffer.PositionKind, function (babylonVertexBuffer, data) {\n      var positions = new Float32Array(data.length);\n      babylonVertexBuffer.forEach(data.length, function (value, index) {\n        positions[index] = data[index] + value;\n      });\n      babylonMorphTarget.setPositions(positions);\n    });\n    loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, function (babylonVertexBuffer, data) {\n      var normals = new Float32Array(data.length);\n      babylonVertexBuffer.forEach(normals.length, function (value, index) {\n        normals[index] = data[index] + value;\n      });\n      babylonMorphTarget.setNormals(normals);\n    });\n    loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, function (babylonVertexBuffer, data) {\n      var tangents = new Float32Array(data.length / 3 * 4);\n      var dataIndex = 0;\n      babylonVertexBuffer.forEach(data.length / 3 * 4, function (value, index) {\n        // Tangent data for morph targets is stored as xyz delta.\n        // The vertexData.tangent is stored as xyzw.\n        // So we need to skip every fourth vertexData.tangent.\n        if ((index + 1) % 4 !== 0) {\n          tangents[dataIndex] = data[dataIndex] + value;\n          dataIndex++;\n        }\n      });\n      babylonMorphTarget.setTangents(tangents);\n    });\n    return Promise.all(promises).then(function () {});\n  };\n\n  GLTFLoader._LoadTransform = function (node, babylonNode) {\n    // Ignore the TRS of skinned nodes.\n    // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n    if (node.skin != undefined) {\n      return;\n    }\n\n    var position = Vector3.Zero();\n    var rotation = Quaternion.Identity();\n    var scaling = Vector3.One();\n\n    if (node.matrix) {\n      var matrix = Matrix.FromArray(node.matrix);\n      matrix.decompose(scaling, rotation, position);\n    } else {\n      if (node.translation) {\n        position = Vector3.FromArray(node.translation);\n      }\n\n      if (node.rotation) {\n        rotation = Quaternion.FromArray(node.rotation);\n      }\n\n      if (node.scale) {\n        scaling = Vector3.FromArray(node.scale);\n      }\n    }\n\n    babylonNode.position = position;\n    babylonNode.rotationQuaternion = rotation;\n    babylonNode.scaling = scaling;\n  };\n\n  GLTFLoader.prototype._loadSkinAsync = function (context, node, skin) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var assignSkeleton = function assignSkeleton(skeleton) {\n      _this._forEachPrimitive(node, function (babylonMesh) {\n        babylonMesh.skeleton = skeleton;\n      });\n    };\n\n    if (skin._data) {\n      assignSkeleton(skin._data.babylonSkeleton);\n      return skin._data.promise;\n    }\n\n    var skeletonId = \"skeleton\" + skin.index;\n    this._babylonScene._blockEntityCollection = this._forAssetContainer;\n    var babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\n    this._babylonScene._blockEntityCollection = false; // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n\n    babylonSkeleton.overrideMesh = this._rootBabylonMesh;\n\n    this._loadBones(context, skin, babylonSkeleton);\n\n    assignSkeleton(babylonSkeleton);\n\n    var promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then(function (inverseBindMatricesData) {\n      _this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\n    });\n\n    skin._data = {\n      babylonSkeleton: babylonSkeleton,\n      promise: promise\n    };\n    return promise;\n  };\n\n  GLTFLoader.prototype._loadBones = function (context, skin, babylonSkeleton) {\n    var babylonBones = {};\n\n    for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {\n      var index = _a[_i];\n      var node = ArrayItem.Get(context + \"/joints/\" + index, this._gltf.nodes, index);\n\n      this._loadBone(node, skin, babylonSkeleton, babylonBones);\n    }\n  };\n\n  GLTFLoader.prototype._loadBone = function (node, skin, babylonSkeleton, babylonBones) {\n    var babylonBone = babylonBones[node.index];\n\n    if (babylonBone) {\n      return babylonBone;\n    }\n\n    var babylonParentBone = null;\n\n    if (node.parent && node.parent._babylonTransformNode !== this._rootBabylonMesh) {\n      babylonParentBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\n    }\n\n    var boneIndex = skin.joints.indexOf(node.index);\n    babylonBone = new Bone(node.name || \"joint\" + node.index, babylonSkeleton, babylonParentBone, this._getNodeMatrix(node), null, null, boneIndex);\n    babylonBones[node.index] = babylonBone;\n    node._babylonBones = node._babylonBones || [];\n\n    node._babylonBones.push(babylonBone);\n\n    return babylonBone;\n  };\n\n  GLTFLoader.prototype._loadSkinInverseBindMatricesDataAsync = function (context, skin) {\n    if (skin.inverseBindMatrices == undefined) {\n      return Promise.resolve(null);\n    }\n\n    var accessor = ArrayItem.Get(context + \"/inverseBindMatrices\", this._gltf.accessors, skin.inverseBindMatrices);\n    return this._loadFloatAccessorAsync(\"/accessors/\" + accessor.index, accessor);\n  };\n\n  GLTFLoader.prototype._updateBoneMatrices = function (babylonSkeleton, inverseBindMatricesData) {\n    for (var _i = 0, _a = babylonSkeleton.bones; _i < _a.length; _i++) {\n      var babylonBone = _a[_i];\n      var baseMatrix = Matrix.Identity();\n      var boneIndex = babylonBone._index;\n\n      if (inverseBindMatricesData && boneIndex !== -1) {\n        Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\n        baseMatrix.invertToRef(baseMatrix);\n      }\n\n      var babylonParentBone = babylonBone.getParent();\n\n      if (babylonParentBone) {\n        baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\n      }\n\n      babylonBone.setBindPose(baseMatrix);\n      babylonBone.updateMatrix(baseMatrix, false, false);\n\n      babylonBone._updateDifferenceMatrix(undefined, false);\n    }\n  };\n\n  GLTFLoader.prototype._getNodeMatrix = function (node) {\n    return node.matrix ? Matrix.FromArray(node.matrix) : Matrix.Compose(node.scale ? Vector3.FromArray(node.scale) : Vector3.One(), node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(), node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());\n  };\n  /**\r\n   * Loads a glTF camera.\r\n   * @param context The context when loading the asset\r\n   * @param camera The glTF camera property\r\n   * @param assign A function called synchronously after parsing the glTF properties\r\n   * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadCameraAsync = function (context, camera, assign) {\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var promises = new Array();\n    this.logOpen(context + \" \" + (camera.name || \"\"));\n    this._babylonScene._blockEntityCollection = this._forAssetContainer;\n    var babylonCamera = new FreeCamera(camera.name || \"camera\" + camera.index, Vector3.Zero(), this._babylonScene, false);\n    this._babylonScene._blockEntityCollection = false;\n    babylonCamera.ignoreParentScaling = true;\n    babylonCamera.rotation = new Vector3(0, Math.PI, 0);\n\n    switch (camera.type) {\n      case \"perspective\"\n      /* PERSPECTIVE */\n      :\n        {\n          var perspective = camera.perspective;\n\n          if (!perspective) {\n            throw new Error(context + \": Camera perspective properties are missing\");\n          }\n\n          babylonCamera.fov = perspective.yfov;\n          babylonCamera.minZ = perspective.znear;\n          babylonCamera.maxZ = perspective.zfar || Number.MAX_VALUE;\n          break;\n        }\n\n      case \"orthographic\"\n      /* ORTHOGRAPHIC */\n      :\n        {\n          if (!camera.orthographic) {\n            throw new Error(context + \": Camera orthographic properties are missing\");\n          }\n\n          babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n          babylonCamera.orthoLeft = -camera.orthographic.xmag;\n          babylonCamera.orthoRight = camera.orthographic.xmag;\n          babylonCamera.orthoBottom = -camera.orthographic.ymag;\n          babylonCamera.orthoTop = camera.orthographic.ymag;\n          babylonCamera.minZ = camera.orthographic.znear;\n          babylonCamera.maxZ = camera.orthographic.zfar;\n          break;\n        }\n\n      default:\n        {\n          throw new Error(context + \": Invalid camera type (\" + camera.type + \")\");\n        }\n    }\n\n    GLTFLoader.AddPointerMetadata(babylonCamera, context);\n\n    this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\n\n    assign(babylonCamera);\n    this.logClose();\n    return Promise.all(promises).then(function () {\n      return babylonCamera;\n    });\n  };\n\n  GLTFLoader.prototype._loadAnimationsAsync = function () {\n    var animations = this._gltf.animations;\n\n    if (!animations) {\n      return Promise.resolve();\n    }\n\n    var promises = new Array();\n\n    for (var index = 0; index < animations.length; index++) {\n      var animation = animations[index];\n      promises.push(this.loadAnimationAsync(\"/animations/\" + animation.index, animation));\n    }\n\n    return Promise.all(promises).then(function () {});\n  };\n  /**\r\n   * Loads a glTF animation.\r\n   * @param context The context when loading the asset\r\n   * @param animation The glTF animation property\r\n   * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadAnimationAsync = function (context, animation) {\n    var promise = this._extensionsLoadAnimationAsync(context, animation);\n\n    if (promise) {\n      return promise;\n    }\n\n    this._babylonScene._blockEntityCollection = this._forAssetContainer;\n    var babylonAnimationGroup = new AnimationGroup(animation.name || \"animation\" + animation.index, this._babylonScene);\n    this._babylonScene._blockEntityCollection = false;\n    animation._babylonAnimationGroup = babylonAnimationGroup;\n    var promises = new Array();\n    ArrayItem.Assign(animation.channels);\n    ArrayItem.Assign(animation.samplers);\n\n    for (var _i = 0, _a = animation.channels; _i < _a.length; _i++) {\n      var channel = _a[_i];\n      promises.push(this._loadAnimationChannelAsync(context + \"/channels/\" + channel.index, context, animation, channel, babylonAnimationGroup));\n    }\n\n    return Promise.all(promises).then(function () {\n      babylonAnimationGroup.normalize(0);\n      return babylonAnimationGroup;\n    });\n  };\n  /**\r\n   * @hidden Loads a glTF animation channel.\r\n   * @param context The context when loading the asset\r\n   * @param animationContext The context of the animation when loading the asset\r\n   * @param animation The glTF animation property\r\n   * @param channel The glTF animation channel property\r\n   * @param babylonAnimationGroup The babylon animation group property\r\n   * @param animationTargetOverride The babylon animation channel target override property. My be null.\r\n   * @returns A void promise when the channel load is complete\r\n   */\n\n\n  GLTFLoader.prototype._loadAnimationChannelAsync = function (context, animationContext, animation, channel, babylonAnimationGroup, animationTargetOverride) {\n    var _this = this;\n\n    if (animationTargetOverride === void 0) {\n      animationTargetOverride = null;\n    }\n\n    if (channel.target.node == undefined) {\n      return Promise.resolve();\n    }\n\n    var targetNode = ArrayItem.Get(context + \"/target/node\", this._gltf.nodes, channel.target.node); // Ignore animations that have no animation targets.\n\n    if (channel.target.path === \"weights\"\n    /* WEIGHTS */\n    && !targetNode._numMorphTargets || channel.target.path !== \"weights\"\n    /* WEIGHTS */\n    && !targetNode._babylonTransformNode) {\n      return Promise.resolve();\n    }\n\n    var sampler = ArrayItem.Get(context + \"/sampler\", animation.samplers, channel.sampler);\n    return this._loadAnimationSamplerAsync(animationContext + \"/samplers/\" + channel.sampler, sampler).then(function (data) {\n      var targetPath;\n      var animationType;\n\n      switch (channel.target.path) {\n        case \"translation\"\n        /* TRANSLATION */\n        :\n          {\n            targetPath = \"position\";\n            animationType = Animation.ANIMATIONTYPE_VECTOR3;\n            break;\n          }\n\n        case \"rotation\"\n        /* ROTATION */\n        :\n          {\n            targetPath = \"rotationQuaternion\";\n            animationType = Animation.ANIMATIONTYPE_QUATERNION;\n            break;\n          }\n\n        case \"scale\"\n        /* SCALE */\n        :\n          {\n            targetPath = \"scaling\";\n            animationType = Animation.ANIMATIONTYPE_VECTOR3;\n            break;\n          }\n\n        case \"weights\"\n        /* WEIGHTS */\n        :\n          {\n            targetPath = \"influence\";\n            animationType = Animation.ANIMATIONTYPE_FLOAT;\n            break;\n          }\n\n        default:\n          {\n            throw new Error(context + \"/target/path: Invalid value (\" + channel.target.path + \")\");\n          }\n      }\n\n      var outputBufferOffset = 0;\n      var getNextOutputValue;\n\n      switch (targetPath) {\n        case \"position\":\n          {\n            getNextOutputValue = function getNextOutputValue() {\n              var value = Vector3.FromArray(data.output, outputBufferOffset);\n              outputBufferOffset += 3;\n              return value;\n            };\n\n            break;\n          }\n\n        case \"rotationQuaternion\":\n          {\n            getNextOutputValue = function getNextOutputValue() {\n              var value = Quaternion.FromArray(data.output, outputBufferOffset);\n              outputBufferOffset += 4;\n              return value;\n            };\n\n            break;\n          }\n\n        case \"scaling\":\n          {\n            getNextOutputValue = function getNextOutputValue() {\n              var value = Vector3.FromArray(data.output, outputBufferOffset);\n              outputBufferOffset += 3;\n              return value;\n            };\n\n            break;\n          }\n\n        case \"influence\":\n          {\n            getNextOutputValue = function getNextOutputValue() {\n              var value = new Array(targetNode._numMorphTargets);\n\n              for (var i = 0; i < targetNode._numMorphTargets; i++) {\n                value[i] = data.output[outputBufferOffset++];\n              }\n\n              return value;\n            };\n\n            break;\n          }\n      }\n\n      var getNextKey;\n\n      switch (data.interpolation) {\n        case \"STEP\"\n        /* STEP */\n        :\n          {\n            getNextKey = function getNextKey(frameIndex) {\n              return {\n                frame: data.input[frameIndex],\n                value: getNextOutputValue(),\n                interpolation: AnimationKeyInterpolation.STEP\n              };\n            };\n\n            break;\n          }\n\n        case \"LINEAR\"\n        /* LINEAR */\n        :\n          {\n            getNextKey = function getNextKey(frameIndex) {\n              return {\n                frame: data.input[frameIndex],\n                value: getNextOutputValue()\n              };\n            };\n\n            break;\n          }\n\n        case \"CUBICSPLINE\"\n        /* CUBICSPLINE */\n        :\n          {\n            getNextKey = function getNextKey(frameIndex) {\n              return {\n                frame: data.input[frameIndex],\n                inTangent: getNextOutputValue(),\n                value: getNextOutputValue(),\n                outTangent: getNextOutputValue()\n              };\n            };\n\n            break;\n          }\n      }\n\n      var keys = new Array(data.input.length);\n\n      for (var frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\n        keys[frameIndex] = getNextKey(frameIndex);\n      }\n\n      if (targetPath === \"influence\") {\n        var _loop_2 = function _loop_2(targetIndex) {\n          var animationName = babylonAnimationGroup.name + \"_channel\" + babylonAnimationGroup.targetedAnimations.length;\n          var babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\n          babylonAnimation.setKeys(keys.map(function (key) {\n            return {\n              frame: key.frame,\n              inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\n              value: key.value[targetIndex],\n              outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined\n            };\n          }));\n\n          _this._forEachPrimitive(targetNode, function (babylonAbstractMesh) {\n            var babylonMesh = babylonAbstractMesh;\n            var morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\n            var babylonAnimationClone = babylonAnimation.clone();\n            morphTarget.animations.push(babylonAnimationClone);\n            babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);\n          });\n        };\n\n        for (var targetIndex = 0; targetIndex < targetNode._numMorphTargets; targetIndex++) {\n          _loop_2(targetIndex);\n        }\n      } else {\n        var animationName = babylonAnimationGroup.name + \"_channel\" + babylonAnimationGroup.targetedAnimations.length;\n        var babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\n        babylonAnimation.setKeys(keys);\n\n        if (animationTargetOverride != null && animationTargetOverride.animations != null) {\n          animationTargetOverride.animations.push(babylonAnimation);\n          babylonAnimationGroup.addTargetedAnimation(babylonAnimation, animationTargetOverride);\n        } else {\n          targetNode._babylonTransformNode.animations.push(babylonAnimation);\n\n          babylonAnimationGroup.addTargetedAnimation(babylonAnimation, targetNode._babylonTransformNode);\n        }\n      }\n    });\n  };\n\n  GLTFLoader.prototype._loadAnimationSamplerAsync = function (context, sampler) {\n    if (sampler._data) {\n      return sampler._data;\n    }\n\n    var interpolation = sampler.interpolation || \"LINEAR\"\n    /* LINEAR */\n    ;\n\n    switch (interpolation) {\n      case \"STEP\"\n      /* STEP */\n      :\n      case \"LINEAR\"\n      /* LINEAR */\n      :\n      case \"CUBICSPLINE\"\n      /* CUBICSPLINE */\n      :\n        {\n          break;\n        }\n\n      default:\n        {\n          throw new Error(context + \"/interpolation: Invalid value (\" + sampler.interpolation + \")\");\n        }\n    }\n\n    var inputAccessor = ArrayItem.Get(context + \"/input\", this._gltf.accessors, sampler.input);\n    var outputAccessor = ArrayItem.Get(context + \"/output\", this._gltf.accessors, sampler.output);\n    sampler._data = Promise.all([this._loadFloatAccessorAsync(\"/accessors/\" + inputAccessor.index, inputAccessor), this._loadFloatAccessorAsync(\"/accessors/\" + outputAccessor.index, outputAccessor)]).then(function (_a) {\n      var inputData = _a[0],\n          outputData = _a[1];\n      return {\n        input: inputData,\n        interpolation: interpolation,\n        output: outputData\n      };\n    });\n    return sampler._data;\n  };\n\n  GLTFLoader.prototype._loadBufferAsync = function (context, buffer, byteOffset, byteLength) {\n    var extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (!buffer._data) {\n      if (buffer.uri) {\n        buffer._data = this.loadUriAsync(context + \"/uri\", buffer, buffer.uri);\n      } else {\n        if (!this._bin) {\n          throw new Error(context + \": Uri is missing or the binary glTF is missing its binary chunk\");\n        }\n\n        buffer._data = this._bin.readAsync(0, buffer.byteLength);\n      }\n    }\n\n    return buffer._data.then(function (data) {\n      try {\n        return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\n      } catch (e) {\n        throw new Error(context + \": \" + e.message);\n      }\n    });\n  };\n  /**\r\n   * Loads a glTF buffer view.\r\n   * @param context The context when loading the asset\r\n   * @param bufferView The glTF buffer view property\r\n   * @returns A promise that resolves with the loaded data when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadBufferViewAsync = function (context, bufferView) {\n    var extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (bufferView._data) {\n      return bufferView._data;\n    }\n\n    var buffer = ArrayItem.Get(context + \"/buffer\", this._gltf.buffers, bufferView.buffer);\n    bufferView._data = this._loadBufferAsync(\"/buffers/\" + buffer.index, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\n    return bufferView._data;\n  };\n\n  GLTFLoader.prototype._loadAccessorAsync = function (context, accessor, constructor) {\n    var _this = this;\n\n    if (accessor._data) {\n      return accessor._data;\n    }\n\n    var numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\n\n    var byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\n    var length = numComponents * accessor.count;\n\n    if (accessor.bufferView == undefined) {\n      accessor._data = Promise.resolve(new constructor(length));\n    } else {\n      var bufferView_1 = ArrayItem.Get(context + \"/bufferView\", this._gltf.bufferViews, accessor.bufferView);\n      accessor._data = this.loadBufferViewAsync(\"/bufferViews/\" + bufferView_1.index, bufferView_1).then(function (data) {\n        if (accessor.componentType === 5126\n        /* FLOAT */\n        && !accessor.normalized && (!bufferView_1.byteStride || bufferView_1.byteStride === byteStride)) {\n          return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\n        } else {\n          var typedArray_1 = new constructor(length);\n          VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView_1.byteStride || byteStride, numComponents, accessor.componentType, typedArray_1.length, accessor.normalized || false, function (value, index) {\n            typedArray_1[index] = value;\n          });\n          return typedArray_1;\n        }\n      });\n    }\n\n    if (accessor.sparse) {\n      var sparse_1 = accessor.sparse;\n      accessor._data = accessor._data.then(function (data) {\n        var typedArray = data;\n        var indicesBufferView = ArrayItem.Get(context + \"/sparse/indices/bufferView\", _this._gltf.bufferViews, sparse_1.indices.bufferView);\n        var valuesBufferView = ArrayItem.Get(context + \"/sparse/values/bufferView\", _this._gltf.bufferViews, sparse_1.values.bufferView);\n        return Promise.all([_this.loadBufferViewAsync(\"/bufferViews/\" + indicesBufferView.index, indicesBufferView), _this.loadBufferViewAsync(\"/bufferViews/\" + valuesBufferView.index, valuesBufferView)]).then(function (_a) {\n          var indicesData = _a[0],\n              valuesData = _a[1];\n\n          var indices = GLTFLoader._GetTypedArray(context + \"/sparse/indices\", sparse_1.indices.componentType, indicesData, sparse_1.indices.byteOffset, sparse_1.count);\n\n          var sparseLength = numComponents * sparse_1.count;\n          var values;\n\n          if (accessor.componentType === 5126\n          /* FLOAT */\n          && !accessor.normalized) {\n            values = GLTFLoader._GetTypedArray(context + \"/sparse/values\", accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);\n          } else {\n            var sparseData = GLTFLoader._GetTypedArray(context + \"/sparse/values\", accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);\n\n            values = new constructor(sparseLength);\n            VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, function (value, index) {\n              values[index] = value;\n            });\n          }\n\n          var valuesIndex = 0;\n\n          for (var indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\n            var dataIndex = indices[indicesIndex] * numComponents;\n\n            for (var componentIndex = 0; componentIndex < numComponents; componentIndex++) {\n              typedArray[dataIndex++] = values[valuesIndex++];\n            }\n          }\n\n          return typedArray;\n        });\n      });\n    }\n\n    return accessor._data;\n  };\n  /** @hidden */\n\n\n  GLTFLoader.prototype._loadFloatAccessorAsync = function (context, accessor) {\n    return this._loadAccessorAsync(context, accessor, Float32Array);\n  };\n\n  GLTFLoader.prototype._loadIndicesAccessorAsync = function (context, accessor) {\n    if (accessor.type !== \"SCALAR\"\n    /* SCALAR */\n    ) {\n      throw new Error(context + \"/type: Invalid value \" + accessor.type);\n    }\n\n    if (accessor.componentType !== 5121\n    /* UNSIGNED_BYTE */\n    && accessor.componentType !== 5123\n    /* UNSIGNED_SHORT */\n    && accessor.componentType !== 5125\n    /* UNSIGNED_INT */\n    ) {\n      throw new Error(context + \"/componentType: Invalid value \" + accessor.componentType);\n    }\n\n    if (accessor._data) {\n      return accessor._data;\n    }\n\n    if (accessor.sparse) {\n      var constructor = GLTFLoader._GetTypedArrayConstructor(context + \"/componentType\", accessor.componentType);\n\n      accessor._data = this._loadAccessorAsync(context, accessor, constructor);\n    } else {\n      var bufferView = ArrayItem.Get(context + \"/bufferView\", this._gltf.bufferViews, accessor.bufferView);\n      accessor._data = this.loadBufferViewAsync(\"/bufferViews/\" + bufferView.index, bufferView).then(function (data) {\n        return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\n      });\n    }\n\n    return accessor._data;\n  };\n\n  GLTFLoader.prototype._loadVertexBufferViewAsync = function (bufferView, kind) {\n    var _this = this;\n\n    if (bufferView._babylonBuffer) {\n      return bufferView._babylonBuffer;\n    }\n\n    bufferView._babylonBuffer = this.loadBufferViewAsync(\"/bufferViews/\" + bufferView.index, bufferView).then(function (data) {\n      return new Buffer(_this._babylonScene.getEngine(), data, false);\n    });\n    return bufferView._babylonBuffer;\n  };\n\n  GLTFLoader.prototype._loadVertexAccessorAsync = function (context, accessor, kind) {\n    var _this = this;\n\n    if (accessor._babylonVertexBuffer) {\n      return accessor._babylonVertexBuffer;\n    }\n\n    if (accessor.sparse) {\n      accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(\"/accessors/\" + accessor.index, accessor).then(function (data) {\n        return new VertexBuffer(_this._babylonScene.getEngine(), data, kind, false);\n      });\n    } // HACK: If byte offset is not a multiple of component type byte length then load as a float array instead of using Babylon buffers.\n    else if (accessor.byteOffset && accessor.byteOffset % VertexBuffer.GetTypeByteLength(accessor.componentType) !== 0) {\n      Logger.Warn(\"Accessor byte offset is not a multiple of component type byte length\");\n      accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(\"/accessors/\" + accessor.index, accessor).then(function (data) {\n        return new VertexBuffer(_this._babylonScene.getEngine(), data, kind, false);\n      });\n    } // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\n    // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\n    else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\n      accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(\"/accessors/\" + accessor.index, accessor).then(function (data) {\n        return new VertexBuffer(_this._babylonScene.getEngine(), data, kind, false);\n      });\n    } else {\n      var bufferView_2 = ArrayItem.Get(context + \"/bufferView\", this._gltf.bufferViews, accessor.bufferView);\n      accessor._babylonVertexBuffer = this._loadVertexBufferViewAsync(bufferView_2, kind).then(function (babylonBuffer) {\n        var size = GLTFLoader._GetNumComponents(context, accessor.type);\n\n        return new VertexBuffer(_this._babylonScene.getEngine(), babylonBuffer, kind, false, false, bufferView_2.byteStride, false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true, 1, true);\n      });\n    }\n\n    return accessor._babylonVertexBuffer;\n  };\n\n  GLTFLoader.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function (context, properties, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(context + \": Material type not supported\");\n    }\n\n    var promises = new Array();\n\n    if (properties) {\n      if (properties.baseColorFactor) {\n        babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\n        babylonMaterial.alpha = properties.baseColorFactor[3];\n      } else {\n        babylonMaterial.albedoColor = Color3.White();\n      }\n\n      babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\n      babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\n\n      if (properties.baseColorTexture) {\n        promises.push(this.loadTextureInfoAsync(context + \"/baseColorTexture\", properties.baseColorTexture, function (texture) {\n          texture.name = babylonMaterial.name + \" (Base Color)\";\n          babylonMaterial.albedoTexture = texture;\n        }));\n      }\n\n      if (properties.metallicRoughnessTexture) {\n        properties.metallicRoughnessTexture.nonColorData = true;\n        promises.push(this.loadTextureInfoAsync(context + \"/metallicRoughnessTexture\", properties.metallicRoughnessTexture, function (texture) {\n          texture.name = babylonMaterial.name + \" (Metallic Roughness)\";\n          babylonMaterial.metallicTexture = texture;\n        }));\n        babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\n        babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\n        babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\n      }\n    }\n\n    return Promise.all(promises).then(function () {});\n  };\n  /** @hidden */\n\n\n  GLTFLoader.prototype._loadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    material._data = material._data || {};\n    var babylonData = material._data[babylonDrawMode];\n\n    if (!babylonData) {\n      this.logOpen(context + \" \" + (material.name || \"\"));\n      var babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\n      babylonData = {\n        babylonMaterial: babylonMaterial,\n        babylonMeshes: [],\n        promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)\n      };\n      material._data[babylonDrawMode] = babylonData;\n      GLTFLoader.AddPointerMetadata(babylonMaterial, context);\n\n      this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n\n      this.logClose();\n    }\n\n    if (babylonMesh) {\n      babylonData.babylonMeshes.push(babylonMesh);\n      babylonMesh.onDisposeObservable.addOnce(function () {\n        var index = babylonData.babylonMeshes.indexOf(babylonMesh);\n\n        if (index !== -1) {\n          babylonData.babylonMeshes.splice(index, 1);\n        }\n      });\n    }\n\n    assign(babylonData.babylonMaterial);\n    return babylonData.promise.then(function () {\n      return babylonData.babylonMaterial;\n    });\n  };\n\n  GLTFLoader.prototype._createDefaultMaterial = function (name, babylonDrawMode) {\n    this._babylonScene._blockEntityCollection = this._forAssetContainer;\n    var babylonMaterial = new PBRMaterial(name, this._babylonScene);\n    this._babylonScene._blockEntityCollection = false; // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n\n    babylonMaterial.fillMode = babylonDrawMode;\n    babylonMaterial.enableSpecularAntiAliasing = true;\n    babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\n    babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\n    babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n    babylonMaterial.metallic = 1;\n    babylonMaterial.roughness = 1;\n    return babylonMaterial;\n  };\n  /**\r\n   * Creates a Babylon material from a glTF material.\r\n   * @param context The context when loading the asset\r\n   * @param material The glTF material property\r\n   * @param babylonDrawMode The draw mode for the Babylon material\r\n   * @returns The Babylon material\r\n   */\n\n\n  GLTFLoader.prototype.createMaterial = function (context, material, babylonDrawMode) {\n    var extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var name = material.name || \"material\" + material.index;\n\n    var babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\n\n    return babylonMaterial;\n  };\n  /**\r\n   * Loads properties from a glTF material into a Babylon material.\r\n   * @param context The context when loading the asset\r\n   * @param material The glTF material property\r\n   * @param babylonMaterial The Babylon material\r\n   * @returns A promise that resolves when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    var extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    var promises = new Array();\n    promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n\n    if (material.pbrMetallicRoughness) {\n      promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(context + \"/pbrMetallicRoughness\", material.pbrMetallicRoughness, babylonMaterial));\n    }\n\n    this.loadMaterialAlphaProperties(context, material, babylonMaterial);\n    return Promise.all(promises).then(function () {});\n  };\n  /**\r\n   * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n   * @param context The context when loading the asset\r\n   * @param material The glTF material property\r\n   * @param babylonMaterial The Babylon material\r\n   * @returns A promise that resolves when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadMaterialBasePropertiesAsync = function (context, material, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(context + \": Material type not supported\");\n    }\n\n    var promises = new Array();\n    babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\n\n    if (material.doubleSided) {\n      babylonMaterial.backFaceCulling = false;\n      babylonMaterial.twoSidedLighting = true;\n    }\n\n    if (material.normalTexture) {\n      material.normalTexture.nonColorData = true;\n      promises.push(this.loadTextureInfoAsync(context + \"/normalTexture\", material.normalTexture, function (texture) {\n        texture.name = babylonMaterial.name + \" (Normal)\";\n        babylonMaterial.bumpTexture = texture;\n      }));\n      babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\n      babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\n\n      if (material.normalTexture.scale != undefined) {\n        babylonMaterial.bumpTexture.level = material.normalTexture.scale;\n      }\n\n      babylonMaterial.forceIrradianceInFragment = true;\n    }\n\n    if (material.occlusionTexture) {\n      material.occlusionTexture.nonColorData = true;\n      promises.push(this.loadTextureInfoAsync(context + \"/occlusionTexture\", material.occlusionTexture, function (texture) {\n        texture.name = babylonMaterial.name + \" (Occlusion)\";\n        babylonMaterial.ambientTexture = texture;\n      }));\n      babylonMaterial.useAmbientInGrayScale = true;\n\n      if (material.occlusionTexture.strength != undefined) {\n        babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\n      }\n    }\n\n    if (material.emissiveTexture) {\n      promises.push(this.loadTextureInfoAsync(context + \"/emissiveTexture\", material.emissiveTexture, function (texture) {\n        texture.name = babylonMaterial.name + \" (Emissive)\";\n        babylonMaterial.emissiveTexture = texture;\n      }));\n    }\n\n    return Promise.all(promises).then(function () {});\n  };\n  /**\r\n   * Loads the alpha properties from a glTF material into a Babylon material.\r\n   * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n   * @param context The context when loading the asset\r\n   * @param material The glTF material property\r\n   * @param babylonMaterial The Babylon material\r\n   */\n\n\n  GLTFLoader.prototype.loadMaterialAlphaProperties = function (context, material, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(context + \": Material type not supported\");\n    }\n\n    var alphaMode = material.alphaMode || \"OPAQUE\"\n    /* OPAQUE */\n    ;\n\n    switch (alphaMode) {\n      case \"OPAQUE\"\n      /* OPAQUE */\n      :\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n          break;\n        }\n\n      case \"MASK\"\n      /* MASK */\n      :\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\n          babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\n\n          if (babylonMaterial.albedoTexture) {\n            babylonMaterial.albedoTexture.hasAlpha = true;\n          }\n\n          break;\n        }\n\n      case \"BLEND\"\n      /* BLEND */\n      :\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\n\n          if (babylonMaterial.albedoTexture) {\n            babylonMaterial.albedoTexture.hasAlpha = true;\n            babylonMaterial.useAlphaFromAlbedoTexture = true;\n          }\n\n          break;\n        }\n\n      default:\n        {\n          throw new Error(context + \"/alphaMode: Invalid value (\" + material.alphaMode + \")\");\n        }\n    }\n  };\n  /**\r\n   * Loads a glTF texture info.\r\n   * @param context The context when loading the asset\r\n   * @param textureInfo The glTF texture info property\r\n   * @param assign A function called synchronously after parsing the glTF properties\r\n   * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadTextureInfoAsync = function (context, textureInfo, assign) {\n    var _this = this;\n\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    this.logOpen(\"\" + context);\n\n    if (textureInfo.texCoord >= 2) {\n      throw new Error(context + \"/texCoord: Invalid value (\" + textureInfo.texCoord + \")\");\n    }\n\n    var texture = ArrayItem.Get(context + \"/index\", this._gltf.textures, textureInfo.index);\n    texture._textureInfo = textureInfo;\n\n    var promise = this._loadTextureAsync(\"/textures/\" + textureInfo.index, texture, function (babylonTexture) {\n      babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\n      GLTFLoader.AddPointerMetadata(babylonTexture, context);\n\n      _this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\n\n      assign(babylonTexture);\n    });\n\n    this.logClose();\n    return promise;\n  };\n  /** @hidden */\n\n\n  GLTFLoader.prototype._loadTextureAsync = function (context, texture, assign) {\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    this.logOpen(context + \" \" + (texture.name || \"\"));\n    var sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(context + \"/sampler\", this._gltf.samplers, texture.sampler);\n    var image = ArrayItem.Get(context + \"/source\", this._gltf.images, texture.source);\n\n    var promise = this._createTextureAsync(context, sampler, image, assign);\n\n    this.logClose();\n    return promise;\n  };\n  /** @hidden */\n\n\n  GLTFLoader.prototype._createTextureAsync = function (context, sampler, image, assign, textureLoaderOptions) {\n    var _this = this;\n\n    if (assign === void 0) {\n      assign = function assign() {};\n    }\n\n    var samplerData = this._loadSampler(\"/samplers/\" + sampler.index, sampler);\n\n    var promises = new Array();\n    var deferred = new Deferred();\n    this._babylonScene._blockEntityCollection = this._forAssetContainer;\n    var babylonTexture = new Texture(null, this._babylonScene, samplerData.noMipMaps, false, samplerData.samplingMode, function () {\n      if (!_this._disposed) {\n        deferred.resolve();\n      }\n    }, function (message, exception) {\n      if (!_this._disposed) {\n        deferred.reject(new Error(context + \": \" + (exception && exception.message ? exception.message : message || \"Failed to load texture\")));\n      }\n    }, undefined, undefined, undefined, image.mimeType, textureLoaderOptions);\n    this._babylonScene._blockEntityCollection = false;\n    promises.push(deferred.promise);\n    promises.push(this.loadImageAsync(\"/images/\" + image.index, image).then(function (data) {\n      var name = image.uri || _this._fileName + \"#image\" + image.index;\n      var dataUrl = \"data:\" + _this._uniqueRootUrl + name;\n      babylonTexture.updateURL(dataUrl, data);\n    }));\n    babylonTexture.wrapU = samplerData.wrapU;\n    babylonTexture.wrapV = samplerData.wrapV;\n    assign(babylonTexture);\n    return Promise.all(promises).then(function () {\n      return babylonTexture;\n    });\n  };\n\n  GLTFLoader.prototype._loadSampler = function (context, sampler) {\n    if (!sampler._data) {\n      sampler._data = {\n        noMipMaps: sampler.minFilter === 9728\n        /* NEAREST */\n        || sampler.minFilter === 9729\n        /* LINEAR */\n        ,\n        samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\n        wrapU: GLTFLoader._GetTextureWrapMode(context + \"/wrapS\", sampler.wrapS),\n        wrapV: GLTFLoader._GetTextureWrapMode(context + \"/wrapT\", sampler.wrapT)\n      };\n    }\n\n    return sampler._data;\n  };\n  /**\r\n   * Loads a glTF image.\r\n   * @param context The context when loading the asset\r\n   * @param image The glTF image property\r\n   * @returns A promise that resolves with the loaded data when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadImageAsync = function (context, image) {\n    if (!image._data) {\n      this.logOpen(context + \" \" + (image.name || \"\"));\n\n      if (image.uri) {\n        image._data = this.loadUriAsync(context + \"/uri\", image, image.uri);\n      } else {\n        var bufferView = ArrayItem.Get(context + \"/bufferView\", this._gltf.bufferViews, image.bufferView);\n        image._data = this.loadBufferViewAsync(\"/bufferViews/\" + bufferView.index, bufferView);\n      }\n\n      this.logClose();\n    }\n\n    return image._data;\n  };\n  /**\r\n   * Loads a glTF uri.\r\n   * @param context The context when loading the asset\r\n   * @param property The glTF property associated with the uri\r\n   * @param uri The base64 or relative uri\r\n   * @returns A promise that resolves with the loaded data when the load is complete\r\n   */\n\n\n  GLTFLoader.prototype.loadUriAsync = function (context, property, uri) {\n    var _this = this;\n\n    var extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\n\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n\n    if (!GLTFLoader._ValidateUri(uri)) {\n      throw new Error(context + \": '\" + uri + \"' is invalid\");\n    }\n\n    if (Tools.IsBase64(uri)) {\n      var data = new Uint8Array(Tools.DecodeBase64(uri));\n      this.log(\"Decoded \" + uri.substr(0, 64) + \"... (\" + data.length + \" bytes)\");\n      return Promise.resolve(data);\n    }\n\n    this.log(\"Loading \" + uri);\n    return this._parent.preprocessUrlAsync(this._rootUrl + uri).then(function (url) {\n      return new Promise(function (resolve, reject) {\n        _this._parent._loadFile(url, _this._babylonScene, function (data) {\n          if (!_this._disposed) {\n            _this.log(\"Loaded \" + uri + \" (\" + data.byteLength + \" bytes)\");\n\n            resolve(new Uint8Array(data));\n          }\n        }, true, function (request) {\n          reject(new LoadFileError(context + \": Failed to load '\" + uri + \"'\" + (request ? \": \" + request.status + \" \" + request.statusText : \"\"), request));\n        });\n      });\n    });\n  };\n  /**\r\n   * Adds a JSON pointer to the metadata of the Babylon object at `<object>.metadata.gltf.pointers`.\r\n   * @param babylonObject the Babylon object with metadata\r\n   * @param pointer the JSON pointer\r\n   */\n\n\n  GLTFLoader.AddPointerMetadata = function (babylonObject, pointer) {\n    var metadata = babylonObject.metadata = babylonObject.metadata || {};\n    var gltf = metadata.gltf = metadata.gltf || {};\n    var pointers = gltf.pointers = gltf.pointers || [];\n    pointers.push(pointer);\n  };\n\n  GLTFLoader._GetTextureWrapMode = function (context, mode) {\n    // Set defaults if undefined\n    mode = mode == undefined ? 10497\n    /* REPEAT */\n    : mode;\n\n    switch (mode) {\n      case 33071\n      /* CLAMP_TO_EDGE */\n      :\n        return Texture.CLAMP_ADDRESSMODE;\n\n      case 33648\n      /* MIRRORED_REPEAT */\n      :\n        return Texture.MIRROR_ADDRESSMODE;\n\n      case 10497\n      /* REPEAT */\n      :\n        return Texture.WRAP_ADDRESSMODE;\n\n      default:\n        Logger.Warn(context + \": Invalid value (\" + mode + \")\");\n        return Texture.WRAP_ADDRESSMODE;\n    }\n  };\n\n  GLTFLoader._GetTextureSamplingMode = function (context, sampler) {\n    // Set defaults if undefined\n    var magFilter = sampler.magFilter == undefined ? 9729\n    /* LINEAR */\n    : sampler.magFilter;\n    var minFilter = sampler.minFilter == undefined ? 9987\n    /* LINEAR_MIPMAP_LINEAR */\n    : sampler.minFilter;\n\n    if (magFilter === 9729\n    /* LINEAR */\n    ) {\n      switch (minFilter) {\n        case 9728\n        /* NEAREST */\n        :\n          return Texture.LINEAR_NEAREST;\n\n        case 9729\n        /* LINEAR */\n        :\n          return Texture.LINEAR_LINEAR;\n\n        case 9984\n        /* NEAREST_MIPMAP_NEAREST */\n        :\n          return Texture.LINEAR_NEAREST_MIPNEAREST;\n\n        case 9985\n        /* LINEAR_MIPMAP_NEAREST */\n        :\n          return Texture.LINEAR_LINEAR_MIPNEAREST;\n\n        case 9986\n        /* NEAREST_MIPMAP_LINEAR */\n        :\n          return Texture.LINEAR_NEAREST_MIPLINEAR;\n\n        case 9987\n        /* LINEAR_MIPMAP_LINEAR */\n        :\n          return Texture.LINEAR_LINEAR_MIPLINEAR;\n\n        default:\n          Logger.Warn(context + \"/minFilter: Invalid value (\" + minFilter + \")\");\n          return Texture.LINEAR_LINEAR_MIPLINEAR;\n      }\n    } else {\n      if (magFilter !== 9728\n      /* NEAREST */\n      ) {\n        Logger.Warn(context + \"/magFilter: Invalid value (\" + magFilter + \")\");\n      }\n\n      switch (minFilter) {\n        case 9728\n        /* NEAREST */\n        :\n          return Texture.NEAREST_NEAREST;\n\n        case 9729\n        /* LINEAR */\n        :\n          return Texture.NEAREST_LINEAR;\n\n        case 9984\n        /* NEAREST_MIPMAP_NEAREST */\n        :\n          return Texture.NEAREST_NEAREST_MIPNEAREST;\n\n        case 9985\n        /* LINEAR_MIPMAP_NEAREST */\n        :\n          return Texture.NEAREST_LINEAR_MIPNEAREST;\n\n        case 9986\n        /* NEAREST_MIPMAP_LINEAR */\n        :\n          return Texture.NEAREST_NEAREST_MIPLINEAR;\n\n        case 9987\n        /* LINEAR_MIPMAP_LINEAR */\n        :\n          return Texture.NEAREST_LINEAR_MIPLINEAR;\n\n        default:\n          Logger.Warn(context + \"/minFilter: Invalid value (\" + minFilter + \")\");\n          return Texture.NEAREST_NEAREST_MIPNEAREST;\n      }\n    }\n  };\n\n  GLTFLoader._GetTypedArrayConstructor = function (context, componentType) {\n    switch (componentType) {\n      case 5120\n      /* BYTE */\n      :\n        return Int8Array;\n\n      case 5121\n      /* UNSIGNED_BYTE */\n      :\n        return Uint8Array;\n\n      case 5122\n      /* SHORT */\n      :\n        return Int16Array;\n\n      case 5123\n      /* UNSIGNED_SHORT */\n      :\n        return Uint16Array;\n\n      case 5125\n      /* UNSIGNED_INT */\n      :\n        return Uint32Array;\n\n      case 5126\n      /* FLOAT */\n      :\n        return Float32Array;\n\n      default:\n        throw new Error(context + \": Invalid component type \" + componentType);\n    }\n  };\n\n  GLTFLoader._GetTypedArray = function (context, componentType, bufferView, byteOffset, length) {\n    var buffer = bufferView.buffer;\n    byteOffset = bufferView.byteOffset + (byteOffset || 0);\n\n    var constructor = GLTFLoader._GetTypedArrayConstructor(context + \"/componentType\", componentType);\n\n    try {\n      return new constructor(buffer, byteOffset, length);\n    } catch (e) {\n      throw new Error(context + \": \" + e);\n    }\n  };\n\n  GLTFLoader._GetNumComponents = function (context, type) {\n    switch (type) {\n      case \"SCALAR\":\n        return 1;\n\n      case \"VEC2\":\n        return 2;\n\n      case \"VEC3\":\n        return 3;\n\n      case \"VEC4\":\n        return 4;\n\n      case \"MAT2\":\n        return 4;\n\n      case \"MAT3\":\n        return 9;\n\n      case \"MAT4\":\n        return 16;\n    }\n\n    throw new Error(context + \": Invalid type (\" + type + \")\");\n  };\n\n  GLTFLoader._ValidateUri = function (uri) {\n    return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\n  };\n  /** @hidden */\n\n\n  GLTFLoader._GetDrawMode = function (context, mode) {\n    if (mode == undefined) {\n      mode = 4\n      /* TRIANGLES */\n      ;\n    }\n\n    switch (mode) {\n      case 0\n      /* POINTS */\n      :\n        return Material.PointListDrawMode;\n\n      case 1\n      /* LINES */\n      :\n        return Material.LineListDrawMode;\n\n      case 2\n      /* LINE_LOOP */\n      :\n        return Material.LineLoopDrawMode;\n\n      case 3\n      /* LINE_STRIP */\n      :\n        return Material.LineStripDrawMode;\n\n      case 4\n      /* TRIANGLES */\n      :\n        return Material.TriangleFillMode;\n\n      case 5\n      /* TRIANGLE_STRIP */\n      :\n        return Material.TriangleStripDrawMode;\n\n      case 6\n      /* TRIANGLE_FAN */\n      :\n        return Material.TriangleFanDrawMode;\n    }\n\n    throw new Error(context + \": Invalid mesh primitive mode (\" + mode + \")\");\n  };\n\n  GLTFLoader.prototype._compileMaterialsAsync = function () {\n    var _this = this;\n\n    this._parent._startPerformanceCounter(\"Compile materials\");\n\n    var promises = new Array();\n\n    if (this._gltf.materials) {\n      for (var _i = 0, _a = this._gltf.materials; _i < _a.length; _i++) {\n        var material = _a[_i];\n\n        if (material._data) {\n          for (var babylonDrawMode in material._data) {\n            var babylonData = material._data[babylonDrawMode];\n\n            for (var _b = 0, _c = babylonData.babylonMeshes; _b < _c.length; _b++) {\n              var babylonMesh = _c[_b]; // Ensure nonUniformScaling is set if necessary.\n\n              babylonMesh.computeWorldMatrix(true);\n              var babylonMaterial = babylonData.babylonMaterial;\n              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\n              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                useInstances: true\n              }));\n\n              if (this._parent.useClipPlane) {\n                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                  clipPlane: true\n                }));\n                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                  clipPlane: true,\n                  useInstances: true\n                }));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return Promise.all(promises).then(function () {\n      _this._parent._endPerformanceCounter(\"Compile materials\");\n    });\n  };\n\n  GLTFLoader.prototype._compileShadowGeneratorsAsync = function () {\n    var _this = this;\n\n    this._parent._startPerformanceCounter(\"Compile shadow generators\");\n\n    var promises = new Array();\n    var lights = this._babylonScene.lights;\n\n    for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {\n      var light = lights_1[_i];\n      var generator = light.getShadowGenerator();\n\n      if (generator) {\n        promises.push(generator.forceCompilationAsync());\n      }\n    }\n\n    return Promise.all(promises).then(function () {\n      _this._parent._endPerformanceCounter(\"Compile shadow generators\");\n    });\n  };\n\n  GLTFLoader.prototype._forEachExtensions = function (action) {\n    for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {\n      var extension = _a[_i];\n\n      if (extension.enabled) {\n        action(extension);\n      }\n    }\n  };\n\n  GLTFLoader.prototype._applyExtensions = function (property, functionName, actionAsync) {\n    for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {\n      var extension = _a[_i];\n\n      if (extension.enabled) {\n        var id = extension.name + \".\" + functionName;\n        var loaderProperty = property;\n        loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\n        var activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\n\n        if (!activeLoaderExtensionFunctions[id]) {\n          activeLoaderExtensionFunctions[id] = true;\n\n          try {\n            var result = actionAsync(extension);\n\n            if (result) {\n              return result;\n            }\n          } finally {\n            delete activeLoaderExtensionFunctions[id];\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  GLTFLoader.prototype._extensionsOnLoading = function () {\n    this._forEachExtensions(function (extension) {\n      return extension.onLoading && extension.onLoading();\n    });\n  };\n\n  GLTFLoader.prototype._extensionsOnReady = function () {\n    this._forEachExtensions(function (extension) {\n      return extension.onReady && extension.onReady();\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadSceneAsync = function (context, scene) {\n    return this._applyExtensions(scene, \"loadScene\", function (extension) {\n      return extension.loadSceneAsync && extension.loadSceneAsync(context, scene);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadNodeAsync = function (context, node, assign) {\n    return this._applyExtensions(node, \"loadNode\", function (extension) {\n      return extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadCameraAsync = function (context, camera, assign) {\n    return this._applyExtensions(camera, \"loadCamera\", function (extension) {\n      return extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadVertexDataAsync = function (context, primitive, babylonMesh) {\n    return this._applyExtensions(primitive, \"loadVertexData\", function (extension) {\n      return extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadMeshPrimitiveAsync = function (context, name, node, mesh, primitive, assign) {\n    return this._applyExtensions(primitive, \"loadMeshPrimitive\", function (extension) {\n      return extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadMaterialAsync = function (context, material, babylonMesh, babylonDrawMode, assign) {\n    return this._applyExtensions(material, \"loadMaterial\", function (extension) {\n      return extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsCreateMaterial = function (context, material, babylonDrawMode) {\n    return this._applyExtensions(material, \"createMaterial\", function (extension) {\n      return extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    return this._applyExtensions(material, \"loadMaterialProperties\", function (extension) {\n      return extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadTextureInfoAsync = function (context, textureInfo, assign) {\n    return this._applyExtensions(textureInfo, \"loadTextureInfo\", function (extension) {\n      return extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadTextureAsync = function (context, texture, assign) {\n    return this._applyExtensions(texture, \"loadTexture\", function (extension) {\n      return extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadAnimationAsync = function (context, animation) {\n    return this._applyExtensions(animation, \"loadAnimation\", function (extension) {\n      return extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadSkinAsync = function (context, node, skin) {\n    return this._applyExtensions(skin, \"loadSkin\", function (extension) {\n      return extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadUriAsync = function (context, property, uri) {\n    return this._applyExtensions(property, \"loadUri\", function (extension) {\n      return extension._loadUriAsync && extension._loadUriAsync(context, property, uri);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadBufferViewAsync = function (context, bufferView) {\n    return this._applyExtensions(bufferView, \"loadBufferView\", function (extension) {\n      return extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView);\n    });\n  };\n\n  GLTFLoader.prototype._extensionsLoadBufferAsync = function (context, buffer, byteOffset, byteLength) {\n    return this._applyExtensions(buffer, \"loadBuffer\", function (extension) {\n      return extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength);\n    });\n  };\n  /**\r\n   * Helper method called by a loader extension to load an glTF extension.\r\n   * @param context The context when loading the asset\r\n   * @param property The glTF property to load the extension from\r\n   * @param extensionName The name of the extension to load\r\n   * @param actionAsync The action to run\r\n   * @returns The promise returned by actionAsync or null if the extension does not exist\r\n   */\n\n\n  GLTFLoader.LoadExtensionAsync = function (context, property, extensionName, actionAsync) {\n    if (!property.extensions) {\n      return null;\n    }\n\n    var extensions = property.extensions;\n    var extension = extensions[extensionName];\n\n    if (!extension) {\n      return null;\n    }\n\n    return actionAsync(context + \"/extensions/\" + extensionName, extension);\n  };\n  /**\r\n   * Helper method called by a loader extension to load a glTF extra.\r\n   * @param context The context when loading the asset\r\n   * @param property The glTF property to load the extra from\r\n   * @param extensionName The name of the extension to load\r\n   * @param actionAsync The action to run\r\n   * @returns The promise returned by actionAsync or null if the extra does not exist\r\n   */\n\n\n  GLTFLoader.LoadExtraAsync = function (context, property, extensionName, actionAsync) {\n    if (!property.extras) {\n      return null;\n    }\n\n    var extras = property.extras;\n    var extra = extras[extensionName];\n\n    if (!extra) {\n      return null;\n    }\n\n    return actionAsync(context + \"/extras/\" + extensionName, extra);\n  };\n  /**\r\n   * Checks for presence of an extension.\r\n   * @param name The name of the extension to check\r\n   * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\r\n   */\n\n\n  GLTFLoader.prototype.isExtensionUsed = function (name) {\n    return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\n  };\n  /**\r\n   * Increments the indentation level and logs a message.\r\n   * @param message The message to log\r\n   */\n\n\n  GLTFLoader.prototype.logOpen = function (message) {\n    this._parent._logOpen(message);\n  };\n  /**\r\n   * Decrements the indentation level.\r\n   */\n\n\n  GLTFLoader.prototype.logClose = function () {\n    this._parent._logClose();\n  };\n  /**\r\n   * Logs a message\r\n   * @param message The message to log\r\n   */\n\n\n  GLTFLoader.prototype.log = function (message) {\n    this._parent._log(message);\n  };\n  /**\r\n   * Starts a performance counter.\r\n   * @param counterName The name of the performance counter\r\n   */\n\n\n  GLTFLoader.prototype.startPerformanceCounter = function (counterName) {\n    this._parent._startPerformanceCounter(counterName);\n  };\n  /**\r\n   * Ends a performance counter.\r\n   * @param counterName The name of the performance counter\r\n   */\n\n\n  GLTFLoader.prototype.endPerformanceCounter = function (counterName) {\n    this._parent._endPerformanceCounter(counterName);\n  };\n\n  GLTFLoader._RegisteredExtensions = {};\n  /**\r\n   * The default glTF sampler.\r\n   */\n\n  GLTFLoader.DefaultSampler = {\n    index: -1\n  };\n  return GLTFLoader;\n}();\n\nexport { GLTFLoader };\n\nGLTFFileLoader._CreateGLTF2Loader = function (parent) {\n  return new GLTFLoader(parent);\n};","map":null,"metadata":{},"sourceType":"module"}