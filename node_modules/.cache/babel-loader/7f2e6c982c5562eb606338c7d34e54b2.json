{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nimport { ShadowLight } from \"./shadowLight\";\nNode.AddNodeConstructor(\"Light_Type_1\", function (name, scene) {\n  return function () {\n    return new DirectionalLight(name, Vector3.Zero(), scene);\n  };\n});\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/babylon101/lights\r\n */\n\nvar DirectionalLight =\n/** @class */\nfunction (_super) {\n  __extends(DirectionalLight, _super);\n  /**\r\n   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n   * The directional light is emitted from everywhere in the given direction.\r\n   * It can cast shadows.\r\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n   * @param name The friendly name of the light\r\n   * @param direction The direction of the light\r\n   * @param scene The scene the light belongs to\r\n   */\n\n\n  function DirectionalLight(name, direction, scene) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._shadowFrustumSize = 0;\n    _this._shadowOrthoScale = 0.1;\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\n\n    _this.autoUpdateExtends = true;\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\n\n    _this.autoCalcShadowZBounds = false; // Cache\n\n    _this._orthoLeft = Number.MAX_VALUE;\n    _this._orthoRight = Number.MIN_VALUE;\n    _this._orthoTop = Number.MIN_VALUE;\n    _this._orthoBottom = Number.MAX_VALUE;\n    _this.position = direction.scale(-1.0);\n    _this.direction = direction;\n    return _this;\n  }\n\n  Object.defineProperty(DirectionalLight.prototype, \"shadowFrustumSize\", {\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\n    get: function get() {\n      return this._shadowFrustumSize;\n    },\n\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\n    set: function set(value) {\n      this._shadowFrustumSize = value;\n      this.forceProjectionMatrixCompute();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DirectionalLight.prototype, \"shadowOrthoScale\", {\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\n    get: function get() {\n      return this._shadowOrthoScale;\n    },\n\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\n    set: function set(value) {\n      this._shadowOrthoScale = value;\n      this.forceProjectionMatrixCompute();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"DirectionalLight\".\r\n   * @return The class name\r\n   */\n\n  DirectionalLight.prototype.getClassName = function () {\n    return \"DirectionalLight\";\n  };\n  /**\r\n   * Returns the integer 1.\r\n   * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n   */\n\n\n  DirectionalLight.prototype.getTypeID = function () {\n    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n  };\n  /**\r\n   * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n   * Returns the DirectionalLight Shadow projection matrix.\r\n   */\n\n\n  DirectionalLight.prototype._setDefaultShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n    if (this.shadowFrustumSize > 0) {\n      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\n    } else {\n      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n    }\n  };\n  /**\r\n   * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n   * Returns the DirectionalLight Shadow projection matrix.\r\n   */\n\n\n  DirectionalLight.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function (matrix) {\n    var activeCamera = this.getScene().activeCamera;\n\n    if (!activeCamera) {\n      return;\n    }\n\n    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\n  };\n  /**\r\n   * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n   * Returns the DirectionalLight Shadow projection matrix.\r\n   */\n\n\n  DirectionalLight.prototype._setDefaultAutoExtendShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n    var activeCamera = this.getScene().activeCamera;\n\n    if (!activeCamera) {\n      return;\n    } // Check extends\n\n\n    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n      var tempVector3 = Vector3.Zero();\n      this._orthoLeft = Number.MAX_VALUE;\n      this._orthoRight = Number.MIN_VALUE;\n      this._orthoTop = Number.MIN_VALUE;\n      this._orthoBottom = Number.MAX_VALUE;\n      var shadowMinZ = Number.MAX_VALUE;\n      var shadowMaxZ = Number.MIN_VALUE;\n\n      for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n        var mesh = renderList[meshIndex];\n\n        if (!mesh) {\n          continue;\n        }\n\n        var boundingInfo = mesh.getBoundingInfo();\n        var boundingBox = boundingInfo.boundingBox;\n\n        for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {\n          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n\n          if (tempVector3.x < this._orthoLeft) {\n            this._orthoLeft = tempVector3.x;\n          }\n\n          if (tempVector3.y < this._orthoBottom) {\n            this._orthoBottom = tempVector3.y;\n          }\n\n          if (tempVector3.x > this._orthoRight) {\n            this._orthoRight = tempVector3.x;\n          }\n\n          if (tempVector3.y > this._orthoTop) {\n            this._orthoTop = tempVector3.y;\n          }\n\n          if (this.autoCalcShadowZBounds) {\n            if (tempVector3.z < shadowMinZ) {\n              shadowMinZ = tempVector3.z;\n            }\n\n            if (tempVector3.z > shadowMaxZ) {\n              shadowMaxZ = tempVector3.z;\n            }\n          }\n        }\n      }\n\n      if (this.autoCalcShadowZBounds) {\n        this._shadowMinZ = shadowMinZ;\n        this._shadowMaxZ = shadowMaxZ;\n      }\n    }\n\n    var xOffset = this._orthoRight - this._orthoLeft;\n    var yOffset = this._orthoTop - this._orthoBottom;\n    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\n  };\n\n  DirectionalLight.prototype._buildUniformLayout = function () {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n\n    this._uniformBuffer.create();\n  };\n  /**\r\n   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n   * @param effect The effect to update\r\n   * @param lightIndex The index of the light in the effect to update\r\n   * @returns The directional light\r\n   */\n\n\n  DirectionalLight.prototype.transferToEffect = function (effect, lightIndex) {\n    if (this.computeTransformedInformation()) {\n      this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n\n      return this;\n    }\n\n    this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n\n    return this;\n  };\n\n  DirectionalLight.prototype.transferToNodeMaterialEffect = function (effect, lightDataUniformName) {\n    if (this.computeTransformedInformation()) {\n      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\n      return this;\n    }\n\n    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\n    return this;\n  };\n  /**\r\n   * Gets the minZ used for shadow according to both the scene and the light.\r\n   *\r\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n   * @param activeCamera The camera we are returning the min for\r\n   * @returns the depth min z\r\n   */\n\n\n  DirectionalLight.prototype.getDepthMinZ = function (activeCamera) {\n    return 1;\n  };\n  /**\r\n   * Gets the maxZ used for shadow according to both the scene and the light.\r\n   *\r\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n   * @param activeCamera The camera we are returning the max for\r\n   * @returns the depth max z\r\n   */\n\n\n  DirectionalLight.prototype.getDepthMaxZ = function (activeCamera) {\n    return 1;\n  };\n  /**\r\n   * Prepares the list of defines specific to the light type.\r\n   * @param defines the list of defines\r\n   * @param lightIndex defines the index of the light for the effect\r\n   */\n\n\n  DirectionalLight.prototype.prepareLightSpecificDefines = function (defines, lightIndex) {\n    defines[\"DIRLIGHT\" + lightIndex] = true;\n  };\n\n  __decorate([serialize()], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"autoCalcShadowZBounds\", void 0);\n\n  return DirectionalLight;\n}(ShadowLight);\n\nexport { DirectionalLight };","map":null,"metadata":{},"sourceType":"module"}