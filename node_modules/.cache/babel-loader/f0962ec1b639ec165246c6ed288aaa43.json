{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\nimport { Plane } from '../Maths/math.plane';\n\nvar intersectBoxAASphere = function intersectBoxAASphere(boxMin, boxMax, sphereCenter, sphereRadius) {\n  if (boxMin.x > sphereCenter.x + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.x - sphereRadius > boxMax.x) {\n    return false;\n  }\n\n  if (boxMin.y > sphereCenter.y + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.y - sphereRadius > boxMax.y) {\n    return false;\n  }\n\n  if (boxMin.z > sphereCenter.z + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.z - sphereRadius > boxMax.z) {\n    return false;\n  }\n\n  return true;\n};\n\nvar getLowestRoot = function () {\n  var result = {\n    root: 0,\n    found: false\n  };\n  return function (a, b, c, maxR) {\n    result.root = 0;\n    result.found = false;\n    var determinant = b * b - 4.0 * a * c;\n\n    if (determinant < 0) {\n      return result;\n    }\n\n    var sqrtD = Math.sqrt(determinant);\n    var r1 = (-b - sqrtD) / (2.0 * a);\n    var r2 = (-b + sqrtD) / (2.0 * a);\n\n    if (r1 > r2) {\n      var temp = r2;\n      r2 = r1;\n      r1 = temp;\n    }\n\n    if (r1 > 0 && r1 < maxR) {\n      result.root = r1;\n      result.found = true;\n      return result;\n    }\n\n    if (r2 > 0 && r2 < maxR) {\n      result.root = r2;\n      result.found = true;\n      return result;\n    }\n\n    return result;\n  };\n}();\n/** @hidden */\n\n\nvar Collider =\n/** @class */\nfunction () {\n  function Collider() {\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\n    // https://www.peroxide.dk/papers/collision/collision.pdf\n    this._collisionPoint = Vector3.Zero();\n    this._planeIntersectionPoint = Vector3.Zero();\n    this._tempVector = Vector3.Zero();\n    this._tempVector2 = Vector3.Zero();\n    this._tempVector3 = Vector3.Zero();\n    this._tempVector4 = Vector3.Zero();\n    this._edge = Vector3.Zero();\n    this._baseToVertex = Vector3.Zero();\n    this._destinationPoint = Vector3.Zero();\n    this._slidePlaneNormal = Vector3.Zero();\n    this._displacementVector = Vector3.Zero();\n    /** @hidden */\n\n    this._radius = Vector3.One();\n    /** @hidden */\n\n    this._retry = 0;\n    /** @hidden */\n\n    this._basePointWorld = Vector3.Zero();\n    this._velocityWorld = Vector3.Zero();\n    this._normalizedVelocity = Vector3.Zero();\n    this._collisionMask = -1;\n  }\n\n  Object.defineProperty(Collider.prototype, \"collisionMask\", {\n    get: function get() {\n      return this._collisionMask;\n    },\n    set: function set(mask) {\n      this._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Collider.prototype, \"slidePlaneNormal\", {\n    /**\r\n     * Gets the plane normal used to compute the sliding response (in local space)\r\n     */\n    get: function get() {\n      return this._slidePlaneNormal;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /** @hidden */\n\n  Collider.prototype._initialize = function (source, dir, e) {\n    this._velocity = dir;\n    Vector3.NormalizeToRef(dir, this._normalizedVelocity);\n    this._basePoint = source;\n    source.multiplyToRef(this._radius, this._basePointWorld);\n    dir.multiplyToRef(this._radius, this._velocityWorld);\n    this._velocityWorldLength = this._velocityWorld.length();\n    this._epsilon = e;\n    this.collisionFound = false;\n  };\n  /** @hidden */\n\n\n  Collider.prototype._checkPointInTriangle = function (point, pa, pb, pc, n) {\n    pa.subtractToRef(point, this._tempVector);\n    pb.subtractToRef(point, this._tempVector2);\n    Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n    var d = Vector3.Dot(this._tempVector4, n);\n\n    if (d < 0) {\n      return false;\n    }\n\n    pc.subtractToRef(point, this._tempVector3);\n    Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n\n    if (d < 0) {\n      return false;\n    }\n\n    Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    return d >= 0;\n  };\n  /** @hidden */\n\n\n  Collider.prototype._canDoCollision = function (sphereCenter, sphereRadius, vecMin, vecMax) {\n    var distance = Vector3.Distance(this._basePointWorld, sphereCenter);\n    var max = Math.max(this._radius.x, this._radius.y, this._radius.z);\n\n    if (distance > this._velocityWorldLength + max + sphereRadius) {\n      return false;\n    }\n\n    if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\n      return false;\n    }\n\n    return true;\n  };\n  /** @hidden */\n\n\n  Collider.prototype._testTriangle = function (faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {\n    var t0;\n    var embeddedInPlane = false; //defensive programming, actually not needed.\n\n    if (!trianglePlaneArray) {\n      trianglePlaneArray = [];\n    }\n\n    if (!trianglePlaneArray[faceIndex]) {\n      trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\n      trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n    }\n\n    var trianglePlane = trianglePlaneArray[faceIndex];\n\n    if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\n      return;\n    }\n\n    var signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\n    var normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\n\n    if (normalDotVelocity == 0) {\n      if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\n        return;\n      }\n\n      embeddedInPlane = true;\n      t0 = 0;\n    } else {\n      t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      var t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n\n      if (t0 > t1) {\n        var temp = t1;\n        t1 = t0;\n        t0 = temp;\n      }\n\n      if (t0 > 1.0 || t1 < 0.0) {\n        return;\n      }\n\n      if (t0 < 0) {\n        t0 = 0;\n      }\n\n      if (t0 > 1.0) {\n        t0 = 1.0;\n      }\n    }\n\n    this._collisionPoint.copyFromFloats(0, 0, 0);\n\n    var found = false;\n    var t = 1.0;\n\n    if (!embeddedInPlane) {\n      this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n\n      this._velocity.scaleToRef(t0, this._tempVector);\n\n      this._planeIntersectionPoint.addInPlace(this._tempVector);\n\n      if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n        found = true;\n        t = t0;\n\n        this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n      }\n    }\n\n    if (!found) {\n      var velocitySquaredLength = this._velocity.lengthSquared();\n\n      var a = velocitySquaredLength;\n\n      this._basePoint.subtractToRef(p1, this._tempVector);\n\n      var b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      var c = this._tempVector.lengthSquared() - 1.0;\n      var lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p1);\n      }\n\n      this._basePoint.subtractToRef(p2, this._tempVector);\n\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p2);\n      }\n\n      this._basePoint.subtractToRef(p3, this._tempVector);\n\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p3);\n      }\n\n      p2.subtractToRef(p1, this._edge);\n      p1.subtractToRef(this._basePoint, this._baseToVertex);\n\n      var edgeSquaredLength = this._edge.lengthSquared();\n\n      var edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      var edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p1.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n\n      p3.subtractToRef(p2, this._edge);\n      p2.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p2.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n\n      p1.subtractToRef(p3, this._edge);\n      p3.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p3.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n    }\n\n    if (found) {\n      var distToCollision = t * this._velocity.length();\n\n      if (!this.collisionFound || distToCollision < this._nearestDistance) {\n        // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\n        // onCollide observable are triggered if collideMesh is set\n        // this allow trigger volumes to be created.\n        if (hostMesh.collisionResponse) {\n          if (!this.intersectionPoint) {\n            this.intersectionPoint = this._collisionPoint.clone();\n          } else {\n            this.intersectionPoint.copyFrom(this._collisionPoint);\n          }\n\n          this._nearestDistance = distToCollision;\n          this.collisionFound = true;\n        }\n\n        this.collidedMesh = hostMesh;\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Collider.prototype._collide = function (trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh) {\n    if (!indices || indices.length === 0) {\n      for (var i = 0; i < pts.length; i += 3) {\n        var p1 = pts[i];\n        var p2 = pts[i + 1];\n        var p3 = pts[i + 2];\n\n        this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n      }\n    } else {\n      for (var i = indexStart; i < indexEnd; i += 3) {\n        var p1 = pts[indices[i] - decal];\n        var p2 = pts[indices[i + 1] - decal];\n        var p3 = pts[indices[i + 2] - decal];\n\n        this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Collider.prototype._getResponse = function (pos, vel) {\n    pos.addToRef(vel, this._destinationPoint);\n    vel.scaleInPlace(this._nearestDistance / vel.length());\n\n    this._basePoint.addToRef(vel, pos);\n\n    pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n\n    this._slidePlaneNormal.normalize();\n\n    this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\n\n    pos.addInPlace(this._displacementVector);\n    this.intersectionPoint.addInPlace(this._displacementVector);\n\n    this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n\n    this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n\n    this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n  };\n\n  return Collider;\n}();\n\nexport { Collider };","map":null,"metadata":{},"sourceType":"module"}