{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Color3 } from \"../../Maths/math.color\";\nimport { Axis } from \"../../Maths/math.axis\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\nimport { CylinderBuilder } from \"../../Meshes/Builders/cylinderBuilder\";\nimport { TorusBuilder } from \"../../Meshes/Builders/torusBuilder\";\nimport { Ray } from \"../../Culling/ray\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\nimport { Viewport } from \"../../Maths/math.viewport\";\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\n\nvar WebXRControllerPointerSelection =\n/** @class */\nfunction (_super) {\n  __extends(WebXRControllerPointerSelection, _super);\n  /**\r\n   * constructs a new background remover module\r\n   * @param _xrSessionManager the session manager for this module\r\n   * @param _options read-only options to be used in this module\r\n   */\n\n\n  function WebXRControllerPointerSelection(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      var _a = _this._generateNewMeshPair(xrController.pointer),\n          laserPointer = _a.laserPointer,\n          selectionMesh = _a.selectionMesh; // get two new meshes\n\n\n      _this._controllers[xrController.uniqueId] = {\n        xrController: xrController,\n        laserPointer: laserPointer,\n        selectionMesh: selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        id: WebXRControllerPointerSelection._idCounter++\n      };\n\n      if (_this._attachedController) {\n        if (!_this._options.enablePointerSelectionOnAllControllers && _this._options.preferredHandedness && xrController.inputSource.handedness === _this._options.preferredHandedness) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!_this._options.enablePointerSelectionOnAllControllers) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      }\n\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return _this._attachTrackedPointerRayMode(xrController);\n\n        case \"gaze\":\n          return _this._attachGazeMode(xrController);\n\n        case \"screen\":\n          return _this._attachScreenRayMode(xrController);\n      }\n    };\n\n    _this._controllers = {};\n    _this._tmpVectorForPickCompare = new Vector3();\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\n\n    _this.disablePointerLighting = true;\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\n\n    _this.disableSelectionMeshLighting = true;\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\n\n    _this.displayLaserPointer = true;\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\n\n    _this.displaySelectionMesh = true;\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\n\n    _this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);\n    /**\r\n     * Default color of the laser pointer\r\n     */\n\n    _this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);\n    /**\r\n     * default color of the selection ring\r\n     */\n\n    _this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\n\n    _this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    _this._identityMatrix = Matrix.Identity();\n    _this._screenCoordinatesRef = Vector3.Zero();\n    _this._viewportRef = new Viewport(0, 0, 0, 0);\n    _this._scene = _this._xrSessionManager.scene;\n    return _this;\n  }\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRControllerPointerSelection.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n\n    if (this._options.gazeCamera) {\n      var webXRCamera = this._options.gazeCamera;\n\n      var _a = this._generateNewMeshPair(webXRCamera),\n          laserPointer = _a.laserPointer,\n          selectionMesh = _a.selectionMesh;\n\n      this._controllers[\"camera\"] = {\n        webXRCamera: webXRCamera,\n        laserPointer: laserPointer,\n        selectionMesh: selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        id: WebXRControllerPointerSelection._idCounter++\n      };\n\n      this._attachGazeMode();\n    }\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRControllerPointerSelection.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n    return true;\n  };\n  /**\r\n   * Will get the mesh under a specific pointer.\r\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n   * @param controllerId the controllerId to check\r\n   * @returns The mesh under pointer or null if no mesh is under the pointer\r\n   */\n\n\n  WebXRControllerPointerSelection.prototype.getMeshUnderPointer = function (controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * Get the xr controller that correlates to the pointer id in the pointer event\r\n   *\r\n   * @param id the pointer id to search for\r\n   * @returns the controller that correlates to this id or null if not found\r\n   */\n\n\n  WebXRControllerPointerSelection.prototype.getXRControllerByPointerId = function (id) {\n    var keys = Object.keys(this._controllers);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n\n    return null;\n  };\n\n  WebXRControllerPointerSelection.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    Object.keys(this._controllers).forEach(function (id) {\n      // only do this for the selected pointer\n      var controllerData = _this._controllers[id];\n\n      if (!_this._options.enablePointerSelectionOnAllControllers && id !== _this._attachedController) {\n        controllerData.selectionMesh.isVisible = false;\n        controllerData.laserPointer.isVisible = false;\n        controllerData.pick = null;\n        return;\n      }\n\n      controllerData.laserPointer.isVisible = _this.displayLaserPointer;\n      var controllerGlobalPosition; // Every frame check collisions/input\n\n      if (controllerData.xrController) {\n        controllerGlobalPosition = controllerData.xrController.pointer.position;\n        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\n      } else if (controllerData.webXRCamera) {\n        controllerGlobalPosition = controllerData.webXRCamera.position;\n        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\n      } else {\n        return;\n      }\n\n      if (_this._options.maxPointerDistance) {\n        controllerData.tmpRay.length = _this._options.maxPointerDistance;\n      } // update pointerX and pointerY of the scene. Only if the flag is set to true!\n\n\n      if (!_this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\n        var scene = _this._xrSessionManager.scene;\n        var camera = _this._options.xrInput.xrCamera;\n\n        if (camera) {\n          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), _this._viewportRef);\n          Vector3.ProjectToRef(controllerGlobalPosition, _this._identityMatrix, scene.getTransformMatrix(), _this._viewportRef, _this._screenCoordinatesRef);\n          scene.pointerX = _this._screenCoordinatesRef.x;\n          scene.pointerY = _this._screenCoordinatesRef.y;\n        }\n      }\n\n      controllerData.pick = _this._scene.pickWithRay(controllerData.tmpRay, _this._scene.pointerMovePredicate || _this.raySelectionPredicate);\n      var pick = controllerData.pick;\n\n      if (pick && pick.pickedPoint && pick.hit) {\n        // Update laser state\n        _this._updatePointerDistance(controllerData.laserPointer, pick.distance); // Update cursor state\n\n\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance); // To avoid z-fighting\n\n        var pickNormal = _this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\n\n        var deltaFighting = 0.001;\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n\n        if (pickNormal) {\n          var axis1 = Vector3.Cross(Axis.Y, pickNormal);\n          var axis2 = Vector3.Cross(pickNormal, axis1);\n          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\n          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\n        }\n\n        controllerData.selectionMesh.isVisible = true && _this.displaySelectionMesh;\n        controllerData.meshUnderPointer = pick.pickedMesh;\n      } else {\n        controllerData.selectionMesh.isVisible = false;\n\n        _this._updatePointerDistance(controllerData.laserPointer, 1);\n\n        controllerData.meshUnderPointer = null;\n      }\n    });\n  };\n\n  WebXRControllerPointerSelection.prototype._attachGazeMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController && xrController.uniqueId || \"camera\"]; // attached when touched, detaches when raised\n\n    var timeToSelect = this._options.timeToSelect || 3000;\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    var oldPick = new PickingInfo();\n    var discMesh = TorusBuilder.CreateTorus(\"selection\", {\n      diameter: 0.0035 * 15,\n      thickness: 0.0025 * 6,\n      tessellation: 20\n    }, sceneToRenderTo);\n    discMesh.isVisible = false;\n    discMesh.isPickable = false;\n    discMesh.parent = controllerData.selectionMesh;\n    var timer = 0;\n    var downTriggered = false;\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      if (!controllerData.pick) {\n        return;\n      }\n\n      controllerData.laserPointer.material.alpha = 0;\n      discMesh.isVisible = false;\n\n      if (controllerData.pick.hit) {\n        if (!_this._pickingMoved(oldPick, controllerData.pick)) {\n          if (timer > timeToSelect / 10) {\n            discMesh.isVisible = true;\n          }\n\n          timer += _this._scene.getEngine().getDeltaTime();\n\n          if (timer >= timeToSelect) {\n            _this._scene.simulatePointerDown(controllerData.pick, {\n              pointerId: controllerData.id\n            });\n\n            downTriggered = true; // pointer up right after down, if disable on touch out\n\n            if (_this._options.disablePointerUpOnTouchOut) {\n              _this._scene.simulatePointerUp(controllerData.pick, {\n                pointerId: controllerData.id\n              });\n            }\n\n            discMesh.isVisible = false;\n          } else {\n            var scaleFactor = 1 - timer / timeToSelect;\n            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\n          }\n        } else {\n          if (downTriggered) {\n            if (!_this._options.disablePointerUpOnTouchOut) {\n              _this._scene.simulatePointerUp(controllerData.pick, {\n                pointerId: controllerData.id\n              });\n            }\n          }\n\n          downTriggered = false;\n          timer = 0;\n        }\n      } else {\n        downTriggered = false;\n        timer = 0;\n      }\n\n      _this._scene.simulatePointerMove(controllerData.pick, {\n        pointerId: controllerData.id\n      });\n\n      oldPick = controllerData.pick;\n    });\n\n    if (this._options.renderingGroupId !== undefined) {\n      discMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    if (xrController) {\n      xrController.onDisposeObservable.addOnce(function () {\n        if (controllerData.pick && !_this._options.disablePointerUpOnTouchOut && downTriggered) {\n          _this._scene.simulatePointerUp(controllerData.pick, {\n            pointerId: controllerData.id\n          });\n        }\n\n        discMesh.dispose();\n      });\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._attachScreenRayMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController.uniqueId];\n    var downTriggered = false;\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      if (!controllerData.pick || _this._options.disablePointerUpOnTouchOut && downTriggered) {\n        return;\n      }\n\n      if (!downTriggered) {\n        _this._scene.simulatePointerDown(controllerData.pick, {\n          pointerId: controllerData.id\n        });\n\n        downTriggered = true;\n\n        if (_this._options.disablePointerUpOnTouchOut) {\n          _this._scene.simulatePointerUp(controllerData.pick, {\n            pointerId: controllerData.id\n          });\n        }\n      } else {\n        _this._scene.simulatePointerMove(controllerData.pick, {\n          pointerId: controllerData.id\n        });\n      }\n    });\n    xrController.onDisposeObservable.addOnce(function () {\n      if (controllerData.pick && downTriggered && !_this._options.disablePointerUpOnTouchOut) {\n        _this._scene.simulatePointerUp(controllerData.pick, {\n          pointerId: controllerData.id\n        });\n      }\n    });\n  };\n\n  WebXRControllerPointerSelection.prototype._attachTrackedPointerRayMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController.uniqueId];\n\n    if (this._options.forceGazeMode) {\n      return this._attachGazeMode(xrController);\n    }\n\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      controllerData.laserPointer.material.disableLighting = _this.disablePointerLighting;\n      controllerData.selectionMesh.material.disableLighting = _this.disableSelectionMeshLighting;\n\n      if (controllerData.pick) {\n        _this._scene.simulatePointerMove(controllerData.pick, {\n          pointerId: controllerData.id\n        });\n      }\n    });\n\n    if (xrController.inputSource.gamepad) {\n      var init = function init(motionController) {\n        if (_this._options.overrideButtonId) {\n          controllerData.selectionComponent = motionController.getComponent(_this._options.overrideButtonId);\n        }\n\n        if (!controllerData.selectionComponent) {\n          controllerData.selectionComponent = motionController.getMainComponent();\n        }\n\n        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(function (component) {\n          if (component.changes.pressed) {\n            var pressed = component.changes.pressed.current;\n\n            if (controllerData.pick) {\n              if (_this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === _this._attachedController) {\n                if (pressed) {\n                  _this._scene.simulatePointerDown(controllerData.pick, {\n                    pointerId: controllerData.id\n                  });\n\n                  controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshPickedColor;\n                  controllerData.laserPointer.material.emissiveColor = _this.laserPointerPickedColor;\n                } else {\n                  _this._scene.simulatePointerUp(controllerData.pick, {\n                    pointerId: controllerData.id\n                  });\n\n                  controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshDefaultColor;\n                  controllerData.laserPointer.material.emissiveColor = _this.laserPointerDefaultColor;\n                }\n              } else {}\n            } else {\n              if (pressed && !_this._options.enablePointerSelectionOnAllControllers && !_this._options.disableSwitchOnClick) {\n                _this._attachedController = xrController.uniqueId;\n              }\n            }\n          }\n        });\n      };\n\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      var selectStartListener = function selectStartListener(event) {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          _this._scene.simulatePointerDown(controllerData.pick, {\n            pointerId: controllerData.id\n          });\n\n          controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshPickedColor;\n          controllerData.laserPointer.material.emissiveColor = _this.laserPointerPickedColor;\n        }\n      };\n\n      var selectEndListener = function selectEndListener(event) {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          _this._scene.simulatePointerUp(controllerData.pick, {\n            pointerId: controllerData.id\n          });\n\n          controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshDefaultColor;\n          controllerData.laserPointer.material.emissiveColor = _this.laserPointerDefaultColor;\n        }\n      };\n\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._convertNormalToDirectionOfRay = function (normal, ray) {\n    if (normal) {\n      var angle = Math.acos(Vector3.Dot(normal, ray.direction));\n\n      if (angle < Math.PI / 2) {\n        normal.scaleInPlace(-1);\n      }\n    }\n\n    return normal;\n  };\n\n  WebXRControllerPointerSelection.prototype._detachController = function (xrControllerUniqueId) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(function (eventName) {\n        var func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n\n        if (func) {\n          _this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n\n    controllerData.selectionMesh.dispose();\n    controllerData.laserPointer.dispose(); // remove from the map\n\n    delete this._controllers[xrControllerUniqueId];\n\n    if (this._attachedController === xrControllerUniqueId) {\n      // check for other controllers\n      var keys = Object.keys(this._controllers);\n\n      if (keys.length) {\n        this._attachedController = keys[0];\n      } else {\n        this._attachedController = \"\";\n      }\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._generateNewMeshPair = function (meshParent) {\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    var laserPointer = CylinderBuilder.CreateCylinder(\"laserPointer\", {\n      height: 1,\n      diameterTop: 0.0002,\n      diameterBottom: 0.004,\n      tessellation: 20,\n      subdivisions: 1\n    }, sceneToRenderTo);\n    laserPointer.parent = meshParent;\n    var laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\n    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\n    laserPointerMaterial.alpha = 0.7;\n    laserPointer.material = laserPointerMaterial;\n    laserPointer.rotation.x = Math.PI / 2;\n\n    this._updatePointerDistance(laserPointer, 1);\n\n    laserPointer.isPickable = false; // Create a gaze tracker for the  XR controller\n\n    var selectionMesh = TorusBuilder.CreateTorus(\"gazeTracker\", {\n      diameter: 0.0035 * 3,\n      thickness: 0.0025 * 3,\n      tessellation: 20\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    var targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n\n    if (this._options.renderingGroupId !== undefined) {\n      laserPointer.renderingGroupId = this._options.renderingGroupId;\n      selectionMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    return {\n      laserPointer: laserPointer,\n      selectionMesh: selectionMesh\n    };\n  };\n\n  WebXRControllerPointerSelection.prototype._pickingMoved = function (oldPick, newPick) {\n    var _a;\n\n    if (!oldPick.hit || !newPick.hit) {\n      return true;\n    }\n\n    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\n      return true;\n    }\n\n    if (oldPick.pickedMesh !== newPick.pickedMesh) {\n      return true;\n    }\n\n    (_a = oldPick.pickedPoint) === null || _a === void 0 ? void 0 : _a.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\n\n    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\n\n    var delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\n\n    var length = this._tmpVectorForPickCompare.length();\n\n    if (length > delta) {\n      return true;\n    }\n\n    return false;\n  };\n\n  WebXRControllerPointerSelection.prototype._updatePointerDistance = function (_laserPointer, distance) {\n    if (distance === void 0) {\n      distance = 100;\n    }\n\n    _laserPointer.scaling.y = distance; // a bit of distance from the controller\n\n    if (this._scene.useRightHandedSystem) {\n      distance *= -1;\n    }\n\n    _laserPointer.position.z = distance / 2 + 0.05;\n  };\n\n  Object.defineProperty(WebXRControllerPointerSelection.prototype, \"lasterPointerDefaultColor\", {\n    /** @hidden */\n    get: function get() {\n      // here due to a typo\n      return this.laserPointerDefaultColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WebXRControllerPointerSelection._idCounter = 200;\n  /**\r\n   * The module's name\r\n   */\n\n  WebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRControllerPointerSelection.Version = 1;\n  return WebXRControllerPointerSelection;\n}(WebXRAbstractFeature);\n\nexport { WebXRControllerPointerSelection }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRControllerPointerSelection(xrSessionManager, options);\n  };\n}, WebXRControllerPointerSelection.Version, true);","map":null,"metadata":{},"sourceType":"module"}