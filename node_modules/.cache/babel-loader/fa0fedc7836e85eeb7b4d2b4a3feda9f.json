{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector\";\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Buffer } from \"../Meshes/buffer\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { BoxParticleEmitter, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, ConeParticleEmitter, PointParticleEmitter, MeshParticleEmitter, CylinderDirectedParticleEmitter } from \"../Particles/EmitterTypes/index\";\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\nimport { Particle } from \"./particle\";\nimport { SubEmitter, SubEmitterType } from \"./subEmitter\";\nimport { SerializationHelper } from \"../Misc/decorators\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport \"../Shaders/particles.fragment\";\nimport \"../Shaders/particles.vertex\";\nimport { Color4, Color3, TmpColors } from '../Maths/math.color';\nimport { ThinEngine } from '../Engines/thinEngine';\nimport { ThinMaterialHelper } from '../Materials/thinMaterialHelper';\nimport \"../Engines/Extensions/engine.alpha\";\n/**\r\n * This represents a particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/babylon101/particles\r\n */\n\nvar ParticleSystem =\n/** @class */\nfunction (_super) {\n  __extends(ParticleSystem, _super);\n  /**\r\n   * Instantiates a particle system.\r\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n   * @param name The name of the particle system\r\n   * @param capacity The max number of particles alive at the same time\r\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n   * @param customEffect a custom effect used to change the way particles are rendered by default\r\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n   * @param epsilon Offset used to render the particles\r\n   */\n\n\n  function ParticleSystem(name, capacity, sceneOrEngine, customEffect, isAnimationSheetEnabled, epsilon) {\n    if (customEffect === void 0) {\n      customEffect = null;\n    }\n\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    var _this = _super.call(this, name) || this;\n    /**\r\n     * @hidden\r\n     */\n\n\n    _this._inheritedVelocityOffset = new Vector3();\n    /**\r\n    * An event triggered when the system is disposed\r\n    */\n\n    _this.onDisposeObservable = new Observable();\n    /**\r\n    * An event triggered when the system is stopped\r\n    */\n\n    _this.onStoppedObservable = new Observable();\n    _this._particles = new Array();\n    _this._stockParticles = new Array();\n    _this._newPartsExcess = 0;\n    _this._vertexBuffers = {};\n    _this._scaledColorStep = new Color4(0, 0, 0, 0);\n    _this._colorDiff = new Color4(0, 0, 0, 0);\n    _this._scaledDirection = Vector3.Zero();\n    _this._scaledGravity = Vector3.Zero();\n    _this._currentRenderId = -1;\n    _this._useInstancing = false;\n    _this._started = false;\n    _this._stopped = false;\n    _this._actualFrame = 0;\n    /** @hidden */\n\n    _this._currentEmitRate1 = 0;\n    /** @hidden */\n\n    _this._currentEmitRate2 = 0;\n    /** @hidden */\n\n    _this._currentStartSize1 = 0;\n    /** @hidden */\n\n    _this._currentStartSize2 = 0;\n    _this._rawTextureWidth = 256;\n    _this._useRampGradients = false;\n    /**\r\n     * @hidden\r\n     * If the particle systems emitter should be disposed when the particle system is disposed\r\n     */\n\n    _this._disposeEmitterOnDispose = false;\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space\r\n     */\n\n    _this.isLocal = false;\n    /** @hidden */\n\n    _this._onBeforeDrawParticlesObservable = null; // start of sub system methods\n\n    /**\r\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\r\n     * Its lifetime will start back at 0.\r\n     */\n\n    _this.recycleParticle = function (particle) {\n      // move particle from activeParticle list to stock particles\n      var lastParticle = _this._particles.pop();\n\n      if (lastParticle !== particle) {\n        lastParticle.copyTo(particle);\n      }\n\n      _this._stockParticles.push(lastParticle);\n    };\n\n    _this._createParticle = function () {\n      var particle;\n\n      if (_this._stockParticles.length !== 0) {\n        particle = _this._stockParticles.pop();\n\n        particle._reset();\n      } else {\n        particle = new Particle(_this);\n      } // Attach emitters\n\n\n      if (_this._subEmitters && _this._subEmitters.length > 0) {\n        var subEmitters = _this._subEmitters[Math.floor(Math.random() * _this._subEmitters.length)];\n\n        particle._attachedSubEmitters = [];\n        subEmitters.forEach(function (subEmitter) {\n          if (subEmitter.type === SubEmitterType.ATTACHED) {\n            var newEmitter = subEmitter.clone();\n\n            particle._attachedSubEmitters.push(newEmitter);\n\n            newEmitter.particleSystem.start();\n          }\n        });\n      }\n\n      return particle;\n    };\n\n    _this._emitFromParticle = function (particle) {\n      if (!_this._subEmitters || _this._subEmitters.length === 0) {\n        return;\n      }\n\n      var templateIndex = Math.floor(Math.random() * _this._subEmitters.length);\n\n      _this._subEmitters[templateIndex].forEach(function (subEmitter) {\n        if (subEmitter.type === SubEmitterType.END) {\n          var subSystem = subEmitter.clone();\n\n          particle._inheritParticleInfoToSubEmitter(subSystem);\n\n          subSystem.particleSystem._rootParticleSystem = _this;\n\n          _this.activeSubSystems.push(subSystem.particleSystem);\n\n          subSystem.particleSystem.start();\n        }\n      });\n    };\n\n    _this._capacity = capacity;\n    _this._epsilon = epsilon;\n    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      _this._engine = _this._scene.getEngine();\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.particleSystems.push(_this);\n    } else {\n      _this._engine = sceneOrEngine;\n      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100);\n    }\n\n    if (_this._engine.getCaps().vertexArrayObject) {\n      _this._vertexArrayObject = null;\n    } // Setup the default processing configuration to the scene.\n\n\n    _this._attachImageProcessingConfiguration(null);\n\n    _this._customEffect = {\n      0: customEffect\n    };\n    _this._useInstancing = _this._engine.getCaps().instancedArrays;\n\n    _this._createIndexBuffer();\n\n    _this._createVertexBuffers(); // Default emitter type\n\n\n    _this.particleEmitterType = new BoxParticleEmitter(); // Update\n\n    _this.updateFunction = function (particles) {\n      var noiseTextureSize = null;\n      var noiseTextureData = null;\n\n      if (_this.noiseTexture) {\n        // We need to get texture data back to CPU\n        noiseTextureSize = _this.noiseTexture.getSize();\n        noiseTextureData = _this.noiseTexture.getContent();\n      }\n\n      var _loop_1 = function _loop_1() {\n        particle = particles[index];\n        var scaledUpdateSpeed = _this._scaledUpdateSpeed;\n        var previousAge = particle.age;\n        particle.age += scaledUpdateSpeed; // Evaluate step to death\n\n        if (particle.age > particle.lifeTime) {\n          var diff = particle.age - previousAge;\n          var oldDiff = particle.lifeTime - previousAge;\n          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;\n          particle.age = particle.lifeTime;\n        }\n\n        var ratio = particle.age / particle.lifeTime; // Color\n\n        if (_this._colorGradients && _this._colorGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._colorGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentColorGradient) {\n              particle._currentColor1.copyFrom(particle._currentColor2);\n\n              nextGradient.getColorToRef(particle._currentColor2);\n              particle._currentColorGradient = currentGradient;\n            }\n\n            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\n          });\n        } else {\n          particle.colorStep.scaleToRef(scaledUpdateSpeed, _this._scaledColorStep);\n          particle.color.addInPlace(_this._scaledColorStep);\n\n          if (particle.color.a < 0) {\n            particle.color.a = 0;\n          }\n        } // Angular speed\n\n\n        if (_this._angularSpeedGradients && _this._angularSpeedGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._angularSpeedGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentAngularSpeedGradient) {\n              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\n              particle._currentAngularSpeed2 = nextGradient.getFactor();\n              particle._currentAngularSpeedGradient = currentGradient;\n            }\n\n            particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\n          });\n        }\n\n        particle.angle += particle.angularSpeed * scaledUpdateSpeed; // Direction\n\n        var directionScale = scaledUpdateSpeed; /// Velocity\n\n        if (_this._velocityGradients && _this._velocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._velocityGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentVelocityGradient) {\n              particle._currentVelocity1 = particle._currentVelocity2;\n              particle._currentVelocity2 = nextGradient.getFactor();\n              particle._currentVelocityGradient = currentGradient;\n            }\n\n            directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\n          });\n        }\n\n        particle.direction.scaleToRef(directionScale, _this._scaledDirection); /// Limit velocity\n\n        if (_this._limitVelocityGradients && _this._limitVelocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._limitVelocityGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentLimitVelocityGradient) {\n              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\n              particle._currentLimitVelocity2 = nextGradient.getFactor();\n              particle._currentLimitVelocityGradient = currentGradient;\n            }\n\n            var limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\n            var currentVelocity = particle.direction.length();\n\n            if (currentVelocity > limitVelocity) {\n              particle.direction.scaleInPlace(_this.limitVelocityDamping);\n            }\n          });\n        } /// Drag\n\n\n        if (_this._dragGradients && _this._dragGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._dragGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentDragGradient) {\n              particle._currentDrag1 = particle._currentDrag2;\n              particle._currentDrag2 = nextGradient.getFactor();\n              particle._currentDragGradient = currentGradient;\n            }\n\n            var drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\n\n            _this._scaledDirection.scaleInPlace(1.0 - drag);\n          });\n        }\n\n        if (_this.isLocal && particle._localPosition) {\n          particle._localPosition.addInPlace(_this._scaledDirection);\n\n          Vector3.TransformCoordinatesToRef(particle._localPosition, _this._emitterWorldMatrix, particle.position);\n        } else {\n          particle.position.addInPlace(_this._scaledDirection);\n        } // Noise\n\n\n        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\n          var fetchedColorR = _this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var fetchedColorG = _this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var fetchedColorB = _this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var force = TmpVectors.Vector3[0];\n          var scaledForce = TmpVectors.Vector3[1];\n          force.copyFromFloats((2 * fetchedColorR - 1) * _this.noiseStrength.x, (2 * fetchedColorG - 1) * _this.noiseStrength.y, (2 * fetchedColorB - 1) * _this.noiseStrength.z);\n          force.scaleToRef(scaledUpdateSpeed, scaledForce);\n          particle.direction.addInPlace(scaledForce);\n        } // Gravity\n\n\n        _this.gravity.scaleToRef(scaledUpdateSpeed, _this._scaledGravity);\n\n        particle.direction.addInPlace(_this._scaledGravity); // Size\n\n        if (_this._sizeGradients && _this._sizeGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._sizeGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentSizeGradient) {\n              particle._currentSize1 = particle._currentSize2;\n              particle._currentSize2 = nextGradient.getFactor();\n              particle._currentSizeGradient = currentGradient;\n            }\n\n            particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\n          });\n        } // Remap data\n\n\n        if (_this._useRampGradients) {\n          if (_this._colorRemapGradients && _this._colorRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, _this._colorRemapGradients, function (currentGradient, nextGradient, scale) {\n              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.x = min;\n              particle.remapData.y = max - min;\n            });\n          }\n\n          if (_this._alphaRemapGradients && _this._alphaRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, _this._alphaRemapGradients, function (currentGradient, nextGradient, scale) {\n              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.z = min;\n              particle.remapData.w = max - min;\n            });\n          }\n        }\n\n        if (_this._isAnimationSheetEnabled) {\n          particle.updateCellIndex();\n        } // Update the position of the attached sub-emitters to match their attached particle\n\n\n        particle._inheritParticleInfoToSubEmitters();\n\n        if (particle.age >= particle.lifeTime) {\n          // Recycle by swapping with last particle\n          _this._emitFromParticle(particle);\n\n          if (particle._attachedSubEmitters) {\n            particle._attachedSubEmitters.forEach(function (subEmitter) {\n              subEmitter.particleSystem.disposeOnStop = true;\n              subEmitter.particleSystem.stop();\n            });\n\n            particle._attachedSubEmitters = null;\n          }\n\n          _this.recycleParticle(particle);\n\n          index--;\n          return \"continue\";\n        }\n      };\n\n      var particle;\n\n      for (var index = 0; index < particles.length; index++) {\n        _loop_1();\n      }\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(ParticleSystem.prototype, \"onDispose\", {\n    /**\r\n     * Sets a callback that will be triggered when the system is disposed\r\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"useRampGradients\", {\n    /** Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\r\n     */\n    get: function get() {\n      return this._useRampGradients;\n    },\n    set: function set(value) {\n      if (this._useRampGradients === value) {\n        return;\n      }\n\n      this._useRampGradients = value;\n\n      this._resetEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"particles\", {\n    //end of Sub-emitter\n\n    /**\r\n     * Gets the current list of active particles\r\n     */\n    get: function get() {\n      return this._particles;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the number of particles active at the same time.\r\n   * @returns The number of active particles.\r\n   */\n\n  ParticleSystem.prototype.getActiveCount = function () {\n    return this._particles.length;\n  };\n  /**\r\n   * Returns the string \"ParticleSystem\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  ParticleSystem.prototype.getClassName = function () {\n    return \"ParticleSystem\";\n  };\n  /**\r\n   * Gets a boolean indicating that the system is stopping\r\n   * @returns true if the system is currently stopping\r\n   */\n\n\n  ParticleSystem.prototype.isStopping = function () {\n    return this._stopped && this.isAlive();\n  };\n  /**\r\n   * Gets the custom effect used to render the particles\r\n   * @param blendMode Blend mode for which the effect should be retrieved\r\n   * @returns The effect\r\n   */\n\n\n  ParticleSystem.prototype.getCustomEffect = function (blendMode) {\n    var _a;\n\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    return (_a = this._customEffect[blendMode]) !== null && _a !== void 0 ? _a : this._customEffect[0];\n  };\n  /**\r\n   * Sets the custom effect used to render the particles\r\n   * @param effect The effect to set\r\n   * @param blendMode Blend mode for which the effect should be set\r\n   */\n\n\n  ParticleSystem.prototype.setCustomEffect = function (effect, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    this._customEffect[blendMode] = effect;\n  };\n\n  Object.defineProperty(ParticleSystem.prototype, \"onBeforeDrawParticlesObservable\", {\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\n    get: function get() {\n      if (!this._onBeforeDrawParticlesObservable) {\n        this._onBeforeDrawParticlesObservable = new Observable();\n      }\n\n      return this._onBeforeDrawParticlesObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"vertexShaderName\", {\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\n    get: function get() {\n      return \"particles\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ParticleSystem.prototype._addFactorGradient = function (factorGradients, gradient, factor, factor2) {\n    var newGradient = new FactorGradient(gradient, factor, factor2);\n    factorGradients.push(newGradient);\n    factorGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  ParticleSystem.prototype._removeFactorGradient = function (factorGradients, gradient) {\n    if (!factorGradients) {\n      return;\n    }\n\n    var index = 0;\n\n    for (var _i = 0, factorGradients_1 = factorGradients; _i < factorGradients_1.length; _i++) {\n      var factorGradient = factorGradients_1[_i];\n\n      if (factorGradient.gradient === gradient) {\n        factorGradients.splice(index, 1);\n        break;\n      }\n\n      index++;\n    }\n  };\n  /**\r\n   * Adds a new life time gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the life time factor to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addLifeTimeGradient = function (gradient, factor, factor2) {\n    if (!this._lifeTimeGradients) {\n      this._lifeTimeGradients = [];\n    }\n\n    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific life time gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeLifeTimeGradient = function (gradient) {\n    this._removeFactorGradient(this._lifeTimeGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new size gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the size factor to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addSizeGradient = function (gradient, factor, factor2) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n\n    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific size gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeSizeGradient = function (gradient) {\n    this._removeFactorGradient(this._sizeGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new color remap gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param min defines the color remap minimal range\r\n   * @param max defines the color remap maximal range\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addColorRemapGradient = function (gradient, min, max) {\n    if (!this._colorRemapGradients) {\n      this._colorRemapGradients = [];\n    }\n\n    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific color remap gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeColorRemapGradient = function (gradient) {\n    this._removeFactorGradient(this._colorRemapGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new alpha remap gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param min defines the alpha remap minimal range\r\n   * @param max defines the alpha remap maximal range\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addAlphaRemapGradient = function (gradient, min, max) {\n    if (!this._alphaRemapGradients) {\n      this._alphaRemapGradients = [];\n    }\n\n    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific alpha remap gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeAlphaRemapGradient = function (gradient) {\n    this._removeFactorGradient(this._alphaRemapGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new angular speed gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the angular speed  to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addAngularSpeedGradient = function (gradient, factor, factor2) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific angular speed gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeAngularSpeedGradient = function (gradient) {\n    this._removeFactorGradient(this._angularSpeedGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new velocity gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the velocity to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addVelocityGradient = function (gradient, factor, factor2) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n\n    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific velocity gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeVelocityGradient = function (gradient) {\n    this._removeFactorGradient(this._velocityGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new limit velocity gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the limit velocity value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addLimitVelocityGradient = function (gradient, factor, factor2) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific limit velocity gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeLimitVelocityGradient = function (gradient) {\n    this._removeFactorGradient(this._limitVelocityGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new drag gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the drag value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addDragGradient = function (gradient, factor, factor2) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n\n    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific drag gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeDragGradient = function (gradient) {\n    this._removeFactorGradient(this._dragGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the emit rate value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addEmitRateGradient = function (gradient, factor, factor2) {\n    if (!this._emitRateGradients) {\n      this._emitRateGradients = [];\n    }\n\n    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific emit rate gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeEmitRateGradient = function (gradient) {\n    this._removeFactorGradient(this._emitRateGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the start size value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addStartSizeGradient = function (gradient, factor, factor2) {\n    if (!this._startSizeGradients) {\n      this._startSizeGradients = [];\n    }\n\n    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific start size gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeStartSizeGradient = function (gradient) {\n    this._removeFactorGradient(this._startSizeGradients, gradient);\n\n    return this;\n  };\n\n  ParticleSystem.prototype._createRampGradientTexture = function () {\n    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\n      return;\n    }\n\n    var data = new Uint8Array(this._rawTextureWidth * 4);\n    var tmpColor = TmpColors.Color3[0];\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      var ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._rampGradients, function (currentGradient, nextGradient, scale) {\n        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = 255;\n      });\n    }\n\n    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  };\n  /**\r\n   * Gets the current list of ramp gradients.\r\n   * You must use addRampGradient and removeRampGradient to udpate this list\r\n   * @returns the list of ramp gradients\r\n   */\n\n\n  ParticleSystem.prototype.getRampGradients = function () {\n    return this._rampGradients;\n  };\n  /** Force the system to rebuild all gradients that need to be resync */\n\n\n  ParticleSystem.prototype.forceRefreshGradients = function () {\n    this._syncRampGradientTexture();\n  };\n\n  ParticleSystem.prototype._syncRampGradientTexture = function () {\n    if (!this._rampGradients) {\n      return;\n    }\n\n    this._rampGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n\n      this._rampGradientsTexture = null;\n    }\n\n    this._createRampGradientTexture();\n  };\n  /**\r\n   * Adds a new ramp gradient used to remap particle colors\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param color defines the color to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addRampGradient = function (gradient, color) {\n    if (!this._rampGradients) {\n      this._rampGradients = [];\n    }\n\n    var rampGradient = new Color3Gradient(gradient, color);\n\n    this._rampGradients.push(rampGradient);\n\n    this._syncRampGradientTexture();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific ramp gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeRampGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\n\n    this._rampGradientsTexture = null;\n\n    if (this._rampGradients && this._rampGradients.length > 0) {\n      this._createRampGradientTexture();\n    }\n\n    return this;\n  };\n  /**\r\n   * Adds a new color gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param color1 defines the color to affect to the specified gradient\r\n   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n   * @returns this particle system\r\n   */\n\n\n  ParticleSystem.prototype.addColorGradient = function (gradient, color1, color2) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n\n    var colorGradient = new ColorGradient(gradient, color1, color2);\n\n    this._colorGradients.push(colorGradient);\n\n    this._colorGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    return this;\n  };\n  /**\r\n   * Remove a specific color gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns this particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeColorGradient = function (gradient) {\n    if (!this._colorGradients) {\n      return this;\n    }\n\n    var index = 0;\n\n    for (var _i = 0, _a = this._colorGradients; _i < _a.length; _i++) {\n      var colorGradient = _a[_i];\n\n      if (colorGradient.gradient === gradient) {\n        this._colorGradients.splice(index, 1);\n\n        break;\n      }\n\n      index++;\n    }\n\n    return this;\n  };\n\n  ParticleSystem.prototype._fetchR = function (u, v, width, height, pixels) {\n    u = Math.abs(u) * 0.5 + 0.5;\n    v = Math.abs(v) * 0.5 + 0.5;\n    var wrappedU = u * width % width | 0;\n    var wrappedV = v * height % height | 0;\n    var position = (wrappedU + wrappedV * width) * 4;\n    return pixels[position] / 255;\n  };\n\n  ParticleSystem.prototype._reset = function () {\n    this._resetEffect();\n  };\n\n  ParticleSystem.prototype._resetEffect = function () {\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n\n      this._vertexBuffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    this._createVertexBuffers();\n  };\n\n  ParticleSystem.prototype._createVertexBuffers = function () {\n    this._vertexBufferSize = this._useInstancing ? 10 : 12;\n\n    if (this._isAnimationSheetEnabled) {\n      this._vertexBufferSize += 1;\n    }\n\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      this._vertexBufferSize += 3;\n    }\n\n    if (this._useRampGradients) {\n      this._vertexBufferSize += 4;\n    }\n\n    var engine = this._engine;\n    this._vertexData = new Float32Array(this._capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n    this._vertexBuffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n    var dataOffset = 0;\n\n    var positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    dataOffset += 3;\n\n    var colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n    dataOffset += 4;\n\n    var options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[\"angle\"] = options;\n    dataOffset += 1;\n\n    var size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[\"size\"] = size;\n    dataOffset += 2;\n\n    if (this._isAnimationSheetEnabled) {\n      var cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\n      dataOffset += 1;\n    }\n\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      var directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"direction\"] = directionBuffer;\n      dataOffset += 3;\n    }\n\n    if (this._useRampGradients) {\n      var rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"remapData\"] = rampDataBuffer;\n      dataOffset += 4;\n    }\n\n    var offsets;\n\n    if (this._useInstancing) {\n      var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n    } else {\n      offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n      dataOffset += 2;\n    }\n\n    this._vertexBuffers[\"offset\"] = offsets;\n  };\n\n  ParticleSystem.prototype._createIndexBuffer = function () {\n    if (this._useInstancing) {\n      return;\n    }\n\n    var indices = [];\n    var index = 0;\n\n    for (var count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      index += 4;\n    }\n\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  };\n  /**\r\n   * Gets the maximum number of particles active at the same time.\r\n   * @returns The max number of active particles.\r\n   */\n\n\n  ParticleSystem.prototype.getCapacity = function () {\n    return this._capacity;\n  };\n  /**\r\n   * Gets whether there are still active particles in the system.\r\n   * @returns True if it is alive, otherwise false.\r\n   */\n\n\n  ParticleSystem.prototype.isAlive = function () {\n    return this._alive;\n  };\n  /**\r\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n   * @returns True if it has been started, otherwise false.\r\n   */\n\n\n  ParticleSystem.prototype.isStarted = function () {\n    return this._started;\n  };\n\n  ParticleSystem.prototype._prepareSubEmitterInternalArray = function () {\n    var _this = this;\n\n    this._subEmitters = new Array();\n\n    if (this.subEmitters) {\n      this.subEmitters.forEach(function (subEmitter) {\n        if (subEmitter instanceof ParticleSystem) {\n          _this._subEmitters.push([new SubEmitter(subEmitter)]);\n        } else if (subEmitter instanceof SubEmitter) {\n          _this._subEmitters.push([subEmitter]);\n        } else if (subEmitter instanceof Array) {\n          _this._subEmitters.push(subEmitter);\n        }\n      });\n    }\n  };\n  /**\r\n   * Starts the particle system and begins to emit\r\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n   */\n\n\n  ParticleSystem.prototype.start = function (delay) {\n    var _this = this;\n\n    var _a;\n\n    if (delay === void 0) {\n      delay = this.startDelay;\n    }\n\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n\n    if (delay) {\n      setTimeout(function () {\n        _this.start(0);\n      }, delay);\n      return;\n    } // Convert the subEmitters field to the constant type field _subEmitters\n\n\n    this._prepareSubEmitterInternalArray();\n\n    this._started = true;\n    this._stopped = false;\n    this._actualFrame = 0;\n\n    if (this._subEmitters && this._subEmitters.length != 0) {\n      this.activeSubSystems = new Array();\n    } // Reset emit gradient so it acts the same on every start\n\n\n    if (this._emitRateGradients) {\n      if (this._emitRateGradients.length > 0) {\n        this._currentEmitRateGradient = this._emitRateGradients[0];\n        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\n        this._currentEmitRate2 = this._currentEmitRate1;\n      }\n\n      if (this._emitRateGradients.length > 1) {\n        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\n      }\n    } // Reset start size gradient so it acts the same on every start\n\n\n    if (this._startSizeGradients) {\n      if (this._startSizeGradients.length > 0) {\n        this._currentStartSizeGradient = this._startSizeGradients[0];\n        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\n        this._currentStartSize2 = this._currentStartSize1;\n      }\n\n      if (this._startSizeGradients.length > 1) {\n        this._currentStartSize2 = this._startSizeGradients[1].getFactor();\n      }\n    }\n\n    if (this.preWarmCycles) {\n      if (((_a = this.emitter) === null || _a === void 0 ? void 0 : _a.getClassName().indexOf(\"Mesh\")) !== -1) {\n        this.emitter.computeWorldMatrix(true);\n      }\n\n      var noiseTextureAsProcedural_1 = this.noiseTexture;\n\n      if (noiseTextureAsProcedural_1 && noiseTextureAsProcedural_1.onGeneratedObservable) {\n        noiseTextureAsProcedural_1.onGeneratedObservable.addOnce(function () {\n          setTimeout(function () {\n            for (var index = 0; index < _this.preWarmCycles; index++) {\n              _this.animate(true);\n\n              noiseTextureAsProcedural_1.render();\n            }\n          });\n        });\n      } else {\n        for (var index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n        }\n      }\n    } // Animations\n\n\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  };\n  /**\r\n   * Stops the particle system.\r\n   * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\r\n   */\n\n\n  ParticleSystem.prototype.stop = function (stopSubEmitters) {\n    if (stopSubEmitters === void 0) {\n      stopSubEmitters = true;\n    }\n\n    if (this._stopped) {\n      return;\n    }\n\n    this.onStoppedObservable.notifyObservers(this);\n    this._stopped = true;\n\n    if (stopSubEmitters) {\n      this._stopSubEmitters();\n    }\n  }; // animation sheet\n\n  /**\r\n   * Remove all active particles\r\n   */\n\n\n  ParticleSystem.prototype.reset = function () {\n    this._stockParticles = [];\n    this._particles = [];\n  };\n  /**\r\n   * @hidden (for internal use only)\r\n   */\n\n\n  ParticleSystem.prototype._appendParticleVertex = function (index, particle, offsetX, offsetY) {\n    var offset = index * this._vertexBufferSize;\n    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\n    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\n    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\n    this._vertexData[offset++] = particle.color.r;\n    this._vertexData[offset++] = particle.color.g;\n    this._vertexData[offset++] = particle.color.b;\n    this._vertexData[offset++] = particle.color.a;\n    this._vertexData[offset++] = particle.angle;\n    this._vertexData[offset++] = particle.scale.x * particle.size;\n    this._vertexData[offset++] = particle.scale.y * particle.size;\n\n    if (this._isAnimationSheetEnabled) {\n      this._vertexData[offset++] = particle.cellIndex;\n    }\n\n    if (!this._isBillboardBased) {\n      if (particle._initialDirection) {\n        var initialDirection = particle._initialDirection;\n\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          initialDirection = TmpVectors.Vector3[0];\n        }\n\n        if (initialDirection.x === 0 && initialDirection.z === 0) {\n          initialDirection.x = 0.001;\n        }\n\n        this._vertexData[offset++] = initialDirection.x;\n        this._vertexData[offset++] = initialDirection.y;\n        this._vertexData[offset++] = initialDirection.z;\n      } else {\n        var direction = particle.direction;\n\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          direction = TmpVectors.Vector3[0];\n        }\n\n        if (direction.x === 0 && direction.z === 0) {\n          direction.x = 0.001;\n        }\n\n        this._vertexData[offset++] = direction.x;\n        this._vertexData[offset++] = direction.y;\n        this._vertexData[offset++] = direction.z;\n      }\n    } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      this._vertexData[offset++] = particle.direction.x;\n      this._vertexData[offset++] = particle.direction.y;\n      this._vertexData[offset++] = particle.direction.z;\n    }\n\n    if (this._useRampGradients && particle.remapData) {\n      this._vertexData[offset++] = particle.remapData.x;\n      this._vertexData[offset++] = particle.remapData.y;\n      this._vertexData[offset++] = particle.remapData.z;\n      this._vertexData[offset++] = particle.remapData.w;\n    }\n\n    if (!this._useInstancing) {\n      if (this._isAnimationSheetEnabled) {\n        if (offsetX === 0) {\n          offsetX = this._epsilon;\n        } else if (offsetX === 1) {\n          offsetX = 1 - this._epsilon;\n        }\n\n        if (offsetY === 0) {\n          offsetY = this._epsilon;\n        } else if (offsetY === 1) {\n          offsetY = 1 - this._epsilon;\n        }\n      }\n\n      this._vertexData[offset++] = offsetX;\n      this._vertexData[offset++] = offsetY;\n    }\n  };\n\n  ParticleSystem.prototype._stopSubEmitters = function () {\n    if (!this.activeSubSystems) {\n      return;\n    }\n\n    this.activeSubSystems.forEach(function (subSystem) {\n      subSystem.stop(true);\n    });\n    this.activeSubSystems = new Array();\n  };\n\n  ParticleSystem.prototype._removeFromRoot = function () {\n    if (!this._rootParticleSystem) {\n      return;\n    }\n\n    var index = this._rootParticleSystem.activeSubSystems.indexOf(this);\n\n    if (index !== -1) {\n      this._rootParticleSystem.activeSubSystems.splice(index, 1);\n    }\n\n    this._rootParticleSystem = null;\n  }; // End of sub system methods\n\n\n  ParticleSystem.prototype._update = function (newParticles) {\n    var _this = this; // Update current\n\n\n    this._alive = this._particles.length > 0;\n\n    if (this.emitter.position) {\n      var emitterMesh = this.emitter;\n      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\n    } else {\n      var emitterPosition = this.emitter;\n      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n\n    this.updateFunction(this._particles); // Add new ones\n\n    var particle;\n\n    var _loop_2 = function _loop_2() {\n      if (this_1._particles.length === this_1._capacity) {\n        return \"break\";\n      }\n\n      particle = this_1._createParticle();\n\n      this_1._particles.push(particle); // Life time\n\n\n      if (this_1.targetStopDuration && this_1._lifeTimeGradients && this_1._lifeTimeGradients.length > 0) {\n        var ratio_1 = Scalar.Clamp(this_1._actualFrame / this_1.targetStopDuration);\n        GradientHelper.GetCurrentGradient(ratio_1, this_1._lifeTimeGradients, function (currentGradient, nextGradient) {\n          var factorGradient1 = currentGradient;\n          var factorGradient2 = nextGradient;\n          var lifeTime1 = factorGradient1.getFactor();\n          var lifeTime2 = factorGradient2.getFactor();\n          var gradient = (ratio_1 - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\n          particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\n        });\n      } else {\n        particle.lifeTime = Scalar.RandomRange(this_1.minLifeTime, this_1.maxLifeTime);\n      } // Emitter\n\n\n      var emitPower = Scalar.RandomRange(this_1.minEmitPower, this_1.maxEmitPower);\n\n      if (this_1.startPositionFunction) {\n        this_1.startPositionFunction(this_1._emitterWorldMatrix, particle.position, particle, this_1.isLocal);\n      } else {\n        this_1.particleEmitterType.startPositionFunction(this_1._emitterWorldMatrix, particle.position, particle, this_1.isLocal);\n      }\n\n      if (this_1.isLocal) {\n        if (!particle._localPosition) {\n          particle._localPosition = particle.position.clone();\n        } else {\n          particle._localPosition.copyFrom(particle.position);\n        }\n\n        Vector3.TransformCoordinatesToRef(particle._localPosition, this_1._emitterWorldMatrix, particle.position);\n      }\n\n      if (this_1.startDirectionFunction) {\n        this_1.startDirectionFunction(this_1._emitterWorldMatrix, particle.direction, particle, this_1.isLocal);\n      } else {\n        this_1.particleEmitterType.startDirectionFunction(this_1._emitterWorldMatrix, particle.direction, particle, this_1.isLocal);\n      }\n\n      if (emitPower === 0) {\n        if (!particle._initialDirection) {\n          particle._initialDirection = particle.direction.clone();\n        } else {\n          particle._initialDirection.copyFrom(particle.direction);\n        }\n      } else {\n        particle._initialDirection = null;\n      }\n\n      particle.direction.scaleInPlace(emitPower); // Size\n\n      if (!this_1._sizeGradients || this_1._sizeGradients.length === 0) {\n        particle.size = Scalar.RandomRange(this_1.minSize, this_1.maxSize);\n      } else {\n        particle._currentSizeGradient = this_1._sizeGradients[0];\n        particle._currentSize1 = particle._currentSizeGradient.getFactor();\n        particle.size = particle._currentSize1;\n\n        if (this_1._sizeGradients.length > 1) {\n          particle._currentSize2 = this_1._sizeGradients[1].getFactor();\n        } else {\n          particle._currentSize2 = particle._currentSize1;\n        }\n      } // Size and scale\n\n\n      particle.scale.copyFromFloats(Scalar.RandomRange(this_1.minScaleX, this_1.maxScaleX), Scalar.RandomRange(this_1.minScaleY, this_1.maxScaleY)); // Adjust scale by start size\n\n      if (this_1._startSizeGradients && this_1._startSizeGradients[0] && this_1.targetStopDuration) {\n        var ratio = this_1._actualFrame / this_1.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this_1._startSizeGradients, function (currentGradient, nextGradient, scale) {\n          if (currentGradient !== _this._currentStartSizeGradient) {\n            _this._currentStartSize1 = _this._currentStartSize2;\n            _this._currentStartSize2 = nextGradient.getFactor();\n            _this._currentStartSizeGradient = currentGradient;\n          }\n\n          var value = Scalar.Lerp(_this._currentStartSize1, _this._currentStartSize2, scale);\n          particle.scale.scaleInPlace(value);\n        });\n      } // Angle\n\n\n      if (!this_1._angularSpeedGradients || this_1._angularSpeedGradients.length === 0) {\n        particle.angularSpeed = Scalar.RandomRange(this_1.minAngularSpeed, this_1.maxAngularSpeed);\n      } else {\n        particle._currentAngularSpeedGradient = this_1._angularSpeedGradients[0];\n        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\n        particle._currentAngularSpeed1 = particle.angularSpeed;\n\n        if (this_1._angularSpeedGradients.length > 1) {\n          particle._currentAngularSpeed2 = this_1._angularSpeedGradients[1].getFactor();\n        } else {\n          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\n        }\n      }\n\n      particle.angle = Scalar.RandomRange(this_1.minInitialRotation, this_1.maxInitialRotation); // Velocity\n\n      if (this_1._velocityGradients && this_1._velocityGradients.length > 0) {\n        particle._currentVelocityGradient = this_1._velocityGradients[0];\n        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\n\n        if (this_1._velocityGradients.length > 1) {\n          particle._currentVelocity2 = this_1._velocityGradients[1].getFactor();\n        } else {\n          particle._currentVelocity2 = particle._currentVelocity1;\n        }\n      } // Limit velocity\n\n\n      if (this_1._limitVelocityGradients && this_1._limitVelocityGradients.length > 0) {\n        particle._currentLimitVelocityGradient = this_1._limitVelocityGradients[0];\n        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\n\n        if (this_1._limitVelocityGradients.length > 1) {\n          particle._currentLimitVelocity2 = this_1._limitVelocityGradients[1].getFactor();\n        } else {\n          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\n        }\n      } // Drag\n\n\n      if (this_1._dragGradients && this_1._dragGradients.length > 0) {\n        particle._currentDragGradient = this_1._dragGradients[0];\n        particle._currentDrag1 = particle._currentDragGradient.getFactor();\n\n        if (this_1._dragGradients.length > 1) {\n          particle._currentDrag2 = this_1._dragGradients[1].getFactor();\n        } else {\n          particle._currentDrag2 = particle._currentDrag1;\n        }\n      } // Color\n\n\n      if (!this_1._colorGradients || this_1._colorGradients.length === 0) {\n        step = Scalar.RandomRange(0, 1.0);\n        Color4.LerpToRef(this_1.color1, this_1.color2, step, particle.color);\n        this_1.colorDead.subtractToRef(particle.color, this_1._colorDiff);\n\n        this_1._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n      } else {\n        particle._currentColorGradient = this_1._colorGradients[0];\n\n        particle._currentColorGradient.getColorToRef(particle.color);\n\n        particle._currentColor1.copyFrom(particle.color);\n\n        if (this_1._colorGradients.length > 1) {\n          this_1._colorGradients[1].getColorToRef(particle._currentColor2);\n        } else {\n          particle._currentColor2.copyFrom(particle.color);\n        }\n      } // Sheet\n\n\n      if (this_1._isAnimationSheetEnabled) {\n        particle._initialStartSpriteCellID = this_1.startSpriteCellID;\n        particle._initialEndSpriteCellID = this_1.endSpriteCellID;\n      } // Inherited Velocity\n\n\n      particle.direction.addInPlace(this_1._inheritedVelocityOffset); // Ramp\n\n      if (this_1._useRampGradients) {\n        particle.remapData = new Vector4(0, 1, 0, 1);\n      } // Noise texture coordinates\n\n\n      if (this_1.noiseTexture) {\n        if (particle._randomNoiseCoordinates1) {\n          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\n\n          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\n        } else {\n          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\n        }\n      } // Update the position of the attached sub-emitters to match their attached particle\n\n\n      particle._inheritParticleInfoToSubEmitters();\n    };\n\n    var this_1 = this,\n        step;\n\n    for (var index = 0; index < newParticles; index++) {\n      var state_1 = _loop_2();\n\n      if (state_1 === \"break\") break;\n    }\n  };\n  /** @hidden */\n\n\n  ParticleSystem._GetAttributeNamesOrOptions = function (isAnimationSheetEnabled, isBillboardBased, useRampGradients) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (isBillboardBased === void 0) {\n      isBillboardBased = false;\n    }\n\n    if (useRampGradients === void 0) {\n      useRampGradients = false;\n    }\n\n    var attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n\n    if (useRampGradients) {\n      attributeNamesOrOptions.push(\"remapData\");\n    }\n\n    return attributeNamesOrOptions;\n  };\n  /** @hidden */\n\n\n  ParticleSystem._GetEffectCreationOptions = function (isAnimationSheetEnabled) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    var effectCreationOption = [\"invView\", \"view\", \"projection\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"particlesInfos\");\n    }\n\n    return effectCreationOption;\n  };\n  /**\r\n   * Fill the defines array according to the current settings of the particle system\r\n   * @param defines Array to be updated\r\n   * @param blendMode blend mode to take into account when updating the array\r\n   */\n\n\n  ParticleSystem.prototype.fillDefines = function (defines, blendMode) {\n    if (this._scene) {\n      if (this._scene.clipPlane) {\n        defines.push(\"#define CLIPPLANE\");\n      }\n\n      if (this._scene.clipPlane2) {\n        defines.push(\"#define CLIPPLANE2\");\n      }\n\n      if (this._scene.clipPlane3) {\n        defines.push(\"#define CLIPPLANE3\");\n      }\n\n      if (this._scene.clipPlane4) {\n        defines.push(\"#define CLIPPLANE4\");\n      }\n\n      if (this._scene.clipPlane5) {\n        defines.push(\"#define CLIPPLANE5\");\n      }\n\n      if (this._scene.clipPlane6) {\n        defines.push(\"#define CLIPPLANE6\");\n      }\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n\n    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n\n    if (this._useRampGradients) {\n      defines.push(\"#define RAMPGRADIENT\");\n    }\n\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n\n      defines.push(this._imageProcessingConfigurationDefines.toString());\n    }\n  };\n  /**\r\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n   * @param uniforms Uniforms array to fill\r\n   * @param attributes Attributes array to fill\r\n   * @param samplers Samplers array to fill\r\n   */\n\n\n  ParticleSystem.prototype.fillUniformsAttributesAndSamplerNames = function (uniforms, attributes, samplers) {\n    attributes.push.apply(attributes, ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED, this._useRampGradients));\n    uniforms.push.apply(uniforms, ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled));\n    samplers.push(\"diffuseSampler\", \"rampSampler\");\n\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  };\n  /** @hidden */\n\n\n  ParticleSystem.prototype._getEffect = function (blendMode) {\n    var customEffect = this.getCustomEffect(blendMode);\n\n    if (customEffect) {\n      return customEffect;\n    }\n\n    var defines = [];\n    this.fillDefines(defines, blendMode); // Effect\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      var attributesNamesOrOptions = [];\n      var effectCreationOption = [];\n      var samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\n      this._effect = this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join);\n    }\n\n    return this._effect;\n  };\n  /**\r\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n   * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\r\n   */\n\n\n  ParticleSystem.prototype.animate = function (preWarmOnly) {\n    var _this = this;\n\n    var _a;\n\n    if (preWarmOnly === void 0) {\n      preWarmOnly = false;\n    }\n\n    if (!this._started) {\n      return;\n    }\n\n    if (!preWarmOnly && this._scene) {\n      // Check\n      if (!this.isReady()) {\n        return;\n      }\n\n      if (this._currentRenderId === this._scene.getFrameId()) {\n        return;\n      }\n\n      this._currentRenderId = this._scene.getFrameId();\n    }\n\n    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1); // Determine the number of particles we need to create\n\n    var newParticles;\n\n    if (this.manualEmitCount > -1) {\n      newParticles = this.manualEmitCount;\n      this._newPartsExcess = 0;\n      this.manualEmitCount = 0;\n    } else {\n      var rate_1 = this.emitRate;\n\n      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\n        var ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, function (currentGradient, nextGradient, scale) {\n          if (currentGradient !== _this._currentEmitRateGradient) {\n            _this._currentEmitRate1 = _this._currentEmitRate2;\n            _this._currentEmitRate2 = nextGradient.getFactor();\n            _this._currentEmitRateGradient = currentGradient;\n          }\n\n          rate_1 = Scalar.Lerp(_this._currentEmitRate1, _this._currentEmitRate2, scale);\n        });\n      }\n\n      newParticles = rate_1 * this._scaledUpdateSpeed >> 0;\n      this._newPartsExcess += rate_1 * this._scaledUpdateSpeed - newParticles;\n    }\n\n    if (this._newPartsExcess > 1.0) {\n      newParticles += this._newPartsExcess >> 0;\n      this._newPartsExcess -= this._newPartsExcess >> 0;\n    }\n\n    this._alive = false;\n\n    if (!this._stopped) {\n      this._actualFrame += this._scaledUpdateSpeed;\n\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    } else {\n      newParticles = 0;\n    }\n\n    this._update(newParticles); // Stopped?\n\n\n    if (this._stopped) {\n      if (!this._alive) {\n        this._started = false;\n\n        if (this.onAnimationEnd) {\n          this.onAnimationEnd();\n        }\n\n        if (this.disposeOnStop && this._scene) {\n          this._scene._toBeDisposed.push(this);\n        }\n      }\n    }\n\n    if (!preWarmOnly) {\n      // Update VBO\n      var offset = 0;\n\n      for (var index = 0; index < this._particles.length; index++) {\n        var particle = this._particles[index];\n\n        this._appendParticleVertices(offset, particle);\n\n        offset += this._useInstancing ? 1 : 4;\n      }\n\n      if (this._vertexBuffer) {\n        this._vertexBuffer.update(this._vertexData);\n      }\n    }\n\n    if (this.manualEmitCount === 0 && this.disposeOnStop) {\n      this.stop();\n    }\n  };\n\n  ParticleSystem.prototype._appendParticleVertices = function (offset, particle) {\n    this._appendParticleVertex(offset++, particle, 0, 0);\n\n    if (!this._useInstancing) {\n      this._appendParticleVertex(offset++, particle, 1, 0);\n\n      this._appendParticleVertex(offset++, particle, 1, 1);\n\n      this._appendParticleVertex(offset++, particle, 0, 1);\n    }\n  };\n  /**\r\n   * Rebuilds the particle system.\r\n   */\n\n\n  ParticleSystem.prototype.rebuild = function () {\n    this._createIndexBuffer();\n\n    if (this._vertexBuffer) {\n      this._vertexBuffer._rebuild();\n    }\n\n    for (var key in this._vertexBuffers) {\n      this._vertexBuffers[key]._rebuild();\n    }\n  };\n  /**\r\n   * Is this system ready to be used/rendered\r\n   * @return true if the system is ready\r\n   */\n\n\n  ParticleSystem.prototype.isReady = function () {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n\n    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getEffect(this.blendMode).isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getEffect(ParticleSystem.BLENDMODE_MULTIPLY).isReady()) {\n        return false;\n      }\n\n      if (!this._getEffect(ParticleSystem.BLENDMODE_ADD).isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ParticleSystem.prototype._render = function (blendMode) {\n    var _a, _b;\n\n    var effect = this._getEffect(blendMode);\n\n    var engine = this._engine; // Render\n\n    engine.enableEffect(effect);\n    var viewMatrix = (_a = this.defaultViewMatrix) !== null && _a !== void 0 ? _a : this._scene.getViewMatrix();\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      var baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\n    }\n\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n\n    if (this._isBillboardBased && this._scene) {\n      var camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n\n    if (this._rampGradientsTexture) {\n      if (!this._rampGradients || !this._rampGradients.length) {\n        this._rampGradientsTexture.dispose();\n\n        this._rampGradientsTexture = null;\n      }\n\n      effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\n    }\n\n    var defines = effect.defines;\n\n    if (this._scene) {\n      if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\n        ThinMaterialHelper.BindClipPlane(effect, this._scene);\n      }\n    }\n\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      viewMatrix.invertToRef(TmpVectors.Matrix[0]);\n      effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\n    }\n\n    if (this._vertexArrayObject !== undefined) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n\n      this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    } // image processing\n\n\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    } // Draw order\n\n\n    switch (blendMode) {\n      case ParticleSystem.BLENDMODE_ADD:\n        engine.setAlphaMode(1);\n        break;\n\n      case ParticleSystem.BLENDMODE_ONEONE:\n        engine.setAlphaMode(6);\n        break;\n\n      case ParticleSystem.BLENDMODE_STANDARD:\n        engine.setAlphaMode(2);\n        break;\n\n      case ParticleSystem.BLENDMODE_MULTIPLY:\n        engine.setAlphaMode(4);\n        break;\n    }\n\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    }\n\n    if (this._useInstancing) {\n      engine.drawArraysType(8, 0, 4, this._particles.length);\n    } else {\n      engine.drawElementsType(0, 0, this._particles.length * 6);\n    }\n\n    return this._particles.length;\n  };\n  /**\r\n   * Renders the particle system in its current state.\r\n   * @returns the current number of particles\r\n   */\n\n\n  ParticleSystem.prototype.render = function () {\n    // Check\n    if (!this.isReady() || !this._particles.length) {\n      return 0;\n    }\n\n    var engine = this._engine;\n\n    if (engine.setState) {\n      engine.setState(false);\n\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n    }\n\n    var outparticles = 0;\n\n    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\n    } else {\n      outparticles = this._render(this.blendMode);\n    }\n\n    this._engine.unbindInstanceAttributes();\n\n    this._engine.setAlphaMode(0);\n\n    return outparticles;\n  };\n  /**\r\n   * Disposes the particle system and free the associated resources\r\n   * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n   */\n\n\n  ParticleSystem.prototype.dispose = function (disposeTexture) {\n    if (disposeTexture === void 0) {\n      disposeTexture = true;\n    }\n\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n\n      this._vertexBuffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    }\n\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n\n      this._rampGradientsTexture = null;\n    }\n\n    this._removeFromRoot();\n\n    if (this._subEmitters && this._subEmitters.length) {\n      for (var index = 0; index < this._subEmitters.length; index++) {\n        for (var _i = 0, _a = this._subEmitters[index]; _i < _a.length; _i++) {\n          var subEmitter = _a[_i];\n          subEmitter.dispose();\n        }\n      }\n\n      this._subEmitters = [];\n      this.subEmitters = [];\n    }\n\n    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {\n      this.emitter.dispose(true);\n    }\n\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.clear();\n    } // Remove from scene\n\n\n    if (this._scene) {\n      var index = this._scene.particleSystems.indexOf(this);\n\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n\n      this._scene._activeParticleSystems.dispose();\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onStoppedObservable.clear();\n    this.reset();\n  }; // Clone\n\n  /**\r\n   * Clones the particle system.\r\n   * @param name The name of the cloned object\r\n   * @param newEmitter The new emitter to use\r\n   * @returns the cloned particle system\r\n   */\n\n\n  ParticleSystem.prototype.clone = function (name, newEmitter) {\n    var custom = __assign({}, this._customEffect);\n\n    var program = null;\n    var engine = this._engine;\n\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n      }\n    }\n\n    var serialization = this.serialize();\n    var result = ParticleSystem.Parse(serialization, this._scene || this._engine, \"\");\n    result.name = name;\n    result.customShader = program;\n    result._customEffect = custom;\n\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n\n    result.emitter = newEmitter;\n\n    if (!this.preventAutoStart) {\n      result.start();\n    }\n\n    return result;\n  };\n  /**\r\n   * Serializes the particle system to a JSON object\r\n   * @param serializeTexture defines if the texture must be serialized as well\r\n   * @returns the JSON object\r\n   */\n\n\n  ParticleSystem.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n\n    serializationObject.textureMask = this.textureMask.asArray();\n    serializationObject.customShader = this.customShader;\n    serializationObject.preventAutoStart = this.preventAutoStart; // SubEmitters\n\n    if (this.subEmitters) {\n      serializationObject.subEmitters = [];\n\n      if (!this._subEmitters) {\n        this._prepareSubEmitterInternalArray();\n      }\n\n      for (var _i = 0, _a = this._subEmitters; _i < _a.length; _i++) {\n        var subs = _a[_i];\n        var cell = [];\n\n        for (var _b = 0, subs_1 = subs; _b < subs_1.length; _b++) {\n          var sub = subs_1[_b];\n          cell.push(sub.serialize());\n        }\n\n        serializationObject.subEmitters.push(cell);\n      }\n    }\n\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  ParticleSystem._Serialize = function (serializationObject, particleSystem, serializeTexture) {\n    serializationObject.name = particleSystem.name;\n    serializationObject.id = particleSystem.id;\n    serializationObject.capacity = particleSystem.getCapacity(); // Emitter\n\n    if (particleSystem.emitter.position) {\n      var emitterMesh = particleSystem.emitter;\n      serializationObject.emitterId = emitterMesh.id;\n    } else {\n      var emitterPosition = particleSystem.emitter;\n      serializationObject.emitter = emitterPosition.asArray();\n    } // Emitter\n\n\n    if (particleSystem.particleEmitterType) {\n      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\n    }\n\n    if (particleSystem.particleTexture) {\n      if (serializeTexture) {\n        serializationObject.texture = particleSystem.particleTexture.serialize();\n      } else {\n        serializationObject.textureName = particleSystem.particleTexture.name;\n        serializationObject.invertY = !!particleSystem.particleTexture._invertY;\n      }\n    }\n\n    serializationObject.isLocal = particleSystem.isLocal; // Animations\n\n    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\n    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\n    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\n    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\n    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop; // Particle system\n\n    serializationObject.startDelay = particleSystem.startDelay;\n    serializationObject.renderingGroupId = particleSystem.renderingGroupId;\n    serializationObject.isBillboardBased = particleSystem.isBillboardBased;\n    serializationObject.billboardMode = particleSystem.billboardMode;\n    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\n    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\n    serializationObject.minSize = particleSystem.minSize;\n    serializationObject.maxSize = particleSystem.maxSize;\n    serializationObject.minScaleX = particleSystem.minScaleX;\n    serializationObject.maxScaleX = particleSystem.maxScaleX;\n    serializationObject.minScaleY = particleSystem.minScaleY;\n    serializationObject.maxScaleY = particleSystem.maxScaleY;\n    serializationObject.minEmitPower = particleSystem.minEmitPower;\n    serializationObject.maxEmitPower = particleSystem.maxEmitPower;\n    serializationObject.minLifeTime = particleSystem.minLifeTime;\n    serializationObject.maxLifeTime = particleSystem.maxLifeTime;\n    serializationObject.emitRate = particleSystem.emitRate;\n    serializationObject.gravity = particleSystem.gravity.asArray();\n    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\n    serializationObject.color1 = particleSystem.color1.asArray();\n    serializationObject.color2 = particleSystem.color2.asArray();\n    serializationObject.colorDead = particleSystem.colorDead.asArray();\n    serializationObject.updateSpeed = particleSystem.updateSpeed;\n    serializationObject.targetStopDuration = particleSystem.targetStopDuration;\n    serializationObject.blendMode = particleSystem.blendMode;\n    serializationObject.preWarmCycles = particleSystem.preWarmCycles;\n    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\n    serializationObject.minInitialRotation = particleSystem.minInitialRotation;\n    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\n    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\n    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\n    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\n    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\n    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\n    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\n    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\n    var colorGradients = particleSystem.getColorGradients();\n\n    if (colorGradients) {\n      serializationObject.colorGradients = [];\n\n      for (var _i = 0, colorGradients_1 = colorGradients; _i < colorGradients_1.length; _i++) {\n        var colorGradient = colorGradients_1[_i];\n        var serializedGradient = {\n          gradient: colorGradient.gradient,\n          color1: colorGradient.color1.asArray()\n        };\n\n        if (colorGradient.color2) {\n          serializedGradient.color2 = colorGradient.color2.asArray();\n        } else {\n          serializedGradient.color2 = colorGradient.color1.asArray();\n        }\n\n        serializationObject.colorGradients.push(serializedGradient);\n      }\n    }\n\n    var rampGradients = particleSystem.getRampGradients();\n\n    if (rampGradients) {\n      serializationObject.rampGradients = [];\n\n      for (var _a = 0, rampGradients_1 = rampGradients; _a < rampGradients_1.length; _a++) {\n        var rampGradient = rampGradients_1[_a];\n        var serializedGradient = {\n          gradient: rampGradient.gradient,\n          color: rampGradient.color.asArray()\n        };\n        serializationObject.rampGradients.push(serializedGradient);\n      }\n\n      serializationObject.useRampGradients = particleSystem.useRampGradients;\n    }\n\n    var colorRemapGradients = particleSystem.getColorRemapGradients();\n\n    if (colorRemapGradients) {\n      serializationObject.colorRemapGradients = [];\n\n      for (var _b = 0, colorRemapGradients_1 = colorRemapGradients; _b < colorRemapGradients_1.length; _b++) {\n        var colorRemapGradient = colorRemapGradients_1[_b];\n        var serializedGradient = {\n          gradient: colorRemapGradient.gradient,\n          factor1: colorRemapGradient.factor1\n        };\n\n        if (colorRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = colorRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = colorRemapGradient.factor1;\n        }\n\n        serializationObject.colorRemapGradients.push(serializedGradient);\n      }\n    }\n\n    var alphaRemapGradients = particleSystem.getAlphaRemapGradients();\n\n    if (alphaRemapGradients) {\n      serializationObject.alphaRemapGradients = [];\n\n      for (var _c = 0, alphaRemapGradients_1 = alphaRemapGradients; _c < alphaRemapGradients_1.length; _c++) {\n        var alphaRemapGradient = alphaRemapGradients_1[_c];\n        var serializedGradient = {\n          gradient: alphaRemapGradient.gradient,\n          factor1: alphaRemapGradient.factor1\n        };\n\n        if (alphaRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = alphaRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = alphaRemapGradient.factor1;\n        }\n\n        serializationObject.alphaRemapGradients.push(serializedGradient);\n      }\n    }\n\n    var sizeGradients = particleSystem.getSizeGradients();\n\n    if (sizeGradients) {\n      serializationObject.sizeGradients = [];\n\n      for (var _d = 0, sizeGradients_1 = sizeGradients; _d < sizeGradients_1.length; _d++) {\n        var sizeGradient = sizeGradients_1[_d];\n        var serializedGradient = {\n          gradient: sizeGradient.gradient,\n          factor1: sizeGradient.factor1\n        };\n\n        if (sizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = sizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = sizeGradient.factor1;\n        }\n\n        serializationObject.sizeGradients.push(serializedGradient);\n      }\n    }\n\n    var angularSpeedGradients = particleSystem.getAngularSpeedGradients();\n\n    if (angularSpeedGradients) {\n      serializationObject.angularSpeedGradients = [];\n\n      for (var _e = 0, angularSpeedGradients_1 = angularSpeedGradients; _e < angularSpeedGradients_1.length; _e++) {\n        var angularSpeedGradient = angularSpeedGradients_1[_e];\n        var serializedGradient = {\n          gradient: angularSpeedGradient.gradient,\n          factor1: angularSpeedGradient.factor1\n        };\n\n        if (angularSpeedGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = angularSpeedGradient.factor2;\n        } else {\n          serializedGradient.factor2 = angularSpeedGradient.factor1;\n        }\n\n        serializationObject.angularSpeedGradients.push(serializedGradient);\n      }\n    }\n\n    var velocityGradients = particleSystem.getVelocityGradients();\n\n    if (velocityGradients) {\n      serializationObject.velocityGradients = [];\n\n      for (var _f = 0, velocityGradients_1 = velocityGradients; _f < velocityGradients_1.length; _f++) {\n        var velocityGradient = velocityGradients_1[_f];\n        var serializedGradient = {\n          gradient: velocityGradient.gradient,\n          factor1: velocityGradient.factor1\n        };\n\n        if (velocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = velocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = velocityGradient.factor1;\n        }\n\n        serializationObject.velocityGradients.push(serializedGradient);\n      }\n    }\n\n    var dragGradients = particleSystem.getDragGradients();\n\n    if (dragGradients) {\n      serializationObject.dragGradients = [];\n\n      for (var _g = 0, dragGradients_1 = dragGradients; _g < dragGradients_1.length; _g++) {\n        var dragGradient = dragGradients_1[_g];\n        var serializedGradient = {\n          gradient: dragGradient.gradient,\n          factor1: dragGradient.factor1\n        };\n\n        if (dragGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = dragGradient.factor2;\n        } else {\n          serializedGradient.factor2 = dragGradient.factor1;\n        }\n\n        serializationObject.dragGradients.push(serializedGradient);\n      }\n    }\n\n    var emitRateGradients = particleSystem.getEmitRateGradients();\n\n    if (emitRateGradients) {\n      serializationObject.emitRateGradients = [];\n\n      for (var _h = 0, emitRateGradients_1 = emitRateGradients; _h < emitRateGradients_1.length; _h++) {\n        var emitRateGradient = emitRateGradients_1[_h];\n        var serializedGradient = {\n          gradient: emitRateGradient.gradient,\n          factor1: emitRateGradient.factor1\n        };\n\n        if (emitRateGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = emitRateGradient.factor2;\n        } else {\n          serializedGradient.factor2 = emitRateGradient.factor1;\n        }\n\n        serializationObject.emitRateGradients.push(serializedGradient);\n      }\n    }\n\n    var startSizeGradients = particleSystem.getStartSizeGradients();\n\n    if (startSizeGradients) {\n      serializationObject.startSizeGradients = [];\n\n      for (var _j = 0, startSizeGradients_1 = startSizeGradients; _j < startSizeGradients_1.length; _j++) {\n        var startSizeGradient = startSizeGradients_1[_j];\n        var serializedGradient = {\n          gradient: startSizeGradient.gradient,\n          factor1: startSizeGradient.factor1\n        };\n\n        if (startSizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = startSizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = startSizeGradient.factor1;\n        }\n\n        serializationObject.startSizeGradients.push(serializedGradient);\n      }\n    }\n\n    var lifeTimeGradients = particleSystem.getLifeTimeGradients();\n\n    if (lifeTimeGradients) {\n      serializationObject.lifeTimeGradients = [];\n\n      for (var _k = 0, lifeTimeGradients_1 = lifeTimeGradients; _k < lifeTimeGradients_1.length; _k++) {\n        var lifeTimeGradient = lifeTimeGradients_1[_k];\n        var serializedGradient = {\n          gradient: lifeTimeGradient.gradient,\n          factor1: lifeTimeGradient.factor1\n        };\n\n        if (lifeTimeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = lifeTimeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = lifeTimeGradient.factor1;\n        }\n\n        serializationObject.lifeTimeGradients.push(serializedGradient);\n      }\n    }\n\n    var limitVelocityGradients = particleSystem.getLimitVelocityGradients();\n\n    if (limitVelocityGradients) {\n      serializationObject.limitVelocityGradients = [];\n\n      for (var _l = 0, limitVelocityGradients_1 = limitVelocityGradients; _l < limitVelocityGradients_1.length; _l++) {\n        var limitVelocityGradient = limitVelocityGradients_1[_l];\n        var serializedGradient = {\n          gradient: limitVelocityGradient.gradient,\n          factor1: limitVelocityGradient.factor1\n        };\n\n        if (limitVelocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = limitVelocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = limitVelocityGradient.factor1;\n        }\n\n        serializationObject.limitVelocityGradients.push(serializedGradient);\n      }\n\n      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\n    }\n\n    if (particleSystem.noiseTexture) {\n      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\n    }\n  };\n  /** @hidden */\n\n\n  ParticleSystem._Parse = function (parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {\n    var scene;\n\n    if (sceneOrEngine instanceof ThinEngine) {\n      scene = null;\n    } else {\n      scene = sceneOrEngine;\n    }\n\n    var internalClass = _TypeStore.GetClass(\"BABYLON.Texture\");\n\n    if (internalClass && scene) {\n      // Texture\n      if (parsedParticleSystem.texture) {\n        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);\n      } else if (parsedParticleSystem.textureName) {\n        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);\n        particleSystem.particleTexture.name = parsedParticleSystem.textureName;\n      }\n    } // Emitter\n\n\n    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\n      particleSystem.emitter = Vector3.Zero();\n    } else if (parsedParticleSystem.emitterId && scene) {\n      particleSystem.emitter = scene.getLastMeshByID(parsedParticleSystem.emitterId);\n    } else {\n      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\n    }\n\n    particleSystem.isLocal = !!parsedParticleSystem.isLocal; // Misc.\n\n    if (parsedParticleSystem.renderingGroupId !== undefined) {\n      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\n    }\n\n    if (parsedParticleSystem.isBillboardBased !== undefined) {\n      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\n    }\n\n    if (parsedParticleSystem.billboardMode !== undefined) {\n      particleSystem.billboardMode = parsedParticleSystem.billboardMode;\n    } // Animations\n\n\n    if (parsedParticleSystem.animations) {\n      for (var animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n        var parsedAnimation = parsedParticleSystem.animations[animationIndex];\n\n        var internalClass_1 = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass_1) {\n          particleSystem.animations.push(internalClass_1.Parse(parsedAnimation));\n        }\n      }\n\n      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\n      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\n      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\n      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\n    }\n\n    if (parsedParticleSystem.autoAnimate && scene) {\n      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n    } // Particle system\n\n\n    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\n    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n    particleSystem.minSize = parsedParticleSystem.minSize;\n    particleSystem.maxSize = parsedParticleSystem.maxSize;\n\n    if (parsedParticleSystem.minScaleX) {\n      particleSystem.minScaleX = parsedParticleSystem.minScaleX;\n      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\n      particleSystem.minScaleY = parsedParticleSystem.minScaleY;\n      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\n    }\n\n    if (parsedParticleSystem.preWarmCycles !== undefined) {\n      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\n      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\n    }\n\n    if (parsedParticleSystem.minInitialRotation !== undefined) {\n      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\n      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\n    }\n\n    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n    particleSystem.emitRate = parsedParticleSystem.emitRate;\n    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\n\n    if (parsedParticleSystem.noiseStrength) {\n      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\n    }\n\n    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\n    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\n    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\n    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n    particleSystem.blendMode = parsedParticleSystem.blendMode;\n\n    if (parsedParticleSystem.colorGradients) {\n      for (var _i = 0, _a = parsedParticleSystem.colorGradients; _i < _a.length; _i++) {\n        var colorGradient = _a[_i];\n        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);\n      }\n    }\n\n    if (parsedParticleSystem.rampGradients) {\n      for (var _b = 0, _c = parsedParticleSystem.rampGradients; _b < _c.length; _b++) {\n        var rampGradient = _c[_b];\n        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\n      }\n\n      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\n    }\n\n    if (parsedParticleSystem.colorRemapGradients) {\n      for (var _d = 0, _e = parsedParticleSystem.colorRemapGradients; _d < _e.length; _d++) {\n        var colorRemapGradient = _e[_d];\n        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.alphaRemapGradients) {\n      for (var _f = 0, _g = parsedParticleSystem.alphaRemapGradients; _f < _g.length; _f++) {\n        var alphaRemapGradient = _g[_f];\n        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.sizeGradients) {\n      for (var _h = 0, _j = parsedParticleSystem.sizeGradients; _h < _j.length; _h++) {\n        var sizeGradient = _j[_h];\n        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.angularSpeedGradients) {\n      for (var _k = 0, _l = parsedParticleSystem.angularSpeedGradients; _k < _l.length; _k++) {\n        var angularSpeedGradient = _l[_k];\n        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.velocityGradients) {\n      for (var _m = 0, _o = parsedParticleSystem.velocityGradients; _m < _o.length; _m++) {\n        var velocityGradient = _o[_m];\n        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.dragGradients) {\n      for (var _p = 0, _q = parsedParticleSystem.dragGradients; _p < _q.length; _p++) {\n        var dragGradient = _q[_p];\n        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.emitRateGradients) {\n      for (var _r = 0, _s = parsedParticleSystem.emitRateGradients; _r < _s.length; _r++) {\n        var emitRateGradient = _s[_r];\n        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.startSizeGradients) {\n      for (var _t = 0, _u = parsedParticleSystem.startSizeGradients; _t < _u.length; _t++) {\n        var startSizeGradient = _u[_t];\n        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.lifeTimeGradients) {\n      for (var _v = 0, _w = parsedParticleSystem.lifeTimeGradients; _v < _w.length; _v++) {\n        var lifeTimeGradient = _w[_v];\n        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.limitVelocityGradients) {\n      for (var _x = 0, _y = parsedParticleSystem.limitVelocityGradients; _x < _y.length; _x++) {\n        var limitVelocityGradient = _y[_x];\n        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);\n      }\n\n      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\n    }\n\n    if (parsedParticleSystem.noiseTexture && scene) {\n      var internalClass_2 = _TypeStore.GetClass(\"BABYLON.ProceduralTexture\");\n\n      particleSystem.noiseTexture = internalClass_2.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\n    } // Emitter\n\n\n    var emitterType;\n\n    if (parsedParticleSystem.particleEmitterType) {\n      switch (parsedParticleSystem.particleEmitterType.type) {\n        case \"SphereParticleEmitter\":\n          emitterType = new SphereParticleEmitter();\n          break;\n\n        case \"SphereDirectedParticleEmitter\":\n          emitterType = new SphereDirectedParticleEmitter();\n          break;\n\n        case \"ConeEmitter\":\n        case \"ConeParticleEmitter\":\n          emitterType = new ConeParticleEmitter();\n          break;\n\n        case \"CylinderParticleEmitter\":\n          emitterType = new CylinderParticleEmitter();\n          break;\n\n        case \"CylinderDirectedParticleEmitter\":\n          emitterType = new CylinderDirectedParticleEmitter();\n          break;\n\n        case \"HemisphericParticleEmitter\":\n          emitterType = new HemisphericParticleEmitter();\n          break;\n\n        case \"PointParticleEmitter\":\n          emitterType = new PointParticleEmitter();\n          break;\n\n        case \"MeshParticleEmitter\":\n          emitterType = new MeshParticleEmitter();\n          break;\n\n        case \"BoxEmitter\":\n        case \"BoxParticleEmitter\":\n        default:\n          emitterType = new BoxParticleEmitter();\n          break;\n      }\n\n      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\n    } else {\n      emitterType = new BoxParticleEmitter();\n      emitterType.parse(parsedParticleSystem, scene);\n    }\n\n    particleSystem.particleEmitterType = emitterType; // Animation sheet\n\n    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\n    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\n    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\n    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\n    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\n    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\n  };\n  /**\r\n   * Parses a JSON object to create a particle system.\r\n   * @param parsedParticleSystem The JSON object to parse\r\n   * @param sceneOrEngine The scene or the engine to create the particle system in\r\n   * @param rootUrl The root url to use to load external dependencies like texture\r\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n   * @returns the Parsed particle system\r\n   */\n\n\n  ParticleSystem.Parse = function (parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart) {\n    if (doNotStart === void 0) {\n      doNotStart = false;\n    }\n\n    var name = parsedParticleSystem.name;\n    var custom = null;\n    var program = null;\n    var engine;\n    var scene;\n\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      program = parsedParticleSystem.customShader;\n      var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n    }\n\n    var particleSystem = new ParticleSystem(name, parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem.customShader = program;\n\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    } // SubEmitters\n\n\n    if (parsedParticleSystem.subEmitters) {\n      particleSystem.subEmitters = [];\n\n      for (var _i = 0, _a = parsedParticleSystem.subEmitters; _i < _a.length; _i++) {\n        var cell = _a[_i];\n        var cellArray = [];\n\n        for (var _b = 0, cell_1 = cell; _b < cell_1.length; _b++) {\n          var sub = cell_1[_b];\n          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\n        }\n\n        particleSystem.subEmitters.push(cellArray);\n      }\n    }\n\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n\n    if (parsedParticleSystem.textureMask) {\n      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\n    } // Auto start\n\n\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n\n    return particleSystem;\n  };\n  /**\r\n   * Billboard mode will only apply to Y axis\r\n   */\n\n\n  ParticleSystem.BILLBOARDMODE_Y = 2;\n  /**\r\n   * Billboard mode will apply to all axes\r\n   */\n\n  ParticleSystem.BILLBOARDMODE_ALL = 7;\n  /**\r\n   * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\r\n   */\n\n  ParticleSystem.BILLBOARDMODE_STRETCHED = 8;\n  return ParticleSystem;\n}(BaseParticleSystem);\n\nexport { ParticleSystem };\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;","map":null,"metadata":{},"sourceType":"module"}