{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _slicedToArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar rlp_1 = require(\"rlp\");\n\nvar address_1 = require(\"../address\");\n\nvar account_1 = tslib_1.__importDefault(require(\"../eth-lib/account\"));\n\nvar bytes_1 = tslib_1.__importDefault(require(\"../eth-lib/bytes\"));\n\nvar nat_1 = tslib_1.__importDefault(require(\"../eth-lib/nat\"));\n\nvar rlp_2 = tslib_1.__importDefault(require(\"../eth-lib/rlp\"));\n\nvar formatters_1 = require(\"../formatters\");\n\nvar utils_1 = require(\"../utils\");\n\nfunction signTransaction(_x, _x2, _x3) {\n  return _signTransaction.apply(this, arguments);\n}\n\nfunction _signTransaction() {\n  _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tx, privateKey, eth) {\n    var promises, _yield$Promise$all, _yield$Promise$all2, chainId, gasPrice, nonce;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (tx.gas) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new Error('gas is missing or 0');\n\n          case 2:\n            if (!(tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined)) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\", sign(tx, privateKey));\n\n          case 4:\n            // Otherwise, get the missing info from the Ethereum Node\n            promises = [isNot(tx.chainId) ? eth.getId() : Promise.resolve(tx.chainId), isNot(tx.gasPrice) ? eth.getGasPrice() : Promise.resolve(tx.gasPrice), isNot(tx.nonce) ? eth.getTransactionCount(address_1.Address.fromString(account_1.default.fromPrivate(privateKey).address)) : Promise.resolve(tx.nonce)];\n            _context.next = 7;\n            return Promise.all(promises);\n\n          case 7:\n            _yield$Promise$all = _context.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);\n            chainId = _yield$Promise$all2[0];\n            gasPrice = _yield$Promise$all2[1];\n            nonce = _yield$Promise$all2[2];\n\n            if (!(isNot(chainId) || isNot(gasPrice) || isNot(nonce))) {\n              _context.next = 14;\n              break;\n            }\n\n            throw new Error('One of the values chainId, gasPrice, or nonce could not be fetched');\n\n          case 14:\n            return _context.abrupt(\"return\", sign(_objectSpread({}, tx, {\n              chainId: chainId,\n              gasPrice: gasPrice,\n              nonce: nonce\n            }), privateKey));\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _signTransaction.apply(this, arguments);\n}\n\nexports.signTransaction = signTransaction;\n\nfunction recoverTransaction(rawTx) {\n  var values = rlp_2.default.decode(rawTx);\n  var signature = account_1.default.encodeSignature(values.slice(6, 9));\n  var recovery = bytes_1.default.toNumber(values[6]);\n  var extraData = recovery < 35 ? [] : [bytes_1.default.fromNumber(recovery - 35 >> 1), '0x', '0x'];\n  var signingData = values.slice(0, 6).concat(extraData);\n  var signingDataHex = rlp_2.default.encode(signingData);\n  return account_1.default.recover(utils_1.sha3(signingDataHex), signature);\n}\n\nexports.recoverTransaction = recoverTransaction;\n\nfunction sign(tx, privateKey) {\n  if (tx.nonce < 0 || tx.gas < 0 || tx.gasPrice < 0 || tx.chainId < 0) {\n    throw new Error('gas, gasPrice, nonce or chainId is lower than 0');\n  }\n\n  var chainId = utils_1.numberToHex(tx.chainId);\n  var toEncode = [bytes_1.default.fromNat(utils_1.numberToHex(tx.nonce)), bytes_1.default.fromNat(utils_1.numberToHex(tx.gasPrice)), bytes_1.default.fromNat(utils_1.numberToHex(tx.gas)), tx.to ? formatters_1.inputAddressFormatter(tx.to) : '0x', bytes_1.default.fromNat(tx.value ? utils_1.numberToHex(tx.value) : '0x'), tx.data ? utils_1.bufferToHex(tx.data) : '0x', bytes_1.default.fromNat(chainId || '0x1'), '0x', '0x'];\n  var rlpEncoded = rlp_1.encode(toEncode);\n  var messageHash = utils_1.sha3(rlpEncoded);\n  var signature = account_1.default.makeSigner(nat_1.default.toNumber(chainId || '0x1') * 2 + 35)(messageHash, privateKey);\n  var rawTx = [].concat(_toConsumableArray(rlp_1.decode(rlpEncoded).slice(0, 6)), _toConsumableArray(account_1.default.decodeSignature(signature)));\n  rawTx[6] = utils_1.makeHexEven(utils_1.trimHexLeadingZero(rawTx[6]));\n  rawTx[7] = utils_1.makeHexEven(utils_1.trimHexLeadingZero(rawTx[7]));\n  rawTx[8] = utils_1.makeHexEven(utils_1.trimHexLeadingZero(rawTx[8]));\n  var rawTransaction = rlp_1.encode(rawTx);\n  var values = rlp_1.decode(rawTransaction);\n  return {\n    messageHash: messageHash,\n    v: utils_1.trimHexLeadingZero(utils_1.bufferToHex(values[6])),\n    r: utils_1.trimHexLeadingZero(utils_1.bufferToHex(values[7])),\n    s: utils_1.trimHexLeadingZero(utils_1.bufferToHex(values[8])),\n    rawTransaction: utils_1.bufferToHex(rawTransaction)\n  };\n}\n\nexports.sign = sign;\n\nfunction isNot(value) {\n  return value === undefined || value === null;\n}","map":null,"metadata":{},"sourceType":"script"}