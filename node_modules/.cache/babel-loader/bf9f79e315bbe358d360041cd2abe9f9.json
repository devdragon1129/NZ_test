{"ast":null,"code":"import { Color4, Color3 } from \"../Maths/math\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { Ray } from \"../Culling/ray\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\nimport { Scalar } from \"../Maths/math.scalar\";\n/** Defines the 4 color options */\n\nexport var PointColor;\n\n(function (PointColor) {\n  /** color value */\n  PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n  /** uv value */\n\n  PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n  /** random value */\n\n  PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n  /** stated value */\n\n  PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\r\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\r\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The PointCloudSytem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : TO BE ENTERED\r\n */\n\n\nvar PointsCloudSystem =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a PCS (Points Cloud System) object\r\n   * @param name (String) is the PCS name, this will be the underlying mesh name\r\n   * @param pointSize (number) is the size for each point\r\n   * @param scene (Scene) is the scene in which the PCS is added\r\n   * @param options defines the options of the PCS e.g.\r\n   * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\r\n   */\n  function PointsCloudSystem(name, pointSize, scene, options) {\n    /**\r\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\n    this.particles = new Array();\n    /**\r\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\r\n     */\n\n    this.nbParticles = 0;\n    /**\r\n     * This a counter for your own usage. It's not set by any SPS functions.\r\n     */\n\n    this.counter = 0;\n    /**\r\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read :\r\n     */\n\n    this.vars = {};\n    this._promises = [];\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._updatable = true;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._groups = new Array(); //start indices for each group of particles\n\n    this._groupCounter = 0;\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeBoundingBox = false;\n    this._isReady = false;\n    this.name = name;\n    this._size = pointSize;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n  }\n  /**\r\n   * Builds the PCS underlying mesh. Returns a standard Mesh.\r\n   * If no points were added to the PCS, the returned mesh is just a single point.\r\n   * @returns a promise for the created mesh\r\n   */\n\n\n  PointsCloudSystem.prototype.buildMeshAsync = function () {\n    var _this = this;\n\n    return Promise.all(this._promises).then(function () {\n      _this._isReady = true;\n      return _this._buildMesh();\n    });\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  PointsCloudSystem.prototype._buildMesh = function () {\n    if (this.nbParticles === 0) {\n      this.addPoints(1);\n    }\n\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n    var vertexData = new VertexData();\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n\n    var ec = 0; //emissive color value 0 for UVs, 1 for color\n\n    if (this._colors32.length > 0) {\n      ec = 1;\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n\n    var mesh = new Mesh(this.name, this._scene);\n    vertexData.applyToMesh(mesh, this._updatable);\n    this.mesh = mesh; // free memory\n\n    this._positions = null;\n    this._uvs = null;\n    this._colors = null;\n\n    if (!this._updatable) {\n      this.particles.length = 0;\n    }\n\n    var mat = new StandardMaterial(\"point cloud material\", this._scene);\n    mat.emissiveColor = new Color3(ec, ec, ec);\n    mat.disableLighting = true;\n    mat.pointsCloud = true;\n    mat.pointSize = this._size;\n    mesh.material = mat;\n    return new Promise(function (resolve) {\n      return resolve(mesh);\n    });\n  }; // adds a new particle object in the particles array\n\n\n  PointsCloudSystem.prototype._addParticle = function (idx, group, groupId, idxInGroup) {\n    var cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n    this.particles.push(cp);\n    return cp;\n  };\n\n  PointsCloudSystem.prototype._randomUnitVector = function (particle) {\n    particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n    particle.color = new Color4(1, 1, 1, 1);\n  };\n\n  PointsCloudSystem.prototype._getColorIndicesForCoord = function (pointsGroup, x, y, width) {\n    var imageData = pointsGroup._groupImageData;\n    var color = y * (width * 4) + x * 4;\n    var colorIndices = [color, color + 1, color + 2, color + 3];\n    var redIndex = colorIndices[0];\n    var greenIndex = colorIndices[1];\n    var blueIndex = colorIndices[2];\n    var alphaIndex = colorIndices[3];\n    var redForCoord = imageData[redIndex];\n    var greenForCoord = imageData[greenIndex];\n    var blueForCoord = imageData[blueIndex];\n    var alphaForCoord = imageData[alphaIndex];\n    return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n  };\n\n  PointsCloudSystem.prototype._setPointsColorOrUV = function (mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range) {\n    if (isVolume) {\n      mesh.updateFacetData();\n    }\n\n    var boundInfo = mesh.getBoundingInfo();\n    var diameter = 2 * boundInfo.boundingSphere.radius;\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var place = Vector3.Zero();\n    mesh.computeWorldMatrix();\n    var meshMatrix = mesh.getWorldMatrix();\n\n    if (!meshMatrix.isIdentity()) {\n      for (var p = 0; p < meshPos.length / 3; p++) {\n        Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n        meshPos[3 * p] = place.x;\n        meshPos[3 * p + 1] = place.y;\n        meshPos[3 * p + 2] = place.z;\n      }\n    }\n\n    var idxPoints = 0;\n    var index = 0;\n    var id0 = 0;\n    var id1 = 0;\n    var id2 = 0;\n    var v0X = 0;\n    var v0Y = 0;\n    var v0Z = 0;\n    var v1X = 0;\n    var v1Y = 0;\n    var v1Z = 0;\n    var v2X = 0;\n    var v2Y = 0;\n    var v2Z = 0;\n    var vertex0 = Vector3.Zero();\n    var vertex1 = Vector3.Zero();\n    var vertex2 = Vector3.Zero();\n    var vec0 = Vector3.Zero();\n    var vec1 = Vector3.Zero();\n    var uv0X = 0;\n    var uv0Y = 0;\n    var uv1X = 0;\n    var uv1Y = 0;\n    var uv2X = 0;\n    var uv2Y = 0;\n    var uv0 = Vector2.Zero();\n    var uv1 = Vector2.Zero();\n    var uv2 = Vector2.Zero();\n    var uvec0 = Vector2.Zero();\n    var uvec1 = Vector2.Zero();\n    var col0X = 0;\n    var col0Y = 0;\n    var col0Z = 0;\n    var col0A = 0;\n    var col1X = 0;\n    var col1Y = 0;\n    var col1Z = 0;\n    var col1A = 0;\n    var col2X = 0;\n    var col2Y = 0;\n    var col2Z = 0;\n    var col2A = 0;\n    var col0 = Vector4.Zero();\n    var col1 = Vector4.Zero();\n    var col2 = Vector4.Zero();\n    var colvec0 = Vector4.Zero();\n    var colvec1 = Vector4.Zero();\n    var lamda = 0;\n    var mu = 0;\n    range = range ? range : 0;\n    var facetPoint;\n    var uvPoint;\n    var colPoint = new Vector4(0, 0, 0, 0);\n    var norm = Vector3.Zero();\n    var tang = Vector3.Zero();\n    var biNorm = Vector3.Zero();\n    var angle = 0;\n    var facetPlaneVec = Vector3.Zero();\n    var gap = 0;\n    var distance = 0;\n    var ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n    var pickInfo;\n    var direction = Vector3.Zero();\n\n    for (var index = 0; index < meshInd.length / 3; index++) {\n      id0 = meshInd[3 * index];\n      id1 = meshInd[3 * index + 1];\n      id2 = meshInd[3 * index + 2];\n      v0X = meshPos[3 * id0];\n      v0Y = meshPos[3 * id0 + 1];\n      v0Z = meshPos[3 * id0 + 2];\n      v1X = meshPos[3 * id1];\n      v1Y = meshPos[3 * id1 + 1];\n      v1Z = meshPos[3 * id1 + 2];\n      v2X = meshPos[3 * id2];\n      v2Y = meshPos[3 * id2 + 1];\n      v2Z = meshPos[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n\n      if (meshUV) {\n        uv0X = meshUV[2 * id0];\n        uv0Y = meshUV[2 * id0 + 1];\n        uv1X = meshUV[2 * id1];\n        uv1Y = meshUV[2 * id1 + 1];\n        uv2X = meshUV[2 * id2];\n        uv2Y = meshUV[2 * id2 + 1];\n        uv0.set(uv0X, uv0Y);\n        uv1.set(uv1X, uv1Y);\n        uv2.set(uv2X, uv2Y);\n        uv1.subtractToRef(uv0, uvec0);\n        uv2.subtractToRef(uv1, uvec1);\n      }\n\n      if (meshCol && colorFromTexture) {\n        col0X = meshCol[4 * id0];\n        col0Y = meshCol[4 * id0 + 1];\n        col0Z = meshCol[4 * id0 + 2];\n        col0A = meshCol[4 * id0 + 3];\n        col1X = meshCol[4 * id1];\n        col1Y = meshCol[4 * id1 + 1];\n        col1Z = meshCol[4 * id1 + 2];\n        col1A = meshCol[4 * id1 + 3];\n        col2X = meshCol[4 * id2];\n        col2Y = meshCol[4 * id2 + 1];\n        col2Z = meshCol[4 * id2 + 2];\n        col2A = meshCol[4 * id2 + 3];\n        col0.set(col0X, col0Y, col0Z, col0A);\n        col1.set(col1X, col1Y, col1Z, col1A);\n        col2.set(col2X, col2Y, col2Z, col2A);\n        col1.subtractToRef(col0, colvec0);\n        col2.subtractToRef(col1, colvec1);\n      }\n\n      var width;\n      var height;\n      var deltaS;\n      var deltaV;\n      var h;\n      var s;\n      var v;\n      var hsvCol;\n      var statedColor = new Color3(0, 0, 0);\n      var colPoint3 = new Color3(0, 0, 0);\n      var pointColors;\n      var particle;\n\n      for (var i = 0; i < pointsGroup._groupDensity[index]; i++) {\n        idxPoints = this.particles.length;\n\n        this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n\n        particle = this.particles[idxPoints]; //form a point inside the facet v0, v1, v2;\n\n        lamda = Scalar.RandomRange(0, 1);\n        mu = Scalar.RandomRange(0, 1);\n        facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n\n        if (isVolume) {\n          norm = mesh.getFacetNormal(index).normalize().scale(-1);\n          tang = vec0.clone().normalize();\n          biNorm = Vector3.Cross(norm, tang);\n          angle = Scalar.RandomRange(0, 2 * Math.PI);\n          facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n          angle = Scalar.RandomRange(0.1, Math.PI / 2);\n          direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n          ray.origin = facetPoint.add(direction.scale(0.00001));\n          ray.direction = direction;\n          ray.length = diameter;\n          pickInfo = ray.intersectsMesh(mesh);\n\n          if (pickInfo.hit) {\n            distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n            gap = Scalar.RandomRange(0, 1) * distance;\n            facetPoint.addInPlace(direction.scale(gap));\n          }\n        }\n\n        particle.position = facetPoint.clone();\n\n        this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n\n        if (colorFromTexture !== undefined) {\n          if (meshUV) {\n            uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n\n            if (colorFromTexture) {\n              //Set particle color to texture color\n              if (hasTexture && pointsGroup._groupImageData !== null) {\n                width = pointsGroup._groupImgWidth;\n                height = pointsGroup._groupImgHeight;\n                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                particle.color = pointColors;\n\n                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n              } else {\n                if (meshCol) {\n                  //failure in texture and colors available\n                  colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                } else {\n                  colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n              }\n            } else {\n              //Set particle uv based on a mesh uv\n              particle.uv = uvPoint.clone();\n\n              this._uvs.push(particle.uv.x, particle.uv.y);\n            }\n          }\n        } else {\n          if (color) {\n            statedColor.set(color.r, color.g, color.b);\n            deltaS = Scalar.RandomRange(-range, range);\n            deltaV = Scalar.RandomRange(-range, range);\n            hsvCol = statedColor.toHSV();\n            h = hsvCol.r;\n            s = hsvCol.g + deltaS;\n            v = hsvCol.b + deltaV;\n\n            if (s < 0) {\n              s = 0;\n            }\n\n            if (s > 1) {\n              s = 1;\n            }\n\n            if (v < 0) {\n              v = 0;\n            }\n\n            if (v > 1) {\n              v = 1;\n            }\n\n            Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n            colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n          } else {\n            colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n          }\n\n          particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n          this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n        }\n      }\n    }\n  }; // stores mesh texture in dynamic texture for color pixel retrieval\n  // when pointColor type is color for surface points\n\n\n  PointsCloudSystem.prototype._colorFromTexture = function (mesh, pointsGroup, isVolume) {\n    var _this = this;\n\n    if (mesh.material === null) {\n      Logger.Warn(mesh.name + \"has no material.\");\n      pointsGroup._groupImageData = null;\n\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n\n      return;\n    }\n\n    var mat = mesh.material;\n    var textureList = mat.getActiveTextures();\n\n    if (textureList.length === 0) {\n      Logger.Warn(mesh.name + \"has no useable texture.\");\n      pointsGroup._groupImageData = null;\n\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n\n      return;\n    }\n\n    var clone = mesh.clone();\n    clone.setEnabled(false);\n\n    this._promises.push(new Promise(function (resolve) {\n      BaseTexture.WhenAllReady(textureList, function () {\n        var n = pointsGroup._textureNb;\n\n        if (n < 0) {\n          n = 0;\n        }\n\n        if (n > textureList.length - 1) {\n          n = textureList.length - 1;\n        }\n\n        pointsGroup._groupImageData = textureList[n].readPixels();\n        pointsGroup._groupImgWidth = textureList[n].getSize().width;\n        pointsGroup._groupImgHeight = textureList[n].getSize().height;\n\n        _this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);\n\n        clone.dispose();\n        return resolve();\n      });\n    }));\n  }; // calculates the point density per facet of a mesh for surface points\n\n\n  PointsCloudSystem.prototype._calculateDensity = function (nbPoints, positions, indices) {\n    var density = new Array();\n    var index;\n    var id0;\n    var id1;\n    var id2;\n    var v0X;\n    var v0Y;\n    var v0Z;\n    var v1X;\n    var v1Y;\n    var v1Z;\n    var v2X;\n    var v2Y;\n    var v2Z;\n    var vertex0 = Vector3.Zero();\n    var vertex1 = Vector3.Zero();\n    var vertex2 = Vector3.Zero();\n    var vec0 = Vector3.Zero();\n    var vec1 = Vector3.Zero();\n    var vec2 = Vector3.Zero();\n    var a; //length of side of triangle\n\n    var b; //length of side of triangle\n\n    var c; //length of side of triangle\n\n    var p; //perimeter of triangle\n\n    var area;\n    var areas = new Array();\n    var surfaceArea = 0;\n    var nbFacets = indices.length / 3; //surface area\n\n    for (var index = 0; index < nbFacets; index++) {\n      id0 = indices[3 * index];\n      id1 = indices[3 * index + 1];\n      id2 = indices[3 * index + 2];\n      v0X = positions[3 * id0];\n      v0Y = positions[3 * id0 + 1];\n      v0Z = positions[3 * id0 + 2];\n      v1X = positions[3 * id1];\n      v1Y = positions[3 * id1 + 1];\n      v1Z = positions[3 * id1 + 2];\n      v2X = positions[3 * id2];\n      v2Y = positions[3 * id2 + 1];\n      v2Z = positions[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n      vertex2.subtractToRef(vertex0, vec2);\n      a = vec0.length();\n      b = vec1.length();\n      c = vec2.length();\n      p = (a + b + c) / 2;\n      area = Math.sqrt(p * (p - a) * (p - b) * (p - c));\n      surfaceArea += area;\n      areas[index] = area;\n    }\n\n    var pointCount = 0;\n\n    for (var index = 0; index < nbFacets; index++) {\n      density[index] = Math.floor(nbPoints * areas[index] / surfaceArea);\n      pointCount += density[index];\n    }\n\n    var diff = nbPoints - pointCount;\n    var pointsPerFacet = Math.floor(diff / nbFacets);\n    var extraPoints = diff % nbFacets;\n\n    if (pointsPerFacet > 0) {\n      density = density.map(function (x) {\n        return x + pointsPerFacet;\n      });\n    }\n\n    for (var index = 0; index < extraPoints; index++) {\n      density[index] += 1;\n    }\n\n    return density;\n  };\n  /**\r\n   * Adds points to the PCS in random positions within a unit sphere\r\n   * @param nb (positive integer) the number of particles to be created from this model\r\n   * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\r\n   * @returns the number of groups in the system\r\n   */\n\n\n  PointsCloudSystem.prototype.addPoints = function (nb, pointFunction) {\n    if (pointFunction === void 0) {\n      pointFunction = this._randomUnitVector;\n    }\n\n    var pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n    var cp; // particles\n\n    var idx = this.nbParticles;\n\n    for (var i = 0; i < nb; i++) {\n      cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n\n      if (pointsGroup && pointsGroup._positionFunction) {\n        pointsGroup._positionFunction(cp, idx, i);\n      }\n\n      this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n\n      if (cp.color) {\n        this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n      }\n\n      if (cp.uv) {\n        this._uvs.push(cp.uv.x, cp.uv.y);\n      }\n\n      idx++;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter;\n  };\n  /**\r\n   * Adds points to the PCS from the surface of the model shape\r\n   * @param mesh is any Mesh object that will be used as a surface model for the points\r\n   * @param nb (positive integer) the number of particles to be created from this model\r\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n   * @returns the number of groups in the system\r\n   */\n\n\n  PointsCloudSystem.prototype.addSurfacePoints = function (mesh, nb, colorWith, color, range) {\n    var colored = colorWith ? colorWith : PointColor.Random;\n\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n\n    this._groups.push(this._groupCounter);\n\n    var pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, false);\n\n        break;\n\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n\n        break;\n\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, false);\n\n        break;\n\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n\n        break;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  };\n  /**\r\n   * Adds points to the PCS inside the model shape\r\n   * @param mesh is any Mesh object that will be used as a surface model for the points\r\n   * @param nb (positive integer) the number of particles to be created from this model\r\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n   * @returns the number of groups in the system\r\n   */\n\n\n  PointsCloudSystem.prototype.addVolumePoints = function (mesh, nb, colorWith, color, range) {\n    var colored = colorWith ? colorWith : PointColor.Random;\n\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n\n    this._groups.push(this._groupCounter);\n\n    var pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, true);\n\n        break;\n\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n\n        break;\n\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, true);\n\n        break;\n\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n\n        break;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  };\n  /**\r\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n   *  This method calls `updateParticle()` for each particle of the SPS.\r\n   *  For an animated SPS, it is usually called within the render loop.\r\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n   * @returns the PCS.\r\n   */\n\n\n  PointsCloudSystem.prototype.setParticles = function (start, end, update) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (end === void 0) {\n      end = this.nbParticles - 1;\n    }\n\n    if (update === void 0) {\n      update = true;\n    }\n\n    if (!this._updatable || !this._isReady) {\n      return this;\n    } // custom beforeUpdate\n\n\n    this.beforeUpdateParticles(start, end, update);\n    var rotMatrix = TmpVectors.Matrix[0];\n    var mesh = this.mesh;\n    var colors32 = this._colors32;\n    var positions32 = this._positions32;\n    var uvs32 = this._uvs32;\n    var tempVectors = TmpVectors.Vector3;\n    var camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    var camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    var camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    var minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    Matrix.IdentityToRef(rotMatrix);\n    var idx = 0; // current index of the particle\n\n    if (this.mesh.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        var boundingInfo = this.mesh._boundingInfo;\n\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    }\n\n    var idx = 0; // particle index\n\n    var pindex = 0; //index in positions array\n\n    var cindex = 0; //index in color array\n\n    var uindex = 0; //index in uv array\n    // particle loop\n\n    for (var p = start; p <= end; p++) {\n      var particle = this.particles[p];\n      idx = particle.idx;\n      pindex = 3 * idx;\n      cindex = 4 * idx;\n      uindex = 2 * idx; // call to custom user function to update the particle properties\n\n      this.updateParticle(particle);\n      var particleRotationMatrix = particle._rotationMatrix;\n      var particlePosition = particle.position;\n      var particleGlobalPosition = particle._globalPosition;\n\n      if (this._computeParticleRotation) {\n        particle.getRotationMatrix(rotMatrix);\n      }\n\n      var particleHasParent = particle.parentId !== null;\n\n      if (particleHasParent) {\n        var parent_1 = this.particles[particle.parentId];\n        var parentRotationMatrix = parent_1._rotationMatrix;\n        var parentGlobalPosition = parent_1._globalPosition;\n        var rotatedY_1 = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n        var rotatedX_1 = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n        var rotatedZ_1 = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX_1;\n        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY_1;\n        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ_1;\n\n        if (this._computeParticleRotation) {\n          var rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n          particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n          particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n          particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n          particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n          particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n          particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n          particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n          particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n        }\n      } else {\n        particleGlobalPosition.x = 0;\n        particleGlobalPosition.y = 0;\n        particleGlobalPosition.z = 0;\n\n        if (this._computeParticleRotation) {\n          var rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0];\n          particleRotationMatrix[1] = rotMatrixValues[1];\n          particleRotationMatrix[2] = rotMatrixValues[2];\n          particleRotationMatrix[3] = rotMatrixValues[4];\n          particleRotationMatrix[4] = rotMatrixValues[5];\n          particleRotationMatrix[5] = rotMatrixValues[6];\n          particleRotationMatrix[6] = rotMatrixValues[8];\n          particleRotationMatrix[7] = rotMatrixValues[9];\n          particleRotationMatrix[8] = rotMatrixValues[10];\n        }\n      }\n\n      var pivotBackTranslation = tempVectors[11];\n\n      if (particle.translateFromPivot) {\n        pivotBackTranslation.setAll(0.0);\n      } else {\n        pivotBackTranslation.copyFrom(particle.pivot);\n      } // positions\n\n\n      var tmpVertex = tempVectors[0];\n      tmpVertex.copyFrom(particle.position);\n      var vertexX = tmpVertex.x - particle.pivot.x;\n      var vertexY = tmpVertex.y - particle.pivot.y;\n      var vertexZ = tmpVertex.z - particle.pivot.z;\n      var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n      var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n      var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n      rotatedX += pivotBackTranslation.x;\n      rotatedY += pivotBackTranslation.y;\n      rotatedZ += pivotBackTranslation.z;\n      var px = positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n      var py = positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n      var pz = positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n\n      if (this._computeBoundingBox) {\n        minimum.minimizeInPlaceFromFloats(px, py, pz);\n        maximum.maximizeInPlaceFromFloats(px, py, pz);\n      }\n\n      if (this._computeParticleColor && particle.color) {\n        var color = particle.color;\n        var colors32_1 = this._colors32;\n        colors32_1[cindex] = color.r;\n        colors32_1[cindex + 1] = color.g;\n        colors32_1[cindex + 2] = color.b;\n        colors32_1[cindex + 3] = color.a;\n      }\n\n      if (this._computeParticleTexture && particle.uv) {\n        var uv = particle.uv;\n        var uvs32_1 = this._uvs32;\n        uvs32_1[uindex] = uv.x;\n        uvs32_1[uindex + 1] = uv.y;\n      }\n    } // if the VBO must be updated\n\n\n    if (update) {\n      if (this._computeParticleColor) {\n        mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n      }\n\n      if (this._computeParticleTexture) {\n        mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n      }\n\n      mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n    }\n\n    if (this._computeBoundingBox) {\n      if (mesh._boundingInfo) {\n        mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);\n      } else {\n        mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);\n      }\n    }\n\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  };\n  /**\r\n  * Disposes the PCS.\r\n  */\n\n\n  PointsCloudSystem.prototype.dispose = function () {\n    this.mesh.dispose();\n    this.vars = null; // drop references to internal big arrays for the GC\n\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n  };\n  /**\r\n   * Visibilty helper : Recomputes the visible size according to the mesh bounding box\r\n   * doc :\r\n   * @returns the PCS.\r\n   */\n\n\n  PointsCloudSystem.prototype.refreshVisibleSize = function () {\n    if (!this._isVisibilityBoxLocked) {\n      this.mesh.refreshBoundingInfo();\n    }\n\n    return this;\n  };\n  /**\r\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n   * @param size the size (float) of the visibility box\r\n   * note : this doesn't lock the PCS mesh bounding box.\r\n   * doc :\r\n   */\n\n\n  PointsCloudSystem.prototype.setVisibilityBox = function (size) {\n    var vis = size / 2;\n    this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  };\n\n  Object.defineProperty(PointsCloudSystem.prototype, \"isAlwaysVisible\", {\n    /**\r\n     * Gets whether the PCS is always visible or not\r\n     * doc :\r\n     */\n    get: function get() {\n      return this._alwaysVisible;\n    },\n\n    /**\r\n     * Sets the PCS as always visible or not\r\n     * doc :\r\n     */\n    set: function set(val) {\n      this._alwaysVisible = val;\n      this.mesh.alwaysSelectAsActiveMesh = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleRotation\", {\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not\r\n     * Default value : false. The PCS is faster when it's set to false\r\n     * Note : particle rotations are only applied to parent particles\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\r\n     */\n    set: function set(val) {\n      this._computeParticleRotation = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleColor\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\n    get: function get() {\n      return this._computeParticleColor;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\n    set: function set(val) {\n      this._computeParticleColor = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleTexture\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\n    get: function get() {\n      return this._computeParticleTexture;\n    },\n    set: function set(val) {\n      this._computeParticleTexture = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeBoundingBox\", {\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\n    get: function get() {\n      return this._computeBoundingBox;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\n    set: function set(val) {\n      this._computeBoundingBox = val;\n    },\n    enumerable: false,\n    configurable: true\n  }); // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by users to fit their needs\n\n  /**\r\n   * This function does nothing. It may be overwritten to set all the particle first values.\r\n   * The PCS doesn't call this function, you may have to call it by your own.\r\n   * doc :\r\n   */\n\n  PointsCloudSystem.prototype.initParticles = function () {};\n  /**\r\n   * This function does nothing. It may be overwritten to recycle a particle\r\n   * The PCS doesn't call this function, you can to call it\r\n   * doc :\r\n   * @param particle The particle to recycle\r\n   * @returns the recycled particle\r\n   */\n\n\n  PointsCloudSystem.prototype.recycleParticle = function (particle) {\n    return particle;\n  };\n  /**\r\n   * Updates a particle : this function should  be overwritten by the user.\r\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n   * doc :\r\n   * @example : just set a particle position or velocity and recycle conditions\r\n   * @param particle The particle to update\r\n   * @returns the updated particle\r\n   */\n\n\n  PointsCloudSystem.prototype.updateParticle = function (particle) {\n    return particle;\n  };\n  /**\r\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n   * This does nothing and may be overwritten by the user.\r\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param update the boolean update value actually passed to setParticles()\r\n   */\n\n\n  PointsCloudSystem.prototype.beforeUpdateParticles = function (start, stop, update) {};\n  /**\r\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n   * This will be passed three parameters.\r\n   * This does nothing and may be overwritten by the user.\r\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param update the boolean update value actually passed to setParticles()\r\n   */\n\n\n  PointsCloudSystem.prototype.afterUpdateParticles = function (start, stop, update) {};\n\n  return PointsCloudSystem;\n}();\n\nexport { PointsCloudSystem };","map":null,"metadata":{},"sourceType":"module"}