{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport { ArrayTools } from \"../Misc/arrayTools\";\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { PhysicsJoint } from \"./physicsJoint\";\nimport { Space } from \"../Maths/math.axis\";\n\nMesh._PhysicsImpostorParser = function (scene, physicObject, jsonObject) {\n  return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {\n    mass: jsonObject.physicsMass,\n    friction: jsonObject.physicsFriction,\n    restitution: jsonObject.physicsRestitution\n  }, scene);\n};\n/**\r\n * Represents a physics imposter\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\n\n\nvar PhysicsImpostor =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the physics imposter\r\n   * @param object The physics-enabled object used as the physics imposter\r\n   * @param type The type of the physics imposter\r\n   * @param _options The options for the physics imposter\r\n   * @param _scene The Babylon scene\r\n   */\n  function PhysicsImpostor(\n  /**\r\n   * The physics-enabled object used as the physics imposter\r\n   */\n  object,\n  /**\r\n   * The type of the physics imposter\r\n   */\n  type, _options, _scene) {\n    var _this = this;\n\n    if (_options === void 0) {\n      _options = {\n        mass: 0\n      };\n    }\n\n    this.object = object;\n    this.type = type;\n    this._options = _options;\n    this._scene = _scene;\n    /** @hidden */\n\n    this._pluginData = {};\n    this._bodyUpdateRequired = false;\n    this._onBeforePhysicsStepCallbacks = new Array();\n    this._onAfterPhysicsStepCallbacks = new Array();\n    /** @hidden */\n\n    this._onPhysicsCollideCallbacks = [];\n    this._deltaPosition = Vector3.Zero();\n    this._isDisposed = false;\n    /**\r\n     * @hidden\r\n     */\n\n    this.soft = false;\n    /**\r\n     * @hidden\r\n     */\n\n    this.segments = 0; //temp variables for parent rotation calculations\n    //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];\n\n    this._tmpQuat = new Quaternion();\n    this._tmpQuat2 = new Quaternion();\n    /**\r\n     * this function is executed by the physics engine.\r\n     */\n\n    this.beforeStep = function () {\n      if (!_this._physicsEngine) {\n        return;\n      }\n\n      _this.object.translate(_this._deltaPosition, -1);\n\n      _this._deltaRotationConjugated && _this.object.rotationQuaternion && _this.object.rotationQuaternion.multiplyToRef(_this._deltaRotationConjugated, _this.object.rotationQuaternion);\n\n      _this.object.computeWorldMatrix(false);\n\n      if (_this.object.parent && _this.object.rotationQuaternion) {\n        _this.getParentsRotation();\n\n        _this._tmpQuat.multiplyToRef(_this.object.rotationQuaternion, _this._tmpQuat);\n      } else {\n        _this._tmpQuat.copyFrom(_this.object.rotationQuaternion || new Quaternion());\n      }\n\n      if (!_this._options.disableBidirectionalTransformation) {\n        _this.object.rotationQuaternion && _this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(_this,\n        /*bInfo.boundingBox.centerWorld*/\n        _this.object.getAbsolutePosition(), _this._tmpQuat);\n      }\n\n      _this._onBeforePhysicsStepCallbacks.forEach(function (func) {\n        func(_this);\n      });\n    };\n    /**\r\n     * this function is executed by the physics engine\r\n     */\n\n\n    this.afterStep = function () {\n      if (!_this._physicsEngine) {\n        return;\n      }\n\n      _this._onAfterPhysicsStepCallbacks.forEach(function (func) {\n        func(_this);\n      });\n\n      _this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(_this); // object has now its world rotation. needs to be converted to local.\n\n\n      if (_this.object.parent && _this.object.rotationQuaternion) {\n        _this.getParentsRotation();\n\n        _this._tmpQuat.conjugateInPlace();\n\n        _this._tmpQuat.multiplyToRef(_this.object.rotationQuaternion, _this.object.rotationQuaternion);\n      } // take the position set and make it the absolute position of this object.\n\n\n      _this.object.setAbsolutePosition(_this.object.position);\n\n      _this._deltaRotation && _this.object.rotationQuaternion && _this.object.rotationQuaternion.multiplyToRef(_this._deltaRotation, _this.object.rotationQuaternion);\n\n      _this.object.translate(_this._deltaPosition, 1);\n    };\n    /**\r\n     * Legacy collision detection event support\r\n     */\n\n\n    this.onCollideEvent = null;\n    /**\r\n     * event and body object due to cannon's event-based architecture.\r\n     */\n\n    this.onCollide = function (e) {\n      if (!_this._onPhysicsCollideCallbacks.length && !_this.onCollideEvent) {\n        return;\n      }\n\n      if (!_this._physicsEngine) {\n        return;\n      }\n\n      var otherImpostor = _this._physicsEngine.getImpostorWithPhysicsBody(e.body);\n\n      if (otherImpostor) {\n        // Legacy collision detection event support\n        if (_this.onCollideEvent) {\n          _this.onCollideEvent(_this, otherImpostor);\n        }\n\n        _this._onPhysicsCollideCallbacks.filter(function (obj) {\n          return obj.otherImpostors.indexOf(otherImpostor) !== -1;\n        }).forEach(function (obj) {\n          obj.callback(_this, otherImpostor, e.point);\n        });\n      }\n    }; //sanity check!\n\n\n    if (!this.object) {\n      Logger.Error(\"No object was provided. A physics object is obligatory\");\n      return;\n    }\n\n    if (this.object.parent && _options.mass !== 0) {\n      Logger.Warn(\"A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.\");\n    } // Legacy support for old syntax.\n\n\n    if (!this._scene && object.getScene) {\n      this._scene = object.getScene();\n    }\n\n    if (!this._scene) {\n      return;\n    }\n\n    if (this.type > 100) {\n      this.soft = true;\n    }\n\n    this._physicsEngine = this._scene.getPhysicsEngine();\n\n    if (!this._physicsEngine) {\n      Logger.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\n    } else {\n      //set the object's quaternion, if not set\n      if (!this.object.rotationQuaternion) {\n        if (this.object.rotation) {\n          this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\n        } else {\n          this.object.rotationQuaternion = new Quaternion();\n        }\n      } //default options params\n\n\n      this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\n      this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\n      this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\n\n      if (this.soft) {\n        //softbody mass must be above 0;\n        this._options.mass = this._options.mass > 0 ? this._options.mass : 1;\n        this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;\n        this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;\n        this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;\n        this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;\n        this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;\n        this._options.margin = _options.margin === void 0 ? 0 : _options.margin;\n        this._options.damping = _options.damping === void 0 ? 0 : _options.damping;\n        this._options.path = _options.path === void 0 ? null : _options.path;\n        this._options.shape = _options.shape === void 0 ? null : _options.shape;\n      }\n\n      this._joints = []; //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\n\n      if (!this.object.parent || this._options.ignoreParent) {\n        this._init();\n      } else if (this.object.parent.physicsImpostor) {\n        Logger.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\n      }\n    }\n  }\n\n  Object.defineProperty(PhysicsImpostor.prototype, \"isDisposed\", {\n    /**\r\n     * Specifies if the physics imposter is disposed\r\n     */\n    get: function get() {\n      return this._isDisposed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PhysicsImpostor.prototype, \"mass\", {\n    /**\r\n     * Gets the mass of the physics imposter\r\n     */\n    get: function get() {\n      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\n    },\n    set: function set(value) {\n      this.setMass(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PhysicsImpostor.prototype, \"friction\", {\n    /**\r\n     * Gets the coefficient of friction\r\n     */\n    get: function get() {\n      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\n    },\n\n    /**\r\n     * Sets the coefficient of friction\r\n     */\n    set: function set(value) {\n      if (!this._physicsEngine) {\n        return;\n      }\n\n      this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PhysicsImpostor.prototype, \"restitution\", {\n    /**\r\n     * Gets the coefficient of restitution\r\n     */\n    get: function get() {\n      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\n    },\n\n    /**\r\n     * Sets the coefficient of restitution\r\n     */\n    set: function set(value) {\n      if (!this._physicsEngine) {\n        return;\n      }\n\n      this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PhysicsImpostor.prototype, \"pressure\", {\n    /**\r\n     * Gets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\n    get: function get() {\n      if (!this._physicsEngine) {\n        return 0;\n      }\n\n      var plugin = this._physicsEngine.getPhysicsPlugin();\n\n      if (!plugin.setBodyPressure) {\n        return 0;\n      }\n\n      return plugin.getBodyPressure(this);\n    },\n\n    /**\r\n     * Sets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\n    set: function set(value) {\n      if (!this._physicsEngine) {\n        return;\n      }\n\n      var plugin = this._physicsEngine.getPhysicsPlugin();\n\n      if (!plugin.setBodyPressure) {\n        return;\n      }\n\n      plugin.setBodyPressure(this, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PhysicsImpostor.prototype, \"stiffness\", {\n    /**\r\n     * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\n    get: function get() {\n      if (!this._physicsEngine) {\n        return 0;\n      }\n\n      var plugin = this._physicsEngine.getPhysicsPlugin();\n\n      if (!plugin.getBodyStiffness) {\n        return 0;\n      }\n\n      return plugin.getBodyStiffness(this);\n    },\n\n    /**\r\n     * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\n    set: function set(value) {\n      if (!this._physicsEngine) {\n        return;\n      }\n\n      var plugin = this._physicsEngine.getPhysicsPlugin();\n\n      if (!plugin.setBodyStiffness) {\n        return;\n      }\n\n      plugin.setBodyStiffness(this, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PhysicsImpostor.prototype, \"velocityIterations\", {\n    /**\r\n     * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\n    get: function get() {\n      if (!this._physicsEngine) {\n        return 0;\n      }\n\n      var plugin = this._physicsEngine.getPhysicsPlugin();\n\n      if (!plugin.getBodyVelocityIterations) {\n        return 0;\n      }\n\n      return plugin.getBodyVelocityIterations(this);\n    },\n\n    /**\r\n     * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\n    set: function set(value) {\n      if (!this._physicsEngine) {\n        return;\n      }\n\n      var plugin = this._physicsEngine.getPhysicsPlugin();\n\n      if (!plugin.setBodyVelocityIterations) {\n        return;\n      }\n\n      plugin.setBodyVelocityIterations(this, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PhysicsImpostor.prototype, \"positionIterations\", {\n    /**\r\n     * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\n    get: function get() {\n      if (!this._physicsEngine) {\n        return 0;\n      }\n\n      var plugin = this._physicsEngine.getPhysicsPlugin();\n\n      if (!plugin.getBodyPositionIterations) {\n        return 0;\n      }\n\n      return plugin.getBodyPositionIterations(this);\n    },\n\n    /**\r\n     * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\n    set: function set(value) {\n      if (!this._physicsEngine) {\n        return;\n      }\n\n      var plugin = this._physicsEngine.getPhysicsPlugin();\n\n      if (!plugin.setBodyPositionIterations) {\n        return;\n      }\n\n      plugin.setBodyPositionIterations(this, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * This function will completly initialize this impostor.\r\n   * It will create a new body - but only if this mesh has no parent.\r\n   * If it has, this impostor will not be used other than to define the impostor\r\n   * of the child mesh.\r\n   * @hidden\r\n   */\n\n  PhysicsImpostor.prototype._init = function () {\n    if (!this._physicsEngine) {\n      return;\n    }\n\n    this._physicsEngine.removeImpostor(this);\n\n    this.physicsBody = null;\n    this._parent = this._parent || this._getPhysicsParent();\n\n    if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {\n      this._physicsEngine.addImpostor(this);\n    }\n  };\n\n  PhysicsImpostor.prototype._getPhysicsParent = function () {\n    if (this.object.parent instanceof AbstractMesh) {\n      var parentMesh = this.object.parent;\n      return parentMesh.physicsImpostor;\n    }\n\n    return null;\n  };\n  /**\r\n   * Should a new body be generated.\r\n   * @returns boolean specifying if body initialization is required\r\n   */\n\n\n  PhysicsImpostor.prototype.isBodyInitRequired = function () {\n    return this._bodyUpdateRequired || !this._physicsBody && !this._parent;\n  };\n  /**\r\n   * Sets the updated scaling\r\n   * @param updated Specifies if the scaling is updated\r\n   */\n\n\n  PhysicsImpostor.prototype.setScalingUpdated = function () {\n    this.forceUpdate();\n  };\n  /**\r\n   * Force a regeneration of this or the parent's impostor's body.\r\n   * Use under cautious - This will remove all joints already implemented.\r\n   */\n\n\n  PhysicsImpostor.prototype.forceUpdate = function () {\n    this._init();\n\n    if (this.parent && !this._options.ignoreParent) {\n      this.parent.forceUpdate();\n    }\n  };\n\n  Object.defineProperty(PhysicsImpostor.prototype, \"physicsBody\", {\n    /*public get mesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }*/\n\n    /**\r\n     * Gets the body that holds this impostor. Either its own, or its parent.\r\n     */\n    get: function get() {\n      return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;\n    },\n\n    /**\r\n     * Set the physics body. Used mainly by the physics engine/plugin\r\n     */\n    set: function set(physicsBody) {\n      if (this._physicsBody && this._physicsEngine) {\n        this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\n      }\n\n      this._physicsBody = physicsBody;\n      this.resetUpdateFlags();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PhysicsImpostor.prototype, \"parent\", {\n    /**\r\n     * Get the parent of the physics imposter\r\n     * @returns Physics imposter or null\r\n     */\n    get: function get() {\n      return !this._options.ignoreParent && this._parent ? this._parent : null;\n    },\n\n    /**\r\n     * Sets the parent of the physics imposter\r\n     */\n    set: function set(value) {\n      this._parent = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets the update flags\r\n   */\n\n  PhysicsImpostor.prototype.resetUpdateFlags = function () {\n    this._bodyUpdateRequired = false;\n  };\n  /**\r\n   * Gets the object extend size\r\n   * @returns the object extend size\r\n   */\n\n\n  PhysicsImpostor.prototype.getObjectExtendSize = function () {\n    if (this.object.getBoundingInfo) {\n      var q = this.object.rotationQuaternion;\n      var scaling = this.object.scaling.clone(); //reset rotation\n\n      this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION; //calculate the world matrix with no rotation\n\n      var worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\n\n      if (worldMatrix) {\n        worldMatrix.decompose(scaling, undefined, undefined);\n      }\n\n      var boundingInfo = this.object.getBoundingInfo(); // get the global scaling of the object\n\n      var size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling); //bring back the rotation\n\n      this.object.rotationQuaternion = q; //calculate the world matrix with the new rotation\n\n      this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\n      return size;\n    } else {\n      return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\n    }\n  };\n  /**\r\n   * Gets the object center\r\n   * @returns The object center\r\n   */\n\n\n  PhysicsImpostor.prototype.getObjectCenter = function () {\n    if (this.object.getBoundingInfo) {\n      var boundingInfo = this.object.getBoundingInfo();\n      return boundingInfo.boundingBox.centerWorld;\n    } else {\n      return this.object.position;\n    }\n  };\n  /**\r\n   * Get a specific parameter from the options parameters\r\n   * @param paramName The object parameter name\r\n   * @returns The object parameter\r\n   */\n\n\n  PhysicsImpostor.prototype.getParam = function (paramName) {\n    return this._options[paramName];\n  };\n  /**\r\n   * Sets a specific parameter in the options given to the physics plugin\r\n   * @param paramName The parameter name\r\n   * @param value The value of the parameter\r\n   */\n\n\n  PhysicsImpostor.prototype.setParam = function (paramName, value) {\n    this._options[paramName] = value;\n    this._bodyUpdateRequired = true;\n  };\n  /**\r\n   * Specifically change the body's mass option. Won't recreate the physics body object\r\n   * @param mass The mass of the physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.setMass = function (mass) {\n    if (this.getParam(\"mass\") !== mass) {\n      this.setParam(\"mass\", mass);\n    }\n\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\n    }\n  };\n  /**\r\n   * Gets the linear velocity\r\n   * @returns  linear velocity or null\r\n   */\n\n\n  PhysicsImpostor.prototype.getLinearVelocity = function () {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();\n  };\n  /**\r\n   * Sets the linear velocity\r\n   * @param velocity  linear velocity or null\r\n   */\n\n\n  PhysicsImpostor.prototype.setLinearVelocity = function (velocity) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\n    }\n  };\n  /**\r\n   * Gets the angular velocity\r\n   * @returns angular velocity or null\r\n   */\n\n\n  PhysicsImpostor.prototype.getAngularVelocity = function () {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();\n  };\n  /**\r\n   * Sets the angular velocity\r\n   * @param velocity The velocity or null\r\n   */\n\n\n  PhysicsImpostor.prototype.setAngularVelocity = function (velocity) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\n    }\n  };\n  /**\r\n   * Execute a function with the physics plugin native code\r\n   * Provide a function the will have two variables - the world object and the physics body object\r\n   * @param func The function to execute with the physics plugin native code\r\n   */\n\n\n  PhysicsImpostor.prototype.executeNativeFunction = function (func) {\n    if (this._physicsEngine) {\n      func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\n    }\n  };\n  /**\r\n   * Register a function that will be executed before the physics world is stepping forward\r\n   * @param func The function to execute before the physics world is stepped forward\r\n   */\n\n\n  PhysicsImpostor.prototype.registerBeforePhysicsStep = function (func) {\n    this._onBeforePhysicsStepCallbacks.push(func);\n  };\n  /**\r\n   * Unregister a function that will be executed before the physics world is stepping forward\r\n   * @param func The function to execute before the physics world is stepped forward\r\n   */\n\n\n  PhysicsImpostor.prototype.unregisterBeforePhysicsStep = function (func) {\n    var index = this._onBeforePhysicsStepCallbacks.indexOf(func);\n\n    if (index > -1) {\n      this._onBeforePhysicsStepCallbacks.splice(index, 1);\n    } else {\n      Logger.Warn(\"Function to remove was not found\");\n    }\n  };\n  /**\r\n   * Register a function that will be executed after the physics step\r\n   * @param func The function to execute after physics step\r\n   */\n\n\n  PhysicsImpostor.prototype.registerAfterPhysicsStep = function (func) {\n    this._onAfterPhysicsStepCallbacks.push(func);\n  };\n  /**\r\n   * Unregisters a function that will be executed after the physics step\r\n   * @param func The function to execute after physics step\r\n   */\n\n\n  PhysicsImpostor.prototype.unregisterAfterPhysicsStep = function (func) {\n    var index = this._onAfterPhysicsStepCallbacks.indexOf(func);\n\n    if (index > -1) {\n      this._onAfterPhysicsStepCallbacks.splice(index, 1);\n    } else {\n      Logger.Warn(\"Function to remove was not found\");\n    }\n  };\n  /**\r\n   * register a function that will be executed when this impostor collides against a different body\r\n   * @param collideAgainst Physics imposter, or array of physics imposters to collide against\r\n   * @param func Callback that is executed on collision\r\n   */\n\n\n  PhysicsImpostor.prototype.registerOnPhysicsCollide = function (collideAgainst, func) {\n    var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];\n\n    this._onPhysicsCollideCallbacks.push({\n      callback: func,\n      otherImpostors: collidedAgainstList\n    });\n  };\n  /**\r\n   * Unregisters the physics imposter on contact\r\n   * @param collideAgainst The physics object to collide against\r\n   * @param func Callback to execute on collision\r\n   */\n\n\n  PhysicsImpostor.prototype.unregisterOnPhysicsCollide = function (collideAgainst, func) {\n    var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];\n    var index = -1;\n\n    var found = this._onPhysicsCollideCallbacks.some(function (cbDef, idx) {\n      if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {\n        // chcek the arrays match\n        var sameList = cbDef.otherImpostors.every(function (impostor) {\n          return collidedAgainstList.indexOf(impostor) > -1;\n        });\n\n        if (sameList) {\n          index = idx;\n        }\n\n        return sameList;\n      }\n\n      return false;\n    });\n\n    if (found) {\n      this._onPhysicsCollideCallbacks.splice(index, 1);\n    } else {\n      Logger.Warn(\"Function to remove was not found\");\n    }\n  };\n  /**\r\n   * Get the parent rotation\r\n   * @returns The parent rotation\r\n   */\n\n\n  PhysicsImpostor.prototype.getParentsRotation = function () {\n    var parent = this.object.parent;\n\n    this._tmpQuat.copyFromFloats(0, 0, 0, 1);\n\n    while (parent) {\n      if (parent.rotationQuaternion) {\n        this._tmpQuat2.copyFrom(parent.rotationQuaternion);\n      } else {\n        Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);\n      }\n\n      this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);\n\n      parent = parent.parent;\n    }\n\n    return this._tmpQuat;\n  };\n  /**\r\n   * Apply a force\r\n   * @param force The force to apply\r\n   * @param contactPoint The contact point for the force\r\n   * @returns The physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.applyForce = function (force, contactPoint) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\n    }\n\n    return this;\n  };\n  /**\r\n   * Apply an impulse\r\n   * @param force The impulse force\r\n   * @param contactPoint The contact point for the impulse force\r\n   * @returns The physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.applyImpulse = function (force, contactPoint) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\n    }\n\n    return this;\n  };\n  /**\r\n   * A help function to create a joint\r\n   * @param otherImpostor A physics imposter used to create a joint\r\n   * @param jointType The type of joint\r\n   * @param jointData The data for the joint\r\n   * @returns The physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.createJoint = function (otherImpostor, jointType, jointData) {\n    var joint = new PhysicsJoint(jointType, jointData);\n    this.addJoint(otherImpostor, joint);\n    return this;\n  };\n  /**\r\n   * Add a joint to this impostor with a different impostor\r\n   * @param otherImpostor A physics imposter used to add a joint\r\n   * @param joint The joint to add\r\n   * @returns The physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.addJoint = function (otherImpostor, joint) {\n    this._joints.push({\n      otherImpostor: otherImpostor,\n      joint: joint\n    });\n\n    if (this._physicsEngine) {\n      this._physicsEngine.addJoint(this, otherImpostor, joint);\n    }\n\n    return this;\n  };\n  /**\r\n   * Add an anchor to a cloth impostor\r\n   * @param otherImpostor rigid impostor to anchor to\r\n   * @param width ratio across width from 0 to 1\r\n   * @param height ratio up height from 0 to 1\r\n   * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech\r\n   * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false\r\n   * @returns impostor the soft imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.addAnchor = function (otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {\n    if (!this._physicsEngine) {\n      return this;\n    }\n\n    var plugin = this._physicsEngine.getPhysicsPlugin();\n\n    if (!plugin.appendAnchor) {\n      return this;\n    }\n\n    if (this._physicsEngine) {\n      plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);\n    }\n\n    return this;\n  };\n  /**\r\n   * Add a hook to a rope impostor\r\n   * @param otherImpostor rigid impostor to anchor to\r\n   * @param length ratio across rope from 0 to 1\r\n   * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little strech\r\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n   * @returns impostor the rope imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.addHook = function (otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {\n    if (!this._physicsEngine) {\n      return this;\n    }\n\n    var plugin = this._physicsEngine.getPhysicsPlugin();\n\n    if (!plugin.appendAnchor) {\n      return this;\n    }\n\n    if (this._physicsEngine) {\n      plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);\n    }\n\n    return this;\n  };\n  /**\r\n   * Will keep this body still, in a sleep mode.\r\n   * @returns the physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.sleep = function () {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().sleepBody(this);\n    }\n\n    return this;\n  };\n  /**\r\n   * Wake the body up.\r\n   * @returns The physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.wakeUp = function () {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\n    }\n\n    return this;\n  };\n  /**\r\n   * Clones the physics imposter\r\n   * @param newObject The physics imposter clones to this physics-enabled object\r\n   * @returns A nullable physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.clone = function (newObject) {\n    if (!newObject) {\n      return null;\n    }\n\n    return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\n  };\n  /**\r\n   * Disposes the physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.dispose = function\n    /*disposeChildren: boolean = true*/\n  () {\n    var _this = this; //no dispose if no physics engine is available.\n\n\n    if (!this._physicsEngine) {\n      return;\n    }\n\n    this._joints.forEach(function (j) {\n      if (_this._physicsEngine) {\n        _this._physicsEngine.removeJoint(_this, j.otherImpostor, j.joint);\n      }\n    }); //dispose the physics body\n\n\n    this._physicsEngine.removeImpostor(this);\n\n    if (this.parent) {\n      this.parent.forceUpdate();\n    } else {\n      /*this._object.getChildMeshes().forEach(function(mesh) {\r\n          if (mesh.physicsImpostor) {\r\n              if (disposeChildren) {\r\n                  mesh.physicsImpostor.dispose();\r\n                  mesh.physicsImpostor = null;\r\n              }\r\n          }\r\n      })*/\n    }\n\n    this._isDisposed = true;\n  };\n  /**\r\n   * Sets the delta position\r\n   * @param position The delta position amount\r\n   */\n\n\n  PhysicsImpostor.prototype.setDeltaPosition = function (position) {\n    this._deltaPosition.copyFrom(position);\n  };\n  /**\r\n   * Sets the delta rotation\r\n   * @param rotation The delta rotation amount\r\n   */\n\n\n  PhysicsImpostor.prototype.setDeltaRotation = function (rotation) {\n    if (!this._deltaRotation) {\n      this._deltaRotation = new Quaternion();\n    }\n\n    this._deltaRotation.copyFrom(rotation);\n\n    this._deltaRotationConjugated = this._deltaRotation.conjugate();\n  };\n  /**\r\n   * Gets the box size of the physics imposter and stores the result in the input parameter\r\n   * @param result Stores the box size\r\n   * @returns The physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.getBoxSizeToRef = function (result) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\n    }\n\n    return this;\n  };\n  /**\r\n   * Gets the radius of the physics imposter\r\n   * @returns Radius of the physics imposter\r\n   */\n\n\n  PhysicsImpostor.prototype.getRadius = function () {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\n  };\n  /**\r\n   * Sync a bone with this impostor\r\n   * @param bone The bone to sync to the impostor.\r\n   * @param boneMesh The mesh that the bone is influencing.\r\n   * @param jointPivot The pivot of the joint / bone in local space.\r\n   * @param distToJoint Optional distance from the impostor to the joint.\r\n   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n   */\n\n\n  PhysicsImpostor.prototype.syncBoneWithImpostor = function (bone, boneMesh, jointPivot, distToJoint, adjustRotation) {\n    var tempVec = PhysicsImpostor._tmpVecs[0];\n    var mesh = this.object;\n\n    if (mesh.rotationQuaternion) {\n      if (adjustRotation) {\n        var tempQuat = PhysicsImpostor._tmpQuat;\n        mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\n        bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);\n      } else {\n        bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);\n      }\n    }\n\n    tempVec.x = 0;\n    tempVec.y = 0;\n    tempVec.z = 0;\n\n    if (jointPivot) {\n      tempVec.x = jointPivot.x;\n      tempVec.y = jointPivot.y;\n      tempVec.z = jointPivot.z;\n      bone.getDirectionToRef(tempVec, boneMesh, tempVec);\n\n      if (distToJoint === undefined || distToJoint === null) {\n        distToJoint = jointPivot.length();\n      }\n\n      tempVec.x *= distToJoint;\n      tempVec.y *= distToJoint;\n      tempVec.z *= distToJoint;\n    }\n\n    if (bone.getParent()) {\n      tempVec.addInPlace(mesh.getAbsolutePosition());\n      bone.setAbsolutePosition(tempVec, boneMesh);\n    } else {\n      boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\n      boneMesh.position.x -= tempVec.x;\n      boneMesh.position.y -= tempVec.y;\n      boneMesh.position.z -= tempVec.z;\n    }\n  };\n  /**\r\n   * Sync impostor to a bone\r\n   * @param bone The bone that the impostor will be synced to.\r\n   * @param boneMesh The mesh that the bone is influencing.\r\n   * @param jointPivot The pivot of the joint / bone in local space.\r\n   * @param distToJoint Optional distance from the impostor to the joint.\r\n   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n   * @param boneAxis Optional vector3 axis the bone is aligned with\r\n   */\n\n\n  PhysicsImpostor.prototype.syncImpostorWithBone = function (bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {\n    var mesh = this.object;\n\n    if (mesh.rotationQuaternion) {\n      if (adjustRotation) {\n        var tempQuat = PhysicsImpostor._tmpQuat;\n        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\n        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\n      } else {\n        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\n      }\n    }\n\n    var pos = PhysicsImpostor._tmpVecs[0];\n    var boneDir = PhysicsImpostor._tmpVecs[1];\n\n    if (!boneAxis) {\n      boneAxis = PhysicsImpostor._tmpVecs[2];\n      boneAxis.x = 0;\n      boneAxis.y = 1;\n      boneAxis.z = 0;\n    }\n\n    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\n    bone.getAbsolutePositionToRef(boneMesh, pos);\n\n    if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\n      distToJoint = jointPivot.length();\n    }\n\n    if (distToJoint !== undefined && distToJoint !== null) {\n      pos.x += boneDir.x * distToJoint;\n      pos.y += boneDir.y * distToJoint;\n      pos.z += boneDir.z * distToJoint;\n    }\n\n    mesh.setAbsolutePosition(pos);\n  };\n  /**\r\n   * The default object size of the imposter\r\n   */\n\n\n  PhysicsImpostor.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);\n  /**\r\n   * The identity quaternion of the imposter\r\n   */\n\n  PhysicsImpostor.IDENTITY_QUATERNION = Quaternion.Identity();\n  PhysicsImpostor._tmpVecs = ArrayTools.BuildArray(3, Vector3.Zero);\n  PhysicsImpostor._tmpQuat = Quaternion.Identity(); //Impostor types\n\n  /**\r\n   * No-Imposter type\r\n   */\n\n  PhysicsImpostor.NoImpostor = 0;\n  /**\r\n   * Sphere-Imposter type\r\n   */\n\n  PhysicsImpostor.SphereImpostor = 1;\n  /**\r\n   * Box-Imposter type\r\n   */\n\n  PhysicsImpostor.BoxImpostor = 2;\n  /**\r\n   * Plane-Imposter type\r\n   */\n\n  PhysicsImpostor.PlaneImpostor = 3;\n  /**\r\n   * Mesh-imposter type\r\n   */\n\n  PhysicsImpostor.MeshImpostor = 4;\n  /**\r\n   * Capsule-Impostor type (Ammo.js plugin only)\r\n   */\n\n  PhysicsImpostor.CapsuleImpostor = 6;\n  /**\r\n   * Cylinder-Imposter type\r\n   */\n\n  PhysicsImpostor.CylinderImpostor = 7;\n  /**\r\n   * Particle-Imposter type\r\n   */\n\n  PhysicsImpostor.ParticleImpostor = 8;\n  /**\r\n   * Heightmap-Imposter type\r\n   */\n\n  PhysicsImpostor.HeightmapImpostor = 9;\n  /**\r\n   * ConvexHull-Impostor type (Ammo.js plugin only)\r\n   */\n\n  PhysicsImpostor.ConvexHullImpostor = 10;\n  /**\r\n   * Custom-Imposter type (Ammo.js plugin only)\r\n   */\n\n  PhysicsImpostor.CustomImpostor = 100;\n  /**\r\n   * Rope-Imposter type\r\n   */\n\n  PhysicsImpostor.RopeImpostor = 101;\n  /**\r\n   * Cloth-Imposter type\r\n   */\n\n  PhysicsImpostor.ClothImpostor = 102;\n  /**\r\n   * Softbody-Imposter type\r\n   */\n\n  PhysicsImpostor.SoftbodyImpostor = 103;\n  return PhysicsImpostor;\n}();\n\nexport { PhysicsImpostor };","map":null,"metadata":{},"sourceType":"module"}