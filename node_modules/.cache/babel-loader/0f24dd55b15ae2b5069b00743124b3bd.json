{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport { Observable } from \"../Misc/observable\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/how_to/webxr_session_manager\r\n */\n\nvar WebXRSessionManager =\n/** @class */\nfunction () {\n  /**\r\n   * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n   * @param scene The scene which the session should be created for\r\n   */\n  function WebXRSessionManager(\n  /** The scene which the session should be created for */\n  scene) {\n    this.scene = scene;\n    this._sessionEnded = false;\n    this.baseLayer = null;\n    /** WebXR timestamp updated every frame */\n\n    this.currentTimestamp = -1;\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\n\n    this.defaultHeightCompensation = 1.7;\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\n\n    this.onXRFrameObservable = new Observable();\n    /**\r\n     * Fires when the reference space changed\r\n     */\n\n    this.onXRReferenceSpaceChanged = new Observable();\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\n\n    this.onXRSessionEnded = new Observable();\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\n\n    this.onXRSessionInit = new Observable();\n  }\n\n  Object.defineProperty(WebXRSessionManager.prototype, \"referenceSpace\", {\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\n    get: function get() {\n      return this._referenceSpace;\n    },\n\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\n    set: function set(newReferenceSpace) {\n      this._referenceSpace = newReferenceSpace;\n      this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes of the session manager\r\n   */\n\n  WebXRSessionManager.prototype.dispose = function () {\n    // disposing without leaving XR? Exit XR first\n    if (!this._sessionEnded) {\n      this.exitXRAsync();\n    }\n\n    this.onXRFrameObservable.clear();\n    this.onXRSessionEnded.clear();\n    this.onXRReferenceSpaceChanged.clear();\n    this.onXRSessionInit.clear();\n  };\n  /**\r\n   * Stops the xrSession and restores the render loop\r\n   * @returns Promise which resolves after it exits XR\r\n   */\n\n\n  WebXRSessionManager.prototype.exitXRAsync = function () {\n    if (this.session && !this._sessionEnded) {\n      this._sessionEnded = true;\n      return this.session.end().catch(function (e) {\n        Logger.Warn(\"Could not end XR session.\");\n      });\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n   * Gets the correct render target texture to be rendered this frame for this eye\r\n   * @param eye the eye for which to get the render target\r\n   * @returns the render target for the specified eye\r\n   */\n\n\n  WebXRSessionManager.prototype.getRenderTargetTextureForEye = function (eye) {\n    return this._rttProvider.getRenderTargetForEye(eye);\n  };\n  /**\r\n   * Creates a WebXRRenderTarget object for the XR session\r\n   * @param onStateChangedObservable optional, mechanism for enabling/disabling XR rendering canvas, used only on Web\r\n   * @param options optional options to provide when creating a new render target\r\n   * @returns a WebXR render target to which the session can render\r\n   */\n\n\n  WebXRSessionManager.prototype.getWebXRRenderTarget = function (options) {\n    var engine = this.scene.getEngine();\n\n    if (this._xrNavigator.xr.native) {\n      return this._xrNavigator.xr.getWebXRRenderTarget(engine);\n    } else {\n      options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\n      options.canvasElement = engine.getRenderingCanvas() || undefined;\n      return new WebXRManagedOutputCanvas(this, options);\n    }\n  };\n  /**\r\n   * Initializes the manager\r\n   * After initialization enterXR can be called to start an XR session\r\n   * @returns Promise which resolves after it is initialized\r\n   */\n\n\n  WebXRSessionManager.prototype.initializeAsync = function () {\n    // Check if the browser supports webXR\n    this._xrNavigator = navigator;\n\n    if (!this._xrNavigator.xr) {\n      return Promise.reject(\"WebXR not available\");\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n   * Initializes an xr session\r\n   * @param xrSessionMode mode to initialize\r\n   * @param xrSessionInit defines optional and required values to pass to the session builder\r\n   * @returns a promise which will resolve once the session has been initialized\r\n   */\n\n\n  WebXRSessionManager.prototype.initializeSessionAsync = function (xrSessionMode, xrSessionInit) {\n    var _this = this;\n\n    if (xrSessionMode === void 0) {\n      xrSessionMode = \"immersive-vr\";\n    }\n\n    if (xrSessionInit === void 0) {\n      xrSessionInit = {};\n    }\n\n    return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then(function (session) {\n      _this.session = session;\n\n      _this.onXRSessionInit.notifyObservers(session);\n\n      _this._sessionEnded = false; // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\n\n      _this.session.addEventListener(\"end\", function () {\n        var engine = _this.scene.getEngine();\n\n        _this._sessionEnded = true; // Remove render target texture and notify frame observers\n\n        _this._rttProvider = null; // make sure dimensions object is restored\n\n        engine.framebufferDimensionsObject = null; // Restore frame buffer to avoid clear on xr framebuffer after session end\n\n        engine.restoreDefaultFramebuffer(); // Need to restart render loop as after the session is ended the last request for new frame will never call callback\n\n        engine.customAnimationFrameRequester = null;\n\n        _this.onXRSessionEnded.notifyObservers(null);\n\n        engine._renderLoop();\n      }, {\n        once: true\n      });\n\n      return _this.session;\n    });\n  };\n  /**\r\n   * Checks if a session would be supported for the creation options specified\r\n   * @param sessionMode session mode to check if supported eg. immersive-vr\r\n   * @returns A Promise that resolves to true if supported and false if not\r\n   */\n\n\n  WebXRSessionManager.prototype.isSessionSupportedAsync = function (sessionMode) {\n    return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\n  };\n  /**\r\n   * Resets the reference space to the one started the session\r\n   */\n\n\n  WebXRSessionManager.prototype.resetReferenceSpace = function () {\n    this.referenceSpace = this.baseReferenceSpace;\n  };\n  /**\r\n   * Starts rendering to the xr layer\r\n   */\n\n\n  WebXRSessionManager.prototype.runXRRenderLoop = function () {\n    var _this = this;\n\n    var engine = this.scene.getEngine(); // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\n\n    engine.customAnimationFrameRequester = {\n      requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),\n      renderFunction: function renderFunction(timestamp, xrFrame) {\n        if (_this._sessionEnded) {\n          return;\n        } // Store the XR frame and timestamp in the session manager\n\n\n        _this.currentFrame = xrFrame;\n        _this.currentTimestamp = timestamp;\n\n        if (xrFrame) {\n          engine.framebufferDimensionsObject = _this.baseLayer;\n\n          _this.onXRFrameObservable.notifyObservers(xrFrame);\n\n          engine._renderLoop();\n\n          engine.framebufferDimensionsObject = null;\n        }\n      }\n    };\n\n    if (this._xrNavigator.xr.native) {\n      this._rttProvider = this._xrNavigator.xr.getNativeRenderTargetProvider(this.session, this._createRenderTargetTexture.bind(this));\n    } else {\n      // Create render target texture from xr's webgl render target\n      var rtt_1 = this._createRenderTargetTexture(this.baseLayer.framebufferWidth, this.baseLayer.framebufferHeight, this.baseLayer.framebuffer);\n\n      this._rttProvider = {\n        getRenderTargetForEye: function getRenderTargetForEye() {\n          return rtt_1;\n        }\n      };\n      engine.framebufferDimensionsObject = this.baseLayer;\n    } // Stop window's animation frame and trigger sessions animation frame\n\n\n    if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\n      window.cancelAnimationFrame(engine._frameHandler);\n    }\n\n    engine._renderLoop();\n  };\n  /**\r\n   * Sets the reference space on the xr session\r\n   * @param referenceSpaceType space to set\r\n   * @returns a promise that will resolve once the reference space has been set\r\n   */\n\n\n  WebXRSessionManager.prototype.setReferenceSpaceTypeAsync = function (referenceSpaceType) {\n    var _this = this;\n\n    if (referenceSpaceType === void 0) {\n      referenceSpaceType = \"local-floor\";\n    }\n\n    return this.session.requestReferenceSpace(referenceSpaceType).then(function (referenceSpace) {\n      return referenceSpace;\n    }, function (rejectionReason) {\n      Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\n      Logger.Error(rejectionReason);\n      Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\n      return _this.session.requestReferenceSpace(\"viewer\").then(function (referenceSpace) {\n        var heightCompensation = new XRRigidTransform({\n          x: 0,\n          y: -_this.defaultHeightCompensation,\n          z: 0\n        });\n        return referenceSpace.getOffsetReferenceSpace(heightCompensation);\n      }, function (rejectionReason) {\n        Logger.Error(rejectionReason);\n        throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\n      });\n    }).then(function (referenceSpace) {\n      // create viewer reference space before setting the first reference space\n      return _this.session.requestReferenceSpace(\"viewer\").then(function (viewerReferenceSpace) {\n        _this.viewerReferenceSpace = viewerReferenceSpace;\n        return referenceSpace;\n      });\n    }).then(function (referenceSpace) {\n      // initialize the base and offset (currently the same)\n      _this.referenceSpace = _this.baseReferenceSpace = referenceSpace;\n      return _this.referenceSpace;\n    });\n  };\n  /**\r\n   * Updates the render state of the session\r\n   * @param state state to set\r\n   * @returns a promise that resolves once the render state has been updated\r\n   */\n\n\n  WebXRSessionManager.prototype.updateRenderStateAsync = function (state) {\n    if (state.baseLayer) {\n      this.baseLayer = state.baseLayer;\n    }\n\n    return this.session.updateRenderState(state);\n  };\n  /**\r\n   * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n   * @param sessionMode defines the session to test\r\n   * @returns a promise with boolean as final value\r\n   */\n\n\n  WebXRSessionManager.IsSessionSupportedAsync = function (sessionMode) {\n    if (!navigator.xr) {\n      return Promise.resolve(false);\n    } // When the specs are final, remove supportsSession!\n\n\n    var functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;\n\n    if (!functionToUse) {\n      return Promise.resolve(false);\n    } else {\n      return functionToUse.call(navigator.xr, sessionMode).then(function (result) {\n        var returnValue = typeof result === \"undefined\" ? true : result;\n        return Promise.resolve(returnValue);\n      }).catch(function (e) {\n        Logger.Warn(e);\n        return Promise.resolve(false);\n      });\n    }\n  };\n\n  WebXRSessionManager.prototype._createRenderTargetTexture = function (width, height, framebuffer) {\n    if (framebuffer === void 0) {\n      framebuffer = null;\n    } // Create internal texture\n\n\n    var internalTexture = new InternalTexture(this.scene.getEngine(), InternalTextureSource.Unknown, true);\n    internalTexture.width = width;\n    internalTexture.height = height;\n    internalTexture._framebuffer = framebuffer; // Create render target texture from the internal texture\n\n    var renderTargetTexture = new RenderTargetTexture(\"XR renderTargetTexture\", {\n      width: width,\n      height: height\n    }, this.scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\n    renderTargetTexture._texture = internalTexture;\n    return renderTargetTexture;\n  };\n\n  return WebXRSessionManager;\n}();\n\nexport { WebXRSessionManager };","map":null,"metadata":{},"sourceType":"module"}