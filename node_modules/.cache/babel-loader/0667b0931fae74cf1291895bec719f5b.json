{"ast":null,"code":"import { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight\";\nimport { Light } from \"@babylonjs/core/Lights/light\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nvar NAME = \"KHR_lights_punctual\";\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual)\r\n */\n\nvar KHR_lights =\n/** @class */\nfunction () {\n  /** @hidden */\n  function KHR_lights(loader) {\n    /**\r\n     * The name of this extension.\r\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  KHR_lights.prototype.dispose = function () {\n    this._loader = null;\n    delete this._lights;\n  };\n  /** @hidden */\n\n\n  KHR_lights.prototype.onLoading = function () {\n    var extensions = this._loader.gltf.extensions;\n\n    if (extensions && extensions[this.name]) {\n      var extension = extensions[this.name];\n      this._lights = extension.lights;\n    }\n  };\n  /** @hidden */\n\n\n  KHR_lights.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n      return _this._loader.loadNodeAsync(context, node, function (babylonMesh) {\n        var babylonLight;\n        var light = ArrayItem.Get(extensionContext, _this._lights, extension.light);\n        var name = light.name || babylonMesh.name;\n        _this._loader.babylonScene._blockEntityCollection = _this._loader._forAssetContainer;\n\n        switch (light.type) {\n          case \"directional\"\n          /* DIRECTIONAL */\n          :\n            {\n              babylonLight = new DirectionalLight(name, Vector3.Backward(), _this._loader.babylonScene);\n              break;\n            }\n\n          case \"point\"\n          /* POINT */\n          :\n            {\n              babylonLight = new PointLight(name, Vector3.Zero(), _this._loader.babylonScene);\n              break;\n            }\n\n          case \"spot\"\n          /* SPOT */\n          :\n            {\n              var babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, _this._loader.babylonScene);\n              babylonSpotLight.angle = (light.spot && light.spot.outerConeAngle || Math.PI / 4) * 2;\n              babylonSpotLight.innerAngle = (light.spot && light.spot.innerConeAngle || 0) * 2;\n              babylonLight = babylonSpotLight;\n              break;\n            }\n\n          default:\n            {\n              _this._loader.babylonScene._blockEntityCollection = false;\n              throw new Error(extensionContext + \": Invalid light type (\" + light.type + \")\");\n            }\n        }\n\n        _this._loader.babylonScene._blockEntityCollection = false;\n        babylonLight.falloffType = Light.FALLOFF_GLTF;\n        babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n        babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n        babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n        babylonLight.parent = babylonMesh;\n\n        _this._loader._babylonLights.push(babylonLight);\n\n        GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n        assign(babylonMesh);\n      });\n    });\n  };\n\n  return KHR_lights;\n}();\n\nexport { KHR_lights };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_lights(loader);\n});","map":null,"metadata":{},"sourceType":"module"}