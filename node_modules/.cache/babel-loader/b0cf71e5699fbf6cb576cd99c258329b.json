{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport \"../Engines/Extensions/engine.uniformBuffer\";\n/**\r\n * Uniform buffer objects.\r\n *\r\n * Handles blocks of uniform on the GPU.\r\n *\r\n * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.\r\n *\r\n * For more information, please refer to :\r\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n */\n\nvar UniformBuffer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new Uniform buffer objects.\r\n   *\r\n   * Handles blocks of uniform on the GPU.\r\n   *\r\n   * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.\r\n   *\r\n   * For more information, please refer to :\r\n   * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n   * @param engine Define the engine the buffer is associated with\r\n   * @param data Define the data contained in the buffer\r\n   * @param dynamic Define if the buffer is updatable\r\n   */\n  function UniformBuffer(engine, data, dynamic) {\n    /** @hidden */\n    this._alreadyBound = false; // Matrix cache\n\n    this._valueCache = {};\n    this._engine = engine;\n    this._noUBO = !engine.supportsUniformBuffers;\n    this._dynamic = dynamic;\n    this._data = data || [];\n    this._uniformLocations = {};\n    this._uniformSizes = {};\n    this._uniformLocationPointer = 0;\n    this._needSync = false;\n\n    if (this._noUBO) {\n      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\n      this.updateFloat = this._updateFloatForEffect;\n      this.updateFloat2 = this._updateFloat2ForEffect;\n      this.updateFloat3 = this._updateFloat3ForEffect;\n      this.updateFloat4 = this._updateFloat4ForEffect;\n      this.updateMatrix = this._updateMatrixForEffect;\n      this.updateVector3 = this._updateVector3ForEffect;\n      this.updateVector4 = this._updateVector4ForEffect;\n      this.updateColor3 = this._updateColor3ForEffect;\n      this.updateColor4 = this._updateColor4ForEffect;\n    } else {\n      this._engine._uniformBuffers.push(this);\n\n      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\n      this.updateFloat = this._updateFloatForUniform;\n      this.updateFloat2 = this._updateFloat2ForUniform;\n      this.updateFloat3 = this._updateFloat3ForUniform;\n      this.updateFloat4 = this._updateFloat4ForUniform;\n      this.updateMatrix = this._updateMatrixForUniform;\n      this.updateVector3 = this._updateVector3ForUniform;\n      this.updateVector4 = this._updateVector4ForUniform;\n      this.updateColor3 = this._updateColor3ForUniform;\n      this.updateColor4 = this._updateColor4ForUniform;\n    }\n  }\n\n  Object.defineProperty(UniformBuffer.prototype, \"useUbo\", {\n    /**\r\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\r\n     * or just falling back on setUniformXXX calls.\r\n     */\n    get: function get() {\n      return !this._noUBO;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UniformBuffer.prototype, \"isSync\", {\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is in sync\r\n     * with the javascript cache data.\r\n     */\n    get: function get() {\n      return !this._needSync;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Indicates if the WebGL underlying uniform buffer is dynamic.\r\n   * Also, a dynamic UniformBuffer will disable cache verification and always\r\n   * update the underlying WebGL uniform buffer to the GPU.\r\n   * @returns if Dynamic, otherwise false\r\n   */\n\n  UniformBuffer.prototype.isDynamic = function () {\n    return this._dynamic !== undefined;\n  };\n  /**\r\n   * The data cache on JS side.\r\n   * @returns the underlying data as a float array\r\n   */\n\n\n  UniformBuffer.prototype.getData = function () {\n    return this._bufferData;\n  };\n  /**\r\n   * The underlying WebGL Uniform buffer.\r\n   * @returns the webgl buffer\r\n   */\n\n\n  UniformBuffer.prototype.getBuffer = function () {\n    return this._buffer;\n  };\n  /**\r\n   * std140 layout specifies how to align data within an UBO structure.\r\n   * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\r\n   * for specs.\r\n   */\n\n\n  UniformBuffer.prototype._fillAlignment = function (size) {\n    // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\n    // and 4x4 matrices\n    // TODO : change if other types are used\n    var alignment;\n\n    if (size <= 2) {\n      alignment = size;\n    } else {\n      alignment = 4;\n    }\n\n    if (this._uniformLocationPointer % alignment !== 0) {\n      var oldPointer = this._uniformLocationPointer;\n      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;\n      var diff = this._uniformLocationPointer - oldPointer;\n\n      for (var i = 0; i < diff; i++) {\n        this._data.push(0);\n      }\n    }\n  };\n  /**\r\n   * Adds an uniform in the buffer.\r\n   * Warning : the subsequents calls of this function must be in the same order as declared in the shader\r\n   * for the layout to be correct !\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param size Data size, or data directly.\r\n   */\n\n\n  UniformBuffer.prototype.addUniform = function (name, size) {\n    if (this._noUBO) {\n      return;\n    }\n\n    if (this._uniformLocations[name] !== undefined) {\n      // Already existing uniform\n      return;\n    } // This function must be called in the order of the shader layout !\n    // size can be the size of the uniform, or data directly\n\n\n    var data;\n\n    if (size instanceof Array) {\n      data = size;\n      size = data.length;\n    } else {\n      size = size;\n      data = []; // Fill with zeros\n\n      for (var i = 0; i < size; i++) {\n        data.push(0);\n      }\n    }\n\n    this._fillAlignment(size);\n\n    this._uniformSizes[name] = size;\n    this._uniformLocations[name] = this._uniformLocationPointer;\n    this._uniformLocationPointer += size;\n\n    for (var i = 0; i < size; i++) {\n      this._data.push(data[i]);\n    }\n\n    this._needSync = true;\n  };\n  /**\r\n   * Adds a Matrix 4x4 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param mat A 4x4 matrix.\r\n   */\n\n\n  UniformBuffer.prototype.addMatrix = function (name, mat) {\n    this.addUniform(name, Array.prototype.slice.call(mat.toArray()));\n  };\n  /**\r\n   * Adds a vec2 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param x Define the x component value of the vec2\r\n   * @param y Define the y component value of the vec2\r\n   */\n\n\n  UniformBuffer.prototype.addFloat2 = function (name, x, y) {\n    var temp = [x, y];\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a vec3 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param x Define the x component value of the vec3\r\n   * @param y Define the y component value of the vec3\r\n   * @param z Define the z component value of the vec3\r\n   */\n\n\n  UniformBuffer.prototype.addFloat3 = function (name, x, y, z) {\n    var temp = [x, y, z];\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a vec3 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param color Define the vec3 from a Color\r\n   */\n\n\n  UniformBuffer.prototype.addColor3 = function (name, color) {\n    var temp = new Array();\n    color.toArray(temp);\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a vec4 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param color Define the rgb components from a Color\r\n   * @param alpha Define the a component of the vec4\r\n   */\n\n\n  UniformBuffer.prototype.addColor4 = function (name, color, alpha) {\n    var temp = new Array();\n    color.toArray(temp);\n    temp.push(alpha);\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a vec3 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param vector Define the vec3 components from a Vector\r\n   */\n\n\n  UniformBuffer.prototype.addVector3 = function (name, vector) {\n    var temp = new Array();\n    vector.toArray(temp);\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a Matrix 3x3 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   */\n\n\n  UniformBuffer.prototype.addMatrix3x3 = function (name) {\n    this.addUniform(name, 12);\n  };\n  /**\r\n   * Adds a Matrix 2x2 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   */\n\n\n  UniformBuffer.prototype.addMatrix2x2 = function (name) {\n    this.addUniform(name, 8);\n  };\n  /**\r\n   * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\r\n   */\n\n\n  UniformBuffer.prototype.create = function () {\n    if (this._noUBO) {\n      return;\n    }\n\n    if (this._buffer) {\n      return; // nothing to do\n    } // See spec, alignment must be filled as a vec4\n\n\n    this._fillAlignment(4);\n\n    this._bufferData = new Float32Array(this._data);\n\n    this._rebuild();\n\n    this._needSync = true;\n  };\n  /** @hidden */\n\n\n  UniformBuffer.prototype._rebuild = function () {\n    if (this._noUBO || !this._bufferData) {\n      return;\n    }\n\n    if (this._dynamic) {\n      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);\n    } else {\n      this._buffer = this._engine.createUniformBuffer(this._bufferData);\n    }\n  };\n  /**\r\n   * Updates the WebGL Uniform Buffer on the GPU.\r\n   * If the `dynamic` flag is set to true, no cache comparison is done.\r\n   * Otherwise, the buffer will be updated only if the cache differs.\r\n   */\n\n\n  UniformBuffer.prototype.update = function () {\n    if (!this._buffer) {\n      this.create();\n      return;\n    }\n\n    if (!this._dynamic && !this._needSync) {\n      return;\n    }\n\n    this._engine.updateUniformBuffer(this._buffer, this._bufferData);\n\n    this._needSync = false;\n  };\n  /**\r\n   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n   * @param data Define the flattened data\r\n   * @param size Define the size of the data.\r\n   */\n\n\n  UniformBuffer.prototype.updateUniform = function (uniformName, data, size) {\n    var location = this._uniformLocations[uniformName];\n\n    if (location === undefined) {\n      if (this._buffer) {\n        // Cannot add an uniform if the buffer is already created\n        Logger.Error(\"Cannot add an uniform after UBO has been created.\");\n        return;\n      }\n\n      this.addUniform(uniformName, size);\n      location = this._uniformLocations[uniformName];\n    }\n\n    if (!this._buffer) {\n      this.create();\n    }\n\n    if (!this._dynamic) {\n      // Cache for static uniform buffers\n      var changed = false;\n\n      for (var i = 0; i < size; i++) {\n        // We are checking the matrix cache before calling updateUniform so we do not need to check it here\n        // Hence the test for size === 16 to simply commit the matrix values\n        if (size === 16 || this._bufferData[location + i] !== data[i]) {\n          changed = true;\n          this._bufferData[location + i] = data[i];\n        }\n      }\n\n      this._needSync = this._needSync || changed;\n    } else {\n      // No cache for dynamic\n      for (var i = 0; i < size; i++) {\n        this._bufferData[location + i] = data[i];\n      }\n    }\n  };\n\n  UniformBuffer.prototype._cacheMatrix = function (name, matrix) {\n    var cache = this._valueCache[name];\n    var flag = matrix.updateFlag;\n\n    if (cache !== undefined && cache === flag) {\n      return false;\n    }\n\n    this._valueCache[name] = flag;\n    return true;\n  }; // Update methods\n\n\n  UniformBuffer.prototype._updateMatrix3x3ForUniform = function (name, matrix) {\n    // To match std140, matrix must be realigned\n    for (var i = 0; i < 3; i++) {\n      UniformBuffer._tempBuffer[i * 4] = matrix[i * 3];\n      UniformBuffer._tempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\n      UniformBuffer._tempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\n      UniformBuffer._tempBuffer[i * 4 + 3] = 0.0;\n    }\n\n    this.updateUniform(name, UniformBuffer._tempBuffer, 12);\n  };\n\n  UniformBuffer.prototype._updateMatrix3x3ForEffect = function (name, matrix) {\n    this._currentEffect.setMatrix3x3(name, matrix);\n  };\n\n  UniformBuffer.prototype._updateMatrix2x2ForEffect = function (name, matrix) {\n    this._currentEffect.setMatrix2x2(name, matrix);\n  };\n\n  UniformBuffer.prototype._updateMatrix2x2ForUniform = function (name, matrix) {\n    // To match std140, matrix must be realigned\n    for (var i = 0; i < 2; i++) {\n      UniformBuffer._tempBuffer[i * 4] = matrix[i * 2];\n      UniformBuffer._tempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\n      UniformBuffer._tempBuffer[i * 4 + 2] = 0.0;\n      UniformBuffer._tempBuffer[i * 4 + 3] = 0.0;\n    }\n\n    this.updateUniform(name, UniformBuffer._tempBuffer, 8);\n  };\n\n  UniformBuffer.prototype._updateFloatForEffect = function (name, x) {\n    this._currentEffect.setFloat(name, x);\n  };\n\n  UniformBuffer.prototype._updateFloatForUniform = function (name, x) {\n    UniformBuffer._tempBuffer[0] = x;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 1);\n  };\n\n  UniformBuffer.prototype._updateFloat2ForEffect = function (name, x, y, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat2(name + suffix, x, y);\n  };\n\n  UniformBuffer.prototype._updateFloat2ForUniform = function (name, x, y) {\n    UniformBuffer._tempBuffer[0] = x;\n    UniformBuffer._tempBuffer[1] = y;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 2);\n  };\n\n  UniformBuffer.prototype._updateFloat3ForEffect = function (name, x, y, z, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat3(name + suffix, x, y, z);\n  };\n\n  UniformBuffer.prototype._updateFloat3ForUniform = function (name, x, y, z) {\n    UniformBuffer._tempBuffer[0] = x;\n    UniformBuffer._tempBuffer[1] = y;\n    UniformBuffer._tempBuffer[2] = z;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateFloat4ForEffect = function (name, x, y, z, w, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat4(name + suffix, x, y, z, w);\n  };\n\n  UniformBuffer.prototype._updateFloat4ForUniform = function (name, x, y, z, w) {\n    UniformBuffer._tempBuffer[0] = x;\n    UniformBuffer._tempBuffer[1] = y;\n    UniformBuffer._tempBuffer[2] = z;\n    UniformBuffer._tempBuffer[3] = w;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n  };\n\n  UniformBuffer.prototype._updateMatrixForEffect = function (name, mat) {\n    this._currentEffect.setMatrix(name, mat);\n  };\n\n  UniformBuffer.prototype._updateMatrixForUniform = function (name, mat) {\n    if (this._cacheMatrix(name, mat)) {\n      this.updateUniform(name, mat.toArray(), 16);\n    }\n  };\n\n  UniformBuffer.prototype._updateVector3ForEffect = function (name, vector) {\n    this._currentEffect.setVector3(name, vector);\n  };\n\n  UniformBuffer.prototype._updateVector3ForUniform = function (name, vector) {\n    vector.toArray(UniformBuffer._tempBuffer);\n    this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateVector4ForEffect = function (name, vector) {\n    this._currentEffect.setVector4(name, vector);\n  };\n\n  UniformBuffer.prototype._updateVector4ForUniform = function (name, vector) {\n    vector.toArray(UniformBuffer._tempBuffer);\n    this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n  };\n\n  UniformBuffer.prototype._updateColor3ForEffect = function (name, color, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setColor3(name + suffix, color);\n  };\n\n  UniformBuffer.prototype._updateColor3ForUniform = function (name, color) {\n    color.toArray(UniformBuffer._tempBuffer);\n    this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateColor4ForEffect = function (name, color, alpha, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setColor4(name + suffix, color, alpha);\n  };\n\n  UniformBuffer.prototype._updateColor4ForUniform = function (name, color, alpha) {\n    color.toArray(UniformBuffer._tempBuffer);\n    UniformBuffer._tempBuffer[3] = alpha;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n  };\n  /**\r\n   * Sets a sampler uniform on the effect.\r\n   * @param name Define the name of the sampler.\r\n   * @param texture Define the texture to set in the sampler\r\n   */\n\n\n  UniformBuffer.prototype.setTexture = function (name, texture) {\n    this._currentEffect.setTexture(name, texture);\n  };\n  /**\r\n   * Directly updates the value of the uniform in the cache AND on the GPU.\r\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n   * @param data Define the flattened data\r\n   */\n\n\n  UniformBuffer.prototype.updateUniformDirectly = function (uniformName, data) {\n    this.updateUniform(uniformName, data, data.length);\n    this.update();\n  };\n  /**\r\n   * Binds this uniform buffer to an effect.\r\n   * @param effect Define the effect to bind the buffer to\r\n   * @param name Name of the uniform block in the shader.\r\n   */\n\n\n  UniformBuffer.prototype.bindToEffect = function (effect, name) {\n    this._currentEffect = effect;\n\n    if (this._noUBO || !this._buffer) {\n      return;\n    }\n\n    this._alreadyBound = true;\n    effect.bindUniformBuffer(this._buffer, name);\n  };\n  /**\r\n   * Disposes the uniform buffer.\r\n   */\n\n\n  UniformBuffer.prototype.dispose = function () {\n    if (this._noUBO) {\n      return;\n    }\n\n    var uniformBuffers = this._engine._uniformBuffers;\n    var index = uniformBuffers.indexOf(this);\n\n    if (index !== -1) {\n      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\n      uniformBuffers.pop();\n    }\n\n    if (!this._buffer) {\n      return;\n    }\n\n    if (this._engine._releaseBuffer(this._buffer)) {\n      this._buffer = null;\n    }\n  }; // Pool for avoiding memory leaks\n\n\n  UniformBuffer._MAX_UNIFORM_SIZE = 256;\n  UniformBuffer._tempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\n  return UniformBuffer;\n}();\n\nexport { UniformBuffer };","map":null,"metadata":{},"sourceType":"module"}