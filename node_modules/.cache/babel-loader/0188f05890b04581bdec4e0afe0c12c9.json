{"ast":null,"code":"/**\r\n * Class used to inline functions in shader code\r\n*/\nvar ShaderCodeInliner =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the inliner\r\n   * @param sourceCode shader code source to inline\r\n   * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n   */\n  function ShaderCodeInliner(sourceCode, numMaxIterations) {\n    if (numMaxIterations === void 0) {\n      numMaxIterations = 20;\n    }\n    /** Gets or sets the debug mode */\n\n\n    this.debug = false;\n    this._sourceCode = sourceCode;\n    this._numMaxIterations = numMaxIterations;\n    this._functionDescr = [];\n    this.inlineToken = \"#define inline\";\n  }\n\n  Object.defineProperty(ShaderCodeInliner.prototype, \"code\", {\n    /** Gets the code after the inlining process */\n    get: function get() {\n      return this._sourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Start the processing of the shader code\r\n   */\n\n  ShaderCodeInliner.prototype.processCode = function () {\n    if (this.debug) {\n      console.log(\"Start inlining process (code size=\" + this._sourceCode.length + \")...\");\n    }\n\n    this._collectFunctions();\n\n    this._processInlining(this._numMaxIterations);\n\n    if (this.debug) {\n      console.log(\"End of inlining process.\");\n    }\n  };\n\n  ShaderCodeInliner.prototype._collectFunctions = function () {\n    var startIndex = 0;\n\n    while (startIndex < this._sourceCode.length) {\n      // locate the function to inline and extract its name\n      var inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\n\n      if (inlineTokenIndex < 0) {\n        break;\n      }\n\n      var funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\n\n      if (funcParamsStartIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not find the opening parenthesis after the token. startIndex=\" + startIndex);\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\n\n      if (!funcNameMatch) {\n        if (this.debug) {\n          console.warn(\"Could not extract the name/type of the function from: \" + this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var _a = [funcNameMatch[3], funcNameMatch[4]],\n          funcType = _a[0],\n          funcName = _a[1]; // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\n\n      var funcParamsEndIndex = this._extractBetweenMarkers('(', ')', this._sourceCode, funcParamsStartIndex);\n\n      if (funcParamsEndIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not extract the parameters the function '\" + funcName + \"' (type=\" + funcType + \"). funcParamsStartIndex=\" + funcParamsStartIndex);\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex); // extract the body of the function (with the curly brackets)\n\n\n      var funcBodyStartIndex = this._skipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\n\n      if (funcBodyStartIndex === this._sourceCode.length) {\n        if (this.debug) {\n          console.warn(\"Could not extract the body of the function '\" + funcName + \"' (type=\" + funcType + \"). funcParamsEndIndex=\" + funcParamsEndIndex);\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcBodyEndIndex = this._extractBetweenMarkers('{', '}', this._sourceCode, funcBodyStartIndex);\n\n      if (funcBodyEndIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not extract the body of the function '\" + funcName + \"' (type=\" + funcType + \"). funcBodyStartIndex=\" + funcBodyStartIndex);\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1); // process the parameters: extract each names\n\n\n      var params = this._removeComments(funcParams).split(\",\");\n\n      var paramNames = [];\n\n      for (var p = 0; p < params.length; ++p) {\n        var param = params[p].trim();\n        var idx = param.lastIndexOf(\" \");\n\n        if (idx >= 0) {\n          paramNames.push(param.substring(idx + 1));\n        }\n      }\n\n      if (funcType !== 'void') {\n        // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\n        paramNames.push('return');\n      } // collect the function\n\n\n      this._functionDescr.push({\n        \"name\": funcName,\n        \"type\": funcType,\n        \"parameters\": paramNames,\n        \"body\": funcBody,\n        \"callIndex\": 0\n      });\n\n      startIndex = funcBodyEndIndex + 1; // remove the function from the source code\n\n      var partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\n      var partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\n      this._sourceCode = partBefore + partAfter;\n      startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\n    }\n\n    if (this.debug) {\n      console.log(\"Collect functions: \" + this._functionDescr.length + \" functions found. functionDescr=\", this._functionDescr);\n    }\n  };\n\n  ShaderCodeInliner.prototype._processInlining = function (numMaxIterations) {\n    if (numMaxIterations === void 0) {\n      numMaxIterations = 20;\n    }\n\n    while (numMaxIterations-- >= 0) {\n      if (!this._replaceFunctionCallsByCode()) {\n        break;\n      }\n    }\n\n    if (this.debug) {\n      console.log(\"numMaxIterations is \" + numMaxIterations + \" after inlining process\");\n    }\n\n    return numMaxIterations >= 0;\n  };\n\n  ShaderCodeInliner.prototype._extractBetweenMarkers = function (markerOpen, markerClose, block, startIndex) {\n    var currPos = startIndex,\n        openMarkers = 0,\n        waitForChar = '';\n\n    while (currPos < block.length) {\n      var currChar = block.charAt(currPos);\n\n      if (!waitForChar) {\n        switch (currChar) {\n          case markerOpen:\n            openMarkers++;\n            break;\n\n          case markerClose:\n            openMarkers--;\n            break;\n\n          case '\"':\n          case \"'\":\n          case \"`\":\n            waitForChar = currChar;\n            break;\n\n          case '/':\n            if (currPos + 1 < block.length) {\n              var nextChar = block.charAt(currPos + 1);\n\n              if (nextChar === '/') {\n                waitForChar = '\\n';\n              } else if (nextChar === '*') {\n                waitForChar = '*/';\n              }\n            }\n\n            break;\n        }\n      } else {\n        if (currChar === waitForChar) {\n          if (waitForChar === '\"' || waitForChar === \"'\") {\n            block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\n          } else {\n            waitForChar = '';\n          }\n        } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\n          block.charAt(currPos + 1) === '/' && (waitForChar = '');\n\n          if (waitForChar === '') {\n            currPos++;\n          }\n        }\n      }\n\n      currPos++;\n\n      if (openMarkers === 0) {\n        break;\n      }\n    }\n\n    return openMarkers === 0 ? currPos - 1 : -1;\n  };\n\n  ShaderCodeInliner.prototype._skipWhitespaces = function (s, index) {\n    while (index < s.length) {\n      var c = s[index];\n\n      if (c !== ' ' && c !== '\\n' && c !== '\\r' && c !== '\\t' && c !== \"\\n\" && c !== \"\\xA0\") {\n        break;\n      }\n\n      index++;\n    }\n\n    return index;\n  };\n\n  ShaderCodeInliner.prototype._removeComments = function (block) {\n    var currPos = 0,\n        waitForChar = '',\n        inComments = false,\n        s = [];\n\n    while (currPos < block.length) {\n      var currChar = block.charAt(currPos);\n\n      if (!waitForChar) {\n        switch (currChar) {\n          case '\"':\n          case \"'\":\n          case \"`\":\n            waitForChar = currChar;\n            break;\n\n          case '/':\n            if (currPos + 1 < block.length) {\n              var nextChar = block.charAt(currPos + 1);\n\n              if (nextChar === '/') {\n                waitForChar = '\\n';\n                inComments = true;\n              } else if (nextChar === '*') {\n                waitForChar = '*/';\n                inComments = true;\n              }\n            }\n\n            break;\n        }\n\n        if (!inComments) {\n          s.push(currChar);\n        }\n      } else {\n        if (currChar === waitForChar) {\n          if (waitForChar === '\"' || waitForChar === \"'\") {\n            block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\n            s.push(currChar);\n          } else {\n            waitForChar = '';\n            inComments = false;\n          }\n        } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\n          block.charAt(currPos + 1) === '/' && (waitForChar = '');\n\n          if (waitForChar === '') {\n            inComments = false;\n            currPos++;\n          }\n        } else {\n          if (!inComments) {\n            s.push(currChar);\n          }\n        }\n      }\n\n      currPos++;\n    }\n\n    return s.join('');\n  };\n\n  ShaderCodeInliner.prototype._replaceFunctionCallsByCode = function () {\n    var doAgain = false;\n\n    for (var _i = 0, _a = this._functionDescr; _i < _a.length; _i++) {\n      var func = _a[_i];\n      var name_1 = func.name,\n          type = func.type,\n          parameters = func.parameters,\n          body = func.body;\n      var startIndex = 0;\n\n      while (startIndex < this._sourceCode.length) {\n        // Look for the function name in the source code\n        var functionCallIndex = this._sourceCode.indexOf(name_1, startIndex);\n\n        if (functionCallIndex < 0) {\n          break;\n        } // Find the opening parenthesis\n\n\n        var callParamsStartIndex = this._skipWhitespaces(this._sourceCode, functionCallIndex + name_1.length);\n\n        if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== '(') {\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        } // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\n\n\n        var callParamsEndIndex = this._extractBetweenMarkers('(', ')', this._sourceCode, callParamsStartIndex);\n\n        if (callParamsEndIndex < 0) {\n          if (this.debug) {\n            console.warn(\"Could not extract the parameters of the function call. Function '\" + name_1 + \"' (type=\" + type + \"). callParamsStartIndex=\" + callParamsStartIndex);\n          }\n\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        }\n\n        var callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex); // process the parameter call: extract each names\n\n\n        var params = this._removeComments(callParams).split(\",\");\n\n        var paramNames = [];\n\n        for (var p = 0; p < params.length; ++p) {\n          var param = params[p].trim();\n          paramNames.push(param);\n        }\n\n        var retParamName = type !== 'void' ? name_1 + '_' + func.callIndex++ : null;\n\n        if (retParamName) {\n          paramNames.push(retParamName + ' =');\n        }\n\n        if (paramNames.length !== parameters.length) {\n          if (this.debug) {\n            console.warn(\"Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '\" + name_1 + \"' (type=\" + type + \"). function parameters=\" + parameters + \", call parameters=\" + paramNames);\n          }\n\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        }\n\n        startIndex = callParamsEndIndex + 1; // replace the function call by the body function\n\n        var funcBody = this._replaceNames(body, parameters, paramNames);\n\n        var partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\n        var partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\n\n        if (retParamName) {\n          // case where the function returns a value. We generate:\n          // FUNCTYPE retParamName;\n          // {function body}\n          // and replace the function call by retParamName\n          var injectDeclarationIndex = this._findBackward(this._sourceCode, functionCallIndex - 1, '\\n');\n\n          partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\n\n          var partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\n\n          this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\n\n          if (this.debug) {\n            console.log(\"Replace function call by code. Function '\" + name_1 + \"' (type=\" + type + \"). injectDeclarationIndex=\" + injectDeclarationIndex);\n          }\n        } else {\n          // simple case where the return value of the function is \"void\"\n          this._sourceCode = partBefore + funcBody + partAfter;\n          startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\n\n          if (this.debug) {\n            console.log(\"Replace function call by code. Function '\" + name_1 + \"' (type=\" + type + \"). functionCallIndex=\" + functionCallIndex);\n          }\n        }\n\n        doAgain = true;\n      }\n    }\n\n    return doAgain;\n  };\n\n  ShaderCodeInliner.prototype._findBackward = function (s, index, c) {\n    while (index >= 0 && s.charAt(index) !== c) {\n      index--;\n    }\n\n    return index;\n  };\n\n  ShaderCodeInliner.prototype._escapeRegExp = function (s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  };\n\n  ShaderCodeInliner.prototype._replaceNames = function (code, sources, destinations) {\n    for (var i = 0; i < sources.length; ++i) {\n      var source = new RegExp(this._escapeRegExp(sources[i]), 'g'),\n          destination = destinations[i];\n      code = code.replace(source, destination);\n    }\n\n    return code;\n  };\n\n  ShaderCodeInliner._RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\n  return ShaderCodeInliner;\n}();\n\nexport { ShaderCodeInliner };","map":null,"metadata":{},"sourceType":"module"}