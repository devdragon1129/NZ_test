{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators\";\nimport { Logger } from \"../Misc/logger\";\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Material } from \"../Materials/material\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { PostProcess } from \"./postProcess\";\nimport \"../Meshes/Builders/planeBuilder\";\nimport \"../Shaders/depth.vertex\";\nimport \"../Shaders/volumetricLightScattering.fragment\";\nimport \"../Shaders/volumetricLightScatteringPass.vertex\";\nimport \"../Shaders/volumetricLightScatteringPass.fragment\";\nimport { Color4, Color3 } from '../Maths/math.color';\nimport { Viewport } from '../Maths/math.viewport';\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n *  Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html\r\n */\n\nvar VolumetricLightScatteringPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(VolumetricLightScatteringPostProcess, _super);\n  /**\r\n   * @constructor\r\n   * @param name The post-process name\r\n   * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n   * @param camera The camera that the post-process will be attached to\r\n   * @param mesh The mesh used to create the light scattering\r\n   * @param samples The post-process quality, default 100\r\n   * @param samplingModeThe post-process filtering mode\r\n   * @param engine The babylon engine\r\n   * @param reusable If the post-process is reusable\r\n   * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\r\n   */\n\n\n  function VolumetricLightScatteringPostProcess(name, ratio, camera, mesh, samples, samplingMode, engine, reusable, scene) {\n    if (samples === void 0) {\n      samples = 100;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    }\n\n    var _this = _super.call(this, name, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, \"#define NUM_SAMPLES \" + samples) || this;\n\n    _this._screenCoordinates = Vector2.Zero();\n    /**\r\n    * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\r\n    */\n\n    _this.customMeshPosition = Vector3.Zero();\n    /**\r\n    * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\r\n    */\n\n    _this.useCustomMeshPosition = false;\n    /**\r\n    * If the post-process should inverse the light scattering direction\r\n    */\n\n    _this.invert = true;\n    /**\r\n    * Array containing the excluded meshes not rendered in the internal pass\r\n    */\n\n    _this.excludedMeshes = new Array();\n    /**\r\n    * Controls the overall intensity of the post-process\r\n    */\n\n    _this.exposure = 0.3;\n    /**\r\n    * Dissipates each sample's contribution in range [0, 1]\r\n    */\n\n    _this.decay = 0.96815;\n    /**\r\n    * Controls the overall intensity of each sample\r\n    */\n\n    _this.weight = 0.58767;\n    /**\r\n    * Controls the density of each sample\r\n    */\n\n    _this.density = 0.926;\n    scene = camera === null ? scene : camera.getScene(); // parameter \"scene\" can be null.\n\n    engine = scene.getEngine();\n    _this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight()); // Configure mesh\n\n    _this.mesh = mesh !== null ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene); // Configure\n\n    _this._createPass(scene, ratio.passRatio || ratio);\n\n    _this.onActivate = function (camera) {\n      if (!_this.isSupported) {\n        _this.dispose(camera);\n      }\n\n      _this.onActivate = null;\n    };\n\n    _this.onApplyObservable.add(function (effect) {\n      _this._updateMeshScreenCoordinates(scene);\n\n      effect.setTexture(\"lightScatteringSampler\", _this._volumetricLightScatteringRTT);\n      effect.setFloat(\"exposure\", _this.exposure);\n      effect.setFloat(\"decay\", _this.decay);\n      effect.setFloat(\"weight\", _this.weight);\n      effect.setFloat(\"density\", _this.density);\n      effect.setVector2(\"meshPositionOnScreen\", _this._screenCoordinates);\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(VolumetricLightScatteringPostProcess.prototype, \"useDiffuseColor\", {\n    /**\r\n     * @hidden\r\n     * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\r\n     */\n    get: function get() {\n      Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n      return false;\n    },\n    set: function set(useDiffuseColor) {\n      Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"VolumetricLightScatteringPostProcess\"\r\n   * @returns \"VolumetricLightScatteringPostProcess\"\r\n   */\n\n  VolumetricLightScatteringPostProcess.prototype.getClassName = function () {\n    return \"VolumetricLightScatteringPostProcess\";\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._isReady = function (subMesh, useInstances) {\n    var mesh = subMesh.getMesh(); // Render this.mesh as default\n\n    if (mesh === this.mesh && mesh.material) {\n      return mesh.material.isReady(mesh);\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind];\n    var material = subMesh.getMaterial(); // Alpha test\n\n    if (material) {\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._volumetricLightScatteringPass = mesh.getScene().getEngine().createEffect(\"volumetricLightScatteringPass\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: mesh.numBoneInfluencers\n      });\n    }\n\n    return this._volumetricLightScatteringPass.isReady();\n  };\n  /**\r\n   * Sets the new light position for light scattering effect\r\n   * @param position The new custom light position\r\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.setCustomMeshPosition = function (position) {\n    this.customMeshPosition = position;\n  };\n  /**\r\n   * Returns the light position for light scattering effect\r\n   * @return Vector3 The custom light position\r\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.getCustomMeshPosition = function () {\n    return this.customMeshPosition;\n  };\n  /**\r\n   * Disposes the internal assets and detaches the post-process from the camera\r\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.dispose = function (camera) {\n    var rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\n\n    if (rttIndex !== -1) {\n      camera.getScene().customRenderTargets.splice(rttIndex, 1);\n    }\n\n    this._volumetricLightScatteringRTT.dispose();\n\n    _super.prototype.dispose.call(this, camera);\n  };\n  /**\r\n   * Returns the render target texture used by the post-process\r\n   * @return the render target texture used by the post-process\r\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.getPass = function () {\n    return this._volumetricLightScatteringRTT;\n  }; // Private methods\n\n\n  VolumetricLightScatteringPostProcess.prototype._meshExcluded = function (mesh) {\n    if (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return true;\n    }\n\n    return false;\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._createPass = function (scene, ratio) {\n    var _this = this;\n\n    var engine = scene.getEngine();\n    this._volumetricLightScatteringRTT = new RenderTargetTexture(\"volumetricLightScatteringMap\", {\n      width: engine.getRenderWidth() * ratio,\n      height: engine.getRenderHeight() * ratio\n    }, scene, false, true, 0);\n    this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.renderList = null;\n    this._volumetricLightScatteringRTT.renderParticles = false;\n    this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\n    var camera = this.getCamera();\n\n    if (camera) {\n      camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } else {\n      scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } // Custom render function for submeshes\n\n\n    var renderSubMesh = function renderSubMesh(subMesh) {\n      var renderingMesh = subMesh.getRenderingMesh();\n      var effectiveMesh = subMesh.getEffectiveMesh();\n\n      if (_this._meshExcluded(renderingMesh)) {\n        return;\n      }\n\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        return;\n      }\n\n      var scene = renderingMesh.getScene();\n      var engine = scene.getEngine(); // Culling\n\n      engine.setState(material.backFaceCulling); // Managing instances\n\n      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n      if (batch.mustReturn) {\n        return;\n      }\n\n      var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n\n      if (_this._isReady(subMesh, hardwareInstancedRendering)) {\n        var effect = _this._volumetricLightScatteringPass;\n\n        if (renderingMesh === _this.mesh) {\n          if (subMesh.effect) {\n            effect = subMesh.effect;\n          } else {\n            effect = material.getEffect();\n          }\n        }\n\n        engine.enableEffect(effect);\n\n        renderingMesh._bind(subMesh, effect, material.fillMode);\n\n        if (renderingMesh === _this.mesh) {\n          material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\n        } else {\n          _this._volumetricLightScatteringPass.setMatrix(\"viewProjection\", scene.getTransformMatrix()); // Alpha test\n\n\n          if (material && material.needAlphaTesting()) {\n            var alphaTexture = material.getAlphaTestTexture();\n\n            _this._volumetricLightScatteringPass.setTexture(\"diffuseSampler\", alphaTexture);\n\n            if (alphaTexture) {\n              _this._volumetricLightScatteringPass.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          } // Bones\n\n\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            _this._volumetricLightScatteringPass.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n          }\n        } // Draw\n\n\n        renderingMesh._processRendering(effectiveMesh, subMesh, _this._volumetricLightScatteringPass, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n          return effect.setMatrix(\"world\", world);\n        });\n      }\n    }; // Render target texture callbacks\n\n\n    var savedSceneClearColor;\n    var sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\n\n    this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(function () {\n      savedSceneClearColor = scene.clearColor;\n      scene.clearColor = sceneClearColor;\n    });\n\n    this._volumetricLightScatteringRTT.onAfterRenderObservable.add(function () {\n      scene.clearColor = savedSceneClearColor;\n    });\n\n    this._volumetricLightScatteringRTT.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      var engine = scene.getEngine();\n      var index;\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      if (transparentSubMeshes.length) {\n        // Sort sub meshes\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          var submesh = transparentSubMeshes.data[index];\n          var boundingInfo = submesh.getBoundingInfo();\n\n          if (boundingInfo && scene.activeCamera) {\n            submesh._alphaIndex = submesh.getMesh().alphaIndex;\n            submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\n          }\n        }\n\n        var sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\n        sortedArray.sort(function (a, b) {\n          // Alpha index first\n          if (a._alphaIndex > b._alphaIndex) {\n            return 1;\n          }\n\n          if (a._alphaIndex < b._alphaIndex) {\n            return -1;\n          } // Then distance to camera\n\n\n          if (a._distanceToCamera < b._distanceToCamera) {\n            return 1;\n          }\n\n          if (a._distanceToCamera > b._distanceToCamera) {\n            return -1;\n          }\n\n          return 0;\n        }); // Render sub meshes\n\n        engine.setAlphaMode(2);\n\n        for (index = 0; index < sortedArray.length; index++) {\n          renderSubMesh(sortedArray[index]);\n        }\n\n        engine.setAlphaMode(0);\n      }\n    };\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._updateMeshScreenCoordinates = function (scene) {\n    var transform = scene.getTransformMatrix();\n    var meshPosition;\n\n    if (this.useCustomMeshPosition) {\n      meshPosition = this.customMeshPosition;\n    } else if (this.attachedNode) {\n      meshPosition = this.attachedNode.position;\n    } else {\n      meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\n    }\n\n    var pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\n    this._screenCoordinates.x = pos.x / this._viewPort.width;\n    this._screenCoordinates.y = pos.y / this._viewPort.height;\n\n    if (this.invert) {\n      this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\n    }\n  }; // Static methods\n\n  /**\r\n  * Creates a default mesh for the Volumeric Light Scattering post-process\r\n  * @param name The mesh name\r\n  * @param scene The scene where to create the mesh\r\n  * @return the default mesh\r\n  */\n\n\n  VolumetricLightScatteringPostProcess.CreateDefaultMesh = function (name, scene) {\n    var mesh = Mesh.CreatePlane(name, 1, scene);\n    mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\n    var material = new StandardMaterial(name + \"Material\", scene);\n    material.emissiveColor = new Color3(1, 1, 1);\n    mesh.material = material;\n    return mesh;\n  };\n\n  __decorate([serializeAsVector3()], VolumetricLightScatteringPostProcess.prototype, \"customMeshPosition\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"useCustomMeshPosition\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"invert\", void 0);\n\n  __decorate([serializeAsMeshReference()], VolumetricLightScatteringPostProcess.prototype, \"mesh\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"excludedMeshes\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"exposure\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"decay\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"weight\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"density\", void 0);\n\n  return VolumetricLightScatteringPostProcess;\n}(PostProcess);\n\nexport { VolumetricLightScatteringPostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.VolumetricLightScatteringPostProcess\"] = VolumetricLightScatteringPostProcess;","map":null,"metadata":{},"sourceType":"module"}