{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _defineProperty = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ItemFactory = void 0;\n\nvar uuid_1 = require(\"uuid\");\n\nvar content_1 = require(\"../content/content\");\n\nvar constants_1 = require(\"./constants\");\n\nvar ItemFactory_errors_1 = require(\"./ItemFactory.errors\");\n\nvar types_1 = require(\"./types\");\n\nvar ItemFactory = /*#__PURE__*/function () {\n  function ItemFactory() {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, ItemFactory);\n\n    this.item = item;\n    this.newContent = {};\n  }\n  /**\n   * Instantiates a new item with the base properties.\n   * @param BasicItem - The set of properties that, without a representation, defines an item.\n   */\n\n\n  _createClass(ItemFactory, [{\n    key: \"newItem\",\n    value: function newItem(_ref) {\n      var id = _ref.id,\n          name = _ref.name,\n          rarity = _ref.rarity,\n          category = _ref.category,\n          collection_id = _ref.collection_id,\n          description = _ref.description,\n          urn = _ref.urn;\n\n      if (!this.isMetadataTextValid(name) || description && !this.isMetadataTextValid(description)) {\n        throw new Error('Invalid item name or description');\n      }\n\n      this.item = {\n        id: id !== null && id !== void 0 ? id : (0, uuid_1.v4)(),\n        name: name,\n        description: description || '',\n        thumbnail: constants_1.THUMBNAIL_PATH,\n        type: types_1.ItemType.WEARABLE,\n        collection_id: collection_id !== null && collection_id !== void 0 ? collection_id : null,\n        content_hash: null,\n        rarity: rarity,\n        urn: urn !== null && urn !== void 0 ? urn : null,\n        data: {\n          category: category,\n          replaces: [],\n          hides: [],\n          tags: [],\n          representations: []\n        },\n        metrics: constants_1.DEFAULT_METRICS,\n        contents: {}\n      };\n      return this;\n    }\n    /**\n     * Instantiates a new item with the base properties.\n     * @param wearableConfig - The AssetJSON object containing all the information about the item.\n     * @param contents - The item's content.\n     */\n\n  }, {\n    key: \"fromConfig\",\n    value: function fromConfig(wearableConfig, content, builderConfig) {\n      var _this = this;\n\n      var _a, _b, _c, _d, _e;\n\n      this.newItem({\n        id: (_a = builderConfig === null || builderConfig === void 0 ? void 0 : builderConfig.id) !== null && _a !== void 0 ? _a : (0, uuid_1.v4)(),\n        name: wearableConfig.name,\n        rarity: (_b = wearableConfig.rarity) !== null && _b !== void 0 ? _b : null,\n        category: wearableConfig.data.category,\n        collection_id: (_c = builderConfig === null || builderConfig === void 0 ? void 0 : builderConfig.collectionId) !== null && _c !== void 0 ? _c : null,\n        description: (_d = wearableConfig.description) !== null && _d !== void 0 ? _d : null,\n        urn: (_e = wearableConfig.id) !== null && _e !== void 0 ? _e : null\n      });\n\n      if (content[constants_1.THUMBNAIL_PATH]) {\n        this.withThumbnail(content[constants_1.THUMBNAIL_PATH]);\n      }\n\n      if (wearableConfig.data.replaces) {\n        this.withReplaces(wearableConfig.data.replaces);\n      }\n\n      if (wearableConfig.data.hides) {\n        this.withHides(wearableConfig.data.hides);\n      }\n\n      if (wearableConfig.data.tags) {\n        this.withTags(wearableConfig.data.tags);\n      }\n\n      wearableConfig.data.representations.forEach(function (representation) {\n        representation.bodyShapes.forEach(function (bodyShape) {\n          _this.withRepresentation(bodyShape, representation.mainFile, _this.buildWearableConfigRepresentationContents(content, representation.contents), representation.overrideHides, representation.overrideReplaces);\n        });\n      });\n      return this;\n    }\n    /**\n     * Sets or updates the item's id.\n     * It requires the item to be defined first.\n     * @param id - The item's id.\n     */\n\n  }, {\n    key: \"withId\",\n    value: function withId(id) {\n      return this.setItemProperty('id', id);\n    }\n    /**\n     * Sets or updates the item's name.\n     * It requires the item to be defined first.\n     * @param name - The item's name.\n     */\n\n  }, {\n    key: \"withName\",\n    value: function withName(name) {\n      return this.setItemProperty('name', name);\n    }\n    /**\n     * Sets or updates the item's description.\n     * It requires the item to be defined first.\n     * @param description - The item's description.\n     */\n\n  }, {\n    key: \"withDescription\",\n    value: function withDescription(description) {\n      return this.setItemProperty('description', description);\n    }\n    /**\n     * Sets or updates the item's replaces property.\n     * It requires the item to be defined first.\n     * @param replaces - The item's replaces property.\n     */\n\n  }, {\n    key: \"withReplaces\",\n    value: function withReplaces(replaces) {\n      return this.setItemDataProperty('replaces', replaces);\n    }\n    /**\n     * Sets or updates the item's rarity.\n     * It requires the item to be defined first.\n     * @param rarity - The item's rarity.\n     */\n\n  }, {\n    key: \"withRarity\",\n    value: function withRarity(rarity) {\n      return this.setItemProperty('rarity', rarity);\n    }\n    /**\n     * Sets or updates the item's collectionId.\n     * It requires the item to be defined first.\n     * @param collectionId - The item's collectionId.\n     */\n\n  }, {\n    key: \"withCollectionId\",\n    value: function withCollectionId(collectionId) {\n      return this.setItemProperty('collection_id', collectionId);\n    }\n    /**\n     * Sets or updates the item's category.\n     * It requires the item to be defined first.\n     * @param category - The item's category.\n     */\n\n  }, {\n    key: \"withCategory\",\n    value: function withCategory(category) {\n      return this.setItemDataProperty('category', category);\n    }\n    /**\n     * Sets or updates the item's hides property.\n     * It requires the item to be defined first.\n     * @param hides - The item's hides property.\n     */\n\n  }, {\n    key: \"withHides\",\n    value: function withHides(hides) {\n      return this.setItemDataProperty('hides', hides);\n    }\n    /**\n     * Sets or updates the item's tags property.\n     * It requires the item to be defined first.\n     * @param tags - The item's tags property.\n     */\n\n  }, {\n    key: \"withTags\",\n    value: function withTags(tags) {\n      return this.setItemDataProperty('tags', tags);\n    }\n    /**\n     * Sets or updates the item's urn property.\n     * It requires the item to be defined first.\n     * @param urn - The item's urn property.\n     */\n\n  }, {\n    key: \"withUrn\",\n    value: function withUrn(urn) {\n      return this.setItemProperty('urn', urn);\n    }\n    /**\n     * Sets or updates the item's thumbnail.\n     * It requires the item to be defined first.\n     * @param thumbnail - The item's thumbnail.\n     */\n\n  }, {\n    key: \"withThumbnail\",\n    value: function withThumbnail(thumbnail) {\n      if (!this.item) {\n        throw new ItemFactory_errors_1.ItemNotInitializedError();\n      }\n\n      this.newContent = _objectSpread({}, this.newContent, _defineProperty({}, constants_1.THUMBNAIL_PATH, thumbnail));\n      delete this.item.contents[constants_1.THUMBNAIL_PATH];\n      return this;\n    }\n    /**\n     * Sets or updates the item's content.\n     * It requires the item to be defined first.\n     * @param content - The item's new content\n     */\n\n  }, {\n    key: \"withContent\",\n    value: function withContent(content) {\n      if (!this.item) {\n        throw new ItemFactory_errors_1.ItemNotInitializedError();\n      }\n\n      this.newContent = _objectSpread({}, this.newContent, content);\n\n      for (var key in content) {\n        delete this.item.contents[key];\n      }\n\n      return this;\n    }\n    /**\n     * Sets or updates the item's image.\n     * The image will be used at the deployment process\n     * to be uploaded to the catalyst.\n     * It requires the item to be defined first.\n     * @param thumbnail - The item's thumbnail.\n     */\n\n  }, {\n    key: \"withImage\",\n    value: function withImage(image) {\n      if (!this.item) {\n        throw new ItemFactory_errors_1.ItemNotInitializedError();\n      }\n\n      this.newContent = _objectSpread({}, this.newContent, _defineProperty({}, constants_1.IMAGE_PATH, image));\n      delete this.item.contents[constants_1.IMAGE_PATH];\n      return this;\n    }\n    /**\n     * Adds a new a representation and its contents to the item, taking into consideration the specified body shape.\n     * If BOTH is used as the body shape, both representations, female and male will be added.\n     * It requires the item to be defined first.\n     * @param bodyShape - The body shape that the new representation will represent.\n     * @param model - The name of the content's key that points to the model to be used to build the new representation.\n     * @param contents - The contents of the representation to be used to build the new representation.\n     */\n\n  }, {\n    key: \"withRepresentation\",\n    value: function withRepresentation(bodyShape, model, contents) {\n      var _this2 = this;\n\n      var overrideHides = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var overrideReplaces = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n      if (!this.item) {\n        throw new ItemFactory_errors_1.ItemNotInitializedError();\n      }\n\n      var representationAlreadyExists = this.item.data.representations.some(function (representation) {\n        return _this2.representsBodyShape(bodyShape, representation);\n      });\n\n      if (representationAlreadyExists) {\n        throw new Error(\"The representation that you're about to add already exists in the item\");\n      }\n\n      var sortedContents = (0, content_1.sortContent)(bodyShape, contents);\n      this.newContent = _objectSpread({}, this.newContent, this.getBodyShapeSortedContents(bodyShape, sortedContents), this.itemHasRepresentations() && sortedContents.all[constants_1.THUMBNAIL_PATH] ? {} : _defineProperty({}, constants_1.THUMBNAIL_PATH, sortedContents.all[constants_1.THUMBNAIL_PATH]));\n      this.item = _objectSpread({}, this.item, {\n        data: _objectSpread({}, this.item.data, {\n          representations: [].concat(_toConsumableArray(this.item.data.representations), _toConsumableArray(this.buildRepresentations(bodyShape, model, sortedContents, overrideHides, overrideReplaces)))\n        })\n      });\n      return this;\n    }\n    /**\n     * Removes a representation and its contents from the item, taking into consideration the specified body shape.\n     * If BOTH is used as the body shape, all the representations will be removed.\n     * This method will only remove the thumbnail if after removing the representation there are no representations left.\n     * It requires the item to be defined first.\n     * @param bodyShape - The body shape that will be used to identify the representation to remove.\n     */\n\n  }, {\n    key: \"withoutRepresentation\",\n    value: function withoutRepresentation(bodyShape) {\n      var _this3 = this;\n\n      if (!this.item) {\n        throw new ItemFactory_errors_1.ItemNotInitializedError();\n      }\n\n      this.newContent = this.removeContentsOfBodyShape(bodyShape, this.newContent);\n      this.item = _objectSpread({}, this.item, {\n        data: _objectSpread({}, this.item.data, {\n          representations: this.item.data.representations.filter(function (representation) {\n            return !_this3.representsBodyShape(bodyShape, representation);\n          })\n        }),\n        contents: _objectSpread({}, this.item.contents, this.removeContentsOfBodyShape(bodyShape, this.item.contents))\n      });\n\n      if (!this.itemHasRepresentations()) {\n        delete this.item.contents[constants_1.THUMBNAIL_PATH];\n        delete this.newContent[constants_1.THUMBNAIL_PATH];\n      }\n\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function () {\n      var _build = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.item) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('The item must be set before creating it');\n\n              case 2:\n                _context.t0 = _objectSpread;\n                _context.t1 = {};\n                _context.t2 = this.item;\n                _context.t3 = _objectSpread;\n                _context.t4 = {};\n                _context.t5 = this.item.contents;\n                _context.next = 10;\n                return (0, content_1.computeHashes)(this.newContent);\n\n              case 10:\n                _context.t6 = _context.sent;\n                _context.t7 = (0, _context.t3)(_context.t4, _context.t5, _context.t6);\n                _context.t8 = {\n                  contents: _context.t7\n                };\n                _context.t9 = (0, _context.t0)(_context.t1, _context.t2, _context.t8);\n                _context.t10 = this.newContent;\n                return _context.abrupt(\"return\", {\n                  item: _context.t9,\n                  newContent: _context.t10\n                });\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function build() {\n        return _build.apply(this, arguments);\n      }\n\n      return build;\n    }()\n    /**\n     * Check that the given text won't break the item's metadata when used.\n     * @param text - The text to verify that won't break the item's metadata.\n     */\n\n  }, {\n    key: \"isMetadataTextValid\",\n    value: function isMetadataTextValid(text) {\n      var invalidCharacters = [':'];\n      var invalidCharactersRegex = new RegExp(invalidCharacters.join('|'));\n      return text.search(invalidCharactersRegex) === -1;\n    }\n    /**\n     * Builds an item's representation.\n     * @param bodyShape - The body shape of the representation to build.\n     * @param model - The name of the content's key that points to the model.\n     * @param contents - The sorted contents of the representation to build.\n     */\n\n  }, {\n    key: \"buildRepresentations\",\n    value: function buildRepresentations(bodyShape, model, contents, overrideHides, overrideReplaces) {\n      var representations = []; // Add male representation\n\n      if (bodyShape === types_1.WearableBodyShape.MALE) {\n        representations.push({\n          bodyShapes: [types_1.WearableBodyShape.MALE],\n          mainFile: (0, content_1.prefixContentName)(types_1.WearableBodyShape.MALE, model),\n          contents: Object.keys(contents.male),\n          overrideHides: overrideHides,\n          overrideReplaces: overrideReplaces\n        });\n      } // Add female representation\n\n\n      if (bodyShape === types_1.WearableBodyShape.FEMALE) {\n        representations.push({\n          bodyShapes: [types_1.WearableBodyShape.FEMALE],\n          mainFile: (0, content_1.prefixContentName)(types_1.WearableBodyShape.FEMALE, model),\n          contents: Object.keys(contents.female),\n          overrideHides: overrideHides,\n          overrideReplaces: overrideReplaces\n        });\n      }\n\n      return representations;\n    }\n    /**\n     * Checks if an item's representation would fit a specific body shape.\n     * @param bodyShape - The body shape to check for.\n     * @param representation - The representation to see if fits the body shape.\n     */\n\n  }, {\n    key: \"representsBodyShape\",\n    value: function representsBodyShape(bodyShape, representation) {\n      return representation.bodyShapes.includes(bodyShape);\n    }\n    /**\n     * Builds a new record of contents without the contents of the specified body shape.\n     * @param bodyShape - The body shape of the contents to be left out.\n     * @param contents - The contents to be filtered taking into consideration the specified body shape.\n     */\n\n  }, {\n    key: \"removeContentsOfBodyShape\",\n    value: function removeContentsOfBodyShape(bodyShape, contents) {\n      return Object.keys(contents).filter(function (key) {\n        return !key.startsWith(bodyShape === types_1.WearableBodyShape.MALE ? 'male' : 'female');\n      }).reduce(function (accum, key) {\n        accum[key] = contents[key];\n        return accum;\n      }, {});\n    }\n    /**\n     * Checks if the item has representations.\n     * It requires the item to be defined first.\n     */\n\n  }, {\n    key: \"itemHasRepresentations\",\n    value: function itemHasRepresentations() {\n      if (!this.item) {\n        throw new ItemFactory_errors_1.ItemNotInitializedError();\n      }\n\n      return this.item.data.representations.length > 0;\n    }\n    /**\n     * Gets the sorted contents based on a given body shape.\n     * @param bodyShape - The body shape to get the contents of.\n     * @param contents - The full list of sorted contents.\n     */\n\n  }, {\n    key: \"getBodyShapeSortedContents\",\n    value: function getBodyShapeSortedContents(bodyShape, contents) {\n      switch (bodyShape) {\n        case types_1.WearableBodyShape.MALE:\n          return contents.male;\n\n        case types_1.WearableBodyShape.FEMALE:\n          return contents.female;\n\n        default:\n          throw new Error(\"The BodyShape \".concat(bodyShape, \" couldn't get matched with the content\"));\n      }\n    }\n    /**\n     * Sets an item's property by checking first if the item is defined.\n     * @param property - The property of the item to be set.\n     * @param value - The value of the property to be set.\n     */\n\n  }, {\n    key: \"setItemProperty\",\n    value: function setItemProperty(property, value) {\n      if (!this.item) {\n        throw new ItemFactory_errors_1.ItemNotInitializedError();\n      }\n\n      this.item = _objectSpread({}, this.item, _defineProperty({}, property, value));\n      return this;\n    }\n    /**\n     * Sets an item's property in the data section by checking first if the item is defined.\n     * @param property - The property of the item to be set.\n     * @param value - The value of the property to be set.\n     */\n\n  }, {\n    key: \"setItemDataProperty\",\n    value: function setItemDataProperty(property, value) {\n      if (!this.item) {\n        throw new ItemFactory_errors_1.ItemNotInitializedError();\n      }\n\n      this.item = _objectSpread({}, this.item, {\n        data: _objectSpread({}, this.item.data, _defineProperty({}, property, value))\n      });\n      return this;\n    }\n    /**\n     * Builds a map of contents based on a list of content paths (keys of the map).\n     * @param rawContent - The map containing the content available for an item.\n     * @param contentPaths - The paths or keys of the rawContent map to build the new content map.\n     */\n\n  }, {\n    key: \"buildWearableConfigRepresentationContents\",\n    value: function buildWearableConfigRepresentationContents(rawContent, contentPaths) {\n      return contentPaths.reduce(function (accumulator, content) {\n        accumulator[content] = rawContent[content];\n        return accumulator;\n      }, {});\n    }\n  }]);\n\n  return ItemFactory;\n}();\n\nexports.ItemFactory = ItemFactory;","map":null,"metadata":{},"sourceType":"script"}