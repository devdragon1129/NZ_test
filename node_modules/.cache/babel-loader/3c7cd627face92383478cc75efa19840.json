{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { SerializationHelper } from \"../Misc/decorators\";\nimport { Matrix, Vector3, Vector2, Vector4 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { MaterialHelper } from \"./materialHelper\";\nimport { Material } from \"./material\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { Color3, Color4 } from '../Maths/math.color';\nimport { EffectFallbacks } from './effectFallbacks';\nimport { WebRequest } from '../Misc/webRequest';\nimport { Engine } from '../Engines/engine';\nvar onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/shader_material\r\n */\n\nvar ShaderMaterial =\n/** @class */\nfunction (_super) {\n  __extends(ShaderMaterial, _super);\n  /**\r\n   * Instantiate a new shader material.\r\n   * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n   * This returned material effects how the mesh will look based on the code in the shaders.\r\n   * @see https://doc.babylonjs.com/how_to/shader_material\r\n   * @param name Define the name of the material in the scene\r\n   * @param scene Define the scene the material belongs to\r\n   * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n   *  * object: { vertex: \"custom\", fragment: \"custom\" }, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n   *  * object: { vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }, used with shader code in script tags\r\n   *  * object: { vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" } using with strings containing the shaders code\r\n   *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n   * @param options Define the options used to create the shader\r\n   */\n\n\n  function ShaderMaterial(name, scene, shaderPath, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._textures = {};\n    _this._textureArrays = {};\n    _this._floats = {};\n    _this._ints = {};\n    _this._floatsArrays = {};\n    _this._colors3 = {};\n    _this._colors3Arrays = {};\n    _this._colors4 = {};\n    _this._colors4Arrays = {};\n    _this._vectors2 = {};\n    _this._vectors3 = {};\n    _this._vectors4 = {};\n    _this._matrices = {};\n    _this._matrixArrays = {};\n    _this._matrices3x3 = {};\n    _this._matrices2x2 = {};\n    _this._vectors2Arrays = {};\n    _this._vectors3Arrays = {};\n    _this._vectors4Arrays = {};\n    _this._cachedWorldViewMatrix = new Matrix();\n    _this._cachedWorldViewProjectionMatrix = new Matrix();\n    _this._multiview = false;\n    _this._shaderPath = shaderPath;\n    _this._options = __assign({\n      needAlphaBlending: false,\n      needAlphaTesting: false,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\"],\n      uniformBuffers: [],\n      samplers: [],\n      defines: []\n    }, options);\n    return _this;\n  }\n\n  Object.defineProperty(ShaderMaterial.prototype, \"shaderPath\", {\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\n    get: function get() {\n      return this._shaderPath;\n    },\n\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\n    set: function set(shaderPath) {\n      this._shaderPath = shaderPath;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ShaderMaterial.prototype, \"options\", {\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\n    get: function get() {\n      return this._options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n   * Mainly use in serialization.\r\n   * @returns the class name\r\n   */\n\n  ShaderMaterial.prototype.getClassName = function () {\n    return \"ShaderMaterial\";\n  };\n  /**\r\n   * Specifies if the material will require alpha blending\r\n   * @returns a boolean specifying if alpha blending is needed\r\n   */\n\n\n  ShaderMaterial.prototype.needAlphaBlending = function () {\n    return this.alpha < 1.0 || this._options.needAlphaBlending;\n  };\n  /**\r\n   * Specifies if this material should be rendered in alpha test mode\r\n   * @returns a boolean specifying if an alpha test is needed.\r\n   */\n\n\n  ShaderMaterial.prototype.needAlphaTesting = function () {\n    return this._options.needAlphaTesting;\n  };\n\n  ShaderMaterial.prototype._checkUniform = function (uniformName) {\n    if (this._options.uniforms.indexOf(uniformName) === -1) {\n      this._options.uniforms.push(uniformName);\n    }\n  };\n  /**\r\n   * Set a texture in the shader.\r\n   * @param name Define the name of the uniform samplers as defined in the shader\r\n   * @param texture Define the texture to bind to this sampler\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setTexture = function (name, texture) {\n    if (this._options.samplers.indexOf(name) === -1) {\n      this._options.samplers.push(name);\n    }\n\n    this._textures[name] = texture;\n    return this;\n  };\n  /**\r\n   * Set a texture array in the shader.\r\n   * @param name Define the name of the uniform sampler array as defined in the shader\r\n   * @param textures Define the list of textures to bind to this sampler\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setTextureArray = function (name, textures) {\n    if (this._options.samplers.indexOf(name) === -1) {\n      this._options.samplers.push(name);\n    }\n\n    this._checkUniform(name);\n\n    this._textureArrays[name] = textures;\n    return this;\n  };\n  /**\r\n   * Set a float in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setFloat = function (name, value) {\n    this._checkUniform(name);\n\n    this._floats[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a int in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setInt = function (name, value) {\n    this._checkUniform(name);\n\n    this._ints[name] = value;\n    return this;\n  };\n  /**\r\n   * Set an array of floats in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setFloats = function (name, value) {\n    this._checkUniform(name);\n\n    this._floatsArrays[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 in the shader from a Color3.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setColor3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 array in the shader from a Color3 array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setColor3Array = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors3Arrays[name] = value.reduce(function (arr, color) {\n      color.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  };\n  /**\r\n   * Set a vec4 in the shader from a Color4.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setColor4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors4[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec4 array in the shader from a Color4 array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setColor4Array = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors4Arrays[name] = value.reduce(function (arr, color) {\n      color.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  };\n  /**\r\n   * Set a vec2 in the shader from a Vector2.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setVector2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors2[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 in the shader from a Vector3.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setVector3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec4 in the shader from a Vector4.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setVector4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors4[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a mat4 in the shader from a Matrix.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setMatrix = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a float32Array in the shader from a matrix array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setMatrices = function (name, value) {\n    this._checkUniform(name);\n\n    var float32Array = new Float32Array(value.length * 16);\n\n    for (var index = 0; index < value.length; index++) {\n      var matrix = value[index];\n      matrix.copyToArray(float32Array, index * 16);\n    }\n\n    this._matrixArrays[name] = float32Array;\n    return this;\n  };\n  /**\r\n   * Set a mat3 in the shader from a Float32Array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setMatrix3x3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices3x3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a mat2 in the shader from a Float32Array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setMatrix2x2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices2x2[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec2 array in the shader from a number array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setArray2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors2Arrays[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 array in the shader from a number array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setArray3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors3Arrays[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec4 array in the shader from a number array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setArray4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors4Arrays[name] = value;\n    return this;\n  };\n\n  ShaderMaterial.prototype._checkCache = function (mesh, useInstances) {\n    if (!mesh) {\n      return true;\n    }\n\n    if (this._effect && this._effect.defines.indexOf(\"#define INSTANCES\") !== -1 !== useInstances) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used\r\n   * @param mesh defines the mesh to check\r\n   * @param subMesh defines which submesh to check\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns a boolean indicating that the submesh is ready or not\r\n   */\n\n\n  ShaderMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    return this.isReady(mesh, useInstances);\n  };\n  /**\r\n   * Checks if the material is ready to render the requested mesh\r\n   * @param mesh Define the mesh to render\r\n   * @param useInstances Define whether or not the material is used with instances\r\n   * @returns true if ready, otherwise false\r\n   */\n\n\n  ShaderMaterial.prototype.isReady = function (mesh, useInstances) {\n    var _a, _b;\n\n    if (this._effect && this.isFrozen) {\n      if (this._effect._wasPreviouslyReady) {\n        return true;\n      }\n    }\n\n    var scene = this.getScene();\n    var engine = scene.getEngine();\n\n    if (!this.checkReadyOnEveryCall) {\n      if (this._renderId === scene.getRenderId()) {\n        if (this._checkCache(mesh, useInstances)) {\n          return true;\n        }\n      }\n    } // Instances\n\n\n    var defines = [];\n    var attribs = [];\n    var fallbacks = new EffectFallbacks(); // global multiview\n\n    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\n      this._multiview = true;\n      defines.push(\"#define MULTIVIEW\");\n\n      if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 && this._options.uniforms.push(\"viewProjectionR\") === -1) {\n        this._options.uniforms.push(\"viewProjectionR\");\n      }\n    }\n\n    for (var index = 0; index < this._options.defines.length; index++) {\n      defines.push(this._options.defines[index]);\n    }\n\n    for (var index = 0; index < this._options.attributes.length; index++) {\n      attribs.push(this._options.attributes[index]);\n    }\n\n    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXCOLOR\");\n    }\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (mesh === null || mesh === void 0 ? void 0 : mesh.hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Bones\n\n\n    var numInfluencers = 0;\n\n    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      var skeleton = mesh.skeleton;\n      numInfluencers = mesh.numBoneInfluencers;\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + numInfluencers);\n      fallbacks.addCPUSkinningFallback(0, mesh);\n\n      if (skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n\n        if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\n          this._options.uniforms.push(\"boneTextureWidth\");\n        }\n\n        if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\n          this._options.samplers.push(\"boneSampler\");\n        }\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n\n        if (this._options.uniforms.indexOf(\"mBones\") === -1) {\n          this._options.uniforms.push(\"mBones\");\n        }\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Textures\n\n\n    for (var name in this._textures) {\n      if (!this._textures[name].isReady()) {\n        return false;\n      }\n    } // Alpha test\n\n\n    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\n      defines.push(\"#define ALPHATEST\");\n    }\n\n    var shaderName = this._shaderPath,\n        uniforms = this._options.uniforms,\n        uniformBuffers = this._options.uniformBuffers,\n        samplers = this._options.samplers;\n\n    if (this.customShaderNameResolve) {\n      uniforms = uniforms.slice();\n      uniformBuffers = uniformBuffers.slice();\n      samplers = samplers.slice();\n      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\n    }\n\n    var previousEffect = this._effect;\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effect = engine.createEffect(shaderName, {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: join,\n        fallbacks: fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousMorphTargets: numInfluencers\n        }\n      }, engine);\n\n      if (this._onEffectCreatedObservable) {\n        onCreatedEffectParameters.effect = this._effect;\n\n        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n      }\n    }\n\n    if ((_b = !((_a = this._effect) === null || _a === void 0 ? void 0 : _a.isReady())) !== null && _b !== void 0 ? _b : true) {\n      return false;\n    }\n\n    if (previousEffect !== this._effect) {\n      scene.resetCachedMaterial();\n    }\n\n    this._renderId = scene.getRenderId();\n    this._effect._wasPreviouslyReady = true;\n    return true;\n  };\n  /**\r\n   * Binds the world matrix to the material\r\n   * @param world defines the world transformation matrix\r\n   * @param effectOverride - If provided, use this effect instead of internal effect\r\n   */\n\n\n  ShaderMaterial.prototype.bindOnlyWorldMatrix = function (world, effectOverride) {\n    var scene = this.getScene();\n    var effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this._effect;\n\n    if (!effect) {\n      return;\n    }\n\n    if (this._options.uniforms.indexOf(\"world\") !== -1) {\n      effect.setMatrix(\"world\", world);\n    }\n\n    if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n      effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\n    }\n\n    if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n      effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\n    }\n  };\n  /**\r\n   * Binds the submesh to this material by preparing the effect and shader to draw\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh containing the submesh\r\n   * @param subMesh defines the submesh to bind the material to\r\n   */\n\n\n  ShaderMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n    this.bind(world, mesh, subMesh._effectOverride);\n  };\n  /**\r\n   * Binds the material to the mesh\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh to bind the material to\r\n   * @param effectOverride - If provided, use this effect instead of internal effect\r\n   */\n\n\n  ShaderMaterial.prototype.bind = function (world, mesh, effectOverride) {\n    // Std values\n    this.bindOnlyWorldMatrix(world, effectOverride);\n    var effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this._effect;\n\n    if (effect && this.getScene().getCachedMaterial() !== this) {\n      if (this._options.uniforms.indexOf(\"view\") !== -1) {\n        effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n      }\n\n      if (this._options.uniforms.indexOf(\"projection\") !== -1) {\n        effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\n      }\n\n      if (this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\n        effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n\n        if (this._multiview) {\n          effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\n        }\n      }\n\n      if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\n        effect.setVector3(\"cameraPosition\", this.getScene().activeCamera.globalPosition);\n      } // Bones\n\n\n      MaterialHelper.BindBonesParameters(mesh, effect);\n      var name; // Texture\n\n      for (name in this._textures) {\n        effect.setTexture(name, this._textures[name]);\n      } // Texture arrays\n\n\n      for (name in this._textureArrays) {\n        effect.setTextureArray(name, this._textureArrays[name]);\n      } // Int\n\n\n      for (name in this._ints) {\n        effect.setInt(name, this._ints[name]);\n      } // Float\n\n\n      for (name in this._floats) {\n        effect.setFloat(name, this._floats[name]);\n      } // Floats\n\n\n      for (name in this._floatsArrays) {\n        effect.setArray(name, this._floatsArrays[name]);\n      } // Color3\n\n\n      for (name in this._colors3) {\n        effect.setColor3(name, this._colors3[name]);\n      } // Color3Array\n\n\n      for (name in this._colors3Arrays) {\n        effect.setArray3(name, this._colors3Arrays[name]);\n      } // Color4\n\n\n      for (name in this._colors4) {\n        var color = this._colors4[name];\n        effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      } // Color4Array\n\n\n      for (name in this._colors4Arrays) {\n        effect.setArray4(name, this._colors4Arrays[name]);\n      } // Vector2\n\n\n      for (name in this._vectors2) {\n        effect.setVector2(name, this._vectors2[name]);\n      } // Vector3\n\n\n      for (name in this._vectors3) {\n        effect.setVector3(name, this._vectors3[name]);\n      } // Vector4\n\n\n      for (name in this._vectors4) {\n        effect.setVector4(name, this._vectors4[name]);\n      } // Matrix\n\n\n      for (name in this._matrices) {\n        effect.setMatrix(name, this._matrices[name]);\n      } // MatrixArray\n\n\n      for (name in this._matrixArrays) {\n        effect.setMatrices(name, this._matrixArrays[name]);\n      } // Matrix 3x3\n\n\n      for (name in this._matrices3x3) {\n        effect.setMatrix3x3(name, this._matrices3x3[name]);\n      } // Matrix 2x2\n\n\n      for (name in this._matrices2x2) {\n        effect.setMatrix2x2(name, this._matrices2x2[name]);\n      } // Vector2Array\n\n\n      for (name in this._vectors2Arrays) {\n        effect.setArray2(name, this._vectors2Arrays[name]);\n      } // Vector3Array\n\n\n      for (name in this._vectors3Arrays) {\n        effect.setArray3(name, this._vectors3Arrays[name]);\n      } // Vector4Array\n\n\n      for (name in this._vectors4Arrays) {\n        effect.setArray4(name, this._vectors4Arrays[name]);\n      }\n    }\n\n    var seffect = this._effect;\n    this._effect = effect; // make sure the active effect is the right one if there are some observers for onBind that would need to get the current effect\n\n    this._afterBind(mesh);\n\n    this._effect = seffect;\n  };\n\n  ShaderMaterial.prototype._afterBind = function (mesh) {\n    _super.prototype._afterBind.call(this, mesh);\n\n    this.getScene()._cachedEffect = this._effect;\n  };\n  /**\r\n   * Gets the active textures from the material\r\n   * @returns an array of textures\r\n   */\n\n\n  ShaderMaterial.prototype.getActiveTextures = function () {\n    var activeTextures = _super.prototype.getActiveTextures.call(this);\n\n    for (var name in this._textures) {\n      activeTextures.push(this._textures[name]);\n    }\n\n    for (var name in this._textureArrays) {\n      var array = this._textureArrays[name];\n\n      for (var index = 0; index < array.length; index++) {\n        activeTextures.push(array[index]);\n      }\n    }\n\n    return activeTextures;\n  };\n  /**\r\n   * Specifies if the material uses a texture\r\n   * @param texture defines the texture to check against the material\r\n   * @returns a boolean specifying if the material uses the texture\r\n   */\n\n\n  ShaderMaterial.prototype.hasTexture = function (texture) {\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    for (var name in this._textures) {\n      if (this._textures[name] === texture) {\n        return true;\n      }\n    }\n\n    for (var name in this._textureArrays) {\n      var array = this._textureArrays[name];\n\n      for (var index = 0; index < array.length; index++) {\n        if (array[index] === texture) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Makes a duplicate of the material, and gives it a new name\r\n   * @param name defines the new name for the duplicated material\r\n   * @returns the cloned material\r\n   */\n\n\n  ShaderMaterial.prototype.clone = function (name) {\n    var _this = this;\n\n    var result = SerializationHelper.Clone(function () {\n      return new ShaderMaterial(name, _this.getScene(), _this._shaderPath, _this._options);\n    }, this);\n    result.name = name;\n    result.id = name; // Shader code path\n\n    if (typeof result._shaderPath === 'object') {\n      result._shaderPath = __assign({}, result._shaderPath);\n    } // Options\n\n\n    this._options = __assign({}, this._options);\n    Object.keys(this._options).forEach(function (propName) {\n      var propValue = _this._options[propName];\n\n      if (Array.isArray(propValue)) {\n        _this._options[propName] = propValue.slice(0);\n      }\n    }); // Texture\n\n    for (var key in this._textures) {\n      result.setTexture(key, this._textures[key]);\n    } // Float\n\n\n    for (var key in this._floats) {\n      result.setFloat(key, this._floats[key]);\n    } // Floats\n\n\n    for (var key in this._floatsArrays) {\n      result.setFloats(key, this._floatsArrays[key]);\n    } // Color3\n\n\n    for (var key in this._colors3) {\n      result.setColor3(key, this._colors3[key]);\n    } // Color4\n\n\n    for (var key in this._colors4) {\n      result.setColor4(key, this._colors4[key]);\n    } // Vector2\n\n\n    for (var key in this._vectors2) {\n      result.setVector2(key, this._vectors2[key]);\n    } // Vector3\n\n\n    for (var key in this._vectors3) {\n      result.setVector3(key, this._vectors3[key]);\n    } // Vector4\n\n\n    for (var key in this._vectors4) {\n      result.setVector4(key, this._vectors4[key]);\n    } // Matrix\n\n\n    for (var key in this._matrices) {\n      result.setMatrix(key, this._matrices[key]);\n    } // Matrix 3x3\n\n\n    for (var key in this._matrices3x3) {\n      result.setMatrix3x3(key, this._matrices3x3[key]);\n    } // Matrix 2x2\n\n\n    for (var key in this._matrices2x2) {\n      result.setMatrix2x2(key, this._matrices2x2[key]);\n    }\n\n    return result;\n  };\n  /**\r\n   * Disposes the material\r\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n   */\n\n\n  ShaderMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      var name;\n\n      for (name in this._textures) {\n        this._textures[name].dispose();\n      }\n\n      for (name in this._textureArrays) {\n        var array = this._textureArrays[name];\n\n        for (var index = 0; index < array.length; index++) {\n          array[index].dispose();\n        }\n      }\n    }\n\n    this._textures = {};\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  };\n  /**\r\n   * Serializes this material in a JSON representation\r\n   * @returns the serialized material object\r\n   */\n\n\n  ShaderMaterial.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.ShaderMaterial\";\n    serializationObject.options = this._options;\n    serializationObject.shaderPath = this._shaderPath;\n    var name; // Texture\n\n    serializationObject.textures = {};\n\n    for (name in this._textures) {\n      serializationObject.textures[name] = this._textures[name].serialize();\n    } // Texture arrays\n\n\n    serializationObject.textureArrays = {};\n\n    for (name in this._textureArrays) {\n      serializationObject.textureArrays[name] = [];\n      var array = this._textureArrays[name];\n\n      for (var index = 0; index < array.length; index++) {\n        serializationObject.textureArrays[name].push(array[index].serialize());\n      }\n    } // Float\n\n\n    serializationObject.floats = {};\n\n    for (name in this._floats) {\n      serializationObject.floats[name] = this._floats[name];\n    } // Floats\n\n\n    serializationObject.FloatArrays = {};\n\n    for (name in this._floatsArrays) {\n      serializationObject.FloatArrays[name] = this._floatsArrays[name];\n    } // Color3\n\n\n    serializationObject.colors3 = {};\n\n    for (name in this._colors3) {\n      serializationObject.colors3[name] = this._colors3[name].asArray();\n    } // Color3 array\n\n\n    serializationObject.colors3Arrays = {};\n\n    for (name in this._colors3Arrays) {\n      serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\n    } // Color4\n\n\n    serializationObject.colors4 = {};\n\n    for (name in this._colors4) {\n      serializationObject.colors4[name] = this._colors4[name].asArray();\n    } // Color4 array\n\n\n    serializationObject.colors4Arrays = {};\n\n    for (name in this._colors4Arrays) {\n      serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\n    } // Vector2\n\n\n    serializationObject.vectors2 = {};\n\n    for (name in this._vectors2) {\n      serializationObject.vectors2[name] = this._vectors2[name].asArray();\n    } // Vector3\n\n\n    serializationObject.vectors3 = {};\n\n    for (name in this._vectors3) {\n      serializationObject.vectors3[name] = this._vectors3[name].asArray();\n    } // Vector4\n\n\n    serializationObject.vectors4 = {};\n\n    for (name in this._vectors4) {\n      serializationObject.vectors4[name] = this._vectors4[name].asArray();\n    } // Matrix\n\n\n    serializationObject.matrices = {};\n\n    for (name in this._matrices) {\n      serializationObject.matrices[name] = this._matrices[name].asArray();\n    } // MatrixArray\n\n\n    serializationObject.matrixArray = {};\n\n    for (name in this._matrixArrays) {\n      serializationObject.matrixArray[name] = this._matrixArrays[name];\n    } // Matrix 3x3\n\n\n    serializationObject.matrices3x3 = {};\n\n    for (name in this._matrices3x3) {\n      serializationObject.matrices3x3[name] = this._matrices3x3[name];\n    } // Matrix 2x2\n\n\n    serializationObject.matrices2x2 = {};\n\n    for (name in this._matrices2x2) {\n      serializationObject.matrices2x2[name] = this._matrices2x2[name];\n    } // Vector2Array\n\n\n    serializationObject.vectors2Arrays = {};\n\n    for (name in this._vectors2Arrays) {\n      serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\n    } // Vector3Array\n\n\n    serializationObject.vectors3Arrays = {};\n\n    for (name in this._vectors3Arrays) {\n      serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\n    } // Vector4Array\n\n\n    serializationObject.vectors4Arrays = {};\n\n    for (name in this._vectors4Arrays) {\n      serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Creates a shader material from parsed shader material data\r\n   * @param source defines the JSON represnetation of the material\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a new material\r\n   */\n\n\n  ShaderMaterial.Parse = function (source, scene, rootUrl) {\n    var material = SerializationHelper.Parse(function () {\n      return new ShaderMaterial(source.name, scene, source.shaderPath, source.options);\n    }, source, scene, rootUrl);\n    var name; // Texture\n\n    for (name in source.textures) {\n      material.setTexture(name, Texture.Parse(source.textures[name], scene, rootUrl));\n    } // Texture arrays\n\n\n    for (name in source.textureArrays) {\n      var array = source.textureArrays[name];\n      var textureArray = new Array();\n\n      for (var index = 0; index < array.length; index++) {\n        textureArray.push(Texture.Parse(array[index], scene, rootUrl));\n      }\n\n      material.setTextureArray(name, textureArray);\n    } // Float\n\n\n    for (name in source.floats) {\n      material.setFloat(name, source.floats[name]);\n    } // Float s\n\n\n    for (name in source.floatsArrays) {\n      material.setFloats(name, source.floatsArrays[name]);\n    } // Color3\n\n\n    for (name in source.colors3) {\n      material.setColor3(name, Color3.FromArray(source.colors3[name]));\n    } // Color3 arrays\n\n\n    for (name in source.colors3Arrays) {\n      var colors = source.colors3Arrays[name].reduce(function (arr, num, i) {\n        if (i % 3 === 0) {\n          arr.push([num]);\n        } else {\n          arr[arr.length - 1].push(num);\n        }\n\n        return arr;\n      }, []).map(function (color) {\n        return Color3.FromArray(color);\n      });\n      material.setColor3Array(name, colors);\n    } // Color4\n\n\n    for (name in source.colors4) {\n      material.setColor4(name, Color4.FromArray(source.colors4[name]));\n    } // Color4 arrays\n\n\n    for (name in source.colors4Arrays) {\n      var colors = source.colors4Arrays[name].reduce(function (arr, num, i) {\n        if (i % 4 === 0) {\n          arr.push([num]);\n        } else {\n          arr[arr.length - 1].push(num);\n        }\n\n        return arr;\n      }, []).map(function (color) {\n        return Color4.FromArray(color);\n      });\n      material.setColor4Array(name, colors);\n    } // Vector2\n\n\n    for (name in source.vectors2) {\n      material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\n    } // Vector3\n\n\n    for (name in source.vectors3) {\n      material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\n    } // Vector4\n\n\n    for (name in source.vectors4) {\n      material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\n    } // Matrix\n\n\n    for (name in source.matrices) {\n      material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\n    } // MatrixArray\n\n\n    for (name in source.matrixArray) {\n      material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\n    } // Matrix 3x3\n\n\n    for (name in source.matrices3x3) {\n      material.setMatrix3x3(name, source.matrices3x3[name]);\n    } // Matrix 2x2\n\n\n    for (name in source.matrices2x2) {\n      material.setMatrix2x2(name, source.matrices2x2[name]);\n    } // Vector2Array\n\n\n    for (name in source.vectors2Arrays) {\n      material.setArray2(name, source.vectors2Arrays[name]);\n    } // Vector3Array\n\n\n    for (name in source.vectors3Arrays) {\n      material.setArray3(name, source.vectors3Arrays[name]);\n    } // Vector4Array\n\n\n    for (name in source.vectors4Arrays) {\n      material.setArray4(name, source.vectors4Arrays[name]);\n    }\n\n    return material;\n  };\n  /**\r\n   * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n   * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n   * @param url defines the url to load from\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new ShaderMaterial\r\n   */\n\n\n  ShaderMaterial.ParseFromFileAsync = function (name, url, scene, rootUrl) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n\n            var output = _this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\n\n            if (name) {\n              output.name = name;\n            }\n\n            resolve(output);\n          } else {\n            reject(\"Unable to load the ShaderMaterial\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\r\n   * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n   * @param snippetId defines the snippet to load\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new ShaderMaterial\r\n   */\n\n\n  ShaderMaterial.CreateFromSnippetAsync = function (snippetId, scene, rootUrl) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.shaderMaterial);\n\n            var output = _this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\n\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /** Define the Url to load snippets */\n\n\n  ShaderMaterial.SnippetUrl = \"https://snippet.babylonjs.com\";\n  return ShaderMaterial;\n}(Material);\n\nexport { ShaderMaterial };\n_TypeStore.RegisteredTypes[\"BABYLON.ShaderMaterial\"] = ShaderMaterial;","map":null,"metadata":{},"sourceType":"module"}