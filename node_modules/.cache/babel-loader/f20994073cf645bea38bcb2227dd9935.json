{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../../Maths/math.vector\";\nimport { Ray } from \"../../Culling/ray\";\nimport { EngineStore } from \"../../Engines/engineStore\";\nimport { Gamepad } from \"../../Gamepads/gamepad\";\n/**\r\n* Defines the types of pose enabled controllers that are supported\r\n*/\n\nexport var PoseEnabledControllerType;\n\n(function (PoseEnabledControllerType) {\n  /**\r\n   * HTC Vive\r\n   */\n  PoseEnabledControllerType[PoseEnabledControllerType[\"VIVE\"] = 0] = \"VIVE\";\n  /**\r\n   * Oculus Rift\r\n   */\n\n  PoseEnabledControllerType[PoseEnabledControllerType[\"OCULUS\"] = 1] = \"OCULUS\";\n  /**\r\n   * Windows mixed reality\r\n   */\n\n  PoseEnabledControllerType[PoseEnabledControllerType[\"WINDOWS\"] = 2] = \"WINDOWS\";\n  /**\r\n   * Samsung gear VR\r\n   */\n\n  PoseEnabledControllerType[PoseEnabledControllerType[\"GEAR_VR\"] = 3] = \"GEAR_VR\";\n  /**\r\n   * Google Daydream\r\n   */\n\n  PoseEnabledControllerType[PoseEnabledControllerType[\"DAYDREAM\"] = 4] = \"DAYDREAM\";\n  /**\r\n   * Generic\r\n   */\n\n  PoseEnabledControllerType[PoseEnabledControllerType[\"GENERIC\"] = 5] = \"GENERIC\";\n})(PoseEnabledControllerType || (PoseEnabledControllerType = {}));\n/**\r\n * Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)\r\n */\n\n\nvar PoseEnabledControllerHelper =\n/** @class */\nfunction () {\n  function PoseEnabledControllerHelper() {}\n  /**\r\n   * Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)\r\n   * @param vrGamepad the gamepad to initialized\r\n   * @returns a vr controller of the type the gamepad identified as\r\n   */\n\n\n  PoseEnabledControllerHelper.InitiateController = function (vrGamepad) {\n    for (var _i = 0, _a = this._ControllerFactories; _i < _a.length; _i++) {\n      var factory = _a[_i];\n\n      if (factory.canCreate(vrGamepad)) {\n        return factory.create(vrGamepad);\n      }\n    }\n\n    if (this._DefaultControllerFactory) {\n      return this._DefaultControllerFactory(vrGamepad);\n    }\n\n    throw \"The type of gamepad you are trying to load needs to be imported first or is not supported.\";\n  };\n  /** @hidden */\n\n\n  PoseEnabledControllerHelper._ControllerFactories = [];\n  /** @hidden */\n\n  PoseEnabledControllerHelper._DefaultControllerFactory = null;\n  return PoseEnabledControllerHelper;\n}();\n\nexport { PoseEnabledControllerHelper };\n/**\r\n * Defines the PoseEnabledController object that contains state of a vr capable controller\r\n */\n\nvar PoseEnabledController =\n/** @class */\nfunction (_super) {\n  __extends(PoseEnabledController, _super);\n  /**\r\n   * Creates a new PoseEnabledController from a gamepad\r\n   * @param browserGamepad the gamepad that the PoseEnabledController should be created from\r\n   */\n\n\n  function PoseEnabledController(browserGamepad) {\n    var _this = _super.call(this, browserGamepad.id, browserGamepad.index, browserGamepad) || this;\n    /**\r\n     * If the controller is used in a webXR session\r\n     */\n\n\n    _this.isXR = false; // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\n\n    _this._deviceRoomPosition = Vector3.Zero();\n    _this._deviceRoomRotationQuaternion = new Quaternion();\n    /**\r\n     * The device position in babylon space\r\n     */\n\n    _this.devicePosition = Vector3.Zero();\n    /**\r\n     * The device rotation in babylon space\r\n     */\n\n    _this.deviceRotationQuaternion = new Quaternion();\n    /**\r\n     * The scale factor of the device in babylon space\r\n     */\n\n    _this.deviceScaleFactor = 1; // Used to convert 6dof controllers to 3dof\n\n    _this._trackPosition = true;\n    _this._maxRotationDistFromHeadset = Math.PI / 5;\n    _this._draggedRoomRotation = 0;\n    _this._leftHandSystemQuaternion = new Quaternion();\n    /**\r\n     * Internal, matrix used to convert room space to babylon space\r\n     * @hidden\r\n     */\n\n    _this._deviceToWorld = Matrix.Identity();\n    /**\r\n     * Node to be used when casting a ray from the controller\r\n     * @hidden\r\n     */\n\n    _this._pointingPoseNode = null;\n    _this._workingMatrix = Matrix.Identity();\n    /**\r\n     * @hidden\r\n     */\n\n    _this._meshAttachedObservable = new Observable();\n    _this.type = Gamepad.POSE_ENABLED;\n    _this.controllerType = PoseEnabledControllerType.GENERIC;\n    _this.position = Vector3.Zero();\n    _this.rotationQuaternion = new Quaternion();\n    _this._calculatedPosition = Vector3.Zero();\n    _this._calculatedRotation = new Quaternion();\n    Quaternion.RotationYawPitchRollToRef(Math.PI, 0, 0, _this._leftHandSystemQuaternion);\n    return _this;\n  }\n  /**\r\n   * @hidden\r\n   */\n\n\n  PoseEnabledController.prototype._disableTrackPosition = function (fixedPosition) {\n    if (this._trackPosition) {\n      this._calculatedPosition.copyFrom(fixedPosition);\n\n      this._trackPosition = false;\n    }\n  };\n  /**\r\n   * Updates the state of the pose enbaled controller and mesh based on the current position and rotation of the controller\r\n   */\n\n\n  PoseEnabledController.prototype.update = function () {\n    _super.prototype.update.call(this);\n\n    this._updatePoseAndMesh();\n  };\n  /**\r\n   * Updates only the pose device and mesh without doing any button event checking\r\n   */\n\n\n  PoseEnabledController.prototype._updatePoseAndMesh = function () {\n    if (this.isXR) {\n      return;\n    }\n\n    var pose = this.browserGamepad.pose;\n    this.updateFromDevice(pose);\n\n    if (!this._trackPosition && EngineStore.LastCreatedScene && EngineStore.LastCreatedScene.activeCamera && EngineStore.LastCreatedScene.activeCamera.devicePosition) {\n      var camera = EngineStore.LastCreatedScene.activeCamera;\n\n      camera._computeDevicePosition();\n\n      this._deviceToWorld.setTranslation(camera.devicePosition);\n\n      if (camera.deviceRotationQuaternion) {\n        var camera = camera;\n\n        camera._deviceRoomRotationQuaternion.toEulerAnglesToRef(TmpVectors.Vector3[0]); // Find the radian distance away that the headset is from the controllers rotation\n\n\n        var distanceAway = Math.atan2(Math.sin(TmpVectors.Vector3[0].y - this._draggedRoomRotation), Math.cos(TmpVectors.Vector3[0].y - this._draggedRoomRotation));\n\n        if (Math.abs(distanceAway) > this._maxRotationDistFromHeadset) {\n          // Only rotate enouph to be within the _maxRotationDistFromHeadset\n          var rotationAmount = distanceAway - (distanceAway < 0 ? -this._maxRotationDistFromHeadset : this._maxRotationDistFromHeadset);\n          this._draggedRoomRotation += rotationAmount; // Rotate controller around headset\n\n          var sin = Math.sin(-rotationAmount);\n          var cos = Math.cos(-rotationAmount);\n          this._calculatedPosition.x = this._calculatedPosition.x * cos - this._calculatedPosition.z * sin;\n          this._calculatedPosition.z = this._calculatedPosition.x * sin + this._calculatedPosition.z * cos;\n        }\n      }\n    }\n\n    Vector3.TransformCoordinatesToRef(this._calculatedPosition, this._deviceToWorld, this.devicePosition);\n\n    this._deviceToWorld.getRotationMatrixToRef(this._workingMatrix);\n\n    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\n    this.deviceRotationQuaternion.multiplyInPlace(this._calculatedRotation);\n\n    if (this._mesh) {\n      this._mesh.position.copyFrom(this.devicePosition);\n\n      if (this._mesh.rotationQuaternion) {\n        this._mesh.rotationQuaternion.copyFrom(this.deviceRotationQuaternion);\n      }\n    }\n  };\n  /**\r\n   * Updates the state of the pose enbaled controller based on the raw pose data from the device\r\n   * @param poseData raw pose fromthe device\r\n   */\n\n\n  PoseEnabledController.prototype.updateFromDevice = function (poseData) {\n    if (this.isXR) {\n      return;\n    }\n\n    if (poseData) {\n      this.rawPose = poseData;\n\n      if (poseData.position) {\n        this._deviceRoomPosition.copyFromFloats(poseData.position[0], poseData.position[1], -poseData.position[2]);\n\n        if (this._mesh && this._mesh.getScene().useRightHandedSystem) {\n          this._deviceRoomPosition.z *= -1;\n        }\n\n        if (this._trackPosition) {\n          this._deviceRoomPosition.scaleToRef(this.deviceScaleFactor, this._calculatedPosition);\n        }\n\n        this._calculatedPosition.addInPlace(this.position);\n      }\n\n      var pose = this.rawPose;\n\n      if (poseData.orientation && pose.orientation && pose.orientation.length === 4) {\n        this._deviceRoomRotationQuaternion.copyFromFloats(pose.orientation[0], pose.orientation[1], -pose.orientation[2], -pose.orientation[3]);\n\n        if (this._mesh) {\n          if (this._mesh.getScene().useRightHandedSystem) {\n            this._deviceRoomRotationQuaternion.z *= -1;\n            this._deviceRoomRotationQuaternion.w *= -1;\n          } else {\n            this._deviceRoomRotationQuaternion.multiplyToRef(this._leftHandSystemQuaternion, this._deviceRoomRotationQuaternion);\n          }\n        } // if the camera is set, rotate to the camera's rotation\n\n\n        this._deviceRoomRotationQuaternion.multiplyToRef(this.rotationQuaternion, this._calculatedRotation);\n      }\n    }\n  };\n  /**\r\n   * Attaches a mesh to the controller\r\n   * @param mesh the mesh to be attached\r\n   */\n\n\n  PoseEnabledController.prototype.attachToMesh = function (mesh) {\n    if (this._mesh) {\n      this._mesh.parent = null;\n    }\n\n    this._mesh = mesh;\n\n    if (this._poseControlledCamera) {\n      this._mesh.parent = this._poseControlledCamera;\n    }\n\n    if (!this._mesh.rotationQuaternion) {\n      this._mesh.rotationQuaternion = new Quaternion();\n    } // Sync controller mesh and pointing pose node's state with controller, this is done to avoid a frame where position is 0,0,0 when attaching mesh\n\n\n    if (!this.isXR) {\n      this._updatePoseAndMesh();\n\n      if (this._pointingPoseNode) {\n        var parents = [];\n        var obj = this._pointingPoseNode;\n\n        while (obj.parent) {\n          parents.push(obj.parent);\n          obj = obj.parent;\n        }\n\n        parents.reverse().forEach(function (p) {\n          p.computeWorldMatrix(true);\n        });\n      }\n    }\n\n    this._meshAttachedObservable.notifyObservers(mesh);\n  };\n  /**\r\n   * Attaches the controllers mesh to a camera\r\n   * @param camera the camera the mesh should be attached to\r\n   */\n\n\n  PoseEnabledController.prototype.attachToPoseControlledCamera = function (camera) {\n    this._poseControlledCamera = camera;\n\n    if (this._mesh) {\n      this._mesh.parent = this._poseControlledCamera;\n    }\n  };\n  /**\r\n   * Disposes of the controller\r\n   */\n\n\n  PoseEnabledController.prototype.dispose = function () {\n    if (this._mesh) {\n      this._mesh.dispose();\n    }\n\n    this._mesh = null;\n\n    _super.prototype.dispose.call(this);\n  };\n\n  Object.defineProperty(PoseEnabledController.prototype, \"mesh\", {\n    /**\r\n     * The mesh that is attached to the controller\r\n     */\n    get: function get() {\n      return this._mesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the ray of the controller in the direction the controller is pointing\r\n   * @param length the length the resulting ray should be\r\n   * @returns a ray in the direction the controller is pointing\r\n   */\n\n  PoseEnabledController.prototype.getForwardRay = function (length) {\n    if (length === void 0) {\n      length = 100;\n    }\n\n    if (!this.mesh) {\n      return new Ray(Vector3.Zero(), new Vector3(0, 0, 1), length);\n    }\n\n    var m = this._pointingPoseNode ? this._pointingPoseNode.getWorldMatrix() : this.mesh.getWorldMatrix();\n    var origin = m.getTranslation();\n    var forward = new Vector3(0, 0, -1);\n    var forwardWorld = Vector3.TransformNormal(forward, m);\n    var direction = Vector3.Normalize(forwardWorld);\n    return new Ray(origin, direction, length);\n  };\n  /**\r\n   * Name of the child mesh that can be used to cast a ray from the controller\r\n   */\n\n\n  PoseEnabledController.POINTING_POSE = \"POINTING_POSE\";\n  return PoseEnabledController;\n}(Gamepad);\n\nexport { PoseEnabledController };","map":null,"metadata":{},"sourceType":"module"}