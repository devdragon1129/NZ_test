{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Action } from \"./action\";\nimport { Logger } from \"../Misc/logger\";\nimport { Observable } from \"../Misc/observable\";\nimport { Color3 } from \"../Maths/math.color\";\nimport { Vector3, Matrix, Quaternion } from \"../Maths/math.vector\";\nimport { Animation } from \"../Animations/animation\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * This defines an action responsible to change the value of a property\r\n * by interpolating between its current value and the newly set one once triggered.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n */\n\nvar InterpolateValueAction =\n/** @class */\nfunction (_super) {\n  __extends(InterpolateValueAction, _super);\n  /**\r\n   * Instantiate the action\r\n   * @param triggerOptions defines the trigger options\r\n   * @param target defines the object containing the value to interpolate\r\n   * @param propertyPath defines the path to the property in the target object\r\n   * @param value defines the target value at the end of the interpolation\r\n   * @param duration deines the time it will take for the property to interpolate to the value.\r\n   * @param condition defines the trigger related conditions\r\n   * @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered\r\n   * @param onInterpolationDone defines a callback raised once the interpolation animation has been done\r\n   */\n\n\n  function InterpolateValueAction(triggerOptions, target, propertyPath, value, duration, condition, stopOtherAnimations, onInterpolationDone) {\n    if (duration === void 0) {\n      duration = 1000;\n    }\n\n    var _this = _super.call(this, triggerOptions, condition) || this;\n    /**\r\n     * Defines the time it will take for the property to interpolate to the value.\r\n     */\n\n\n    _this.duration = 1000;\n    /**\r\n     * Observable triggered once the interpolation animation has been done.\r\n     */\n\n    _this.onInterpolationDoneObservable = new Observable();\n    _this.propertyPath = propertyPath;\n    _this.value = value;\n    _this.duration = duration;\n    _this.stopOtherAnimations = stopOtherAnimations;\n    _this.onInterpolationDone = onInterpolationDone;\n    _this._target = _this._effectiveTarget = target;\n    return _this;\n  }\n  /** @hidden */\n\n\n  InterpolateValueAction.prototype._prepare = function () {\n    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\n    this._property = this._getProperty(this.propertyPath);\n  };\n  /**\r\n   * Execute the action starts the value interpolation.\r\n   */\n\n\n  InterpolateValueAction.prototype.execute = function () {\n    var _this = this;\n\n    var scene = this._actionManager.getScene();\n\n    var keys = [{\n      frame: 0,\n      value: this._effectiveTarget[this._property]\n    }, {\n      frame: 100,\n      value: this.value\n    }];\n    var dataType;\n\n    if (typeof this.value === \"number\") {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (this.value instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (this.value instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (this.value instanceof Matrix) {\n      dataType = Animation.ANIMATIONTYPE_MATRIX;\n    } else if (this.value instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else {\n      Logger.Warn(\"InterpolateValueAction: Unsupported type (\" + typeof this.value + \")\");\n      return;\n    }\n\n    var animation = new Animation(\"InterpolateValueAction\", this._property, 100 * (1000.0 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setKeys(keys);\n\n    if (this.stopOtherAnimations) {\n      scene.stopAnimation(this._effectiveTarget);\n    }\n\n    var wrapper = function wrapper() {\n      _this.onInterpolationDoneObservable.notifyObservers(_this);\n\n      if (_this.onInterpolationDone) {\n        _this.onInterpolationDone();\n      }\n    };\n\n    scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);\n  };\n  /**\r\n   * Serializes the actions and its related information.\r\n   * @param parent defines the object to serialize in\r\n   * @returns the serialized object\r\n   */\n\n\n  InterpolateValueAction.prototype.serialize = function (parent) {\n    return _super.prototype._serialize.call(this, {\n      name: \"InterpolateValueAction\",\n      properties: [Action._GetTargetProperty(this._target), {\n        name: \"propertyPath\",\n        value: this.propertyPath\n      }, {\n        name: \"value\",\n        value: Action._SerializeValueAsString(this.value)\n      }, {\n        name: \"duration\",\n        value: Action._SerializeValueAsString(this.duration)\n      }, {\n        name: \"stopOtherAnimations\",\n        value: Action._SerializeValueAsString(this.stopOtherAnimations) || false\n      }]\n    }, parent);\n  };\n\n  return InterpolateValueAction;\n}(Action);\n\nexport { InterpolateValueAction };\n_TypeStore.RegisteredTypes[\"BABYLON.InterpolateValueAction\"] = InterpolateValueAction;","map":null,"metadata":{},"sourceType":"module"}