{"ast":null,"code":"import { Engine } from \"../Engines/engine\";\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Effect } from \"../Materials/effect\";\nimport \"../Meshes/Builders/planeBuilder\";\nimport \"../Shaders/spriteMap.fragment\";\nimport \"../Shaders/spriteMap.vertex\";\n/**\r\n * Class used to manage a grid restricted sprite deployment on an Output plane.\r\n */\n\nvar SpriteMap =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new SpriteMap\r\n   * @param name defines the SpriteMaps Name\r\n   * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\r\n   * @param spriteSheet is the Texture that the Sprites are on.\r\n   * @param options a basic deployment configuration\r\n   * @param scene The Scene that the map is deployed on\r\n   */\n  function SpriteMap(name, atlasJSON, spriteSheet, options, scene) {\n    var _this = this;\n\n    this.name = name;\n    this.sprites = [];\n    this.atlasJSON = atlasJSON;\n    this.sprites = this.atlasJSON[\"frames\"];\n    this.spriteSheet = spriteSheet;\n    /**\r\n    * Run through the options and set what ever defaults are needed that where not declared.\r\n    */\n\n    this.options = options;\n    options.stageSize = options.stageSize || new Vector2(1, 1);\n    options.outputSize = options.outputSize || options.stageSize;\n    options.outputPosition = options.outputPosition || Vector3.Zero();\n    options.outputRotation = options.outputRotation || Vector3.Zero();\n    options.layerCount = options.layerCount || 1;\n    options.maxAnimationFrames = options.maxAnimationFrames || 0;\n    options.baseTile = options.baseTile || 0;\n    options.flipU = options.flipU || false;\n    options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\n    this._scene = scene;\n    this._frameMap = this._createFrameBuffer();\n    this._tileMaps = new Array();\n\n    for (var i = 0; i < options.layerCount; i++) {\n      this._tileMaps.push(this._createTileBuffer(null, i));\n    }\n\n    this._animationMap = this._createTileAnimationBuffer(null);\n    var defines = [];\n    defines.push(\"#define LAYERS \" + options.layerCount);\n\n    if (options.flipU) {\n      defines.push(\"#define FLIPU\");\n    }\n\n    defines.push(\"#define MAX_ANIMATION_FRAMES \" + options.maxAnimationFrames + \".0\");\n    var shaderString = Effect.ShadersStore[\"spriteMapPixelShader\"];\n    var layerSampleString;\n\n    if (this._scene.getEngine().webGLVersion === 1) {\n      layerSampleString = \"\";\n\n      for (var i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"if (\" + i + \" == i) { frameID = texture2D(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x; }\";\n      }\n    } else {\n      layerSampleString = \"switch(i) {\";\n\n      for (var i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\n        layerSampleString += \"break;\";\n      }\n\n      layerSampleString += \"}\";\n    }\n\n    Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\n    this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\n      vertex: \"spriteMap\",\n      fragment: \"spriteMap\" + this.name\n    }, {\n      defines: defines,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\n      samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\n      needAlphaBlending: true\n    });\n    this._time = 0;\n\n    this._material.setFloat(\"spriteCount\", this.spriteCount);\n\n    this._material.setVector2(\"stageSize\", options.stageSize);\n\n    this._material.setVector2(\"outputSize\", options.outputSize);\n\n    this._material.setTexture(\"spriteSheet\", this.spriteSheet);\n\n    this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\n\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n\n    var tickSave = 0;\n\n    var bindSpriteTexture = function bindSpriteTexture() {\n      if (_this.spriteSheet && _this.spriteSheet.isReady()) {\n        if (_this.spriteSheet._texture) {\n          _this._material.setVector2(\"spriteMapSize\", new Vector2(_this.spriteSheet._texture.baseWidth || 1, _this.spriteSheet._texture.baseHeight || 1));\n\n          return;\n        }\n      }\n\n      if (tickSave < 100) {\n        setTimeout(function () {\n          tickSave++;\n          bindSpriteTexture();\n        }, 100);\n      }\n    };\n\n    bindSpriteTexture();\n\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n\n    this._material.setTexture(\"frameMap\", this._frameMap);\n\n    this._material.setTextureArray(\"tileMaps\", this._tileMaps);\n\n    this._material.setTexture(\"animationMap\", this._animationMap);\n\n    this._material.setFloat(\"time\", this._time);\n\n    this._output = Mesh.CreatePlane(name + \":output\", 1, scene, true);\n    this._output.scaling.x = options.outputSize.x;\n    this._output.scaling.y = options.outputSize.y;\n    this.position = options.outputPosition;\n    this.rotation = options.outputRotation;\n\n    var obfunction = function obfunction() {\n      _this._time += _this._scene.getEngine().getDeltaTime();\n\n      _this._material.setFloat(\"time\", _this._time);\n    };\n\n    this._scene.onBeforeRenderObservable.add(obfunction);\n\n    this._output.material = this._material;\n  }\n\n  Object.defineProperty(SpriteMap.prototype, \"spriteCount\", {\n    /** Returns the Number of Sprites in the System */\n    get: function get() {\n      return this.sprites.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"position\", {\n    /** Returns the Position of Output Plane*/\n    get: function get() {\n      return this._output.position;\n    },\n\n    /** Returns the Position of Output Plane*/\n    set: function set(v) {\n      this._output.position = v;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"rotation\", {\n    /** Returns the Rotation of Output Plane*/\n    get: function get() {\n      return this._output.rotation;\n    },\n\n    /** Returns the Rotation of Output Plane*/\n    set: function set(v) {\n      this._output.rotation = v;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"animationMap\", {\n    /** Sets the AnimationMap*/\n    get: function get() {\n      return this._animationMap;\n    },\n\n    /** Sets the AnimationMap*/\n    set: function set(v) {\n      var buffer = v._texture._bufferView;\n\n      var am = this._createTileAnimationBuffer(buffer);\n\n      this._animationMap.dispose();\n\n      this._animationMap = am;\n\n      this._material.setTexture(\"animationMap\", this._animationMap);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n  * Returns tileID location\r\n  * @returns Vector2 the cell position ID\r\n  */\n\n  SpriteMap.prototype.getTileID = function () {\n    var p = this.getMousePosition();\n    p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\n    p.x = Math.floor(p.x);\n    p.y = Math.floor(p.y);\n    return p;\n  };\n  /**\r\n  * Gets the UV location of the mouse over the SpriteMap.\r\n  * @returns Vector2 the UV position of the mouse interaction\r\n  */\n\n\n  SpriteMap.prototype.getMousePosition = function () {\n    var out = this._output;\n\n    var pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, function (mesh) {\n      if (mesh !== out) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\n      return new Vector2(-1, -1);\n    }\n\n    var coords = pickinfo.getTextureCoordinates();\n\n    if (coords) {\n      return coords;\n    }\n\n    return new Vector2(-1, -1);\n  };\n  /**\r\n  * Creates the \"frame\" texture Buffer\r\n  * -------------------------------------\r\n  * Structure of frames\r\n  *  \"filename\": \"Falling-Water-2.png\",\r\n  * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\r\n  * \"rotated\": true,\r\n  * \"trimmed\": true,\r\n  * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\r\n  * \"sourceSize\": {\"w\":32,\"h\":32}\r\n  * @returns RawTexture of the frameMap\r\n  */\n\n\n  SpriteMap.prototype._createFrameBuffer = function () {\n    var data = new Array(); //Do two Passes\n\n    for (var i = 0; i < this.spriteCount; i++) {\n      data.push(0, 0, 0, 0); //frame\n\n      data.push(0, 0, 0, 0); //spriteSourceSize\n\n      data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\n\n      data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\n    } //Second Pass\n\n\n    for (var i = 0; i < this.spriteCount; i++) {\n      var f = this.sprites[i][\"frame\"];\n      var sss = this.sprites[i][\"spriteSourceSize\"];\n      var ss = this.sprites[i][\"sourceSize\"];\n      var r = this.sprites[i][\"rotated\"] ? 1 : 0;\n      var t_1 = this.sprites[i][\"trimmed\"] ? 1 : 0; //frame\n\n      data[i * 4] = f.x;\n      data[i * 4 + 1] = f.y;\n      data[i * 4 + 2] = f.w;\n      data[i * 4 + 3] = f.h; //spriteSourceSize\n\n      data[i * 4 + this.spriteCount * 4] = sss.x;\n      data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\n      data[i * 4 + 3 + this.spriteCount * 4] = sss.h; //sourceSize, rotated, trimmed\n\n      data[i * 4 + this.spriteCount * 8] = ss.w;\n      data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\n      data[i * 4 + 2 + this.spriteCount * 8] = r;\n      data[i * 4 + 3 + this.spriteCount * 8] = t_1;\n    }\n\n    var floatArray = new Float32Array(data);\n    var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\r\n  * Creates the tileMap texture Buffer\r\n  * @param buffer normally and array of numbers, or a false to generate from scratch\r\n  * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\r\n  * @returns RawTexture of the tileMap\r\n  */\n\n\n  SpriteMap.prototype._createTileBuffer = function (buffer, _layer) {\n    if (_layer === void 0) {\n      _layer = 0;\n    }\n\n    var data = new Array();\n\n    var _ty = this.options.stageSize.y || 0;\n\n    var _tx = this.options.stageSize.x || 0;\n\n    if (!buffer) {\n      var bt = this.options.baseTile;\n\n      if (_layer != 0) {\n        bt = 0;\n      }\n\n      for (var y = 0; y < _ty; y++) {\n        for (var x = 0; x < _tx * 4; x += 4) {\n          data.push(bt, 0, 0, 0);\n        }\n      }\n    } else {\n      data = buffer;\n    }\n\n    var floatArray = new Float32Array(data);\n    var t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\r\n  * Modifies the data of the tileMaps\r\n  * @param _layer is the ID of the layer you want to edit on the SpriteMap\r\n  * @param pos is the iVector2 Coordinates of the Tile\r\n  * @param tile The SpriteIndex of the new Tile\r\n  */\n\n\n  SpriteMap.prototype.changeTiles = function (_layer, pos, tile) {\n    if (_layer === void 0) {\n      _layer = 0;\n    }\n\n    if (tile === void 0) {\n      tile = 0;\n    }\n\n    var buffer;\n    buffer = this._tileMaps[_layer]._texture._bufferView;\n\n    if (buffer === null) {\n      return;\n    }\n\n    var p = new Array();\n\n    if (pos instanceof Vector2) {\n      p.push(pos);\n    } else {\n      p = pos;\n    }\n\n    var _tx = this.options.stageSize.x || 0;\n\n    for (var i = 0; i < p.length; i++) {\n      var _p = p[i];\n      _p.x = Math.floor(_p.x);\n      _p.y = Math.floor(_p.y);\n      var id = _p.x * 4 + _p.y * (_tx * 4);\n      buffer[id] = tile;\n    }\n\n    var t = this._createTileBuffer(buffer);\n\n    this._tileMaps[_layer].dispose();\n\n    this._tileMaps[_layer] = t;\n\n    this._material.setTextureArray(\"tileMap\", this._tileMaps);\n  };\n  /**\r\n  * Creates the animationMap texture Buffer\r\n  * @param buffer normally and array of numbers, or a false to generate from scratch\r\n  * @returns RawTexture of the animationMap\r\n  */\n\n\n  SpriteMap.prototype._createTileAnimationBuffer = function (buffer) {\n    var data = new Array();\n    var floatArray;\n\n    if (!buffer) {\n      for (var i = 0; i < this.spriteCount; i++) {\n        data.push(0, 0, 0, 0);\n        var count = 1;\n\n        while (count < (this.options.maxAnimationFrames || 4)) {\n          data.push(0, 0, 0, 0);\n          count++;\n        }\n      }\n\n      floatArray = new Float32Array(data);\n    } else {\n      floatArray = buffer;\n    }\n\n    var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\r\n  * Modifies the data of the animationMap\r\n  * @param cellID is the Index of the Sprite\r\n  * @param _frame is the target Animation frame\r\n  * @param toCell is the Target Index of the next frame of the animation\r\n  * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\r\n  * @param speed is a global scalar of the time variable on the map.\r\n  */\n\n\n  SpriteMap.prototype.addAnimationToTile = function (cellID, _frame, toCell, time, speed) {\n    if (cellID === void 0) {\n      cellID = 0;\n    }\n\n    if (_frame === void 0) {\n      _frame = 0;\n    }\n\n    if (toCell === void 0) {\n      toCell = 0;\n    }\n\n    if (time === void 0) {\n      time = 0;\n    }\n\n    if (speed === void 0) {\n      speed = 1;\n    }\n\n    var buffer = this._animationMap._texture._bufferView;\n    var id = cellID * 4 + this.spriteCount * 4 * _frame;\n\n    if (!buffer) {\n      return;\n    }\n\n    buffer[id] = toCell;\n    buffer[id + 1] = time;\n    buffer[id + 2] = speed;\n\n    var t = this._createTileAnimationBuffer(buffer);\n\n    this._animationMap.dispose();\n\n    this._animationMap = t;\n\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  };\n  /**\r\n  * Exports the .tilemaps file\r\n  */\n\n\n  SpriteMap.prototype.saveTileMaps = function () {\n    var maps = \"\";\n\n    for (var i = 0; i < this._tileMaps.length; i++) {\n      if (i > 0) {\n        maps += \"\\n\\r\";\n      }\n\n      maps += this._tileMaps[i]._texture._bufferView.toString();\n    }\n\n    var hiddenElement = document.createElement(\"a\");\n    hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\n    hiddenElement.target = \"_blank\";\n    hiddenElement.download = this.name + \".tilemaps\";\n    hiddenElement.click();\n    hiddenElement.remove();\n  };\n  /**\r\n  * Imports the .tilemaps file\r\n  * @param url of the .tilemaps file\r\n  */\n\n\n  SpriteMap.prototype.loadTileMaps = function (url) {\n    var _this = this;\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n\n    var _lc = this.options.layerCount || 0;\n\n    xhr.onload = function () {\n      var data = xhr.response.split(\"\\n\\r\");\n\n      for (var i = 0; i < _lc; i++) {\n        var d = data[i].split(\",\").map(Number);\n\n        var t = _this._createTileBuffer(d);\n\n        _this._tileMaps[i].dispose();\n\n        _this._tileMaps[i] = t;\n      }\n\n      _this._material.setTextureArray(\"tileMap\", _this._tileMaps);\n    };\n\n    xhr.send();\n  };\n  /**\r\n   * Release associated resources\r\n   */\n\n\n  SpriteMap.prototype.dispose = function () {\n    this._output.dispose();\n\n    this._material.dispose();\n\n    this._animationMap.dispose();\n\n    this._tileMaps.forEach(function (tm) {\n      tm.dispose();\n    });\n\n    this._frameMap.dispose();\n  };\n\n  return SpriteMap;\n}();\n\nexport { SpriteMap };","map":null,"metadata":{},"sourceType":"module"}