{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Matrix } from \"../../Maths/math.vector\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\nimport { _TypeStore } from \"../../Misc/typeStore\"; // Ensures Raw texture are included\n\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\r\n * It can help converting any input color in a desired output one. This can then be used to create effects\r\n * from sepia, black and white to sixties or futuristic rendering...\r\n *\r\n * The only supported format is currently 3dl.\r\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\r\n */\n\nvar ColorGradingTexture =\n/** @class */\nfunction (_super) {\n  __extends(ColorGradingTexture, _super);\n  /**\r\n   * Instantiates a ColorGradingTexture from the following parameters.\r\n   *\r\n   * @param url The location of the color gradind data (currently only supporting 3dl)\r\n   * @param sceneOrEngine The scene or engine the texture will be used in\r\n   * @param onLoad defines a callback triggered when the texture has been loaded\r\n   */\n\n\n  function ColorGradingTexture(url, sceneOrEngine, onLoad) {\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    var _this = _super.call(this, sceneOrEngine) || this;\n\n    if (!url) {\n      return _this;\n    }\n\n    _this._textureMatrix = Matrix.Identity();\n    _this.name = url;\n    _this.url = url;\n    _this._onLoad = onLoad;\n    _this._texture = _this._getFromCache(url, true);\n\n    if (!_this._texture) {\n      var scene = _this.getScene();\n\n      if (scene) {\n        if (!scene.useDelayedTextureLoading) {\n          _this.loadTexture();\n        } else {\n          _this.delayLoadState = 4;\n        }\n      } else {\n        _this.loadTexture();\n      }\n    } else {\n      _this._triggerOnLoad();\n    }\n\n    return _this;\n  }\n  /**\r\n   * Fires the onload event from the constructor if requested.\r\n   */\n\n\n  ColorGradingTexture.prototype._triggerOnLoad = function () {\n    if (this._onLoad) {\n      this._onLoad();\n    }\n  };\n  /**\r\n   * Returns the texture matrix used in most of the material.\r\n   * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\r\n   */\n\n\n  ColorGradingTexture.prototype.getTextureMatrix = function () {\n    return this._textureMatrix;\n  };\n  /**\r\n   * Occurs when the file being loaded is a .3dl LUT file.\r\n   */\n\n\n  ColorGradingTexture.prototype.load3dlTexture = function () {\n    var _this = this;\n\n    var engine = this._getEngine();\n\n    var texture;\n\n    if (engine.webGLVersion === 1) {\n      texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);\n    } else {\n      texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);\n    }\n\n    this._texture = texture;\n    this._texture.isReady = false;\n    this.isCube = false;\n    this.is3D = engine.webGLVersion > 1;\n    this.wrapU = 0;\n    this.wrapV = 0;\n    this.wrapR = 0;\n    this.anisotropicFilteringLevel = 1;\n\n    var callback = function callback(text) {\n      if (typeof text !== \"string\") {\n        return;\n      }\n\n      var data = null;\n      var tempData = null;\n      var line;\n      var lines = text.split('\\n');\n      var size = 0,\n          pixelIndexW = 0,\n          pixelIndexH = 0,\n          pixelIndexSlice = 0;\n      var maxColor = 0;\n\n      for (var i = 0; i < lines.length; i++) {\n        line = lines[i];\n\n        if (!ColorGradingTexture._noneEmptyLineRegex.test(line)) {\n          continue;\n        }\n\n        if (line.indexOf('#') === 0) {\n          continue;\n        }\n\n        var words = line.split(\" \");\n\n        if (size === 0) {\n          // Number of space + one\n          size = words.length;\n          data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\n\n          tempData = new Float32Array(size * size * size * 4);\n          continue;\n        }\n\n        if (size != 0) {\n          var r = Math.max(parseInt(words[0]), 0);\n          var g = Math.max(parseInt(words[1]), 0);\n          var b = Math.max(parseInt(words[2]), 0);\n          maxColor = Math.max(r, maxColor);\n          maxColor = Math.max(g, maxColor);\n          maxColor = Math.max(b, maxColor);\n          var pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\n\n          if (tempData) {\n            tempData[pixelStorageIndex + 0] = r;\n            tempData[pixelStorageIndex + 1] = g;\n            tempData[pixelStorageIndex + 2] = b;\n          } // Keep for reference in case of back compat problems.\n          // pixelIndexSlice++;\n          // if (pixelIndexSlice % size == 0) {\n          //     pixelIndexH++;\n          //     pixelIndexSlice = 0;\n          //     if (pixelIndexH % size == 0) {\n          //         pixelIndexW++;\n          //         pixelIndexH = 0;\n          //     }\n          // }\n\n\n          pixelIndexH++;\n\n          if (pixelIndexH % size == 0) {\n            pixelIndexSlice++;\n            pixelIndexH = 0;\n\n            if (pixelIndexSlice % size == 0) {\n              pixelIndexW++;\n              pixelIndexSlice = 0;\n            }\n          }\n        }\n      }\n\n      if (tempData && data) {\n        for (var i = 0; i < tempData.length; i++) {\n          if (i > 0 && (i + 1) % 4 === 0) {\n            data[i] = 255;\n          } else {\n            var value = tempData[i];\n            data[i] = value / maxColor * 255;\n          }\n        }\n      }\n\n      if (texture.is3D) {\n        texture.updateSize(size, size, size);\n        engine.updateRawTexture3D(texture, data, 5, false);\n      } else {\n        texture.updateSize(size * size, size);\n        engine.updateRawTexture(texture, data, 5, false);\n      }\n\n      texture.isReady = true;\n\n      _this._triggerOnLoad();\n    };\n\n    var scene = this.getScene();\n\n    if (scene) {\n      scene._loadFile(this.url, callback);\n    } else {\n      engine._loadFile(this.url, callback);\n    }\n\n    return this._texture;\n  };\n  /**\r\n   * Starts the loading process of the texture.\r\n   */\n\n\n  ColorGradingTexture.prototype.loadTexture = function () {\n    if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\n      this.load3dlTexture();\n    }\n  };\n  /**\r\n   * Clones the color gradind texture.\r\n   */\n\n\n  ColorGradingTexture.prototype.clone = function () {\n    var newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine()); // Base texture\n\n    newTexture.level = this.level;\n    return newTexture;\n  };\n  /**\r\n   * Called during delayed load for textures.\r\n   */\n\n\n  ColorGradingTexture.prototype.delayLoad = function () {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, true);\n\n    if (!this._texture) {\n      this.loadTexture();\n    }\n  };\n  /**\r\n   * Parses a color grading texture serialized by Babylon.\r\n   * @param parsedTexture The texture information being parsedTexture\r\n   * @param scene The scene to load the texture in\r\n   * @param rootUrl The root url of the data assets to load\r\n   * @return A color gradind texture\r\n   */\n\n\n  ColorGradingTexture.Parse = function (parsedTexture, scene) {\n    var texture = null;\n\n    if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n      texture = new ColorGradingTexture(parsedTexture.name, scene);\n      texture.name = parsedTexture.name;\n      texture.level = parsedTexture.level;\n    }\n\n    return texture;\n  };\n  /**\r\n   * Serializes the LUT texture to json format.\r\n   */\n\n\n  ColorGradingTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.level = this.level;\n    serializationObject.customType = \"BABYLON.ColorGradingTexture\";\n    return serializationObject;\n  };\n  /**\r\n   * Empty line regex stored for GC.\r\n   */\n\n\n  ColorGradingTexture._noneEmptyLineRegex = /\\S+/;\n  return ColorGradingTexture;\n}(BaseTexture);\n\nexport { ColorGradingTexture };\n_TypeStore.RegisteredTypes[\"BABYLON.ColorGradingTexture\"] = ColorGradingTexture;","map":null,"metadata":{},"sourceType":"module"}