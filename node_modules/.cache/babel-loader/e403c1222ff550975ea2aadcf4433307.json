{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport { PushMaterial } from '../pushMaterial';\nimport { AbstractMesh } from '../../Meshes/abstractMesh';\nimport { Matrix, Vector2 } from '../../Maths/math.vector';\nimport { Color3, Color4 } from '../../Maths/math.color';\nimport { Engine } from '../../Engines/engine';\nimport { NodeMaterialBuildState } from './nodeMaterialBuildState';\nimport { Observable } from '../../Misc/observable';\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\nimport { NodeMaterialBuildStateSharedData } from './nodeMaterialBuildStateSharedData';\nimport { MaterialDefines } from '../../Materials/materialDefines';\nimport { VertexBuffer } from '../../Meshes/buffer';\nimport { Tools } from '../../Misc/tools';\nimport { TransformBlock } from './Blocks/transformBlock';\nimport { VertexOutputBlock } from './Blocks/Vertex/vertexOutputBlock';\nimport { FragmentOutputBlock } from './Blocks/Fragment/fragmentOutputBlock';\nimport { InputBlock } from './Blocks/Input/inputBlock';\nimport { _TypeStore } from '../../Misc/typeStore';\nimport { serialize, SerializationHelper } from '../../Misc/decorators';\nimport { CurrentScreenBlock } from './Blocks/Dual/currentScreenBlock';\nimport { ParticleTextureBlock } from './Blocks/Particle/particleTextureBlock';\nimport { ParticleRampGradientBlock } from './Blocks/Particle/particleRampGradientBlock';\nimport { ParticleBlendMultiplyBlock } from './Blocks/Particle/particleBlendMultiplyBlock';\nimport { EffectFallbacks } from '../effectFallbacks';\nimport { WebRequest } from '../../Misc/webRequest';\nimport { Effect } from '../effect';\nimport { PostProcess } from '../../PostProcesses/postProcess';\nimport { VectorMergerBlock } from './Blocks/vectorMergerBlock';\nimport { RemapBlock } from './Blocks/remapBlock';\nimport { MultiplyBlock } from './Blocks/multiplyBlock';\nimport { NodeMaterialModes } from './Enums/nodeMaterialModes';\nimport { Texture } from '../Textures/texture';\nimport { BaseParticleSystem } from '../../Particles/baseParticleSystem';\nimport { ColorSplitterBlock } from './Blocks/colorSplitterBlock';\nimport { TimingTools } from '../../Misc/timingTools';\nimport { ProceduralTexture } from '../Textures/Procedurals/proceduralTexture';\nimport { AnimatedInputBlockTypes } from './Blocks/Input/animatedInputBlockTypes';\nimport { TrigonometryBlock, TrigonometryBlockOperations } from './Blocks/trigonometryBlock';\nvar onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/** @hidden */\n\nvar NodeMaterialDefines =\n/** @class */\nfunction (_super) {\n  __extends(NodeMaterialDefines, _super);\n\n  function NodeMaterialDefines() {\n    var _this = _super.call(this) || this;\n\n    _this.NORMAL = false;\n    _this.TANGENT = false;\n    _this.UV1 = false;\n    /** BONES */\n\n    _this.NUM_BONE_INFLUENCERS = 0;\n    _this.BonesPerMesh = 0;\n    _this.BONETEXTURE = false;\n    /** MORPH TARGETS */\n\n    _this.MORPHTARGETS = false;\n    _this.MORPHTARGETS_NORMAL = false;\n    _this.MORPHTARGETS_TANGENT = false;\n    _this.MORPHTARGETS_UV = false;\n    _this.NUM_MORPH_INFLUENCERS = 0;\n    /** IMAGE PROCESSING */\n\n    _this.IMAGEPROCESSING = false;\n    _this.VIGNETTE = false;\n    _this.VIGNETTEBLENDMODEMULTIPLY = false;\n    _this.VIGNETTEBLENDMODEOPAQUE = false;\n    _this.TONEMAPPING = false;\n    _this.TONEMAPPING_ACES = false;\n    _this.CONTRAST = false;\n    _this.EXPOSURE = false;\n    _this.COLORCURVES = false;\n    _this.COLORGRADING = false;\n    _this.COLORGRADING3D = false;\n    _this.SAMPLER3DGREENDEPTH = false;\n    _this.SAMPLER3DBGRMAP = false;\n    _this.IMAGEPROCESSINGPOSTPROCESS = false;\n    /** MISC. */\n\n    _this.BUMPDIRECTUV = 0;\n\n    _this.rebuild();\n\n    return _this;\n  }\n\n  NodeMaterialDefines.prototype.setValue = function (name, value, markAsUnprocessedIfDirty) {\n    if (markAsUnprocessedIfDirty === void 0) {\n      markAsUnprocessedIfDirty = false;\n    }\n\n    if (this[name] === undefined) {\n      this._keys.push(name);\n    }\n\n    if (markAsUnprocessedIfDirty && this[name] !== value) {\n      this.markAsUnprocessed();\n    }\n\n    this[name] = value;\n  };\n\n  return NodeMaterialDefines;\n}(MaterialDefines);\n\nexport { NodeMaterialDefines };\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\n\nvar NodeMaterial =\n/** @class */\nfunction (_super) {\n  __extends(NodeMaterial, _super);\n  /**\r\n   * Create a new node based material\r\n   * @param name defines the material name\r\n   * @param scene defines the hosting scene\r\n   * @param options defines creation option\r\n   */\n\n\n  function NodeMaterial(name, scene, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, name, scene || Engine.LastCreatedScene) || this;\n\n    _this._buildId = NodeMaterial._BuildIdGenerator++;\n    _this._buildWasSuccessful = false;\n    _this._cachedWorldViewMatrix = new Matrix();\n    _this._cachedWorldViewProjectionMatrix = new Matrix();\n    _this._optimizers = new Array();\n    _this._animationFrame = -1;\n    _this.BJSNODEMATERIALEDITOR = _this._getGlobalNodeMaterialEditor();\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\n\n    _this.editorData = null;\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\n\n    _this.ignoreAlpha = false;\n    /**\r\n    * Defines the maximum number of lights that can be used in the material\r\n    */\n\n    _this.maxSimultaneousLights = 4;\n    /**\r\n     * Observable raised when the material is built\r\n     */\n\n    _this.onBuildObservable = new Observable();\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\n\n    _this._vertexOutputNodes = new Array();\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\n\n    _this._fragmentOutputNodes = new Array();\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\n\n    _this.attachedBlocks = new Array();\n    /**\r\n     * Specifies the mode of the node material\r\n     * @hidden\r\n     */\n\n    _this._mode = NodeMaterialModes.Material;\n    _this._options = __assign({\n      emitComments: false\n    }, options); // Setup the default processing configuration to the scene.\n\n    _this._attachImageProcessingConfiguration(null);\n\n    return _this;\n  }\n  /** Get the inspector from bundle or global */\n\n\n  NodeMaterial.prototype._getGlobalNodeMaterialEditor = function () {\n    // UMD Global name detection from Webpack Bundle UMD Name.\n    if (typeof NODEEDITOR !== 'undefined') {\n      return NODEEDITOR;\n    } // In case of module let's check the global emitted from the editor entry point.\n\n\n    if (typeof BABYLON !== 'undefined' && typeof BABYLON.NodeEditor !== 'undefined') {\n      return BABYLON;\n    }\n\n    return undefined;\n  };\n\n  Object.defineProperty(NodeMaterial.prototype, \"options\", {\n    /** Gets or sets options to control the node material overall behavior */\n    get: function get() {\n      return this._options;\n    },\n    set: function set(options) {\n      this._options = options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterial.prototype, \"imageProcessingConfiguration\", {\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration;\n    },\n\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\n    set: function set(value) {\n      this._attachImageProcessingConfiguration(value); // Ensure the effect will be rebuilt.\n\n\n      this._markAllSubMeshesAsTexturesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterial.prototype, \"mode\", {\n    /**\r\n     * Gets the mode property\r\n     */\n    get: function get() {\n      return this._mode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n   * @returns the class name\r\n   */\n\n  NodeMaterial.prototype.getClassName = function () {\n    return \"NodeMaterial\";\n  };\n  /**\r\n   * Attaches a new image processing configuration to the Standard Material.\r\n   * @param configuration\r\n   */\n\n\n  NodeMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\n    var _this = this;\n\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    } // Detaches observer.\n\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    } // Pick the scene configuration if needed.\n\n\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    } // Attaches observer.\n\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {\n        _this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  };\n  /**\r\n   * Get a block by its name\r\n   * @param name defines the name of the block to retrieve\r\n   * @returns the required block or null if not found\r\n   */\n\n\n  NodeMaterial.prototype.getBlockByName = function (name) {\n    var result = null;\n\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.name === name) {\n        if (!result) {\n          result = block;\n        } else {\n          Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\n          return result;\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Get a block by its name\r\n   * @param predicate defines the predicate used to find the good candidate\r\n   * @returns the required block or null if not found\r\n   */\n\n\n  NodeMaterial.prototype.getBlockByPredicate = function (predicate) {\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (predicate(block)) {\n        return block;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Get an input block by its name\r\n   * @param predicate defines the predicate used to find the good candidate\r\n   * @returns the required input block or null if not found\r\n   */\n\n\n  NodeMaterial.prototype.getInputBlockByPredicate = function (predicate) {\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.isInput && predicate(block)) {\n        return block;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets the list of input blocks attached to this material\r\n   * @returns an array of InputBlocks\r\n   */\n\n\n  NodeMaterial.prototype.getInputBlocks = function () {\n    var blocks = [];\n\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.isInput) {\n        blocks.push(block);\n      }\n    }\n\n    return blocks;\n  };\n  /**\r\n   * Adds a new optimizer to the list of optimizers\r\n   * @param optimizer defines the optimizers to add\r\n   * @returns the current material\r\n   */\n\n\n  NodeMaterial.prototype.registerOptimizer = function (optimizer) {\n    var index = this._optimizers.indexOf(optimizer);\n\n    if (index > -1) {\n      return;\n    }\n\n    this._optimizers.push(optimizer);\n\n    return this;\n  };\n  /**\r\n   * Remove an optimizer from the list of optimizers\r\n   * @param optimizer defines the optimizers to remove\r\n   * @returns the current material\r\n   */\n\n\n  NodeMaterial.prototype.unregisterOptimizer = function (optimizer) {\n    var index = this._optimizers.indexOf(optimizer);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._optimizers.splice(index, 1);\n\n    return this;\n  };\n  /**\r\n   * Add a new block to the list of output nodes\r\n   * @param node defines the node to add\r\n   * @returns the current material\r\n   */\n\n\n  NodeMaterial.prototype.addOutputNode = function (node) {\n    if (node.target === null) {\n      throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._addVertexOutputNode(node);\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._addFragmentOutputNode(node);\n    }\n\n    return this;\n  };\n  /**\r\n   * Remove a block from the list of root nodes\r\n   * @param node defines the node to remove\r\n   * @returns the current material\r\n   */\n\n\n  NodeMaterial.prototype.removeOutputNode = function (node) {\n    if (node.target === null) {\n      return this;\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._removeVertexOutputNode(node);\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._removeFragmentOutputNode(node);\n    }\n\n    return this;\n  };\n\n  NodeMaterial.prototype._addVertexOutputNode = function (node) {\n    if (this._vertexOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n\n    node.target = NodeMaterialBlockTargets.Vertex;\n\n    this._vertexOutputNodes.push(node);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._removeVertexOutputNode = function (node) {\n    var index = this._vertexOutputNodes.indexOf(node);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._vertexOutputNodes.splice(index, 1);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._addFragmentOutputNode = function (node) {\n    if (this._fragmentOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n\n    node.target = NodeMaterialBlockTargets.Fragment;\n\n    this._fragmentOutputNodes.push(node);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._removeFragmentOutputNode = function (node) {\n    var index = this._fragmentOutputNodes.indexOf(node);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._fragmentOutputNodes.splice(index, 1);\n\n    return this;\n  };\n  /**\r\n   * Specifies if the material will require alpha blending\r\n   * @returns a boolean specifying if alpha blending is needed\r\n   */\n\n\n  NodeMaterial.prototype.needAlphaBlending = function () {\n    if (this.ignoreAlpha) {\n      return false;\n    }\n\n    return this.alpha < 1.0 || this._sharedData && this._sharedData.hints.needAlphaBlending;\n  };\n  /**\r\n   * Specifies if this material should be rendered in alpha test mode\r\n   * @returns a boolean specifying if an alpha test is needed.\r\n   */\n\n\n  NodeMaterial.prototype.needAlphaTesting = function () {\n    return this._sharedData && this._sharedData.hints.needAlphaTesting;\n  };\n\n  NodeMaterial.prototype._initializeBlock = function (node, state, nodesToProcessForOtherBuildState) {\n    node.initialize(state);\n    node.autoConfigure(this);\n    node._preparationId = this._buildId;\n\n    if (this.attachedBlocks.indexOf(node) === -1) {\n      if (node.isUnique) {\n        var className = node.getClassName();\n\n        for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n          var other = _a[_i];\n\n          if (other.getClassName() === className) {\n            throw \"Cannot have multiple blocks of type \" + className + \" in the same NodeMaterial\";\n          }\n        }\n      }\n\n      this.attachedBlocks.push(node);\n    }\n\n    for (var _b = 0, _c = node.inputs; _b < _c.length; _b++) {\n      var input = _c[_b];\n      input.associatedVariableName = \"\";\n      var connectedPoint = input.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== node) {\n          if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\n            nodesToProcessForOtherBuildState.push(block);\n          } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\n            nodesToProcessForOtherBuildState.push(block);\n          }\n\n          this._initializeBlock(block, state, nodesToProcessForOtherBuildState);\n        }\n      }\n    }\n\n    for (var _d = 0, _e = node.outputs; _d < _e.length; _d++) {\n      var output = _e[_d];\n      output.associatedVariableName = \"\";\n    }\n  };\n\n  NodeMaterial.prototype._resetDualBlocks = function (node, id) {\n    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\n      node.buildId = id;\n    }\n\n    for (var _i = 0, _a = node.inputs; _i < _a.length; _i++) {\n      var inputs = _a[_i];\n      var connectedPoint = inputs.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== node) {\n          this._resetDualBlocks(block, id);\n        }\n      }\n    }\n  };\n  /**\r\n   * Remove a block from the current node material\r\n   * @param block defines the block to remove\r\n   */\n\n\n  NodeMaterial.prototype.removeBlock = function (block) {\n    var attachedBlockIndex = this.attachedBlocks.indexOf(block);\n\n    if (attachedBlockIndex > -1) {\n      this.attachedBlocks.splice(attachedBlockIndex, 1);\n    }\n\n    if (block.isFinalMerger) {\n      this.removeOutputNode(block);\n    }\n  };\n  /**\r\n   * Build the material and generates the inner effect\r\n   * @param verbose defines if the build should log activity\r\n   */\n\n\n  NodeMaterial.prototype.build = function (verbose) {\n    if (verbose === void 0) {\n      verbose = false;\n    }\n\n    this._buildWasSuccessful = false;\n    var engine = this.getScene().getEngine();\n    var allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\n\n    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\n      throw \"You must define at least one vertexOutputNode\";\n    }\n\n    if (this._fragmentOutputNodes.length === 0) {\n      throw \"You must define at least one fragmentOutputNode\";\n    } // Compilation state\n\n\n    this._vertexCompilationState = new NodeMaterialBuildState();\n    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\n    this._fragmentCompilationState = new NodeMaterialBuildState();\n    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment; // Shared data\n\n    this._sharedData = new NodeMaterialBuildStateSharedData();\n    this._vertexCompilationState.sharedData = this._sharedData;\n    this._fragmentCompilationState.sharedData = this._sharedData;\n    this._sharedData.buildId = this._buildId;\n    this._sharedData.emitComments = this._options.emitComments;\n    this._sharedData.verbose = verbose;\n    this._sharedData.scene = this.getScene();\n    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram; // Initialize blocks\n\n    var vertexNodes = [];\n    var fragmentNodes = [];\n\n    for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n      var vertexOutputNode = _a[_i];\n      vertexNodes.push(vertexOutputNode);\n\n      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes);\n    }\n\n    for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n      var fragmentOutputNode = _c[_b];\n      fragmentNodes.push(fragmentOutputNode);\n\n      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes);\n    } // Optimize\n\n\n    this.optimize(); // Vertex\n\n    for (var _d = 0, vertexNodes_1 = vertexNodes; _d < vertexNodes_1.length; _d++) {\n      var vertexOutputNode = vertexNodes_1[_d];\n      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\n    } // Fragment\n\n\n    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\n    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\n    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\n    this._fragmentCompilationState._vertexState = this._vertexCompilationState;\n\n    for (var _e = 0, fragmentNodes_1 = fragmentNodes; _e < fragmentNodes_1.length; _e++) {\n      var fragmentOutputNode = fragmentNodes_1[_e];\n\n      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\n    }\n\n    for (var _f = 0, fragmentNodes_2 = fragmentNodes; _f < fragmentNodes_2.length; _f++) {\n      var fragmentOutputNode = fragmentNodes_2[_f];\n      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\n    } // Finalize\n\n\n    this._vertexCompilationState.finalize(this._vertexCompilationState);\n\n    this._fragmentCompilationState.finalize(this._fragmentCompilationState);\n\n    this._buildId = NodeMaterial._BuildIdGenerator++; // Errors\n\n    this._sharedData.emitErrors();\n\n    if (verbose) {\n      console.log(\"Vertex shader:\");\n      console.log(this._vertexCompilationState.compilationString);\n      console.log(\"Fragment shader:\");\n      console.log(this._fragmentCompilationState.compilationString);\n    }\n\n    this._buildWasSuccessful = true;\n    this.onBuildObservable.notifyObservers(this); // Wipe defines\n\n    var meshes = this.getScene().meshes;\n\n    for (var _g = 0, meshes_1 = meshes; _g < meshes_1.length; _g++) {\n      var mesh = meshes_1[_g];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _h = 0, _j = mesh.subMeshes; _h < _j.length; _h++) {\n        var subMesh = _j[_h];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        if (!subMesh._materialDefines) {\n          continue;\n        }\n\n        var defines = subMesh._materialDefines;\n        defines.markAllAsDirty();\n        defines.reset();\n      }\n    }\n  };\n  /**\r\n   * Runs an otpimization phase to try to improve the shader code\r\n   */\n\n\n  NodeMaterial.prototype.optimize = function () {\n    for (var _i = 0, _a = this._optimizers; _i < _a.length; _i++) {\n      var optimizer = _a[_i];\n      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\n    }\n  };\n\n  NodeMaterial.prototype._prepareDefinesForAttributes = function (mesh, defines) {\n    var oldNormal = defines[\"NORMAL\"];\n    var oldTangent = defines[\"TANGENT\"];\n    var oldUV1 = defines[\"UV1\"];\n    defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n    defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\n    defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\n\n    if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || oldUV1 !== defines[\"UV1\"]) {\n      defines.markAsAttributesDirty();\n    }\n  };\n  /**\r\n   * Create a post process from the material\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   * @param textureType Type of textures used when performing the post process. (default: 0)\r\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n   * @returns the post process created\r\n   */\n\n\n  NodeMaterial.prototype.createPostProcess = function (camera, options, samplingMode, engine, reusable, textureType, textureFormat) {\n    if (options === void 0) {\n      options = 1;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n\n    if (this.mode !== NodeMaterialModes.PostProcess) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n\n    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\n  };\n  /**\r\n   * Create the post process effect from the material\r\n   * @param postProcess The post process to create the effect for\r\n   */\n\n\n  NodeMaterial.prototype.createEffectForPostProcess = function (postProcess) {\n    this._createEffectForPostProcess(postProcess);\n  };\n\n  NodeMaterial.prototype._createEffectForPostProcess = function (postProcess, camera, options, samplingMode, engine, reusable, textureType, textureFormat) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = 1;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n\n    var tempName = this.name + this._buildId;\n    var defines = new NodeMaterialDefines();\n    var dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\n    var buildId = this._buildId;\n\n    this._processDefines(dummyMesh, defines);\n\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n\n    if (!postProcess) {\n      postProcess = new PostProcess(this.name + \"PostProcess\", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, false, textureFormat);\n    } else {\n      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, undefined, undefined, tempName, tempName);\n    }\n\n    postProcess.nodeMaterialSource = this;\n    postProcess.onApplyObservable.add(function (effect) {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId;\n        defines.markAsUnprocessed();\n        buildId = _this._buildId;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString, _this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(function () {\n          return postProcess.updateEffect(defines.toString(), _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, {\n            maxSimultaneousLights: _this.maxSimultaneousLights\n          }, undefined, undefined, tempName, tempName);\n        });\n      }\n\n      _this._checkInternals(effect);\n    });\n    return postProcess;\n  };\n  /**\r\n   * Create a new procedural texture based on this node material\r\n   * @param size defines the size of the texture\r\n   * @param scene defines the hosting scene\r\n   * @returns the new procedural texture attached to this node material\r\n   */\n\n\n  NodeMaterial.prototype.createProceduralTexture = function (size, scene) {\n    var _this = this;\n\n    if (this.mode !== NodeMaterialModes.ProceduralTexture) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n\n    var tempName = this.name + this._buildId;\n    var proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\n    var dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\n    dummyMesh.reservedDataStore = {\n      hidden: true\n    };\n    var defines = new NodeMaterialDefines();\n\n    var result = this._processDefines(dummyMesh, defines);\n\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    var effect = this.getScene().getEngine().createEffect({\n      vertexElement: tempName,\n      fragmentElement: tempName\n    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n    proceduralTexture.nodeMaterialSource = this;\n    proceduralTexture._effect = effect;\n    var buildId = this._buildId;\n    proceduralTexture.onBeforeGenerationObservable.add(function () {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId;\n        defines.markAsUnprocessed();\n        buildId = _this._buildId;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString, _this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(function () {\n          effect = _this.getScene().getEngine().createEffect({\n            vertexElement: tempName,\n            fragmentElement: tempName\n          }, [VertexBuffer.PositionKind], _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n          proceduralTexture._effect = effect;\n        });\n      }\n\n      _this._checkInternals(effect);\n    });\n    return proceduralTexture;\n  };\n\n  NodeMaterial.prototype._createEffectForParticles = function (particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined_) {\n    var _this = this;\n\n    if (particleSystemDefinesJoined_ === void 0) {\n      particleSystemDefinesJoined_ = \"\";\n    }\n\n    var tempName = this.name + this._buildId + \"_\" + blendMode;\n\n    if (!defines) {\n      defines = new NodeMaterialDefines();\n    }\n\n    if (!dummyMesh) {\n      dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\n\n      if (!dummyMesh) {\n        dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\n        dummyMesh.reservedDataStore = {\n          hidden: true\n        };\n      }\n    }\n\n    var buildId = this._buildId;\n    var particleSystemDefines = [];\n    var particleSystemDefinesJoined = particleSystemDefinesJoined_;\n\n    if (!effect) {\n      var result = this._processDefines(dummyMesh, defines);\n\n      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      particleSystemDefinesJoined = particleSystemDefines.join(\"\\n\");\n      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + particleSystemDefinesJoined, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n      particleSystem.setCustomEffect(effect, blendMode);\n    }\n\n    effect.onBindObservable.add(function (effect) {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId + \"_\" + blendMode;\n        defines.markAsUnprocessed();\n        buildId = _this._buildId;\n      }\n\n      particleSystemDefines.length = 0;\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      var particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\n\n      if (particleSystemDefinesJoinedCurrent !== particleSystemDefinesJoined) {\n        defines.markAsUnprocessed();\n        particleSystemDefinesJoined = particleSystemDefinesJoinedCurrent;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString);\n        effect = _this.getScene().getEngine().createEffectForParticles(tempName, _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + particleSystemDefinesJoined, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n        particleSystem.setCustomEffect(effect, blendMode);\n\n        _this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\n\n\n        return;\n      }\n\n      _this._checkInternals(effect);\n    });\n  };\n\n  NodeMaterial.prototype._checkInternals = function (effect) {\n    // Animated blocks\n    if (this._sharedData.animatedInputs) {\n      var scene = this.getScene();\n      var frameId = scene.getFrameId();\n\n      if (this._animationFrame !== frameId) {\n        for (var _i = 0, _a = this._sharedData.animatedInputs; _i < _a.length; _i++) {\n          var input = _a[_i];\n          input.animate(scene);\n        }\n\n        this._animationFrame = frameId;\n      }\n    } // Bindable blocks\n\n\n    for (var _b = 0, _c = this._sharedData.bindableBlocks; _b < _c.length; _b++) {\n      var block = _c[_b];\n      block.bind(effect, this);\n    } // Connection points\n\n\n    for (var _d = 0, _e = this._sharedData.inputBlocks; _d < _e.length; _d++) {\n      var inputBlock = _e[_d];\n\n      inputBlock._transmit(effect, this.getScene());\n    }\n  };\n  /**\r\n   * Create the effect to be used as the custom effect for a particle system\r\n   * @param particleSystem Particle system to create the effect for\r\n   * @param onCompiled defines a function to call when the effect creation is successful\r\n   * @param onError defines a function to call when the effect creation has failed\r\n   */\n\n\n  NodeMaterial.prototype.createEffectForParticles = function (particleSystem, onCompiled, onError) {\n    if (this.mode !== NodeMaterialModes.Particle) {\n      console.log(\"Incompatible material mode\");\n      return;\n    }\n\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\n\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\n  };\n\n  NodeMaterial.prototype._processDefines = function (mesh, defines, useInstances, subMesh) {\n    var _this = this;\n\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    var result = null; // Shared defines\n\n    this._sharedData.blocksWithDefines.forEach(function (b) {\n      b.initializeDefines(mesh, _this, defines, useInstances);\n    });\n\n    this._sharedData.blocksWithDefines.forEach(function (b) {\n      b.prepareDefines(mesh, _this, defines, useInstances, subMesh);\n    }); // Need to recompile?\n\n\n    if (defines.isDirty) {\n      var lightDisposed = defines._areLightsDisposed;\n      defines.markAsProcessed(); // Repeatable content generators\n\n      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\n      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\n\n      this._sharedData.repeatableContentBlocks.forEach(function (b) {\n        b.replaceRepeatableContent(_this._vertexCompilationState, _this._fragmentCompilationState, mesh, defines);\n      }); // Uniforms\n\n\n      var uniformBuffers_1 = [];\n\n      this._sharedData.dynamicUniformBlocks.forEach(function (b) {\n        b.updateUniformsAndSamples(_this._vertexCompilationState, _this, defines, uniformBuffers_1);\n      });\n\n      var mergedUniforms_1 = this._vertexCompilationState.uniforms;\n\n      this._fragmentCompilationState.uniforms.forEach(function (u) {\n        var index = mergedUniforms_1.indexOf(u);\n\n        if (index === -1) {\n          mergedUniforms_1.push(u);\n        }\n      }); // Samplers\n\n\n      var mergedSamplers_1 = this._vertexCompilationState.samplers;\n\n      this._fragmentCompilationState.samplers.forEach(function (s) {\n        var index = mergedSamplers_1.indexOf(s);\n\n        if (index === -1) {\n          mergedSamplers_1.push(s);\n        }\n      });\n\n      var fallbacks = new EffectFallbacks();\n\n      this._sharedData.blocksWithFallbacks.forEach(function (b) {\n        b.provideFallbacks(mesh, fallbacks);\n      });\n\n      result = {\n        lightDisposed: lightDisposed,\n        uniformBuffers: uniformBuffers_1,\n        mergedUniforms: mergedUniforms_1,\n        mergedSamplers: mergedSamplers_1,\n        fallbacks: fallbacks\n      };\n    }\n\n    return result;\n  };\n  /**\r\n    * Get if the submesh is ready to be used and all its information available.\r\n    * Child classes can use it to update shaders\r\n    * @param mesh defines the mesh to check\r\n    * @param subMesh defines which submesh to check\r\n    * @param useInstances specifies that instances should be used\r\n    * @returns a boolean indicating that the submesh is ready or not\r\n    */\n\n\n  NodeMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    var _this = this;\n\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    if (!this._buildWasSuccessful) {\n      return false;\n    }\n\n    var scene = this.getScene();\n\n    if (this._sharedData.animatedInputs) {\n      var frameId = scene.getFrameId();\n\n      if (this._animationFrame !== frameId) {\n        for (var _i = 0, _a = this._sharedData.animatedInputs; _i < _a.length; _i++) {\n          var input = _a[_i];\n          input.animate(scene);\n        }\n\n        this._animationFrame = frameId;\n      }\n    }\n\n    if (subMesh.effect && this.isFrozen) {\n      if (subMesh.effect._wasPreviouslyReady) {\n        return true;\n      }\n    }\n\n    if (!subMesh._materialDefines) {\n      subMesh._materialDefines = new NodeMaterialDefines();\n    }\n\n    var defines = subMesh._materialDefines;\n\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n\n    var engine = scene.getEngine();\n\n    this._prepareDefinesForAttributes(mesh, defines); // Check if blocks are ready\n\n\n    if (this._sharedData.blockingBlocks.some(function (b) {\n      return !b.isReady(mesh, _this, defines, useInstances);\n    })) {\n      return false;\n    }\n\n    var result = this._processDefines(mesh, defines, useInstances, subMesh);\n\n    if (result) {\n      var previousEffect = subMesh.effect; // Compilation\n\n      var join = defines.toString();\n      var effect = engine.createEffect({\n        vertex: \"nodeMaterial\" + this._buildId,\n        fragment: \"nodeMaterial\" + this._buildId,\n        vertexSource: this._vertexCompilationState.compilationString,\n        fragmentSource: this._fragmentCompilationState.compilationString\n      }, {\n        attributes: this._vertexCompilationState.attributes,\n        uniformsNames: result.mergedUniforms,\n        uniformBuffersNames: result.uniformBuffers,\n        samplers: result.mergedSamplers,\n        defines: join,\n        fallbacks: result.fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousLights: this.maxSimultaneousLights,\n          maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n        }\n      }, engine);\n\n      if (effect) {\n        if (this._onEffectCreatedObservable) {\n          onCreatedEffectParameters.effect = effect;\n          onCreatedEffectParameters.subMesh = subMesh;\n\n          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n        } // Use previous effect while new one is compiling\n\n\n        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n          effect = previousEffect;\n          defines.markAsUnprocessed();\n\n          if (result.lightDisposed) {\n            // re register in case it takes more than one frame.\n            defines._areLightsDisposed = true;\n            return false;\n          }\n        } else {\n          scene.resetCachedMaterial();\n          subMesh.setEffect(effect, defines);\n        }\n      }\n    }\n\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    return true;\n  };\n\n  Object.defineProperty(NodeMaterial.prototype, \"compiledShaders\", {\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\n    get: function get() {\n      return \"// Vertex shader\\r\\n\" + this._vertexCompilationState.compilationString + \"\\r\\n\\r\\n// Fragment shader\\r\\n\" + this._fragmentCompilationState.compilationString;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Binds the world matrix to the material\r\n   * @param world defines the world transformation matrix\r\n   */\n\n  NodeMaterial.prototype.bindOnlyWorldMatrix = function (world) {\n    var scene = this.getScene();\n\n    if (!this._activeEffect) {\n      return;\n    }\n\n    var hints = this._sharedData.hints;\n\n    if (hints.needWorldViewMatrix) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n    }\n\n    if (hints.needWorldViewProjectionMatrix) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n    } // Connection points\n\n\n    for (var _i = 0, _a = this._sharedData.inputBlocks; _i < _a.length; _i++) {\n      var inputBlock = _a[_i];\n\n      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\n    }\n  };\n  /**\r\n   * Binds the submesh to this material by preparing the effect and shader to draw\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh containing the submesh\r\n   * @param subMesh defines the submesh to bind the material to\r\n   */\n\n\n  NodeMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n    var scene = this.getScene();\n    var effect = subMesh.effect;\n\n    if (!effect) {\n      return;\n    }\n\n    this._activeEffect = effect; // Matrices\n\n    this.bindOnlyWorldMatrix(world);\n\n    var mustRebind = this._mustRebind(scene, effect, mesh.visibility);\n\n    if (mustRebind) {\n      var sharedData = this._sharedData;\n\n      if (effect && scene.getCachedEffect() !== effect) {\n        // Bindable blocks\n        for (var _i = 0, _a = sharedData.bindableBlocks; _i < _a.length; _i++) {\n          var block = _a[_i];\n          block.bind(effect, this, mesh, subMesh);\n        } // Connection points\n\n\n        for (var _b = 0, _c = sharedData.inputBlocks; _b < _c.length; _b++) {\n          var inputBlock = _c[_b];\n\n          inputBlock._transmit(effect, scene);\n        }\n      }\n    }\n\n    this._afterBind(mesh, this._activeEffect);\n  };\n  /**\r\n   * Gets the active textures from the material\r\n   * @returns an array of textures\r\n   */\n\n\n  NodeMaterial.prototype.getActiveTextures = function () {\n    var activeTextures = _super.prototype.getActiveTextures.call(this);\n\n    if (this._sharedData) {\n      activeTextures.push.apply(activeTextures, this._sharedData.textureBlocks.filter(function (tb) {\n        return tb.texture;\n      }).map(function (tb) {\n        return tb.texture;\n      }));\n    }\n\n    return activeTextures;\n  };\n  /**\r\n   * Gets the list of texture blocks\r\n   * @returns an array of texture blocks\r\n   */\n\n\n  NodeMaterial.prototype.getTextureBlocks = function () {\n    if (!this._sharedData) {\n      return [];\n    }\n\n    return this._sharedData.textureBlocks;\n  };\n  /**\r\n   * Specifies if the material uses a texture\r\n   * @param texture defines the texture to check against the material\r\n   * @returns a boolean specifying if the material uses the texture\r\n   */\n\n\n  NodeMaterial.prototype.hasTexture = function (texture) {\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    if (!this._sharedData) {\n      return false;\n    }\n\n    for (var _i = 0, _a = this._sharedData.textureBlocks; _i < _a.length; _i++) {\n      var t = _a[_i];\n\n      if (t.texture === texture) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Disposes the material\r\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n   */\n\n\n  NodeMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      for (var _i = 0, _a = this._sharedData.textureBlocks.filter(function (tb) {\n        return tb.texture;\n      }).map(function (tb) {\n        return tb.texture;\n      }); _i < _a.length; _i++) {\n        var texture = _a[_i];\n        texture.dispose();\n      }\n    }\n\n    for (var _b = 0, _c = this.attachedBlocks; _b < _c.length; _b++) {\n      var block = _c[_b];\n      block.dispose();\n    }\n\n    this.onBuildObservable.clear();\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  };\n  /** Creates the node editor window. */\n\n\n  NodeMaterial.prototype._createNodeEditor = function () {\n    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\n    this.BJSNODEMATERIALEDITOR.NodeEditor.Show({\n      nodeMaterial: this\n    });\n  };\n  /**\r\n   * Launch the node material editor\r\n   * @param config Define the configuration of the editor\r\n   * @return a promise fulfilled when the node editor is visible\r\n   */\n\n\n  NodeMaterial.prototype.edit = function (config) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (typeof _this.BJSNODEMATERIALEDITOR == 'undefined') {\n        var editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL; // Load editor and add it to the DOM\n\n        Tools.LoadScript(editorUrl, function () {\n          _this._createNodeEditor();\n\n          resolve();\n        });\n      } else {\n        // Otherwise creates the editor\n        _this._createNodeEditor();\n\n        resolve();\n      }\n    });\n  };\n  /**\r\n   * Clear the current material\r\n   */\n\n\n  NodeMaterial.prototype.clear = function () {\n    this._vertexOutputNodes = [];\n    this._fragmentOutputNodes = [];\n    this.attachedBlocks = [];\n  };\n  /**\r\n   * Clear the current material and set it to a default state\r\n   */\n\n\n  NodeMaterial.prototype.setToDefault = function () {\n    this.clear();\n    this.editorData = null;\n    var positionInput = new InputBlock(\"Position\");\n    positionInput.setAsAttribute(\"position\");\n    var worldInput = new InputBlock(\"World\");\n    worldInput.setAsSystemValue(BABYLON.NodeMaterialSystemValues.World);\n    var worldPos = new TransformBlock(\"WorldPos\");\n    positionInput.connectTo(worldPos);\n    worldInput.connectTo(worldPos);\n    var viewProjectionInput = new InputBlock(\"ViewProjection\");\n    viewProjectionInput.setAsSystemValue(BABYLON.NodeMaterialSystemValues.ViewProjection);\n    var worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\n    worldPos.connectTo(worldPosdMultipliedByViewProjection);\n    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    worldPosdMultipliedByViewProjection.connectTo(vertexOutput); // Pixel\n\n    var pixelColor = new InputBlock(\"color\");\n    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    pixelColor.connectTo(fragmentOutput); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Material;\n  };\n  /**\r\n   * Clear the current material and set it to a default state for post process\r\n   */\n\n\n  NodeMaterial.prototype.setToDefaultPostProcess = function () {\n    this.clear();\n    this.editorData = null;\n    var position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    var const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    var vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput); // Pixel\n\n    var scale = new InputBlock(\"Scale\");\n    scale.visibleInInspector = true;\n    scale.value = new Vector2(1, 1);\n    var uv0 = new RemapBlock(\"uv0\");\n    position.connectTo(uv0);\n    var uv = new MultiplyBlock(\"UV scale\");\n    uv0.connectTo(uv);\n    scale.connectTo(uv);\n    var currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\n    uv.connectTo(currentScreen);\n    currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    currentScreen.connectTo(fragmentOutput, {\n      output: \"rgba\"\n    }); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.PostProcess;\n  };\n  /**\r\n   * Clear the current material and set it to a default state for procedural texture\r\n   */\n\n\n  NodeMaterial.prototype.setToDefaultProceduralTexture = function () {\n    this.clear();\n    this.editorData = null;\n    var position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    var const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    var vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput); // Pixel\n\n    var time = new InputBlock(\"Time\");\n    time.value = 0;\n    time.min = 0;\n    time.max = 0;\n    time.isBoolean = false;\n    time.matrixMode = 0;\n    time.animationType = AnimatedInputBlockTypes.Time;\n    time.isConstant = false;\n    var color = new InputBlock(\"Color3\");\n    color.value = new Color3(1, 1, 1);\n    color.isConstant = false;\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    var vectorMerger = new VectorMergerBlock(\"VectorMerger\");\n    vectorMerger.visibleInInspector = false;\n    var cos = new TrigonometryBlock(\"Cos\");\n    cos.operation = TrigonometryBlockOperations.Cos;\n    position.connectTo(vectorMerger);\n    time.output.connectTo(cos.input);\n    cos.output.connectTo(vectorMerger.z);\n    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.ProceduralTexture;\n  };\n  /**\r\n   * Clear the current material and set it to a default state for particle\r\n   */\n\n\n  NodeMaterial.prototype.setToDefaultParticle = function () {\n    this.clear();\n    this.editorData = null; // Pixel\n\n    var uv = new InputBlock(\"uv\");\n    uv.setAsAttribute(\"particle_uv\");\n    var texture = new ParticleTextureBlock(\"ParticleTexture\");\n    uv.connectTo(texture);\n    var color = new InputBlock(\"Color\");\n    color.setAsAttribute(\"particle_color\");\n    var multiply = new MultiplyBlock(\"Texture * Color\");\n    texture.connectTo(multiply);\n    color.connectTo(multiply);\n    var rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\n    multiply.connectTo(rampGradient);\n    var cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\n    color.connectTo(cSplitter);\n    var blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\n    rampGradient.connectTo(blendMultiply);\n    texture.connectTo(blendMultiply, {\n      \"output\": \"a\"\n    });\n    cSplitter.connectTo(blendMultiply, {\n      \"output\": \"a\"\n    });\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    blendMultiply.connectTo(fragmentOutput); // Add to nodes\n\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Particle;\n  };\n  /**\r\n   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n   * @param url defines the url to load from\r\n   * @returns a promise that will fullfil when the material is fully loaded\r\n   */\n\n\n  NodeMaterial.prototype.loadAsync = function (url) {\n    var _this = this;\n\n    return this.getScene()._loadFileAsync(url).then(function (data) {\n      var serializationObject = JSON.parse(data);\n\n      _this.loadFromSerialization(serializationObject, \"\");\n    });\n  };\n\n  NodeMaterial.prototype._gatherBlocks = function (rootNode, list) {\n    if (list.indexOf(rootNode) !== -1) {\n      return;\n    }\n\n    list.push(rootNode);\n\n    for (var _i = 0, _a = rootNode.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      var connectedPoint = input.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== rootNode) {\n          this._gatherBlocks(block, list);\n        }\n      }\n    }\n  };\n  /**\r\n   * Generate a string containing the code declaration required to create an equivalent of this material\r\n   * @returns a string\r\n   */\n\n\n  NodeMaterial.prototype.generateCode = function () {\n    var alreadyDumped = [];\n    var vertexBlocks = [];\n    var uniqueNames = []; // Gets active blocks\n\n    for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n      var outputNode = _a[_i];\n\n      this._gatherBlocks(outputNode, vertexBlocks);\n    }\n\n    var fragmentBlocks = [];\n\n    for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n      var outputNode = _c[_b];\n\n      this._gatherBlocks(outputNode, fragmentBlocks);\n    } // Generate vertex shader\n\n\n    var codeString = \"var nodeMaterial = new BABYLON.NodeMaterial(\\\"\" + (this.name || \"node material\") + \"\\\");\\r\\n\";\n\n    for (var _d = 0, vertexBlocks_1 = vertexBlocks; _d < vertexBlocks_1.length; _d++) {\n      var node = vertexBlocks_1[_d];\n\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Generate fragment shader\n\n\n    for (var _e = 0, fragmentBlocks_1 = fragmentBlocks; _e < fragmentBlocks_1.length; _e++) {\n      var node = fragmentBlocks_1[_e];\n\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Connections\n\n\n    alreadyDumped = [];\n    codeString += \"\\r\\n// Connections\\r\\n\";\n\n    for (var _f = 0, _g = this._vertexOutputNodes; _f < _g.length; _f++) {\n      var node = _g[_f];\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n\n    for (var _h = 0, _j = this._fragmentOutputNodes; _h < _j.length; _h++) {\n      var node = _j[_h];\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    } // Output nodes\n\n\n    codeString += \"\\r\\n// Output nodes\\r\\n\";\n\n    for (var _k = 0, _l = this._vertexOutputNodes; _k < _l.length; _k++) {\n      var node = _l[_k];\n      codeString += \"nodeMaterial.addOutputNode(\" + node._codeVariableName + \");\\r\\n\";\n    }\n\n    for (var _m = 0, _o = this._fragmentOutputNodes; _m < _o.length; _m++) {\n      var node = _o[_m];\n      codeString += \"nodeMaterial.addOutputNode(\" + node._codeVariableName + \");\\r\\n\";\n    }\n\n    codeString += \"nodeMaterial.build();\\r\\n\";\n    return codeString;\n  };\n  /**\r\n   * Serializes this material in a JSON representation\r\n   * @returns the serialized material object\r\n   */\n\n\n  NodeMaterial.prototype.serialize = function (selectedBlocks) {\n    var serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\n    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\n\n    var blocks = [];\n\n    if (selectedBlocks) {\n      blocks = selectedBlocks;\n    } else {\n      serializationObject.customType = \"BABYLON.NodeMaterial\";\n      serializationObject.outputNodes = []; // Outputs\n\n      for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n        var outputNode = _a[_i];\n\n        this._gatherBlocks(outputNode, blocks);\n\n        serializationObject.outputNodes.push(outputNode.uniqueId);\n      }\n\n      for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n        var outputNode = _c[_b];\n\n        this._gatherBlocks(outputNode, blocks);\n\n        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\n          serializationObject.outputNodes.push(outputNode.uniqueId);\n        }\n      }\n    } // Blocks\n\n\n    serializationObject.blocks = [];\n\n    for (var _d = 0, blocks_1 = blocks; _d < blocks_1.length; _d++) {\n      var block = blocks_1[_d];\n      serializationObject.blocks.push(block.serialize());\n    }\n\n    if (!selectedBlocks) {\n      for (var _e = 0, _f = this.attachedBlocks; _e < _f.length; _e++) {\n        var block = _f[_e];\n\n        if (blocks.indexOf(block) !== -1) {\n          continue;\n        }\n\n        serializationObject.blocks.push(block.serialize());\n      }\n    }\n\n    return serializationObject;\n  };\n\n  NodeMaterial.prototype._restoreConnections = function (block, source, map) {\n    for (var _i = 0, _a = block.outputs; _i < _a.length; _i++) {\n      var outputPoint = _a[_i];\n\n      for (var _b = 0, _c = source.blocks; _b < _c.length; _b++) {\n        var candidate = _c[_b];\n        var target = map[candidate.id];\n\n        if (!target) {\n          continue;\n        }\n\n        for (var _d = 0, _e = candidate.inputs; _d < _e.length; _d++) {\n          var input = _e[_d];\n\n          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\n            var inputPoint = target.getInputByName(input.inputName);\n\n            if (!inputPoint || inputPoint.isConnected) {\n              continue;\n            }\n\n            outputPoint.connectTo(inputPoint, true);\n\n            this._restoreConnections(target, source, map);\n\n            continue;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Clear the current graph and load a new one from a serialization object\r\n   * @param source defines the JSON representation of the material\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @param merge defines whether or not the source must be merged or replace the current content\r\n   */\n\n\n  NodeMaterial.prototype.loadFromSerialization = function (source, rootUrl, merge) {\n    var _a;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (merge === void 0) {\n      merge = false;\n    }\n\n    if (!merge) {\n      this.clear();\n    }\n\n    var map = {}; // Create blocks\n\n    for (var _i = 0, _b = source.blocks; _i < _b.length; _i++) {\n      var parsedBlock = _b[_i];\n\n      var blockType = _TypeStore.GetClass(parsedBlock.customType);\n\n      if (blockType) {\n        var block = new blockType();\n\n        block._deserialize(parsedBlock, this.getScene(), rootUrl);\n\n        map[parsedBlock.id] = block;\n        this.attachedBlocks.push(block);\n      }\n    } // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\n\n\n    for (var blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\n      var parsedBlock_1 = source.blocks[blockIndex];\n      var block = map[parsedBlock_1.id];\n\n      if (!block) {\n        continue;\n      }\n\n      if (block.inputs.length && !merge) {\n        continue;\n      }\n\n      this._restoreConnections(block, source, map);\n    } // Outputs\n\n\n    if (source.outputNodes) {\n      for (var _c = 0, _d = source.outputNodes; _c < _d.length; _c++) {\n        var outputNodeId = _d[_c];\n        this.addOutputNode(map[outputNodeId]);\n      }\n    } // UI related info\n\n\n    if (source.locations || source.editorData && source.editorData.locations) {\n      var locations = source.locations || source.editorData.locations;\n\n      for (var _e = 0, locations_1 = locations; _e < locations_1.length; _e++) {\n        var location = locations_1[_e];\n\n        if (map[location.blockId]) {\n          location.blockId = map[location.blockId].uniqueId;\n        }\n      }\n\n      if (merge && this.editorData && this.editorData.locations) {\n        locations.concat(this.editorData.locations);\n      }\n\n      if (source.locations) {\n        this.editorData = {\n          locations: locations\n        };\n      } else {\n        this.editorData = source.editorData;\n        this.editorData.locations = locations;\n      }\n\n      var blockMap = [];\n\n      for (var key in map) {\n        blockMap[key] = map[key].uniqueId;\n      }\n\n      this.editorData.map = blockMap;\n    }\n\n    this.comment = source.comment;\n\n    if (!merge) {\n      this._mode = (_a = source.mode) !== null && _a !== void 0 ? _a : NodeMaterialModes.Material;\n    }\n  };\n  /**\r\n   * Makes a duplicate of the current material.\r\n   * @param name - name to use for the new material.\r\n   */\n\n\n  NodeMaterial.prototype.clone = function (name) {\n    var _this = this;\n\n    var serializationObject = this.serialize();\n    var clone = SerializationHelper.Clone(function () {\n      return new NodeMaterial(name, _this.getScene(), _this.options);\n    }, this);\n    clone.id = name;\n    clone.name = name;\n    clone.loadFromSerialization(serializationObject);\n    clone.build();\n    return clone;\n  };\n  /**\r\n   * Creates a node material from parsed material data\r\n   * @param source defines the JSON representation of the material\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a new node material\r\n   */\n\n\n  NodeMaterial.Parse = function (source, scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    var nodeMaterial = SerializationHelper.Parse(function () {\n      return new NodeMaterial(source.name, scene);\n    }, source, scene, rootUrl);\n    nodeMaterial.loadFromSerialization(source, rootUrl);\n    nodeMaterial.build();\n    return nodeMaterial;\n  };\n  /**\r\n   * Creates a node material from a snippet saved in a remote file\r\n   * @param name defines the name of the material to create\r\n   * @param url defines the url to load from\r\n   * @param scene defines the hosting scene\r\n   * @returns a promise that will resolve to the new node material\r\n   */\n\n\n  NodeMaterial.ParseFromFileAsync = function (name, url, scene) {\n    var material = new NodeMaterial(name, scene);\n    return new Promise(function (resolve, reject) {\n      return material.loadAsync(url).then(function () {\n        material.build();\n        resolve(material);\n      }).catch(reject);\n    });\n  };\n  /**\r\n   * Creates a node material from a snippet saved by the node material editor\r\n   * @param snippetId defines the snippet to load\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n   * @returns a promise that will resolve to the new node material\r\n   */\n\n\n  NodeMaterial.ParseFromSnippetAsync = function (snippetId, scene, rootUrl, nodeMaterial) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(this.CreateDefault(\"blank\", scene));\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.nodeMaterial);\n\n            if (!nodeMaterial) {\n              nodeMaterial = SerializationHelper.Parse(function () {\n                return new NodeMaterial(snippetId, scene);\n              }, serializationObject, scene, rootUrl);\n              nodeMaterial.uniqueId = scene.getUniqueId();\n            }\n\n            nodeMaterial.loadFromSerialization(serializationObject);\n            nodeMaterial.snippetId = snippetId;\n\n            try {\n              nodeMaterial.build();\n              resolve(nodeMaterial);\n            } catch (err) {\n              reject(err);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /**\r\n   * Creates a new node material set to default basic configuration\r\n   * @param name defines the name of the material\r\n   * @param scene defines the hosting scene\r\n   * @returns a new NodeMaterial\r\n   */\n\n\n  NodeMaterial.CreateDefault = function (name, scene) {\n    var newMaterial = new NodeMaterial(name, scene);\n    newMaterial.setToDefault();\n    newMaterial.build();\n    return newMaterial;\n  };\n\n  NodeMaterial._BuildIdGenerator = 0;\n  /** Define the Url to load node editor script */\n\n  NodeMaterial.EditorURL = \"https://unpkg.com/babylonjs-node-editor@\" + Engine.Version + \"/babylon.nodeEditor.js\";\n  /** Define the Url to load snippets */\n\n  NodeMaterial.SnippetUrl = \"https://snippet.babylonjs.com\";\n  /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\n\n  NodeMaterial.IgnoreTexturesAtLoadTime = false;\n\n  __decorate([serialize(\"mode\")], NodeMaterial.prototype, \"_mode\", void 0);\n\n  __decorate([serialize(\"comment\")], NodeMaterial.prototype, \"comment\", void 0);\n\n  return NodeMaterial;\n}(PushMaterial);\n\nexport { NodeMaterial };\n_TypeStore.RegisteredTypes[\"BABYLON.NodeMaterial\"] = NodeMaterial;","map":null,"metadata":{},"sourceType":"module"}