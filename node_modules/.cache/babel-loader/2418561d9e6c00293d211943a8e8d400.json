{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { Tools } from \"../../Misc/tools\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\n\nvar BaseCameraPointersInput =\n/** @class */\nfunction () {\n  function BaseCameraPointersInput() {\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\n    this.buttons = [0, 1, 2];\n  }\n  /**\r\n   * Attach the input controls to a specific dom element to get the input from.\r\n   * @param element Defines the element the controls should be listened from\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n\n  BaseCameraPointersInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this;\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    var engine = this.camera.getEngine();\n    var element = engine.getInputElement();\n    var previousPinchSquaredDistance = 0;\n    var previousMultiTouchPanPosition = null;\n    this.pointA = null;\n    this.pointB = null;\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n\n    this._pointerInput = function (p, s) {\n      var evt = p.event;\n      var isTouch = evt.pointerType === \"touch\";\n\n      if (engine.isInVRExclusivePointerMode) {\n        return;\n      }\n\n      if (p.type !== PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {\n        return;\n      }\n\n      var srcElement = evt.srcElement || evt.target;\n      _this._altKey = evt.altKey;\n      _this._ctrlKey = evt.ctrlKey;\n      _this._metaKey = evt.metaKey;\n      _this._shiftKey = evt.shiftKey;\n      _this._buttonsPressed = evt.buttons;\n\n      if (engine.isPointerLock) {\n        var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\n        var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\n\n        _this.onTouch(null, offsetX, offsetY);\n\n        _this.pointA = null;\n        _this.pointB = null;\n      } else if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\n        try {\n          srcElement.setPointerCapture(evt.pointerId);\n        } catch (e) {//Nothing to do with the error. Execution will continue.\n        }\n\n        if (_this.pointA === null) {\n          _this.pointA = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        } else if (_this.pointB === null) {\n          _this.pointB = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        }\n\n        _this.onButtonDown(evt);\n\n        if (!noPreventDefault) {\n          evt.preventDefault();\n          element && element.focus();\n        }\n      } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\n        _this.onDoubleTap(evt.pointerType);\n      } else if (p.type === PointerEventTypes.POINTERUP && srcElement) {\n        try {\n          srcElement.releasePointerCapture(evt.pointerId);\n        } catch (e) {//Nothing to do with the error.\n        }\n\n        if (!isTouch) {\n          _this.pointB = null; // Mouse and pen are mono pointer\n        } //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\n        //but emptying completely pointers collection is required to fix a bug on iPhone :\n        //when changing orientation while pinching camera,\n        //one pointer stay pressed forever if we don't release all pointers\n        //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n\n\n        if (engine._badOS) {\n          _this.pointA = _this.pointB = null;\n        } else {\n          //only remove the impacted pointer in case of multitouch allowing on most\n          //platforms switching from rotate to zoom and pan seamlessly.\n          if (_this.pointB && _this.pointA && _this.pointA.pointerId == evt.pointerId) {\n            _this.pointA = _this.pointB;\n            _this.pointB = null;\n          } else if (_this.pointA && _this.pointB && _this.pointB.pointerId == evt.pointerId) {\n            _this.pointB = null;\n          } else {\n            _this.pointA = _this.pointB = null;\n          }\n        }\n\n        if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\n          // Previous pinch data is populated but a button has been lifted\n          // so pinch has ended.\n          _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, 0, // pinchSquaredDistance\n          previousMultiTouchPanPosition, null // multiTouchPanPosition\n          );\n\n          previousPinchSquaredDistance = 0;\n          previousMultiTouchPanPosition = null;\n        }\n\n        _this.onButtonUp(evt);\n\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        }\n      } else if (p.type === PointerEventTypes.POINTERMOVE) {\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        } // One button down\n\n\n        if (_this.pointA && _this.pointB === null) {\n          var offsetX = evt.clientX - _this.pointA.x;\n          var offsetY = evt.clientY - _this.pointA.y;\n\n          _this.onTouch(_this.pointA, offsetX, offsetY);\n\n          _this.pointA.x = evt.clientX;\n          _this.pointA.y = evt.clientY;\n        } // Two buttons down: pinch\n        else if (_this.pointA && _this.pointB) {\n          var ed = _this.pointA.pointerId === evt.pointerId ? _this.pointA : _this.pointB;\n          ed.x = evt.clientX;\n          ed.y = evt.clientY;\n          var distX = _this.pointA.x - _this.pointB.x;\n          var distY = _this.pointA.y - _this.pointB.y;\n          var pinchSquaredDistance = distX * distX + distY * distY;\n          var multiTouchPanPosition = {\n            x: (_this.pointA.x + _this.pointB.x) / 2,\n            y: (_this.pointA.y + _this.pointB.y) / 2,\n            pointerId: evt.pointerId,\n            type: p.type\n          };\n\n          _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\n\n          previousMultiTouchPanPosition = multiTouchPanPosition;\n          previousPinchSquaredDistance = pinchSquaredDistance;\n        }\n      }\n    };\n\n    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n\n    this._onLostFocus = function () {\n      _this.pointA = _this.pointB = null;\n      previousPinchSquaredDistance = 0;\n      previousMultiTouchPanPosition = null;\n\n      _this.onLostFocus();\n    };\n\n    element && element.addEventListener(\"contextmenu\", this.onContextMenu.bind(this), false);\n    var hostWindow = this.camera.getScene().getEngine().getHostWindow();\n\n    if (hostWindow) {\n      Tools.RegisterTopRootEvents(hostWindow, [{\n        name: \"blur\",\n        handler: this._onLostFocus\n      }]);\n    }\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  BaseCameraPointersInput.prototype.detachControl = function (ignored) {\n    if (this._onLostFocus) {\n      var hostWindow = this.camera.getScene().getEngine().getHostWindow();\n\n      if (hostWindow) {\n        Tools.UnregisterTopRootEvents(hostWindow, [{\n          name: \"blur\",\n          handler: this._onLostFocus\n        }]);\n      }\n    }\n\n    if (this._observer) {\n      this.camera.getScene().onPointerObservable.remove(this._observer);\n      this._observer = null;\n\n      if (this.onContextMenu) {\n        var inputElement = this.camera.getScene().getEngine().getInputElement();\n        inputElement && inputElement.removeEventListener(\"contextmenu\", this.onContextMenu);\n      }\n\n      this._onLostFocus = null;\n    }\n\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n  };\n  /**\r\n   * Gets the class name of the current input.\r\n   * @returns the class name\r\n   */\n\n\n  BaseCameraPointersInput.prototype.getClassName = function () {\n    return \"BaseCameraPointersInput\";\n  };\n  /**\r\n   * Get the friendly name associated with the input class.\r\n   * @returns the input friendly name\r\n   */\n\n\n  BaseCameraPointersInput.prototype.getSimpleName = function () {\n    return \"pointers\";\n  };\n  /**\r\n   * Called on pointer POINTERDOUBLETAP event.\r\n   * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onDoubleTap = function (type) {};\n  /**\r\n   * Called on pointer POINTERMOVE event if only a single touch is active.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {};\n  /**\r\n   * Called on pointer POINTERMOVE event if multiple touches are active.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {};\n  /**\r\n   * Called on JS contextmenu event.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onContextMenu = function (evt) {\n    evt.preventDefault();\n  };\n  /**\r\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n   * press.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onButtonDown = function (evt) {};\n  /**\r\n   * Called each time a new POINTERUP event occurs. Ie, for each button\r\n   * release.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onButtonUp = function (evt) {};\n  /**\r\n   * Called when window becomes inactive.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onLostFocus = function () {};\n\n  __decorate([serialize()], BaseCameraPointersInput.prototype, \"buttons\", void 0);\n\n  return BaseCameraPointersInput;\n}();\n\nexport { BaseCameraPointersInput };","map":null,"metadata":{},"sourceType":"module"}