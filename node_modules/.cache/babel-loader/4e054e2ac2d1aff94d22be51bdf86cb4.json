{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\nimport { Camera } from \"./camera\";\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\nimport { Epsilon } from '../Maths/math.constants';\nimport { Axis } from '../Maths/math.axis';\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\n\nvar TargetCamera =\n/** @class */\nfunction (_super) {\n  __extends(TargetCamera, _super);\n  /**\r\n   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n   * This is the base of the follow, arc rotate cameras and Free camera\r\n   * @see https://doc.babylonjs.com/features/cameras\r\n   * @param name Defines the name of the camera in the scene\r\n   * @param position Defines the start position of the camera in the scene\r\n   * @param scene Defines the scene the camera belongs to\r\n   * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined\r\n   */\n\n\n  function TargetCamera(name, position, scene, setActiveOnSceneIfNoneActive) {\n    if (setActiveOnSceneIfNoneActive === void 0) {\n      setActiveOnSceneIfNoneActive = true;\n    }\n\n    var _this = _super.call(this, name, position, scene, setActiveOnSceneIfNoneActive) || this;\n\n    _this._tmpUpVector = Vector3.Zero();\n    _this._tmpTargetVector = Vector3.Zero();\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\n\n    _this.cameraDirection = new Vector3(0, 0, 0);\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\n\n    _this.cameraRotation = new Vector2(0, 0);\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\n\n    _this.ignoreParentScaling = false;\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\n\n    _this.updateUpVectorFromRotation = false;\n    _this._tmpQuaternion = new Quaternion();\n    /**\r\n     * Define the current rotation of the camera\r\n     */\n\n    _this.rotation = new Vector3(0, 0, 0);\n    /**\r\n     * Define the current speed of the camera\r\n     */\n\n    _this.speed = 2.0;\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\n\n    _this.noRotationConstraint = false;\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\n\n    _this.invertRotation = false;\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\n\n    _this.inverseRotationSpeed = 0.2;\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     */\n\n    _this.lockedTarget = null;\n    /** @hidden */\n\n    _this._currentTarget = Vector3.Zero();\n    /** @hidden */\n\n    _this._initialFocalDistance = 1;\n    /** @hidden */\n\n    _this._viewMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._camMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._cameraTransformMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._cameraRotationMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._referencePoint = new Vector3(0, 0, 1);\n    /** @hidden */\n\n    _this._transformedReferencePoint = Vector3.Zero();\n    _this._defaultUp = Vector3.Up();\n    _this._cachedRotationZ = 0;\n    _this._cachedQuaternionRotationZ = 0;\n    return _this;\n  }\n  /**\r\n   * Gets the position in front of the camera at a given distance.\r\n   * @param distance The distance from the camera we want the position to be\r\n   * @returns the position\r\n   */\n\n\n  TargetCamera.prototype.getFrontPosition = function (distance) {\n    this.getWorldMatrix();\n    var direction = this.getTarget().subtract(this.position);\n    direction.normalize();\n    direction.scaleInPlace(distance);\n    return this.globalPosition.add(direction);\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._getLockedTargetPosition = function () {\n    if (!this.lockedTarget) {\n      return null;\n    }\n\n    if (this.lockedTarget.absolutePosition) {\n      this.lockedTarget.computeWorldMatrix();\n    }\n\n    return this.lockedTarget.absolutePosition || this.lockedTarget;\n  };\n  /**\r\n   * Store current camera state of the camera (fov, position, rotation, etc..)\r\n   * @returns the camera\r\n   */\n\n\n  TargetCamera.prototype.storeState = function () {\n    this._storedPosition = this.position.clone();\n    this._storedRotation = this.rotation.clone();\n\n    if (this.rotationQuaternion) {\n      this._storedRotationQuaternion = this.rotationQuaternion.clone();\n    }\n\n    return _super.prototype.storeState.call(this);\n  };\n  /**\r\n   * Restored camera state. You must call storeState() first\r\n   * @returns whether it was successful or not\r\n   * @hidden\r\n   */\n\n\n  TargetCamera.prototype._restoreStateValues = function () {\n    if (!_super.prototype._restoreStateValues.call(this)) {\n      return false;\n    }\n\n    this.position = this._storedPosition.clone();\n    this.rotation = this._storedRotation.clone();\n\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion = this._storedRotationQuaternion.clone();\n    }\n\n    this.cameraDirection.copyFromFloats(0, 0, 0);\n    this.cameraRotation.copyFromFloats(0, 0);\n    return true;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._initCache = function () {\n    _super.prototype._initCache.call(this);\n\n    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._updateCache = function (ignoreParentClass) {\n    if (!ignoreParentClass) {\n      _super.prototype._updateCache.call(this);\n    }\n\n    var lockedTargetPosition = this._getLockedTargetPosition();\n\n    if (!lockedTargetPosition) {\n      this._cache.lockedTarget = null;\n    } else {\n      if (!this._cache.lockedTarget) {\n        this._cache.lockedTarget = lockedTargetPosition.clone();\n      } else {\n        this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n      }\n    }\n\n    this._cache.rotation.copyFrom(this.rotation);\n\n    if (this.rotationQuaternion) {\n      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n    }\n  }; // Synchronized\n\n  /** @hidden */\n\n\n  TargetCamera.prototype._isSynchronizedViewMatrix = function () {\n    if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {\n      return false;\n    }\n\n    var lockedTargetPosition = this._getLockedTargetPosition();\n\n    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\n  }; // Methods\n\n  /** @hidden */\n\n\n  TargetCamera.prototype._computeLocalCameraSpeed = function () {\n    var engine = this.getEngine();\n    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n  }; // Target\n\n  /**\r\n   * Defines the target the camera should look at.\r\n   * @param target Defines the new target as a Vector or a mesh\r\n   */\n\n\n  TargetCamera.prototype.setTarget = function (target) {\n    this.upVector.normalize();\n    this._initialFocalDistance = target.subtract(this.position).length();\n\n    if (this.position.z === target.z) {\n      this.position.z += Epsilon;\n    }\n\n    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\n\n    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\n\n    this._camMatrix.invert();\n\n    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n    var vDir = target.subtract(this.position);\n\n    if (vDir.x >= 0.0) {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\n    } else {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\n    }\n\n    this.rotation.z = 0;\n\n    if (isNaN(this.rotation.x)) {\n      this.rotation.x = 0;\n    }\n\n    if (isNaN(this.rotation.y)) {\n      this.rotation.y = 0;\n    }\n\n    if (isNaN(this.rotation.z)) {\n      this.rotation.z = 0;\n    }\n\n    if (this.rotationQuaternion) {\n      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n    }\n  };\n\n  Object.defineProperty(TargetCamera.prototype, \"target\", {\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\n    get: function get() {\n      return this.getTarget();\n    },\n    set: function set(value) {\n      this.setTarget(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Return the current target position of the camera. This value is expressed in local space.\r\n   * @returns the target position\r\n   */\n\n  TargetCamera.prototype.getTarget = function () {\n    return this._currentTarget;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._decideIfNeedsToMove = function () {\n    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._updatePosition = function () {\n    if (this.parent) {\n      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n      this.position.addInPlace(TmpVectors.Vector3[0]);\n      return;\n    }\n\n    this.position.addInPlace(this.cameraDirection);\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._checkInputs = function () {\n    var directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\n\n    var needToMove = this._decideIfNeedsToMove();\n\n    var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0; // Move\n\n    if (needToMove) {\n      this._updatePosition();\n    } // Rotate\n\n\n    if (needToRotate) {\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\n      }\n\n      this.rotation.x += this.cameraRotation.x * directionMultiplier;\n      this.rotation.y += this.cameraRotation.y * directionMultiplier; // Apply constraints\n\n      if (!this.noRotationConstraint) {\n        var limit = 1.570796;\n\n        if (this.rotation.x > limit) {\n          this.rotation.x = limit;\n        }\n\n        if (this.rotation.x < -limit) {\n          this.rotation.x = -limit;\n        }\n      } //rotate, if quaternion is set and rotation was used\n\n\n      if (this.rotationQuaternion) {\n        var len = this.rotation.lengthSquared();\n\n        if (len) {\n          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n        }\n      }\n    } // Inertia\n\n\n    if (needToMove) {\n      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\n        this.cameraDirection.x = 0;\n      }\n\n      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\n        this.cameraDirection.y = 0;\n      }\n\n      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\n        this.cameraDirection.z = 0;\n      }\n\n      this.cameraDirection.scaleInPlace(this.inertia);\n    }\n\n    if (needToRotate) {\n      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\n        this.cameraRotation.x = 0;\n      }\n\n      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\n        this.cameraRotation.y = 0;\n      }\n\n      this.cameraRotation.scaleInPlace(this.inertia);\n    }\n\n    _super.prototype._checkInputs.call(this);\n  };\n\n  TargetCamera.prototype._updateCameraRotationMatrix = function () {\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n    } else {\n      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n    }\n  };\n  /**\r\n   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n   * @returns the current camera\r\n   */\n\n\n  TargetCamera.prototype._rotateUpVectorWithCameraRotationMatrix = function () {\n    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\n    return this;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._getViewMatrix = function () {\n    if (this.lockedTarget) {\n      this.setTarget(this._getLockedTargetPosition());\n    } // Compute\n\n\n    this._updateCameraRotationMatrix(); // Apply the changed rotation to the upVector\n\n\n    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n\n      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\n    } else if (this._cachedRotationZ != this.rotation.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n\n      this._cachedRotationZ = this.rotation.z;\n    }\n\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint); // Computing target and final matrix\n\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n\n    if (this.updateUpVectorFromRotation) {\n      if (this.rotationQuaternion) {\n        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\n      } else {\n        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\n        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\n      }\n    }\n\n    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\n\n    return this._viewMatrix;\n  };\n\n  TargetCamera.prototype._computeViewMatrix = function (position, target, up) {\n    if (this.ignoreParentScaling) {\n      if (this.parent) {\n        var parentWorldMatrix = this.parent.getWorldMatrix();\n        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\n        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\n        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\n\n        this._markSyncedWithParent();\n      } else {\n        this._globalPosition.copyFrom(position);\n\n        this._tmpTargetVector.copyFrom(target);\n\n        this._tmpUpVector.copyFrom(up);\n      }\n\n      if (this.getScene().useRightHandedSystem) {\n        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      } else {\n        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      }\n\n      return;\n    }\n\n    if (this.getScene().useRightHandedSystem) {\n      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\n    } else {\n      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\n    }\n\n    if (this.parent) {\n      var parentWorldMatrix = this.parent.getWorldMatrix();\n\n      this._viewMatrix.invert();\n\n      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\n\n      this._viewMatrix.getTranslationToRef(this._globalPosition);\n\n      this._viewMatrix.invert();\n\n      this._markSyncedWithParent();\n    } else {\n      this._globalPosition.copyFrom(position);\n    }\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  TargetCamera.prototype.createRigCamera = function (name, cameraIndex) {\n    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      var rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n      rigCamera.isRigCamera = true;\n      rigCamera.rigParent = this;\n\n      if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\n        if (!this.rotationQuaternion) {\n          this.rotationQuaternion = new Quaternion();\n        }\n\n        rigCamera._cameraRigParams = {};\n        rigCamera.rotationQuaternion = new Quaternion();\n      }\n\n      return rigCamera;\n    }\n\n    return null;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  TargetCamera.prototype._updateRigCameras = function () {\n    var camLeft = this._rigCameras[0];\n    var camRight = this._rigCameras[1];\n    this.computeWorldMatrix();\n\n    switch (this.cameraRigMode) {\n      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n        //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n        var leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\n        var rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n\n        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\n\n        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\n\n        break;\n\n      case Camera.RIG_MODE_VR:\n        if (camLeft.rotationQuaternion) {\n          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        } else {\n          camLeft.rotation.copyFrom(this.rotation);\n          camRight.rotation.copyFrom(this.rotation);\n        }\n\n        camLeft.position.copyFrom(this.position);\n        camRight.position.copyFrom(this.position);\n        break;\n    }\n\n    _super.prototype._updateRigCameras.call(this);\n  };\n\n  TargetCamera.prototype._getRigCamPositionAndTarget = function (halfSpace, rigCamera) {\n    var target = this.getTarget();\n    target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\n\n    TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\n\n    var newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\n\n    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n\n    TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\n\n    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n\n    TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\n\n    Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\n    rigCamera.setTarget(newFocalTarget);\n  };\n  /**\r\n   * Gets the current object class name.\r\n   * @return the class name\r\n   */\n\n\n  TargetCamera.prototype.getClassName = function () {\n    return \"TargetCamera\";\n  };\n\n  TargetCamera._RigCamTransformMatrix = new Matrix();\n  TargetCamera._TargetTransformMatrix = new Matrix();\n  TargetCamera._TargetFocalPoint = new Vector3();\n\n  __decorate([serializeAsVector3()], TargetCamera.prototype, \"rotation\", void 0);\n\n  __decorate([serialize()], TargetCamera.prototype, \"speed\", void 0);\n\n  __decorate([serializeAsMeshReference(\"lockedTargetId\")], TargetCamera.prototype, \"lockedTarget\", void 0);\n\n  return TargetCamera;\n}(Camera);\n\nexport { TargetCamera };","map":null,"metadata":{},"sourceType":"module"}