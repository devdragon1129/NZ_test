{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Light } from \"./light\";\nimport { Axis } from '../Maths/math.axis';\n/**\r\n * Base implementation IShadowLight\r\n * It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.\r\n */\n\nvar ShadowLight =\n/** @class */\nfunction (_super) {\n  __extends(ShadowLight, _super);\n\n  function ShadowLight() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._needProjectionMatrixCompute = true;\n    return _this;\n  }\n\n  ShadowLight.prototype._setPosition = function (value) {\n    this._position = value;\n  };\n\n  Object.defineProperty(ShadowLight.prototype, \"position\", {\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\n    get: function get() {\n      return this._position;\n    },\n\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\n    set: function set(value) {\n      this._setPosition(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ShadowLight.prototype._setDirection = function (value) {\n    this._direction = value;\n  };\n\n  Object.defineProperty(ShadowLight.prototype, \"direction\", {\n    /**\r\n     * In 2d mode (needCube being false), gets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\n    get: function get() {\n      return this._direction;\n    },\n\n    /**\r\n     * In 2d mode (needCube being false), sets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\n    set: function set(value) {\n      this._setDirection(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ShadowLight.prototype, \"shadowMinZ\", {\n    /**\r\n     * Gets the shadow projection clipping minimum z value.\r\n     */\n    get: function get() {\n      return this._shadowMinZ;\n    },\n\n    /**\r\n     * Sets the shadow projection clipping minimum z value.\r\n     */\n    set: function set(value) {\n      this._shadowMinZ = value;\n      this.forceProjectionMatrixCompute();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ShadowLight.prototype, \"shadowMaxZ\", {\n    /**\r\n     * Sets the shadow projection clipping maximum z value.\r\n     */\n    get: function get() {\n      return this._shadowMaxZ;\n    },\n\n    /**\r\n     * Gets the shadow projection clipping maximum z value.\r\n     */\n    set: function set(value) {\n      this._shadowMaxZ = value;\n      this.forceProjectionMatrixCompute();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n   * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n   */\n\n  ShadowLight.prototype.computeTransformedInformation = function () {\n    if (this.parent && this.parent.getWorldMatrix) {\n      if (!this.transformedPosition) {\n        this.transformedPosition = Vector3.Zero();\n      }\n\n      Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition); // In case the direction is present.\n\n      if (this.direction) {\n        if (!this.transformedDirection) {\n          this.transformedDirection = Vector3.Zero();\n        }\n\n        Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Return the depth scale used for the shadow map.\r\n   * @returns the depth scale.\r\n   */\n\n\n  ShadowLight.prototype.getDepthScale = function () {\n    return 50.0;\n  };\n  /**\r\n   * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n   * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n   * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n   */\n\n\n  ShadowLight.prototype.getShadowDirection = function (faceIndex) {\n    return this.transformedDirection ? this.transformedDirection : this.direction;\n  };\n  /**\r\n   * Returns the ShadowLight absolute position in the World.\r\n   * @returns the position vector in world space\r\n   */\n\n\n  ShadowLight.prototype.getAbsolutePosition = function () {\n    return this.transformedPosition ? this.transformedPosition : this.position;\n  };\n  /**\r\n   * Sets the ShadowLight direction toward the passed target.\r\n   * @param target The point to target in local space\r\n   * @returns the updated ShadowLight direction\r\n   */\n\n\n  ShadowLight.prototype.setDirectionToTarget = function (target) {\n    this.direction = Vector3.Normalize(target.subtract(this.position));\n    return this.direction;\n  };\n  /**\r\n   * Returns the light rotation in euler definition.\r\n   * @returns the x y z rotation in local space.\r\n   */\n\n\n  ShadowLight.prototype.getRotation = function () {\n    this.direction.normalize();\n    var xaxis = Vector3.Cross(this.direction, Axis.Y);\n    var yaxis = Vector3.Cross(xaxis, this.direction);\n    return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\n  };\n  /**\r\n   * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n   * @returns true if a cube texture needs to be use\r\n   */\n\n\n  ShadowLight.prototype.needCube = function () {\n    return false;\n  };\n  /**\r\n   * Detects if the projection matrix requires to be recomputed this frame.\r\n   * @returns true if it requires to be recomputed otherwise, false.\r\n   */\n\n\n  ShadowLight.prototype.needProjectionMatrixCompute = function () {\n    return this._needProjectionMatrixCompute;\n  };\n  /**\r\n   * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n   */\n\n\n  ShadowLight.prototype.forceProjectionMatrixCompute = function () {\n    this._needProjectionMatrixCompute = true;\n  };\n  /** @hidden */\n\n\n  ShadowLight.prototype._initCache = function () {\n    _super.prototype._initCache.call(this);\n\n    this._cache.position = Vector3.Zero();\n  };\n  /** @hidden */\n\n\n  ShadowLight.prototype._isSynchronized = function () {\n    if (!this._cache.position.equals(this.position)) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Computes the world matrix of the node\r\n   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n   * @returns the world matrix\r\n   */\n\n\n  ShadowLight.prototype.computeWorldMatrix = function (force) {\n    if (!force && this.isSynchronized()) {\n      this._currentRenderId = this.getScene().getRenderId();\n      return this._worldMatrix;\n    }\n\n    this._updateCache();\n\n    this._cache.position.copyFrom(this.position);\n\n    if (!this._worldMatrix) {\n      this._worldMatrix = Matrix.Identity();\n    }\n\n    Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\n\n    if (this.parent && this.parent.getWorldMatrix) {\n      this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\n\n      this._markSyncedWithParent();\n    } // Cache the determinant\n\n\n    this._worldMatrixDeterminantIsDirty = true;\n    return this._worldMatrix;\n  };\n  /**\r\n   * Gets the minZ used for shadow according to both the scene and the light.\r\n   * @param activeCamera The camera we are returning the min for\r\n   * @returns the depth min z\r\n   */\n\n\n  ShadowLight.prototype.getDepthMinZ = function (activeCamera) {\n    return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n  };\n  /**\r\n   * Gets the maxZ used for shadow according to both the scene and the light.\r\n   * @param activeCamera The camera we are returning the max for\r\n   * @returns the depth max z\r\n   */\n\n\n  ShadowLight.prototype.getDepthMaxZ = function (activeCamera) {\n    return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n  };\n  /**\r\n   * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n   * @param matrix The materix to updated with the projection information\r\n   * @param viewMatrix The transform matrix of the light\r\n   * @param renderList The list of mesh to render in the map\r\n   * @returns The current light\r\n   */\n\n\n  ShadowLight.prototype.setShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n    if (this.customProjectionMatrixBuilder) {\n      this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\n    } else {\n      this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\n    }\n\n    return this;\n  };\n\n  __decorate([serializeAsVector3()], ShadowLight.prototype, \"position\", null);\n\n  __decorate([serializeAsVector3()], ShadowLight.prototype, \"direction\", null);\n\n  __decorate([serialize()], ShadowLight.prototype, \"shadowMinZ\", null);\n\n  __decorate([serialize()], ShadowLight.prototype, \"shadowMaxZ\", null);\n\n  return ShadowLight;\n}(Light);\n\nexport { ShadowLight };","map":null,"metadata":{},"sourceType":"module"}