{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Color3, Color4 } from \"../Maths/math.color\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\nimport { Material } from \"../Materials/material\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\nimport { MaterialHelper } from '../Materials/materialHelper';\nimport \"../Shaders/color.fragment\";\nimport \"../Shaders/color.vertex\";\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\n\nvar LinesMesh =\n/** @class */\nfunction (_super) {\n  __extends(LinesMesh, _super);\n  /**\r\n   * Creates a new LinesMesh\r\n   * @param name defines the name\r\n   * @param scene defines the hosting scene\r\n   * @param parent defines the parent mesh if any\r\n   * @param source defines the optional source LinesMesh used to clone data from\r\n   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n   * When false, achieved by calling a clone(), also passing False.\r\n   * This will make creation of children, recursive.\r\n   * @param useVertexColor defines if this LinesMesh supports vertex color\r\n   * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n   */\n\n\n  function LinesMesh(name, scene, parent, source, doNotCloneChildren,\n  /**\r\n   * If vertex color should be applied to the mesh\r\n   */\n  useVertexColor,\n  /**\r\n   * If vertex alpha should be applied to the mesh\r\n   */\n  useVertexAlpha) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (source === void 0) {\n      source = null;\n    }\n\n    var _this = _super.call(this, name, scene, parent, source, doNotCloneChildren) || this;\n\n    _this.useVertexColor = useVertexColor;\n    _this.useVertexAlpha = useVertexAlpha;\n    /**\r\n     * Color of the line (Default: White)\r\n     */\n\n    _this.color = new Color3(1, 1, 1);\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\n\n    _this.alpha = 1;\n\n    if (source) {\n      _this.color = source.color.clone();\n      _this.alpha = source.alpha;\n      _this.useVertexColor = source.useVertexColor;\n      _this.useVertexAlpha = source.useVertexAlpha;\n    }\n\n    _this.intersectionThreshold = 0.1;\n    var defines = [];\n    var options = {\n      attributes: [VertexBuffer.PositionKind, \"world0\", \"world1\", \"world2\", \"world3\"],\n      uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\n      needAlphaBlending: true,\n      defines: defines\n    };\n\n    if (useVertexAlpha === false) {\n      options.needAlphaBlending = false;\n    }\n\n    if (!useVertexColor) {\n      options.uniforms.push(\"color\");\n      _this.color4 = new Color4();\n    } else {\n      options.defines.push(\"#define VERTEXCOLOR\");\n      options.attributes.push(VertexBuffer.ColorKind);\n    }\n\n    _this._colorShader = new ShaderMaterial(\"colorShader\", _this.getScene(), \"color\", options);\n    return _this;\n  }\n\n  LinesMesh.prototype._addClipPlaneDefine = function (label) {\n    var define = \"#define \" + label;\n\n    var index = this._colorShader.options.defines.indexOf(define);\n\n    if (index !== -1) {\n      return;\n    }\n\n    this._colorShader.options.defines.push(define);\n  };\n\n  LinesMesh.prototype._removeClipPlaneDefine = function (label) {\n    var define = \"#define \" + label;\n\n    var index = this._colorShader.options.defines.indexOf(define);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._colorShader.options.defines.splice(index, 1);\n  };\n\n  LinesMesh.prototype.isReady = function () {\n    var scene = this.getScene(); // Clip planes\n\n    scene.clipPlane ? this._addClipPlaneDefine(\"CLIPPLANE\") : this._removeClipPlaneDefine(\"CLIPPLANE\");\n    scene.clipPlane2 ? this._addClipPlaneDefine(\"CLIPPLANE2\") : this._removeClipPlaneDefine(\"CLIPPLANE2\");\n    scene.clipPlane3 ? this._addClipPlaneDefine(\"CLIPPLANE3\") : this._removeClipPlaneDefine(\"CLIPPLANE3\");\n    scene.clipPlane4 ? this._addClipPlaneDefine(\"CLIPPLANE4\") : this._removeClipPlaneDefine(\"CLIPPLANE4\");\n    scene.clipPlane5 ? this._addClipPlaneDefine(\"CLIPPLANE5\") : this._removeClipPlaneDefine(\"CLIPPLANE5\");\n    scene.clipPlane6 ? this._addClipPlaneDefine(\"CLIPPLANE6\") : this._removeClipPlaneDefine(\"CLIPPLANE6\");\n\n    if (!this._colorShader.isReady(this)) {\n      return false;\n    }\n\n    return _super.prototype.isReady.call(this);\n  };\n  /**\r\n   * Returns the string \"LineMesh\"\r\n   */\n\n\n  LinesMesh.prototype.getClassName = function () {\n    return \"LinesMesh\";\n  };\n\n  Object.defineProperty(LinesMesh.prototype, \"material\", {\n    /**\r\n     * @hidden\r\n     */\n    get: function get() {\n      return this._colorShader;\n    },\n\n    /**\r\n     * @hidden\r\n     */\n    set: function set(value) {// Do nothing\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LinesMesh.prototype, \"checkCollisions\", {\n    /**\r\n     * @hidden\r\n     */\n    get: function get() {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  LinesMesh.prototype._bind = function (subMesh, effect, fillMode) {\n    if (!this._geometry) {\n      return this;\n    }\n\n    var colorEffect = this._colorShader.getEffect(); // VBOs\n\n\n    var indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\n\n    this._geometry._bind(colorEffect, indexToBind); // Color\n\n\n    if (!this.useVertexColor) {\n      var _a = this.color,\n          r = _a.r,\n          g = _a.g,\n          b = _a.b;\n      this.color4.set(r, g, b, this.alpha);\n\n      this._colorShader.setColor4(\"color\", this.color4);\n    } // Clip planes\n\n\n    MaterialHelper.BindClipPlane(colorEffect, this.getScene());\n    return this;\n  };\n  /** @hidden */\n\n\n  LinesMesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\n    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n      return this;\n    }\n\n    var engine = this.getScene().getEngine(); // Draw order\n\n    if (this._unIndexed) {\n      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\n    } else {\n      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\n    }\n\n    return this;\n  };\n  /**\r\n   * Disposes of the line mesh\r\n   * @param doNotRecurse If children should be disposed\r\n   */\n\n\n  LinesMesh.prototype.dispose = function (doNotRecurse) {\n    this._colorShader.dispose(false, false, true);\n\n    _super.prototype.dispose.call(this, doNotRecurse);\n  };\n  /**\r\n   * Returns a new LineMesh object cloned from the current one.\r\n   */\n\n\n  LinesMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\n  };\n  /**\r\n   * Creates a new InstancedLinesMesh object from the mesh model.\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n   * @param name defines the name of the new instance\r\n   * @returns a new InstancedLinesMesh\r\n   */\n\n\n  LinesMesh.prototype.createInstance = function (name) {\n    return new InstancedLinesMesh(name, this);\n  };\n\n  return LinesMesh;\n}(Mesh);\n\nexport { LinesMesh };\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\n\nvar InstancedLinesMesh =\n/** @class */\nfunction (_super) {\n  __extends(InstancedLinesMesh, _super);\n\n  function InstancedLinesMesh(name, source) {\n    var _this = _super.call(this, name, source) || this;\n\n    _this.intersectionThreshold = source.intersectionThreshold;\n    return _this;\n  }\n  /**\r\n   * Returns the string \"InstancedLinesMesh\".\r\n   */\n\n\n  InstancedLinesMesh.prototype.getClassName = function () {\n    return \"InstancedLinesMesh\";\n  };\n\n  return InstancedLinesMesh;\n}(InstancedMesh);\n\nexport { InstancedLinesMesh };","map":null,"metadata":{},"sourceType":"module"}