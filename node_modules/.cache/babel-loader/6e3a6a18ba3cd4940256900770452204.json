{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Texture } from \"./texture\";\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\n\nvar RawTexture =\n/** @class */\nfunction (_super) {\n  __extends(RawTexture, _super);\n  /**\r\n   * Instantiates a new RawTexture.\r\n   * Raw texture can help creating a texture directly from an array of data.\r\n   * This can be super useful if you either get the data from an uncompressed source or\r\n   * if you wish to create your texture pixel by pixel.\r\n   * @param data define the array of data to use to create the texture\r\n   * @param width define the width of the texture\r\n   * @param height define the height of the texture\r\n   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps define whether mip maps should be generated or not\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n   */\n\n\n  function RawTexture(data, width, height,\n  /**\r\n   * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n   */\n  format, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    var _this = _super.call(this, null, sceneOrEngine, !generateMipMaps, invertY) || this;\n\n    _this.format = format;\n\n    if (!_this._engine) {\n      return _this;\n    }\n\n    _this._texture = _this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type);\n    _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    return _this;\n  }\n  /**\r\n   * Updates the texture underlying data.\r\n   * @param data Define the new data of the texture\r\n   */\n\n\n  RawTexture.prototype.update = function (data) {\n    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n  };\n  /**\r\n   * Creates a luminance texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @returns the luminance texture\r\n   */\n\n\n  RawTexture.CreateLuminanceTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\r\n   * Creates a luminance alpha texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @returns the luminance alpha texture\r\n   */\n\n\n  RawTexture.CreateLuminanceAlphaTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\r\n   * Creates an alpha texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @returns the alpha texture\r\n   */\n\n\n  RawTexture.CreateAlphaTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\r\n   * Creates a RGB texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n   * @returns the RGB alpha texture\r\n   */\n\n\n  RawTexture.CreateRGBTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    return new RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n  /**\r\n   * Creates a RGBA texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n   * @returns the RGBA texture\r\n   */\n\n\n  RawTexture.CreateRGBATexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n  /**\r\n   * Creates a R texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n   * @returns the R texture\r\n   */\n\n\n  RawTexture.CreateRTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (type === void 0) {\n      type = 1;\n    }\n\n    return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n\n  return RawTexture;\n}(Texture);\n\nexport { RawTexture };","map":null,"metadata":{},"sourceType":"module"}