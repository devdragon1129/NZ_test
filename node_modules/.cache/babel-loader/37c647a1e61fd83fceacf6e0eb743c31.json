{"ast":null,"code":"import { Size } from '../../Maths/math.size';\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\n\nvar ThinTexture =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new ThinTexture.\r\n   * Base class of all the textures in babylon.\r\n   * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\r\n   * @param internalTexture Define the internalTexture to wrap\r\n   */\n  function ThinTexture(internalTexture) {\n    this._wrapU = 1;\n    this._wrapV = 1;\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\n\n    this.wrapR = 1;\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\n\n    this.anisotropicFilteringLevel = 4;\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\n\n    this.delayLoadState = 0;\n    /** @hidden */\n\n    this._texture = null;\n    this._engine = null;\n    this._cachedSize = Size.Zero();\n    this._cachedBaseSize = Size.Zero();\n    this._texture = internalTexture;\n\n    if (this._texture) {\n      this._engine = this._texture.getEngine();\n    }\n  }\n\n  Object.defineProperty(ThinTexture.prototype, \"wrapU\", {\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\n    get: function get() {\n      return this._wrapU;\n    },\n    set: function set(value) {\n      this._wrapU = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"wrapV\", {\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\n    get: function get() {\n      return this._wrapV;\n    },\n    set: function set(value) {\n      this._wrapV = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"coordinatesMode\", {\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\n    get: function get() {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"isCube\", {\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.isCube;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.isCube = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"is3D\", {\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is3D;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is3D = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"is2DArray\", {\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\n    get: function get() {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is2DArray;\n    },\n    set: function set(value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is2DArray = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the class name of the texture.\r\n   * @returns \"ThinTexture\"\r\n   */\n\n  ThinTexture.prototype.getClassName = function () {\n    return \"ThinTexture\";\n  };\n  /**\r\n   * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n   * @returns true if fully ready\r\n   */\n\n\n  ThinTexture.prototype.isReady = function () {\n    if (this.delayLoadState === 4) {\n      this.delayLoad();\n      return false;\n    }\n\n    if (this._texture) {\n      return this._texture.isReady;\n    }\n\n    return false;\n  };\n  /**\r\n   * Triggers the load sequence in delayed load mode.\r\n   */\n\n\n  ThinTexture.prototype.delayLoad = function () {};\n  /**\r\n   * Get the underlying lower level texture from Babylon.\r\n   * @returns the insternal texture\r\n   */\n\n\n  ThinTexture.prototype.getInternalTexture = function () {\n    return this._texture;\n  };\n  /**\r\n   * Get the size of the texture.\r\n   * @returns the texture size.\r\n   */\n\n\n  ThinTexture.prototype.getSize = function () {\n    if (this._texture) {\n      if (this._texture.width) {\n        this._cachedSize.width = this._texture.width;\n        this._cachedSize.height = this._texture.height;\n        return this._cachedSize;\n      }\n\n      if (this._texture._size) {\n        this._cachedSize.width = this._texture._size;\n        this._cachedSize.height = this._texture._size;\n        return this._cachedSize;\n      }\n    }\n\n    return this._cachedSize;\n  };\n  /**\r\n   * Get the base size of the texture.\r\n   * It can be different from the size if the texture has been resized for POT for instance\r\n   * @returns the base size\r\n   */\n\n\n  ThinTexture.prototype.getBaseSize = function () {\n    if (!this.isReady() || !this._texture) {\n      this._cachedBaseSize.width = 0;\n      this._cachedBaseSize.height = 0;\n      return this._cachedBaseSize;\n    }\n\n    if (this._texture._size) {\n      this._cachedBaseSize.width = this._texture._size;\n      this._cachedBaseSize.height = this._texture._size;\n      return this._cachedBaseSize;\n    }\n\n    this._cachedBaseSize.width = this._texture.baseWidth;\n    this._cachedBaseSize.height = this._texture.baseHeight;\n    return this._cachedBaseSize;\n  };\n  /**\r\n   * Update the sampling mode of the texture.\r\n   * Default is Trilinear mode.\r\n   *\r\n   * | Value | Type               | Description |\r\n   * | ----- | ------------------ | ----------- |\r\n   * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n   * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n   * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n   * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n   * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n   * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n   * | 7    | NEAREST_LINEAR |             |\r\n   * | 8    | NEAREST_NEAREST |             |\r\n   * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n   * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n   * | 11   | LINEAR_LINEAR |             |\r\n   * | 12   | LINEAR_NEAREST |             |\r\n   *\r\n   *    > _mag_: magnification filter (close to the viewer)\r\n   *    > _min_: minification filter (far from the viewer)\r\n   *    > _mip_: filter used between mip map levels\r\n   *@param samplingMode Define the new sampling mode of the texture\r\n   */\n\n\n  ThinTexture.prototype.updateSamplingMode = function (samplingMode) {\n    if (this._texture && this._engine) {\n      this._engine.updateTextureSamplingMode(samplingMode, this._texture);\n    }\n  };\n  /**\r\n   * Release and destroy the underlying lower level texture aka internalTexture.\r\n   */\n\n\n  ThinTexture.prototype.releaseInternalTexture = function () {\n    if (this._texture) {\n      this._texture.dispose();\n\n      this._texture = null;\n    }\n  };\n  /**\r\n   * Dispose the texture and release its associated resources.\r\n   */\n\n\n  ThinTexture.prototype.dispose = function () {\n    if (this._texture) {\n      this.releaseInternalTexture();\n      this._engine = null;\n    }\n  };\n\n  return ThinTexture;\n}();\n\nexport { ThinTexture };","map":null,"metadata":{},"sourceType":"module"}