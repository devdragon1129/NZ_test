{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Tools } from \"../../Misc/tools\";\nvar anchorIdProvider = 0;\n/**\r\n * An implementation of the anchor system for WebXR.\r\n * For further information see https://github.com/immersive-web/anchors/\r\n */\n\nvar WebXRAnchorSystem =\n/** @class */\nfunction (_super) {\n  __extends(WebXRAnchorSystem, _super);\n  /**\r\n   * constructs a new anchor system\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param _options configuration object for this feature\r\n   */\n\n\n  function WebXRAnchorSystem(_xrSessionManager, _options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._lastFrameDetected = new Set();\n    _this._trackedAnchors = [];\n    _this._futureAnchors = [];\n    /**\r\n     * Observers registered here will be executed when a new anchor was added to the session\r\n     */\n\n    _this.onAnchorAddedObservable = new Observable();\n    /**\r\n     * Observers registered here will be executed when an anchor was removed from the session\r\n     */\n\n    _this.onAnchorRemovedObservable = new Observable();\n    /**\r\n     * Observers registered here will be executed when an existing anchor updates\r\n     * This can execute N times every frame\r\n     */\n\n    _this.onAnchorUpdatedObservable = new Observable();\n    _this._tmpVector = new Vector3();\n    _this._tmpQuaternion = new Quaternion();\n    _this.xrNativeFeatureName = \"anchors\";\n    return _this;\n  }\n\n  Object.defineProperty(WebXRAnchorSystem.prototype, \"referenceSpaceForFrameAnchors\", {\n    /**\r\n     * Set the reference space to use for anchor creation, when not using a hit test.\r\n     * Will default to the session's reference space if not defined\r\n     */\n    set: function set(referenceSpace) {\n      this._referenceSpaceForFrameAnchors = referenceSpace;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRAnchorSystem.prototype._populateTmpTransformation = function (position, rotationQuaternion) {\n    this._tmpVector.copyFrom(position);\n\n    this._tmpQuaternion.copyFrom(rotationQuaternion);\n\n    if (!this._xrSessionManager.scene.useRightHandedSystem) {\n      this._tmpVector.z *= -1;\n      this._tmpQuaternion.z *= -1;\n      this._tmpQuaternion.w *= -1;\n    }\n\n    return {\n      position: this._tmpVector,\n      rotationQuaternion: this._tmpQuaternion\n    };\n  };\n  /**\r\n   * Create a new anchor point using a hit test result at a specific point in the scene\r\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n   *\r\n   * @param hitTestResult The hit test result to use for this anchor creation\r\n   * @param position an optional position offset for this anchor\r\n   * @param rotationQuaternion an optional rotation offset for this anchor\r\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n   */\n\n\n  WebXRAnchorSystem.prototype.addAnchorPointUsingHitTestResultAsync = function (hitTestResult, position, rotationQuaternion) {\n    if (position === void 0) {\n      position = new Vector3();\n    }\n\n    if (rotationQuaternion === void 0) {\n      rotationQuaternion = new Quaternion();\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var m, nativeAnchor_1, error_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // convert to XR space (right handed) if needed\n            this._populateTmpTransformation(position, rotationQuaternion);\n\n            m = new XRRigidTransform({\n              x: this._tmpVector.x,\n              y: this._tmpVector.y,\n              z: this._tmpVector.z\n            }, {\n              x: this._tmpQuaternion.x,\n              y: this._tmpQuaternion.y,\n              z: this._tmpQuaternion.z,\n              w: this._tmpQuaternion.w\n            });\n            if (!!hitTestResult.xrHitResult.createAnchor) return [3\n            /*break*/\n            , 1];\n            this.detach();\n            throw new Error(\"Anchors not enabled in this environment/browser\");\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , hitTestResult.xrHitResult.createAnchor(m)];\n\n          case 2:\n            nativeAnchor_1 = _a.sent();\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              _this._futureAnchors.push({\n                nativeAnchor: nativeAnchor_1,\n                resolved: false,\n                submitted: true,\n                xrTransformation: m,\n                resolve: resolve,\n                reject: reject\n              });\n            })];\n\n          case 3:\n            error_1 = _a.sent();\n            throw new Error(error_1);\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Add a new anchor at a specific position and rotation\r\n   * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\r\n   * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\r\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n   *\r\n   * @param position the position in which to add an anchor\r\n   * @param rotationQuaternion an optional rotation for the anchor transformation\r\n   * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\r\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n   */\n\n\n  WebXRAnchorSystem.prototype.addAnchorAtPositionAndRotationAsync = function (position, rotationQuaternion, forceCreateInCurrentFrame) {\n    if (rotationQuaternion === void 0) {\n      rotationQuaternion = new Quaternion();\n    }\n\n    if (forceCreateInCurrentFrame === void 0) {\n      forceCreateInCurrentFrame = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var xrTransformation, xrAnchor, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // convert to XR space (right handed) if needed\n            this._populateTmpTransformation(position, rotationQuaternion);\n\n            xrTransformation = new XRRigidTransform({\n              x: this._tmpVector.x,\n              y: this._tmpVector.y,\n              z: this._tmpVector.z\n            }, {\n              x: this._tmpQuaternion.x,\n              y: this._tmpQuaternion.y,\n              z: this._tmpQuaternion.z,\n              w: this._tmpQuaternion.w\n            });\n            if (!(forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)];\n\n          case 1:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _a = undefined;\n            _b.label = 3;\n\n          case 3:\n            xrAnchor = _a; // add the transformation to the future anchors list\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              _this._futureAnchors.push({\n                nativeAnchor: xrAnchor,\n                resolved: false,\n                submitted: false,\n                xrTransformation: xrTransformation,\n                resolve: resolve,\n                reject: reject\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(WebXRAnchorSystem.prototype, \"anchors\", {\n    /**\r\n     * Get the list of anchors currently being tracked by the system\r\n     */\n    get: function get() {\n      return this._trackedAnchors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n  WebXRAnchorSystem.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\n      while (this._trackedAnchors.length) {\n        var toRemove = this._trackedAnchors.pop();\n\n        if (toRemove) {\n          try {\n            // try to natively remove it as well\n            toRemove.remove();\n          } catch (e) {// no-op\n          } // as the xr frame loop is removed, we need to notify manually\n\n\n          this.onAnchorRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRAnchorSystem.prototype.dispose = function () {\n    this._futureAnchors.length = 0;\n\n    _super.prototype.dispose.call(this);\n\n    this.onAnchorAddedObservable.clear();\n    this.onAnchorRemovedObservable.clear();\n    this.onAnchorUpdatedObservable.clear();\n  };\n\n  WebXRAnchorSystem.prototype._onXRFrame = function (frame) {\n    var _this = this;\n\n    if (!this.attached || !frame) {\n      return;\n    }\n\n    var trackedAnchors = frame.trackedAnchors;\n\n    if (trackedAnchors) {\n      var toRemove = this._trackedAnchors.filter(function (anchor) {\n        return !trackedAnchors.has(anchor.xrAnchor);\n      }).map(function (anchor) {\n        var index = _this._trackedAnchors.indexOf(anchor);\n\n        return index;\n      });\n\n      var idxTracker_1 = 0;\n      toRemove.forEach(function (index) {\n        var anchor = _this._trackedAnchors.splice(index - idxTracker_1, 1)[0];\n\n        _this.onAnchorRemovedObservable.notifyObservers(anchor);\n\n        idxTracker_1++;\n      }); // now check for new ones\n\n      trackedAnchors.forEach(function (xrAnchor) {\n        if (!_this._lastFrameDetected.has(xrAnchor)) {\n          var newAnchor = {\n            id: anchorIdProvider++,\n            xrAnchor: xrAnchor,\n            remove: xrAnchor.delete\n          };\n\n          var anchor = _this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\n\n          _this._trackedAnchors.push(anchor);\n\n          _this.onAnchorAddedObservable.notifyObservers(anchor); // search for the future anchor promise that matches this\n\n\n          var results = _this._futureAnchors.filter(function (futureAnchor) {\n            return futureAnchor.nativeAnchor === xrAnchor;\n          });\n\n          var result = results[0];\n\n          if (result) {\n            result.resolve(anchor);\n            result.resolved = true;\n          }\n        } else {\n          var index = _this._findIndexInAnchorArray(xrAnchor);\n\n          var anchor = _this._trackedAnchors[index];\n\n          try {\n            // anchors update every frame\n            _this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\n\n            if (anchor.attachedNode) {\n              anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\n              anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\n            }\n\n            _this.onAnchorUpdatedObservable.notifyObservers(anchor);\n          } catch (e) {\n            Tools.Warn(\"Anchor could not be updated\");\n          }\n        }\n      });\n      this._lastFrameDetected = trackedAnchors;\n    } // process future anchors\n\n\n    this._futureAnchors.forEach(function (futureAnchor) {\n      if (!futureAnchor.resolved && !futureAnchor.submitted) {\n        _this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(function (nativeAnchor) {\n          futureAnchor.nativeAnchor = nativeAnchor;\n        }, function (error) {\n          futureAnchor.resolved = true;\n          futureAnchor.reject(error);\n        });\n\n        futureAnchor.submitted = true;\n      }\n    });\n  };\n  /**\r\n   * avoiding using Array.find for global support.\r\n   * @param xrAnchor the plane to find in the array\r\n   */\n\n\n  WebXRAnchorSystem.prototype._findIndexInAnchorArray = function (xrAnchor) {\n    for (var i = 0; i < this._trackedAnchors.length; ++i) {\n      if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  WebXRAnchorSystem.prototype._updateAnchorWithXRFrame = function (xrAnchor, anchor, xrFrame) {\n    // matrix\n    var pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\n\n    if (pose) {\n      var mat = anchor.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n\n      anchor.transformationMatrix = mat;\n\n      if (!this._options.worldParentNode) {// Logger.Warn(\"Please provide a world parent node to apply world transformation\");\n      } else {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n\n    return anchor;\n  };\n\n  WebXRAnchorSystem.prototype._createAnchorAtTransformation = function (xrTransformation, xrFrame) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        if (xrFrame.createAnchor) {\n          try {\n            return [2\n            /*return*/\n            , xrFrame.createAnchor(xrTransformation, (_a = this._referenceSpaceForFrameAnchors) !== null && _a !== void 0 ? _a : this._xrSessionManager.referenceSpace)];\n          } catch (error) {\n            throw new Error(error);\n          }\n        } else {\n          this.detach();\n          throw new Error(\"Anchors are not enabled in your browser\");\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRAnchorSystem.Version = 1;\n  return WebXRAnchorSystem;\n}(WebXRAbstractFeature);\n\nexport { WebXRAnchorSystem }; // register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRAnchorSystem(xrSessionManager, options);\n  };\n}, WebXRAnchorSystem.Version);","map":null,"metadata":{},"sourceType":"module"}