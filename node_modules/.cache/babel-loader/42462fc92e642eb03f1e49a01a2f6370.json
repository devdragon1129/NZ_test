{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { SerializationHelper, serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\nimport { Vector2 } from \"../../Maths/math.vector\";\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\n/**\r\n * Define the code related to the anisotropic parameters of the pbr material.\r\n */\n\nvar PBRAnisotropicConfiguration =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new istance of anisotropy configuration.\r\n   * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n   */\n  function PBRAnisotropicConfiguration(markAllSubMeshesAsTexturesDirty) {\n    this._isEnabled = false;\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\n\n    this.isEnabled = false;\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\n\n    this.intensity = 1;\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"strectching\" the highlights along the tangents.\r\n     */\n\n    this.direction = new Vector2(1, 0);\n    this._texture = null;\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\n\n    this.texture = null;\n    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\n  }\n  /** @hidden */\n\n\n  PBRAnisotropicConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - boolean indicating that the submesh is ready or not.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param mesh the mesh we are preparing the defines for.\r\n   * @param scene defines the scene the material belongs to.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.prepareDefines = function (defines, mesh, scene) {\n    if (this._isEnabled) {\n      defines.ANISOTROPIC = this._isEnabled;\n\n      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n        defines._needUVs = true;\n        defines.MAINUV1 = true;\n      }\n\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\n          } else {\n            defines.ANISOTROPIC_TEXTURE = false;\n          }\n        }\n      }\n    } else {\n      defines.ANISOTROPIC = false;\n      defines.ANISOTROPIC_TEXTURE = false;\n    }\n  };\n  /**\r\n   * Binds the material data.\r\n   * @param uniformBuffer defines the Uniform buffer to fill in.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @param isFrozen defines wether the material is frozen or not.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, isFrozen) {\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\n        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\n      } // Anisotropy\n\n\n      uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\n      }\n    }\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param texture - Base texture to use.\r\n   * @returns - Boolean specifying if a texture is used in the material.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.hasTexture = function (texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns an array of the actively used textures.\r\n   * @param activeTextures Array of BaseTextures\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n  };\n  /**\r\n   * Returns the animatable textures.\r\n   * @param animatables Array of animatable textures.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n  };\n  /**\r\n   * Disposes the resources of the material.\r\n   * @param forceDisposeTextures - Forces the disposal of all textures.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._texture) {\n        this._texture.dispose();\n      }\n    }\n  };\n  /**\r\n  * Get the current class name of the texture useful for serialization or dynamic coding.\r\n  * @returns \"PBRAnisotropicConfiguration\"\r\n  */\n\n\n  PBRAnisotropicConfiguration.prototype.getClassName = function () {\n    return \"PBRAnisotropicConfiguration\";\n  };\n  /**\r\n   * Add fallbacks to the effect fallbacks list.\r\n   * @param defines defines the Base texture to use.\r\n   * @param fallbacks defines the current fallback list.\r\n   * @param currentRank defines the current fallback rank.\r\n   * @returns the new fallback rank.\r\n   */\n\n\n  PBRAnisotropicConfiguration.AddFallbacks = function (defines, fallbacks, currentRank) {\n    if (defines.ANISOTROPIC) {\n      fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\n    }\n\n    return currentRank;\n  };\n  /**\r\n   * Add the required uniforms to the current list.\r\n   * @param uniforms defines the current uniform list.\r\n   */\n\n\n  PBRAnisotropicConfiguration.AddUniforms = function (uniforms) {\n    uniforms.push(\"vAnisotropy\", \"vAnisotropyInfos\", \"anisotropyMatrix\");\n  };\n  /**\r\n   * Add the required uniforms to the current buffer.\r\n   * @param uniformBuffer defines the current uniform buffer.\r\n   */\n\n\n  PBRAnisotropicConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\n    uniformBuffer.addUniform(\"vAnisotropy\", 3);\n    uniformBuffer.addUniform(\"vAnisotropyInfos\", 2);\n    uniformBuffer.addUniform(\"anisotropyMatrix\", 16);\n  };\n  /**\r\n   * Add the required samplers to the current list.\r\n   * @param samplers defines the current sampler list.\r\n   */\n\n\n  PBRAnisotropicConfiguration.AddSamplers = function (samplers) {\n    samplers.push(\"anisotropySampler\");\n  };\n  /**\r\n   * Makes a duplicate of the current configuration into another one.\r\n   * @param anisotropicConfiguration define the config where to copy the info\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.copyTo = function (anisotropicConfiguration) {\n    SerializationHelper.Clone(function () {\n      return anisotropicConfiguration;\n    }, this);\n  };\n  /**\r\n   * Serializes this anisotropy configuration.\r\n   * @returns - An object with the serialized config.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Parses a anisotropy Configuration from a serialized object.\r\n   * @param source - Serialized object.\r\n   * @param scene Defines the scene we are parsing for\r\n   * @param rootUrl Defines the rootUrl to load from\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.parse = function (source, scene, rootUrl) {\n    var _this = this;\n\n    SerializationHelper.Parse(function () {\n      return _this;\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"isEnabled\", void 0);\n\n  __decorate([serialize()], PBRAnisotropicConfiguration.prototype, \"intensity\", void 0);\n\n  __decorate([serializeAsVector2()], PBRAnisotropicConfiguration.prototype, \"direction\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"texture\", void 0);\n\n  return PBRAnisotropicConfiguration;\n}();\n\nexport { PBRAnisotropicConfiguration };","map":null,"metadata":{},"sourceType":"module"}