{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar isomorphic_ws_1 = tslib_1.__importDefault(require(\"isomorphic-ws\"));\n\nvar util_1 = require(\"util\");\n\nvar legacy_provider_adapter_1 = require(\"./legacy-provider-adapter\");\n\nvar WebsocketProvider = /*#__PURE__*/function (_legacy_provider_adap) {\n  _inherits(WebsocketProvider, _legacy_provider_adap);\n\n  function WebsocketProvider(url) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, WebsocketProvider);\n\n    var legacyProvider = new LegacyWebsocketProvider(url, options);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebsocketProvider).call(this, legacyProvider));\n    _this.legacyProvider = legacyProvider;\n    return _this;\n  }\n\n  _createClass(WebsocketProvider, [{\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.legacyProvider.disconnect();\n    }\n  }]);\n\n  return WebsocketProvider;\n}(legacy_provider_adapter_1.LegacyProviderAdapter);\n\nexports.WebsocketProvider = WebsocketProvider;\n\nvar LegacyWebsocketProvider = /*#__PURE__*/function () {\n  function LegacyWebsocketProvider(url) {\n    var _this2 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, LegacyWebsocketProvider);\n\n    this.responseCallbacks = {};\n    this.notificationCallbacks = [];\n    this.lastChunk = '';\n    this.connected = false;\n\n    this.onOpen = function () {\n      _this2.connected = true;\n    };\n\n    this.onError = function () {\n      _this2.timeout();\n    };\n\n    this.onClose = function () {\n      _this2.timeout();\n\n      _this2.reset();\n\n      _this2.connected = false;\n    };\n\n    this.onMessage = function (e) {\n      var data = typeof e.data === 'string' ? e.data : '';\n\n      _this2.parseResponse(data).forEach(function (result) {\n        var id = null; // get the id which matches the returned id\n\n        if (util_1.isArray(result)) {\n          result.forEach(function (load) {\n            if (_this2.responseCallbacks[load.id]) {\n              id = load.id;\n            }\n          });\n        } else {\n          id = result.id;\n        } // notification\n\n\n        if (!id && result && result.method && result.method.indexOf('_subscription') !== -1) {\n          _this2.notificationCallbacks.forEach(function (callback) {\n            callback(result);\n          }); // fire the callback\n\n        } else if (id && _this2.responseCallbacks[id]) {\n          _this2.responseCallbacks[id].callback(undefined, result);\n\n          delete _this2.responseCallbacks[id];\n        }\n      });\n    };\n\n    this.options = options;\n    this.connection = new isomorphic_ws_1.default(url, options.protocol, options.clientOptions);\n    this.connection.onopen = this.onOpen;\n    this.connection.onerror = this.onError;\n    this.connection.onclose = this.onClose;\n    this.connection.onmessage = this.onMessage;\n  }\n\n  _createClass(LegacyWebsocketProvider, [{\n    key: \"parseResponse\",\n    value: function parseResponse(data) {\n      var _this3 = this;\n\n      var returnValues = []; // DE-CHUNKER\n\n      var dechunkedData = data.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n      .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n      .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n      .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n      .split('|--|');\n      dechunkedData.forEach(function (data) {\n        // prepend the last chunk\n        if (_this3.lastChunk) {\n          data = _this3.lastChunk + data;\n        }\n\n        var result = null;\n\n        try {\n          result = JSON.parse(data);\n        } catch (e) {\n          _this3.lastChunk = data; // start timeout to cancel all requests\n\n          clearTimeout(_this3.lastChunkTimeout);\n          _this3.lastChunkTimeout = setTimeout(function () {\n            _this3.timeout();\n\n            throw new Error(\"Invalid response data: \".concat(data));\n          }, 1000 * 15);\n          return;\n        } // cancel timeout and set chunk to null\n\n\n        clearTimeout(_this3.lastChunkTimeout);\n        _this3.lastChunk = '';\n\n        if (result) {\n          returnValues.push(result);\n        }\n      });\n      return returnValues;\n    }\n  }, {\n    key: \"addResponseCallback\",\n    value: function addResponseCallback(payload, callback) {\n      var _this4 = this;\n\n      var id = payload.id || payload[0].id;\n      var method = payload.method || payload[0].method;\n      this.responseCallbacks[id] = {\n        callback: callback,\n        method: method\n      }; // schedule triggering the error response if a custom timeout is set\n\n      if (this.options.timeout) {\n        setTimeout(function () {\n          if (_this4.responseCallbacks[id]) {\n            _this4.responseCallbacks[id].callback(new Error('Connection timeout'), undefined);\n\n            delete _this4.responseCallbacks[id];\n          }\n        }, this.options.timeout);\n      }\n    }\n  }, {\n    key: \"timeout\",\n    value: function timeout() {\n      for (var key in this.responseCallbacks) {\n        if (this.responseCallbacks[key]) {\n          this.responseCallbacks[key].callback(new Error('Connection error'), undefined);\n          delete this.responseCallbacks[key];\n        }\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload, callback) {\n      var _this5 = this;\n\n      if (this.connection.readyState === this.connection.CONNECTING) {\n        setTimeout(function () {\n          _this5.send(payload, callback);\n        }, 10);\n        return;\n      }\n\n      if (this.connection.readyState !== this.connection.OPEN) {\n        // tslint:disable-next-line:no-console\n        console.error('connection not open on send()');\n        this.onError();\n        callback(new Error('connection not open'), undefined);\n        return;\n      }\n\n      this.connection.send(JSON.stringify(payload));\n      this.addResponseCallback(payload, callback);\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, callback) {\n      switch (type) {\n        case 'data':\n          this.notificationCallbacks.push(callback);\n          break;\n\n        default:\n          throw new Error('Only supports data.');\n      }\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(type, callback) {\n      switch (type) {\n        case 'data':\n          var i = this.notificationCallbacks.indexOf(callback);\n\n          if (i !== -1) {\n            this.notificationCallbacks.splice(i, 1);\n          }\n\n          break;\n\n        default:\n          throw new Error('Only supports data.');\n      }\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(type) {\n      switch (type) {\n        case 'data':\n          this.notificationCallbacks = [];\n          break;\n\n        default:\n          throw new Error('Only supports data.');\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.timeout();\n      this.notificationCallbacks = [];\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.connection) {\n        this.connection.close();\n      }\n    }\n  }]);\n\n  return LegacyWebsocketProvider;\n}();","map":null,"metadata":{},"sourceType":"script"}