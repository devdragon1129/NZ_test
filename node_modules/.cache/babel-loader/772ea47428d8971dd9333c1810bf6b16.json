{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsFresnelParameters, serializeAsTexture } from \"../Misc/decorators\";\nimport { SmartArray } from \"../Misc/smartArray\";\nimport { Scene } from \"../scene\";\nimport { Matrix } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { PrePassConfiguration } from \"./prePassConfiguration\";\nimport { ImageProcessingConfiguration } from \"./imageProcessingConfiguration\";\nimport { Material } from \"../Materials/material\";\nimport { MaterialDefines } from \"../Materials/materialDefines\";\nimport { PushMaterial } from \"./pushMaterial\";\nimport { MaterialHelper } from \"./materialHelper\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { _TypeStore } from \"../Misc/typeStore\";\nimport { MaterialFlags } from \"./materialFlags\";\nimport \"../Shaders/default.fragment\";\nimport \"../Shaders/default.vertex\";\nimport { EffectFallbacks } from './effectFallbacks';\nimport { DetailMapConfiguration } from './material.detailMapConfiguration';\nvar onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/** @hidden */\n\nvar StandardMaterialDefines =\n/** @class */\nfunction (_super) {\n  __extends(StandardMaterialDefines, _super);\n\n  function StandardMaterialDefines() {\n    var _this = _super.call(this) || this;\n\n    _this.MAINUV1 = false;\n    _this.MAINUV2 = false;\n    _this.DIFFUSE = false;\n    _this.DIFFUSEDIRECTUV = 0;\n    _this.DETAIL = false;\n    _this.DETAILDIRECTUV = 0;\n    _this.DETAIL_NORMALBLENDMETHOD = 0;\n    _this.AMBIENT = false;\n    _this.AMBIENTDIRECTUV = 0;\n    _this.OPACITY = false;\n    _this.OPACITYDIRECTUV = 0;\n    _this.OPACITYRGB = false;\n    _this.REFLECTION = false;\n    _this.EMISSIVE = false;\n    _this.EMISSIVEDIRECTUV = 0;\n    _this.SPECULAR = false;\n    _this.SPECULARDIRECTUV = 0;\n    _this.BUMP = false;\n    _this.BUMPDIRECTUV = 0;\n    _this.PARALLAX = false;\n    _this.PARALLAXOCCLUSION = false;\n    _this.SPECULAROVERALPHA = false;\n    _this.CLIPPLANE = false;\n    _this.CLIPPLANE2 = false;\n    _this.CLIPPLANE3 = false;\n    _this.CLIPPLANE4 = false;\n    _this.CLIPPLANE5 = false;\n    _this.CLIPPLANE6 = false;\n    _this.ALPHATEST = false;\n    _this.DEPTHPREPASS = false;\n    _this.ALPHAFROMDIFFUSE = false;\n    _this.POINTSIZE = false;\n    _this.FOG = false;\n    _this.SPECULARTERM = false;\n    _this.DIFFUSEFRESNEL = false;\n    _this.OPACITYFRESNEL = false;\n    _this.REFLECTIONFRESNEL = false;\n    _this.REFRACTIONFRESNEL = false;\n    _this.EMISSIVEFRESNEL = false;\n    _this.FRESNEL = false;\n    _this.NORMAL = false;\n    _this.UV1 = false;\n    _this.UV2 = false;\n    _this.VERTEXCOLOR = false;\n    _this.VERTEXALPHA = false;\n    _this.NUM_BONE_INFLUENCERS = 0;\n    _this.BonesPerMesh = 0;\n    _this.BONETEXTURE = false;\n    _this.BONES_VELOCITY_ENABLED = false;\n    _this.INSTANCES = false;\n    _this.THIN_INSTANCES = false;\n    _this.GLOSSINESS = false;\n    _this.ROUGHNESS = false;\n    _this.EMISSIVEASILLUMINATION = false;\n    _this.LINKEMISSIVEWITHDIFFUSE = false;\n    _this.REFLECTIONFRESNELFROMSPECULAR = false;\n    _this.LIGHTMAP = false;\n    _this.LIGHTMAPDIRECTUV = 0;\n    _this.OBJECTSPACE_NORMALMAP = false;\n    _this.USELIGHTMAPASSHADOWMAP = false;\n    _this.REFLECTIONMAP_3D = false;\n    _this.REFLECTIONMAP_SPHERICAL = false;\n    _this.REFLECTIONMAP_PLANAR = false;\n    _this.REFLECTIONMAP_CUBIC = false;\n    _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\n    _this.REFLECTIONMAP_PROJECTION = false;\n    _this.REFLECTIONMAP_SKYBOX = false;\n    _this.REFLECTIONMAP_EXPLICIT = false;\n    _this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n    _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n    _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n    _this.INVERTCUBICMAP = false;\n    _this.LOGARITHMICDEPTH = false;\n    _this.REFRACTION = false;\n    _this.REFRACTIONMAP_3D = false;\n    _this.REFLECTIONOVERALPHA = false;\n    _this.TWOSIDEDLIGHTING = false;\n    _this.SHADOWFLOAT = false;\n    _this.MORPHTARGETS = false;\n    _this.MORPHTARGETS_NORMAL = false;\n    _this.MORPHTARGETS_TANGENT = false;\n    _this.MORPHTARGETS_UV = false;\n    _this.NUM_MORPH_INFLUENCERS = 0;\n    _this.NONUNIFORMSCALING = false; // https://playground.babylonjs.com#V6DWIH\n\n    _this.PREMULTIPLYALPHA = false; // https://playground.babylonjs.com#LNVJJ7\n\n    _this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;\n    _this.ALPHABLEND = true;\n    _this.PREPASS = false;\n    _this.PREPASS_IRRADIANCE = false;\n    _this.PREPASS_IRRADIANCE_INDEX = -1;\n    _this.PREPASS_ALBEDO = false;\n    _this.PREPASS_ALBEDO_INDEX = -1;\n    _this.PREPASS_DEPTHNORMAL = false;\n    _this.PREPASS_DEPTHNORMAL_INDEX = -1;\n    _this.PREPASS_POSITION = false;\n    _this.PREPASS_POSITION_INDEX = -1;\n    _this.PREPASS_VELOCITY = false;\n    _this.PREPASS_VELOCITY_INDEX = -1;\n    _this.PREPASS_REFLECTIVITY = false;\n    _this.PREPASS_REFLECTIVITY_INDEX = -1;\n    _this.SCENE_MRT_COUNT = 0;\n    _this.RGBDLIGHTMAP = false;\n    _this.RGBDREFLECTION = false;\n    _this.RGBDREFRACTION = false;\n    _this.IMAGEPROCESSING = false;\n    _this.VIGNETTE = false;\n    _this.VIGNETTEBLENDMODEMULTIPLY = false;\n    _this.VIGNETTEBLENDMODEOPAQUE = false;\n    _this.TONEMAPPING = false;\n    _this.TONEMAPPING_ACES = false;\n    _this.CONTRAST = false;\n    _this.COLORCURVES = false;\n    _this.COLORGRADING = false;\n    _this.COLORGRADING3D = false;\n    _this.SAMPLER3DGREENDEPTH = false;\n    _this.SAMPLER3DBGRMAP = false;\n    _this.IMAGEPROCESSINGPOSTPROCESS = false;\n    _this.MULTIVIEW = false;\n    /**\r\n     * If the reflection texture on this material is in linear color space\r\n     * @hidden\r\n     */\n\n    _this.IS_REFLECTION_LINEAR = false;\n    /**\r\n     * If the refraction texture on this material is in linear color space\r\n     * @hidden\r\n     */\n\n    _this.IS_REFRACTION_LINEAR = false;\n    _this.EXPOSURE = false;\n\n    _this.rebuild();\n\n    return _this;\n  }\n\n  StandardMaterialDefines.prototype.setReflectionMode = function (modeToEnable) {\n    var modes = [\"REFLECTIONMAP_CUBIC\", \"REFLECTIONMAP_EXPLICIT\", \"REFLECTIONMAP_PLANAR\", \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_SKYBOX\", \"REFLECTIONMAP_SPHERICAL\", \"REFLECTIONMAP_EQUIRECTANGULAR\", \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\", \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\"];\n\n    for (var _i = 0, modes_1 = modes; _i < modes_1.length; _i++) {\n      var mode = modes_1[_i];\n      this[mode] = mode === modeToEnable;\n    }\n  };\n\n  return StandardMaterialDefines;\n}(MaterialDefines);\n\nexport { StandardMaterialDefines };\n/**\r\n * This is the default material used in Babylon. It is the best trade off between quality\r\n * and performances.\r\n * @see https://doc.babylonjs.com/babylon101/materials\r\n */\n\nvar StandardMaterial =\n/** @class */\nfunction (_super) {\n  __extends(StandardMaterial, _super);\n  /**\r\n   * Instantiates a new standard material.\r\n   * This is the default material used in Babylon. It is the best trade off between quality\r\n   * and performances.\r\n   * @see https://doc.babylonjs.com/babylon101/materials\r\n   * @param name Define the name of the material in the scene\r\n   * @param scene Define the scene the material belong to\r\n   */\n\n\n  function StandardMaterial(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._diffuseTexture = null;\n    _this._ambientTexture = null;\n    _this._opacityTexture = null;\n    _this._reflectionTexture = null;\n    _this._emissiveTexture = null;\n    _this._specularTexture = null;\n    _this._bumpTexture = null;\n    _this._lightmapTexture = null;\n    _this._refractionTexture = null;\n    /**\r\n     * The color of the material lit by the environmental background lighting.\r\n     * @see https://doc.babylonjs.com/babylon101/materials#ambient-color-example\r\n     */\n\n    _this.ambientColor = new Color3(0, 0, 0);\n    /**\r\n     * The basic color of the material as viewed under a light.\r\n     */\n\n    _this.diffuseColor = new Color3(1, 1, 1);\n    /**\r\n     * Define how the color and intensity of the highlight given by the light in the material.\r\n     */\n\n    _this.specularColor = new Color3(1, 1, 1);\n    /**\r\n     * Define the color of the material as if self lit.\r\n     * This will be mixed in the final result even in the absence of light.\r\n     */\n\n    _this.emissiveColor = new Color3(0, 0, 0);\n    /**\r\n     * Defines how sharp are the highlights in the material.\r\n     * The bigger the value the sharper giving a more glossy feeling to the result.\r\n     * Reversely, the smaller the value the blurrier giving a more rough feeling to the result.\r\n     */\n\n    _this.specularPower = 64;\n    _this._useAlphaFromDiffuseTexture = false;\n    _this._useEmissiveAsIllumination = false;\n    _this._linkEmissiveWithDiffuse = false;\n    _this._useSpecularOverAlpha = false;\n    _this._useReflectionOverAlpha = false;\n    _this._disableLighting = false;\n    _this._useObjectSpaceNormalMap = false;\n    _this._useParallax = false;\n    _this._useParallaxOcclusion = false;\n    /**\r\n     * Apply a scaling factor that determine which \"depth\" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.\r\n     */\n\n    _this.parallaxScaleBias = 0.05;\n    _this._roughness = 0;\n    /**\r\n     * In case of refraction, define the value of the index of refraction.\r\n     * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n     */\n\n    _this.indexOfRefraction = 0.98;\n    /**\r\n     * Invert the refraction texture alongside the y axis.\r\n     * It can be useful with procedural textures or probe for instance.\r\n     * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions\r\n     */\n\n    _this.invertRefractionY = true;\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\n\n    _this.alphaCutOff = 0.4;\n    _this._useLightmapAsShadowmap = false;\n    _this._useReflectionFresnelFromSpecular = false;\n    _this._useGlossinessFromSpecularMapAlpha = false;\n    _this._maxSimultaneousLights = 4;\n    _this._invertNormalMapX = false;\n    _this._invertNormalMapY = false;\n    _this._twoSidedLighting = false;\n    /**\r\n     * Defines the detail map parameters for the material.\r\n     */\n\n    _this.detailMap = new DetailMapConfiguration(_this._markAllSubMeshesAsTexturesDirty.bind(_this));\n    _this._renderTargets = new SmartArray(16);\n    _this._worldViewProjectionMatrix = Matrix.Zero();\n    _this._globalAmbientColor = new Color3(0, 0, 0);\n    _this._rebuildInParallel = false; // Setup the default processing configuration to the scene.\n\n    _this._attachImageProcessingConfiguration(null);\n\n    _this.prePassConfiguration = new PrePassConfiguration();\n\n    _this.getRenderTargetTextures = function () {\n      _this._renderTargets.reset();\n\n      if (StandardMaterial.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {\n        _this._renderTargets.push(_this._reflectionTexture);\n      }\n\n      if (StandardMaterial.RefractionTextureEnabled && _this._refractionTexture && _this._refractionTexture.isRenderTarget) {\n        _this._renderTargets.push(_this._refractionTexture);\n      }\n\n      return _this._renderTargets;\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(StandardMaterial.prototype, \"imageProcessingConfiguration\", {\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration;\n    },\n\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\n    set: function set(value) {\n      this._attachImageProcessingConfiguration(value); // Ensure the effect will be rebuilt.\n\n\n      this._markAllSubMeshesAsTexturesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Attaches a new image processing configuration to the Standard Material.\r\n   * @param configuration\r\n   */\n\n  StandardMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\n    var _this = this;\n\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    } // Detaches observer\n\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    } // Pick the scene configuration if needed\n\n\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    } // Attaches observer\n\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {\n        _this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  };\n\n  Object.defineProperty(StandardMaterial.prototype, \"cameraColorCurvesEnabled\", {\n    /**\r\n     * Gets wether the color curves effect is enabled.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.colorCurvesEnabled;\n    },\n\n    /**\r\n     * Sets wether the color curves effect is enabled.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.colorCurvesEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial.prototype, \"cameraColorGradingEnabled\", {\n    /**\r\n     * Gets wether the color grading effect is enabled.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.colorGradingEnabled;\n    },\n\n    /**\r\n     * Gets wether the color grading effect is enabled.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.colorGradingEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial.prototype, \"cameraToneMappingEnabled\", {\n    /**\r\n     * Gets wether tonemapping is enabled or not.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration.toneMappingEnabled;\n    },\n\n    /**\r\n     * Sets wether tonemapping is enabled or not\r\n     */\n    set: function set(value) {\n      this._imageProcessingConfiguration.toneMappingEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial.prototype, \"cameraExposure\", {\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration.exposure;\n    },\n\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\n    set: function set(value) {\n      this._imageProcessingConfiguration.exposure = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial.prototype, \"cameraContrast\", {\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration.contrast;\n    },\n\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\n    set: function set(value) {\n      this._imageProcessingConfiguration.contrast = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial.prototype, \"cameraColorGradingTexture\", {\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration.colorGradingTexture;\n    },\n\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\n    set: function set(value) {\n      this._imageProcessingConfiguration.colorGradingTexture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial.prototype, \"cameraColorCurves\", {\n    /**\r\n     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration.colorCurves;\n    },\n\n    /**\r\n     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\n    set: function set(value) {\n      this._imageProcessingConfiguration.colorCurves = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial.prototype, \"canRenderToMRT\", {\n    /**\r\n     * Can this material render to several textures at once\r\n     */\n    get: function get() {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial.prototype, \"hasRenderTargetTextures\", {\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\n    get: function get() {\n      if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n        return true;\n      }\n\n      if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n        return true;\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current class name of the material e.g. \"StandardMaterial\"\r\n   * Mainly use in serialization.\r\n   * @returns the class name\r\n   */\n\n  StandardMaterial.prototype.getClassName = function () {\n    return \"StandardMaterial\";\n  };\n\n  Object.defineProperty(StandardMaterial.prototype, \"useLogarithmicDepth\", {\n    /**\r\n     * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n     * You can try switching to logarithmic depth.\r\n     * @see https://doc.babylonjs.com/how_to/using_logarithmic_depth_buffer\r\n     */\n    get: function get() {\n      return this._useLogarithmicDepth;\n    },\n    set: function set(value) {\n      this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n\n      this._markAllSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Specifies if the material will require alpha blending\r\n   * @returns a boolean specifying if alpha blending is needed\r\n   */\n\n  StandardMaterial.prototype.needAlphaBlending = function () {\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n\n    return this.alpha < 1.0 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\n  };\n  /**\r\n   * Specifies if this material should be rendered in alpha test mode\r\n   * @returns a boolean specifying if an alpha test is needed.\r\n   */\n\n\n  StandardMaterial.prototype.needAlphaTesting = function () {\n    if (this._forceAlphaTest) {\n      return true;\n    }\n\n    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);\n  };\n  /**\r\n   * Specifies whether or not the alpha value of the diffuse texture should be used for alpha blending.\r\n   */\n\n\n  StandardMaterial.prototype._shouldUseAlphaFromDiffuseTexture = function () {\n    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;\n  };\n  /**\r\n   * Specifies whether or not there is a usable alpha channel for transparency.\r\n   */\n\n\n  StandardMaterial.prototype._hasAlphaChannel = function () {\n    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;\n  };\n  /**\r\n   * Get the texture used for alpha test purpose.\r\n   * @returns the diffuse texture in case of the standard material.\r\n   */\n\n\n  StandardMaterial.prototype.getAlphaTestTexture = function () {\n    return this._diffuseTexture;\n  };\n  /**\r\n   * Get if the submesh is ready to be used and all its information available.\r\n   * Child classes can use it to update shaders\r\n   * @param mesh defines the mesh to check\r\n   * @param subMesh defines which submesh to check\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns a boolean indicating that the submesh is ready or not\r\n   */\n\n\n  StandardMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    if (subMesh.effect && this.isFrozen) {\n      if (subMesh.effect._wasPreviouslyReady) {\n        return true;\n      }\n    }\n\n    if (!subMesh._materialDefines) {\n      subMesh._materialDefines = new StandardMaterialDefines();\n    }\n\n    var scene = this.getScene();\n    var defines = subMesh._materialDefines;\n\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n\n    var engine = scene.getEngine(); // Lights\n\n    defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting); // Multiview\n\n    MaterialHelper.PrepareDefinesForMultiview(scene, defines); // PrePass\n\n    MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT); // Textures\n\n    if (defines._areTexturesDirty) {\n      defines._needUVs = false;\n      defines.MAINUV1 = false;\n      defines.MAINUV2 = false;\n\n      if (scene.texturesEnabled) {\n        if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n          if (!this._diffuseTexture.isReadyOrNotBlocking()) {\n            return false;\n          } else {\n            MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\n          }\n        } else {\n          defines.DIFFUSE = false;\n        }\n\n        if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n          if (!this._ambientTexture.isReadyOrNotBlocking()) {\n            return false;\n          } else {\n            MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\n          }\n        } else {\n          defines.AMBIENT = false;\n        }\n\n        if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n          if (!this._opacityTexture.isReadyOrNotBlocking()) {\n            return false;\n          } else {\n            MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\n            defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\n          }\n        } else {\n          defines.OPACITY = false;\n        }\n\n        if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n          if (!this._reflectionTexture.isReadyOrNotBlocking()) {\n            return false;\n          } else {\n            defines._needNormals = true;\n            defines.REFLECTION = true;\n            defines.ROUGHNESS = this._roughness > 0;\n            defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;\n            defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\n            defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;\n            defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;\n\n            switch (this._reflectionTexture.coordinatesMode) {\n              case Texture.EXPLICIT_MODE:\n                defines.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\n                break;\n\n              case Texture.PLANAR_MODE:\n                defines.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\n                break;\n\n              case Texture.PROJECTION_MODE:\n                defines.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\n                break;\n\n              case Texture.SKYBOX_MODE:\n                defines.setReflectionMode(\"REFLECTIONMAP_SKYBOX\");\n                break;\n\n              case Texture.SPHERICAL_MODE:\n                defines.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\n                break;\n\n              case Texture.EQUIRECTANGULAR_MODE:\n                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n                break;\n\n              case Texture.FIXED_EQUIRECTANGULAR_MODE:\n                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n                break;\n\n              case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                defines.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n                break;\n\n              case Texture.CUBIC_MODE:\n              case Texture.INVCUBIC_MODE:\n              default:\n                defines.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\n                break;\n            }\n\n            defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;\n          }\n        } else {\n          defines.REFLECTION = false;\n        }\n\n        if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n          if (!this._emissiveTexture.isReadyOrNotBlocking()) {\n            return false;\n          } else {\n            MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\n          }\n        } else {\n          defines.EMISSIVE = false;\n        }\n\n        if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n          if (!this._lightmapTexture.isReadyOrNotBlocking()) {\n            return false;\n          } else {\n            MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\n            defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\n            defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\n          }\n        } else {\n          defines.LIGHTMAP = false;\n        }\n\n        if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n          if (!this._specularTexture.isReadyOrNotBlocking()) {\n            return false;\n          } else {\n            MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, \"SPECULAR\");\n            defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\n          }\n        } else {\n          defines.SPECULAR = false;\n        }\n\n        if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {\n          // Bump texure can not be not blocking.\n          if (!this._bumpTexture.isReady()) {\n            return false;\n          } else {\n            MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\n            defines.PARALLAX = this._useParallax;\n            defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;\n          }\n\n          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\n        } else {\n          defines.BUMP = false;\n        }\n\n        if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n          if (!this._refractionTexture.isReadyOrNotBlocking()) {\n            return false;\n          } else {\n            defines._needUVs = true;\n            defines.REFRACTION = true;\n            defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;\n            defines.RGBDREFRACTION = this._refractionTexture.isRGBD;\n          }\n        } else {\n          defines.REFRACTION = false;\n        }\n\n        defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\n      } else {\n        defines.DIFFUSE = false;\n        defines.AMBIENT = false;\n        defines.OPACITY = false;\n        defines.REFLECTION = false;\n        defines.EMISSIVE = false;\n        defines.LIGHTMAP = false;\n        defines.BUMP = false;\n        defines.REFRACTION = false;\n      }\n\n      defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();\n      defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;\n      defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;\n      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\n      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;\n      defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;\n      defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh); // check on null for backward compatibility\n    }\n\n    if (!this.detailMap.isReadyForSubMesh(defines, scene)) {\n      return false;\n    }\n\n    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n      if (!this._imageProcessingConfiguration.isReady()) {\n        return false;\n      }\n\n      this._imageProcessingConfiguration.prepareDefines(defines);\n\n      defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;\n      defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;\n    }\n\n    if (defines._areFresnelDirty) {\n      if (StandardMaterial.FresnelEnabled) {\n        // Fresnel\n        if (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) {\n          defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;\n          defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\n          defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;\n          defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;\n          defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;\n          defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;\n          defines._needNormals = true;\n          defines.FRESNEL = true;\n        }\n      } else {\n        defines.FRESNEL = false;\n      }\n    } // Misc.\n\n\n    MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines); // Attribs\n\n    MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true); // Values that need to be evaluated on every frame\n\n    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances); // External config\n\n    this.detailMap.prepareDefines(defines, scene); // Get correct effect\n\n    if (defines.isDirty) {\n      var lightDisposed = defines._areLightsDisposed;\n      defines.markAsProcessed(); // Fallbacks\n\n      var fallbacks = new EffectFallbacks();\n\n      if (defines.REFLECTION) {\n        fallbacks.addFallback(0, \"REFLECTION\");\n      }\n\n      if (defines.SPECULAR) {\n        fallbacks.addFallback(0, \"SPECULAR\");\n      }\n\n      if (defines.BUMP) {\n        fallbacks.addFallback(0, \"BUMP\");\n      }\n\n      if (defines.PARALLAX) {\n        fallbacks.addFallback(1, \"PARALLAX\");\n      }\n\n      if (defines.PARALLAXOCCLUSION) {\n        fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\n      }\n\n      if (defines.SPECULAROVERALPHA) {\n        fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\n      }\n\n      if (defines.FOG) {\n        fallbacks.addFallback(1, \"FOG\");\n      }\n\n      if (defines.POINTSIZE) {\n        fallbacks.addFallback(0, \"POINTSIZE\");\n      }\n\n      if (defines.LOGARITHMICDEPTH) {\n        fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\n      }\n\n      MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\n\n      if (defines.SPECULARTERM) {\n        fallbacks.addFallback(0, \"SPECULARTERM\");\n      }\n\n      if (defines.DIFFUSEFRESNEL) {\n        fallbacks.addFallback(1, \"DIFFUSEFRESNEL\");\n      }\n\n      if (defines.OPACITYFRESNEL) {\n        fallbacks.addFallback(2, \"OPACITYFRESNEL\");\n      }\n\n      if (defines.REFLECTIONFRESNEL) {\n        fallbacks.addFallback(3, \"REFLECTIONFRESNEL\");\n      }\n\n      if (defines.EMISSIVEFRESNEL) {\n        fallbacks.addFallback(4, \"EMISSIVEFRESNEL\");\n      }\n\n      if (defines.FRESNEL) {\n        fallbacks.addFallback(4, \"FRESNEL\");\n      }\n\n      if (defines.MULTIVIEW) {\n        fallbacks.addFallback(0, \"MULTIVIEW\");\n      } //Attributes\n\n\n      var attribs = [VertexBuffer.PositionKind];\n\n      if (defines.NORMAL) {\n        attribs.push(VertexBuffer.NormalKind);\n      }\n\n      if (defines.UV1) {\n        attribs.push(VertexBuffer.UVKind);\n      }\n\n      if (defines.UV2) {\n        attribs.push(VertexBuffer.UV2Kind);\n      }\n\n      if (defines.VERTEXCOLOR) {\n        attribs.push(VertexBuffer.ColorKind);\n      }\n\n      MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n      MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n      MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\n      var shaderName = \"default\";\n      var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vDiffuseColor\", \"vSpecularColor\", \"vEmissiveColor\", \"visibility\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"vDiffuseInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vEmissiveInfos\", \"vSpecularInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"vRefractionInfos\", \"mBones\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"specularMatrix\", \"bumpMatrix\", \"normalMatrix\", \"lightmapMatrix\", \"refractionMatrix\", \"diffuseLeftColor\", \"diffuseRightColor\", \"opacityParts\", \"reflectionLeftColor\", \"reflectionRightColor\", \"emissiveLeftColor\", \"emissiveRightColor\", \"refractionLeftColor\", \"refractionRightColor\", \"vReflectionPosition\", \"vReflectionSize\", \"logarithmicDepthConstant\", \"vTangentSpaceParams\", \"alphaCutOff\", \"boneTextureWidth\"];\n      var samplers = [\"diffuseSampler\", \"ambientSampler\", \"opacitySampler\", \"reflectionCubeSampler\", \"reflection2DSampler\", \"emissiveSampler\", \"specularSampler\", \"bumpSampler\", \"lightmapSampler\", \"refractionCubeSampler\", \"refraction2DSampler\", \"boneSampler\"];\n      var uniformBuffers = [\"Material\", \"Scene\"];\n      DetailMapConfiguration.AddUniforms(uniforms);\n      DetailMapConfiguration.AddSamplers(samplers);\n      PrePassConfiguration.AddUniforms(uniforms);\n      PrePassConfiguration.AddSamplers(uniforms);\n\n      if (ImageProcessingConfiguration) {\n        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n      }\n\n      MaterialHelper.PrepareUniformsAndSamplersList({\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: defines,\n        maxSimultaneousLights: this._maxSimultaneousLights\n      });\n      var csnrOptions = {};\n\n      if (this.customShaderNameResolve) {\n        shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\n      }\n\n      var join = defines.toString();\n      var previousEffect = subMesh.effect;\n      var effect = scene.getEngine().createEffect(shaderName, {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: join,\n        fallbacks: fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousLights: this._maxSimultaneousLights,\n          maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n        },\n        processFinalCode: csnrOptions.processFinalCode,\n        multiTarget: defines.PREPASS\n      }, engine);\n\n      if (effect) {\n        if (this._onEffectCreatedObservable) {\n          onCreatedEffectParameters.effect = effect;\n          onCreatedEffectParameters.subMesh = subMesh;\n\n          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n        } // Use previous effect while new one is compiling\n\n\n        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n          effect = previousEffect;\n          this._rebuildInParallel = true;\n          defines.markAsUnprocessed();\n\n          if (lightDisposed) {\n            // re register in case it takes more than one frame.\n            defines._areLightsDisposed = true;\n            return false;\n          }\n        } else {\n          this._rebuildInParallel = false;\n          scene.resetCachedMaterial();\n          subMesh.setEffect(effect, defines);\n          this.buildUniformLayout();\n        }\n      }\n    }\n\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    return true;\n  };\n  /**\r\n   * Builds the material UBO layouts.\r\n   * Used internally during the effect preparation.\r\n   */\n\n\n  StandardMaterial.prototype.buildUniformLayout = function () {\n    // Order is important !\n    var ubo = this._uniformBuffer;\n    ubo.addUniform(\"diffuseLeftColor\", 4);\n    ubo.addUniform(\"diffuseRightColor\", 4);\n    ubo.addUniform(\"opacityParts\", 4);\n    ubo.addUniform(\"reflectionLeftColor\", 4);\n    ubo.addUniform(\"reflectionRightColor\", 4);\n    ubo.addUniform(\"refractionLeftColor\", 4);\n    ubo.addUniform(\"refractionRightColor\", 4);\n    ubo.addUniform(\"emissiveLeftColor\", 4);\n    ubo.addUniform(\"emissiveRightColor\", 4);\n    ubo.addUniform(\"vDiffuseInfos\", 2);\n    ubo.addUniform(\"vAmbientInfos\", 2);\n    ubo.addUniform(\"vOpacityInfos\", 2);\n    ubo.addUniform(\"vReflectionInfos\", 2);\n    ubo.addUniform(\"vReflectionPosition\", 3);\n    ubo.addUniform(\"vReflectionSize\", 3);\n    ubo.addUniform(\"vEmissiveInfos\", 2);\n    ubo.addUniform(\"vLightmapInfos\", 2);\n    ubo.addUniform(\"vSpecularInfos\", 2);\n    ubo.addUniform(\"vBumpInfos\", 3);\n    ubo.addUniform(\"diffuseMatrix\", 16);\n    ubo.addUniform(\"ambientMatrix\", 16);\n    ubo.addUniform(\"opacityMatrix\", 16);\n    ubo.addUniform(\"reflectionMatrix\", 16);\n    ubo.addUniform(\"emissiveMatrix\", 16);\n    ubo.addUniform(\"lightmapMatrix\", 16);\n    ubo.addUniform(\"specularMatrix\", 16);\n    ubo.addUniform(\"bumpMatrix\", 16);\n    ubo.addUniform(\"vTangentSpaceParams\", 2);\n    ubo.addUniform(\"pointSize\", 1);\n    ubo.addUniform(\"refractionMatrix\", 16);\n    ubo.addUniform(\"vRefractionInfos\", 4);\n    ubo.addUniform(\"vSpecularColor\", 4);\n    ubo.addUniform(\"vEmissiveColor\", 3);\n    ubo.addUniform(\"visibility\", 1);\n    ubo.addUniform(\"vDiffuseColor\", 4);\n    DetailMapConfiguration.PrepareUniformBuffer(ubo);\n    ubo.create();\n  };\n  /**\r\n   * Unbinds the material from the mesh\r\n   */\n\n\n  StandardMaterial.prototype.unbind = function () {\n    if (this._activeEffect) {\n      var needFlag = false;\n\n      if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n        this._activeEffect.setTexture(\"reflection2DSampler\", null);\n\n        needFlag = true;\n      }\n\n      if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\n        this._activeEffect.setTexture(\"refraction2DSampler\", null);\n\n        needFlag = true;\n      }\n\n      if (needFlag) {\n        this._markAllSubMeshesAsTexturesDirty();\n      }\n    }\n\n    _super.prototype.unbind.call(this);\n  };\n  /**\r\n   * Binds the submesh to this material by preparing the effect and shader to draw\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh containing the submesh\r\n   * @param subMesh defines the submesh to bind the material to\r\n   */\n\n\n  StandardMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n    var scene = this.getScene();\n    var defines = subMesh._materialDefines;\n\n    if (!defines) {\n      return;\n    }\n\n    var effect = subMesh.effect;\n\n    if (!effect) {\n      return;\n    }\n\n    this._activeEffect = effect; // Matrices\n\n    if (!defines.INSTANCES || defines.THIN_INSTANCES) {\n      this.bindOnlyWorldMatrix(world);\n    } // PrePass\n\n\n    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen); // Normal Matrix\n\n    if (defines.OBJECTSPACE_NORMALMAP) {\n      world.toNormalMatrix(this._normalMatrix);\n      this.bindOnlyNormalMatrix(this._normalMatrix);\n    }\n\n    var mustRebind = this._mustRebind(scene, effect, mesh.visibility); // Bones\n\n\n    MaterialHelper.BindBonesParameters(mesh, effect);\n    var ubo = this._uniformBuffer;\n\n    if (mustRebind) {\n      ubo.bindToEffect(effect, \"Material\");\n      this.bindViewProjection(effect);\n\n      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {\n        if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {\n          // Fresnel\n          if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {\n            ubo.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);\n            ubo.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);\n          }\n\n          if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {\n            ubo.updateColor4(\"opacityParts\", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);\n          }\n\n          if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {\n            ubo.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);\n            ubo.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);\n          }\n\n          if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {\n            ubo.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);\n            ubo.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);\n          }\n\n          if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {\n            ubo.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);\n            ubo.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);\n          }\n        } // Textures\n\n\n        if (scene.texturesEnabled) {\n          if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n            ubo.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\n            MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, \"diffuse\");\n          }\n\n          if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n            ubo.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);\n            MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\n          }\n\n          if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n            ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\n            MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\n          }\n\n          if (this._hasAlphaChannel()) {\n            effect.setFloat(\"alphaCutOff\", this.alphaCutOff);\n          }\n\n          if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n            ubo.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness);\n            ubo.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix());\n\n            if (this._reflectionTexture.boundingBoxSize) {\n              var cubeTexture = this._reflectionTexture;\n              ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\n              ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\n            }\n          }\n\n          if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n            ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\n            MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\n          }\n\n          if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n            ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\n            MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\n          }\n\n          if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n            ubo.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level);\n            MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, \"specular\");\n          }\n\n          if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\n            ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1.0 / this._bumpTexture.level, this.parallaxScaleBias);\n            MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\n\n            if (scene._mirroredCameraPosition) {\n              ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\n            } else {\n              ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\n            }\n          }\n\n          if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n            var depth = 1.0;\n\n            if (!this._refractionTexture.isCube) {\n              ubo.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix());\n\n              if (this._refractionTexture.depth) {\n                depth = this._refractionTexture.depth;\n              }\n            }\n\n            ubo.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n          }\n        } // Point size\n\n\n        if (this.pointsCloud) {\n          ubo.updateFloat(\"pointSize\", this.pointSize);\n        }\n\n        if (defines.SPECULARTERM) {\n          ubo.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\n        }\n\n        ubo.updateColor3(\"vEmissiveColor\", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly); // Diffuse\n\n        ubo.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha);\n      } // Visibility\n\n\n      ubo.updateFloat(\"visibility\", mesh.visibility); // Textures\n\n      if (scene.texturesEnabled) {\n        if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n          effect.setTexture(\"diffuseSampler\", this._diffuseTexture);\n        }\n\n        if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n          effect.setTexture(\"ambientSampler\", this._ambientTexture);\n        }\n\n        if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n          effect.setTexture(\"opacitySampler\", this._opacityTexture);\n        }\n\n        if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n          if (this._reflectionTexture.isCube) {\n            effect.setTexture(\"reflectionCubeSampler\", this._reflectionTexture);\n          } else {\n            effect.setTexture(\"reflection2DSampler\", this._reflectionTexture);\n          }\n        }\n\n        if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n          effect.setTexture(\"emissiveSampler\", this._emissiveTexture);\n        }\n\n        if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n          effect.setTexture(\"lightmapSampler\", this._lightmapTexture);\n        }\n\n        if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n          effect.setTexture(\"specularSampler\", this._specularTexture);\n        }\n\n        if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\n          effect.setTexture(\"bumpSampler\", this._bumpTexture);\n        }\n\n        if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n          var depth = 1.0;\n\n          if (this._refractionTexture.isCube) {\n            effect.setTexture(\"refractionCubeSampler\", this._refractionTexture);\n          } else {\n            effect.setTexture(\"refraction2DSampler\", this._refractionTexture);\n          }\n        }\n      }\n\n      this.detailMap.bindForSubMesh(ubo, scene, this.isFrozen); // Clip plane\n\n      MaterialHelper.BindClipPlane(effect, scene); // Colors\n\n      scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);\n      MaterialHelper.BindEyePosition(effect, scene);\n      effect.setColor3(\"vAmbientColor\", this._globalAmbientColor);\n    }\n\n    if (mustRebind || !this.isFrozen) {\n      // Lights\n      if (scene.lightsEnabled && !this._disableLighting) {\n        MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights, this._rebuildInParallel);\n      } // View\n\n\n      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture) {\n        this.bindView(effect);\n      } // Fog\n\n\n      MaterialHelper.BindFogParameters(scene, mesh, effect); // Morph targets\n\n      if (defines.NUM_MORPH_INFLUENCERS) {\n        MaterialHelper.BindMorphTargetParameters(mesh, effect);\n      } // Log. depth\n\n\n      if (this.useLogarithmicDepth) {\n        MaterialHelper.BindLogDepth(defines, effect, scene);\n      } // image processing\n\n\n      if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n        this._imageProcessingConfiguration.bind(this._activeEffect);\n      }\n    }\n\n    ubo.update();\n\n    this._afterBind(mesh, this._activeEffect);\n  };\n  /**\r\n   * Get the list of animatables in the material.\r\n   * @returns the list of animatables object used in the material\r\n   */\n\n\n  StandardMaterial.prototype.getAnimatables = function () {\n    var results = [];\n\n    if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\n      results.push(this._diffuseTexture);\n    }\n\n    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\n      results.push(this._ambientTexture);\n    }\n\n    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\n      results.push(this._opacityTexture);\n    }\n\n    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\n      results.push(this._reflectionTexture);\n    }\n\n    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\n      results.push(this._emissiveTexture);\n    }\n\n    if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {\n      results.push(this._specularTexture);\n    }\n\n    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\n      results.push(this._bumpTexture);\n    }\n\n    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\n      results.push(this._lightmapTexture);\n    }\n\n    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n      results.push(this._refractionTexture);\n    }\n\n    this.detailMap.getAnimatables(results);\n    return results;\n  };\n  /**\r\n   * Gets the active textures from the material\r\n   * @returns an array of textures\r\n   */\n\n\n  StandardMaterial.prototype.getActiveTextures = function () {\n    var activeTextures = _super.prototype.getActiveTextures.call(this);\n\n    if (this._diffuseTexture) {\n      activeTextures.push(this._diffuseTexture);\n    }\n\n    if (this._ambientTexture) {\n      activeTextures.push(this._ambientTexture);\n    }\n\n    if (this._opacityTexture) {\n      activeTextures.push(this._opacityTexture);\n    }\n\n    if (this._reflectionTexture) {\n      activeTextures.push(this._reflectionTexture);\n    }\n\n    if (this._emissiveTexture) {\n      activeTextures.push(this._emissiveTexture);\n    }\n\n    if (this._specularTexture) {\n      activeTextures.push(this._specularTexture);\n    }\n\n    if (this._bumpTexture) {\n      activeTextures.push(this._bumpTexture);\n    }\n\n    if (this._lightmapTexture) {\n      activeTextures.push(this._lightmapTexture);\n    }\n\n    if (this._refractionTexture) {\n      activeTextures.push(this._refractionTexture);\n    }\n\n    this.detailMap.getActiveTextures(activeTextures);\n    return activeTextures;\n  };\n  /**\r\n   * Specifies if the material uses a texture\r\n   * @param texture defines the texture to check against the material\r\n   * @returns a boolean specifying if the material uses the texture\r\n   */\n\n\n  StandardMaterial.prototype.hasTexture = function (texture) {\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    if (this._diffuseTexture === texture) {\n      return true;\n    }\n\n    if (this._ambientTexture === texture) {\n      return true;\n    }\n\n    if (this._opacityTexture === texture) {\n      return true;\n    }\n\n    if (this._reflectionTexture === texture) {\n      return true;\n    }\n\n    if (this._emissiveTexture === texture) {\n      return true;\n    }\n\n    if (this._specularTexture === texture) {\n      return true;\n    }\n\n    if (this._bumpTexture === texture) {\n      return true;\n    }\n\n    if (this._lightmapTexture === texture) {\n      return true;\n    }\n\n    if (this._refractionTexture === texture) {\n      return true;\n    }\n\n    return this.detailMap.hasTexture(texture);\n  };\n  /**\r\n   * Disposes the material\r\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n   */\n\n\n  StandardMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n    if (forceDisposeTextures) {\n      (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n      (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();\n      (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();\n      (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();\n      (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();\n      (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();\n      (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();\n      (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();\n    }\n\n    this.detailMap.dispose(forceDisposeTextures);\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\n  };\n  /**\r\n   * Makes a duplicate of the material, and gives it a new name\r\n   * @param name defines the new name for the duplicated material\r\n   * @returns the cloned material\r\n   */\n\n\n  StandardMaterial.prototype.clone = function (name) {\n    var _this = this;\n\n    var result = SerializationHelper.Clone(function () {\n      return new StandardMaterial(name, _this.getScene());\n    }, this);\n    result.name = name;\n    result.id = name;\n    return result;\n  };\n  /**\r\n   * Serializes this material in a JSON representation\r\n   * @returns the serialized material object\r\n   */\n\n\n  StandardMaterial.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Creates a standard material from parsed material data\r\n   * @param source defines the JSON representation of the material\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a new standard material\r\n   */\n\n\n  StandardMaterial.Parse = function (source, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new StandardMaterial(source.name, scene);\n    }, source, scene, rootUrl);\n  };\n\n  Object.defineProperty(StandardMaterial, \"DiffuseTextureEnabled\", {\n    // Flags used to enable or disable a type of texture for all Standard Materials\n\n    /**\r\n     * Are diffuse textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.DiffuseTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.DiffuseTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"DetailTextureEnabled\", {\n    /**\r\n     * Are detail textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.DetailTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.DetailTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"AmbientTextureEnabled\", {\n    /**\r\n     * Are ambient textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.AmbientTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.AmbientTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"OpacityTextureEnabled\", {\n    /**\r\n     * Are opacity textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.OpacityTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.OpacityTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"ReflectionTextureEnabled\", {\n    /**\r\n     * Are reflection textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.ReflectionTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.ReflectionTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"EmissiveTextureEnabled\", {\n    /**\r\n     * Are emissive textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.EmissiveTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.EmissiveTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"SpecularTextureEnabled\", {\n    /**\r\n     * Are specular textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.SpecularTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.SpecularTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"BumpTextureEnabled\", {\n    /**\r\n     * Are bump textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.BumpTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.BumpTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"LightmapTextureEnabled\", {\n    /**\r\n     * Are lightmap textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.LightmapTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.LightmapTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"RefractionTextureEnabled\", {\n    /**\r\n     * Are refraction textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.RefractionTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.RefractionTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"ColorGradingTextureEnabled\", {\n    /**\r\n     * Are color grading textures enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.ColorGradingTextureEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.ColorGradingTextureEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardMaterial, \"FresnelEnabled\", {\n    /**\r\n     * Are fresnels enabled in the application.\r\n     */\n    get: function get() {\n      return MaterialFlags.FresnelEnabled;\n    },\n    set: function set(value) {\n      MaterialFlags.FresnelEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  __decorate([serializeAsTexture(\"diffuseTexture\")], StandardMaterial.prototype, \"_diffuseTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], StandardMaterial.prototype, \"diffuseTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"ambientTexture\")], StandardMaterial.prototype, \"_ambientTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"ambientTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"opacityTexture\")], StandardMaterial.prototype, \"_opacityTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], StandardMaterial.prototype, \"opacityTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"reflectionTexture\")], StandardMaterial.prototype, \"_reflectionTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"reflectionTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"emissiveTexture\")], StandardMaterial.prototype, \"_emissiveTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"emissiveTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"specularTexture\")], StandardMaterial.prototype, \"_specularTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"specularTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"bumpTexture\")], StandardMaterial.prototype, \"_bumpTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"bumpTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"lightmapTexture\")], StandardMaterial.prototype, \"_lightmapTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"lightmapTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"refractionTexture\")], StandardMaterial.prototype, \"_refractionTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"refractionTexture\", void 0);\n\n  __decorate([serializeAsColor3(\"ambient\")], StandardMaterial.prototype, \"ambientColor\", void 0);\n\n  __decorate([serializeAsColor3(\"diffuse\")], StandardMaterial.prototype, \"diffuseColor\", void 0);\n\n  __decorate([serializeAsColor3(\"specular\")], StandardMaterial.prototype, \"specularColor\", void 0);\n\n  __decorate([serializeAsColor3(\"emissive\")], StandardMaterial.prototype, \"emissiveColor\", void 0);\n\n  __decorate([serialize()], StandardMaterial.prototype, \"specularPower\", void 0);\n\n  __decorate([serialize(\"useAlphaFromDiffuseTexture\")], StandardMaterial.prototype, \"_useAlphaFromDiffuseTexture\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], StandardMaterial.prototype, \"useAlphaFromDiffuseTexture\", void 0);\n\n  __decorate([serialize(\"useEmissiveAsIllumination\")], StandardMaterial.prototype, \"_useEmissiveAsIllumination\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"useEmissiveAsIllumination\", void 0);\n\n  __decorate([serialize(\"linkEmissiveWithDiffuse\")], StandardMaterial.prototype, \"_linkEmissiveWithDiffuse\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"linkEmissiveWithDiffuse\", void 0);\n\n  __decorate([serialize(\"useSpecularOverAlpha\")], StandardMaterial.prototype, \"_useSpecularOverAlpha\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"useSpecularOverAlpha\", void 0);\n\n  __decorate([serialize(\"useReflectionOverAlpha\")], StandardMaterial.prototype, \"_useReflectionOverAlpha\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"useReflectionOverAlpha\", void 0);\n\n  __decorate([serialize(\"disableLighting\")], StandardMaterial.prototype, \"_disableLighting\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], StandardMaterial.prototype, \"disableLighting\", void 0);\n\n  __decorate([serialize(\"useObjectSpaceNormalMap\")], StandardMaterial.prototype, \"_useObjectSpaceNormalMap\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"useObjectSpaceNormalMap\", void 0);\n\n  __decorate([serialize(\"useParallax\")], StandardMaterial.prototype, \"_useParallax\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"useParallax\", void 0);\n\n  __decorate([serialize(\"useParallaxOcclusion\")], StandardMaterial.prototype, \"_useParallaxOcclusion\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"useParallaxOcclusion\", void 0);\n\n  __decorate([serialize()], StandardMaterial.prototype, \"parallaxScaleBias\", void 0);\n\n  __decorate([serialize(\"roughness\")], StandardMaterial.prototype, \"_roughness\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"roughness\", void 0);\n\n  __decorate([serialize()], StandardMaterial.prototype, \"indexOfRefraction\", void 0);\n\n  __decorate([serialize()], StandardMaterial.prototype, \"invertRefractionY\", void 0);\n\n  __decorate([serialize()], StandardMaterial.prototype, \"alphaCutOff\", void 0);\n\n  __decorate([serialize(\"useLightmapAsShadowmap\")], StandardMaterial.prototype, \"_useLightmapAsShadowmap\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\n\n  __decorate([serializeAsFresnelParameters(\"diffuseFresnelParameters\")], StandardMaterial.prototype, \"_diffuseFresnelParameters\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], StandardMaterial.prototype, \"diffuseFresnelParameters\", void 0);\n\n  __decorate([serializeAsFresnelParameters(\"opacityFresnelParameters\")], StandardMaterial.prototype, \"_opacityFresnelParameters\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsFresnelAndMiscDirty\")], StandardMaterial.prototype, \"opacityFresnelParameters\", void 0);\n\n  __decorate([serializeAsFresnelParameters(\"reflectionFresnelParameters\")], StandardMaterial.prototype, \"_reflectionFresnelParameters\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], StandardMaterial.prototype, \"reflectionFresnelParameters\", void 0);\n\n  __decorate([serializeAsFresnelParameters(\"refractionFresnelParameters\")], StandardMaterial.prototype, \"_refractionFresnelParameters\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], StandardMaterial.prototype, \"refractionFresnelParameters\", void 0);\n\n  __decorate([serializeAsFresnelParameters(\"emissiveFresnelParameters\")], StandardMaterial.prototype, \"_emissiveFresnelParameters\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], StandardMaterial.prototype, \"emissiveFresnelParameters\", void 0);\n\n  __decorate([serialize(\"useReflectionFresnelFromSpecular\")], StandardMaterial.prototype, \"_useReflectionFresnelFromSpecular\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], StandardMaterial.prototype, \"useReflectionFresnelFromSpecular\", void 0);\n\n  __decorate([serialize(\"useGlossinessFromSpecularMapAlpha\")], StandardMaterial.prototype, \"_useGlossinessFromSpecularMapAlpha\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"useGlossinessFromSpecularMapAlpha\", void 0);\n\n  __decorate([serialize(\"maxSimultaneousLights\")], StandardMaterial.prototype, \"_maxSimultaneousLights\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], StandardMaterial.prototype, \"maxSimultaneousLights\", void 0);\n\n  __decorate([serialize(\"invertNormalMapX\")], StandardMaterial.prototype, \"_invertNormalMapX\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"invertNormalMapX\", void 0);\n\n  __decorate([serialize(\"invertNormalMapY\")], StandardMaterial.prototype, \"_invertNormalMapY\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"invertNormalMapY\", void 0);\n\n  __decorate([serialize(\"twoSidedLighting\")], StandardMaterial.prototype, \"_twoSidedLighting\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], StandardMaterial.prototype, \"twoSidedLighting\", void 0);\n\n  __decorate([serialize()], StandardMaterial.prototype, \"useLogarithmicDepth\", null);\n\n  return StandardMaterial;\n}(PushMaterial);\n\nexport { StandardMaterial };\n_TypeStore.RegisteredTypes[\"BABYLON.StandardMaterial\"] = StandardMaterial;\n\nScene.DefaultMaterialFactory = function (scene) {\n  return new StandardMaterial(\"default material\", scene);\n};","map":null,"metadata":{},"sourceType":"module"}