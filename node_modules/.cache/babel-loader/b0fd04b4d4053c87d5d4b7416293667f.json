{"ast":null,"code":"import { Camera } from \"../Cameras/camera\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { EffectLayer } from \"./effectLayer\";\nimport { AbstractScene } from \"../abstractScene\"; // Adds the parser to the scene parsers.\n\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, function (parsedData, scene, container, rootUrl) {\n  if (parsedData.effectLayers) {\n    if (!container.effectLayers) {\n      container.effectLayers = new Array();\n    }\n\n    for (var index = 0; index < parsedData.effectLayers.length; index++) {\n      var effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\n      container.effectLayers.push(effectLayer);\n    }\n  }\n});\n\nAbstractScene.prototype.removeEffectLayer = function (toRemove) {\n  var index = this.effectLayers.indexOf(toRemove);\n\n  if (index !== -1) {\n    this.effectLayers.splice(index, 1);\n  }\n\n  return index;\n};\n\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer) {\n  this.effectLayers.push(newEffectLayer);\n};\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\n\n\nvar EffectLayerSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function EffectLayerSceneComponent(scene) {\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_EFFECTLAYER;\n    this._renderEffects = false;\n    this._needStencil = false;\n    this._previousStencilState = false;\n    this.scene = scene;\n    this._engine = scene.getEngine();\n    scene.effectLayers = new Array();\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.register = function () {\n    this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\n\n    this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\n\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\n\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.rebuild = function () {\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {\n      var effectLayer = layers_1[_i];\n\n      effectLayer._rebuild();\n    }\n  };\n  /**\r\n   * Serializes the component data to the specified json object\r\n   * @param serializationObject The object to serialize to\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.serialize = function (serializationObject) {\n    // Effect layers\n    serializationObject.effectLayers = [];\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {\n      var effectLayer = layers_2[_i];\n\n      if (effectLayer.serialize) {\n        serializationObject.effectLayers.push(effectLayer.serialize());\n      }\n    }\n  };\n  /**\r\n   * Adds all the elements from the container to the scene\r\n   * @param container the container holding the elements\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.addFromContainer = function (container) {\n    var _this = this;\n\n    if (!container.effectLayers) {\n      return;\n    }\n\n    container.effectLayers.forEach(function (o) {\n      _this.scene.addEffectLayer(o);\n    });\n  };\n  /**\r\n   * Removes all the elements in the container from the scene\r\n   * @param container contains the elements to remove\r\n   * @param dispose if the removed element should be disposed (default: false)\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.removeFromContainer = function (container, dispose) {\n    var _this = this;\n\n    if (!container.effectLayers) {\n      return;\n    }\n\n    container.effectLayers.forEach(function (o) {\n      _this.scene.removeEffectLayer(o);\n\n      if (dispose) {\n        o.dispose();\n      }\n    });\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.dispose = function () {\n    var layers = this.scene.effectLayers;\n\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._isReadyForMesh = function (mesh, hardwareInstancedRendering) {\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_3 = layers; _i < layers_3.length; _i++) {\n      var layer = layers_3[_i];\n\n      if (!layer.hasMesh(mesh)) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  EffectLayerSceneComponent.prototype._renderMainTexture = function (camera) {\n    this._renderEffects = false;\n    this._needStencil = false;\n    var needRebind = false;\n    var layers = this.scene.effectLayers;\n\n    if (layers && layers.length > 0) {\n      this._previousStencilState = this._engine.getStencilBuffer();\n\n      for (var _i = 0, layers_4 = layers; _i < layers_4.length; _i++) {\n        var effectLayer = layers_4[_i];\n\n        if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {\n          this._renderEffects = true;\n          this._needStencil = this._needStencil || effectLayer.needStencil();\n          var renderTarget = effectLayer._mainTexture;\n\n          if (renderTarget._shouldRender()) {\n            this.scene.incrementRenderId();\n            renderTarget.render(false, false);\n            needRebind = true;\n          }\n        }\n      }\n\n      this.scene.incrementRenderId();\n    }\n\n    return needRebind;\n  };\n\n  EffectLayerSceneComponent.prototype._setStencil = function () {\n    // Activate effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(true);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._setStencilBack = function () {\n    // Restore effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(this._previousStencilState);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._draw = function (renderingGroupId) {\n    if (this._renderEffects) {\n      this._engine.setDepthBuffer(false);\n\n      var layers = this.scene.effectLayers;\n\n      for (var i = 0; i < layers.length; i++) {\n        var effectLayer = layers[i];\n\n        if (effectLayer.renderingGroupId === renderingGroupId) {\n          if (effectLayer.shouldRender()) {\n            effectLayer.render();\n          }\n        }\n      }\n\n      this._engine.setDepthBuffer(true);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._drawCamera = function () {\n    if (this._renderEffects) {\n      this._draw(-1);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._drawRenderingGroup = function (index) {\n    if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\n      this._draw(index);\n    }\n  };\n\n  return EffectLayerSceneComponent;\n}();\n\nexport { EffectLayerSceneComponent };\n\nEffectLayer._SceneComponentInitialization = function (scene) {\n  var component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);\n\n  if (!component) {\n    component = new EffectLayerSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}