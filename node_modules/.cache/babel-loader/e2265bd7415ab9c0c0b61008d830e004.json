{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardles.\n *\n */\n\n\nvar bn_js_1 = tslib_1.__importDefault(require(\"bn.js\"));\n\nvar bytes_1 = require(\"./bytes\");\n\nvar properties_1 = require(\"./properties\");\n\nvar errors = tslib_1.__importStar(require(\"./errors\"));\n\nvar BN_1 = new bn_js_1.default(-1);\n\nfunction toHex(bn) {\n  var value = bn.toString(16);\n\n  if (value[0] === '-') {\n    if (value.length % 2 === 0) {\n      return '-0x0' + value.substring(1);\n    }\n\n    return '-0x' + value.substring(1);\n  }\n\n  if (value.length % 2 === 1) {\n    return '0x0' + value;\n  }\n\n  return '0x' + value;\n}\n\nfunction toBN(value) {\n  return _bnify(bigNumberify(value));\n}\n\nfunction toBigNumber(bn) {\n  return new BigNumber(toHex(bn));\n}\n\nfunction _bnify(value) {\n  var hex = value._hex;\n\n  if (hex[0] === '-') {\n    return new bn_js_1.default(hex.substring(3), 16).mul(BN_1);\n  }\n\n  return new bn_js_1.default(hex.substring(2), 16);\n}\n\nvar BigNumber = /*#__PURE__*/function () {\n  function BigNumber(value) {\n    _classCallCheck(this, BigNumber);\n\n    this._hex = '';\n    errors.checkNew(this, BigNumber);\n    properties_1.setType(this, 'BigNumber');\n\n    if (typeof value === 'string') {\n      if (bytes_1.isHexString(value)) {\n        if (value == '0x') {\n          value = '0x0';\n        }\n\n        properties_1.defineReadOnly(this, '_hex', value);\n      } else if (value[0] === '-' && bytes_1.isHexString(value.substring(1))) {\n        properties_1.defineReadOnly(this, '_hex', value);\n      } else if (value.match(/^-?[0-9]*$/)) {\n        if (value == '') {\n          value = '0';\n        }\n\n        properties_1.defineReadOnly(this, '_hex', toHex(new bn_js_1.default(value)));\n      } else {\n        errors.throwError('invalid BigNumber string value', errors.INVALID_ARGUMENT, {\n          arg: 'value',\n          value: value\n        });\n      }\n    } else if (typeof value === 'number') {\n      if (parseInt(String(value)) !== value) {\n        errors.throwError('underflow', errors.NUMERIC_FAULT, {\n          operation: 'setValue',\n          fault: 'underflow',\n          value: value,\n          outputValue: parseInt(String(value))\n        });\n      }\n\n      try {\n        properties_1.defineReadOnly(this, '_hex', toHex(new bn_js_1.default(value)));\n      } catch (error) {\n        errors.throwError('overflow', errors.NUMERIC_FAULT, {\n          operation: 'setValue',\n          fault: 'overflow',\n          details: error.message\n        });\n      }\n    } else if (value instanceof BigNumber) {\n      properties_1.defineReadOnly(this, '_hex', value._hex);\n    } else if (value.toHexString) {\n      properties_1.defineReadOnly(this, '_hex', toHex(toBN(value.toHexString())));\n    } else if (value._hex && bytes_1.isHexString(value._hex)) {\n      properties_1.defineReadOnly(this, '_hex', value._hex);\n    } else if (bytes_1.isArrayish(value)) {\n      properties_1.defineReadOnly(this, '_hex', toHex(new bn_js_1.default(bytes_1.hexlify(value).substring(2), 16)));\n    } else {\n      errors.throwError('invalid BigNumber value', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n  }\n\n  _createClass(BigNumber, [{\n    key: \"fromTwos\",\n    value: function fromTwos(value) {\n      return toBigNumber(_bnify(this).fromTwos(value));\n    }\n  }, {\n    key: \"toTwos\",\n    value: function toTwos(value) {\n      return toBigNumber(_bnify(this).toTwos(value));\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return toBigNumber(_bnify(this).add(toBN(other)));\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(other) {\n      return toBigNumber(_bnify(this).sub(toBN(other)));\n    }\n  }, {\n    key: \"div\",\n    value: function div(other) {\n      var o = bigNumberify(other);\n\n      if (o.isZero()) {\n        errors.throwError('division by zero', errors.NUMERIC_FAULT, {\n          operation: 'divide',\n          fault: 'division by zero'\n        });\n      }\n\n      return toBigNumber(_bnify(this).div(toBN(other)));\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(other) {\n      return toBigNumber(_bnify(this).mul(toBN(other)));\n    }\n  }, {\n    key: \"mod\",\n    value: function mod(other) {\n      return toBigNumber(_bnify(this).mod(toBN(other)));\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(other) {\n      return toBigNumber(_bnify(this).pow(toBN(other)));\n    }\n  }, {\n    key: \"maskn\",\n    value: function maskn(value) {\n      return toBigNumber(_bnify(this).maskn(value));\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return _bnify(this).eq(toBN(other));\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(other) {\n      return _bnify(this).lt(toBN(other));\n    }\n  }, {\n    key: \"lte\",\n    value: function lte(other) {\n      return _bnify(this).lte(toBN(other));\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(other) {\n      return _bnify(this).gt(toBN(other));\n    }\n  }, {\n    key: \"gte\",\n    value: function gte(other) {\n      return _bnify(this).gte(toBN(other));\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return _bnify(this).isZero();\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      try {\n        return _bnify(this).toNumber();\n      } catch (error) {\n        return errors.throwError('overflow', errors.NUMERIC_FAULT, {\n          operation: 'setValue',\n          fault: 'overflow',\n          details: error.message\n        });\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return _bnify(this).toString(10);\n    }\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return this._hex;\n    }\n  }], [{\n    key: \"isBigNumber\",\n    value: function isBigNumber(value) {\n      return properties_1.isType(value, 'BigNumber');\n    }\n  }]);\n\n  return BigNumber;\n}();\n\nexports.BigNumber = BigNumber;\n\nfunction bigNumberify(value) {\n  if (bn_js_1.default.isBN(value)) {\n    return new BigNumber(value.toString());\n  }\n\n  if (BigNumber.isBigNumber(value)) {\n    return value;\n  }\n\n  return new BigNumber(value);\n}\n\nexports.bigNumberify = bigNumberify;","map":null,"metadata":{},"sourceType":"script"}