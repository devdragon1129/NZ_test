{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: \"must match exactly one schema in oneOf\",\n  params: function params(_ref) {\n    var _params = _ref.params;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{passingSchemas: \", \"}\"])), _params.passing);\n  }\n};\nvar def = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    /* istanbul ignore if */\n\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    if (it.opts.discriminator && parentSchema.discriminator) return;\n    var schArr = schema;\n    var valid = gen.let(\"valid\", false);\n    var passing = gen.let(\"passing\", null);\n    var schValid = gen.name(\"_valid\");\n    cxt.setParams({\n      passing: passing\n    }); // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf);\n    cxt.result(valid, function () {\n      return cxt.reset();\n    }, function () {\n      return cxt.error(true);\n    });\n\n    function validateOneOf() {\n      schArr.forEach(function (sch, i) {\n        var schCxt;\n\n        if ((0, util_1.alwaysValidSchema)(it, sch)) {\n          gen.var(schValid, true);\n        } else {\n          schCxt = cxt.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: true\n          }, schValid);\n        }\n\n        if (i > 0) {\n          gen.if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), schValid, valid)).assign(valid, false).assign(passing, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"[\", \", \", \"]\"])), passing, i)).else();\n        }\n\n        gen.if(schValid, function () {\n          gen.assign(valid, true);\n          gen.assign(passing, i);\n          if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}