{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Tools } from \"./Misc/tools\";\nimport { PrecisionDate } from \"./Misc/precisionDate\";\nimport { Observable } from \"./Misc/observable\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray\";\nimport { StringDictionary } from \"./Misc/stringDictionary\";\nimport { Tags } from \"./Misc/tags\";\nimport { Vector3, Matrix } from \"./Maths/math.vector\";\nimport { TransformNode } from \"./Meshes/transformNode\";\nimport { AbstractMesh } from \"./Meshes/abstractMesh\";\nimport { Camera } from \"./Cameras/camera\";\nimport { AbstractScene } from \"./abstractScene\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer\";\nimport { Light } from \"./Lights/light\";\nimport { PickingInfo } from \"./Collisions/pickingInfo\";\nimport { ActionEvent } from \"./Actions/actionEvent\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager\";\nimport { RenderingManager } from \"./Rendering/renderingManager\";\nimport { Stage } from \"./sceneComponent\";\nimport { DomManagement } from \"./Misc/domManagement\";\nimport { Logger } from \"./Misc/logger\";\nimport { EngineStore } from \"./Engines/engineStore\";\nimport { _DevTools } from './Misc/devTools';\nimport { InputManager } from './Inputs/scene.inputManager';\nimport { PerfCounter } from './Misc/perfCounter';\nimport { Color4, Color3 } from './Maths/math.color';\nimport { Frustum } from './Maths/math.frustum';\nimport { UniqueIdGenerator } from './Misc/uniqueIdGenerator';\nimport { FileTools } from './Misc/fileTools';\n/**\r\n * Represents a scene to be rendered by the engine.\r\n * @see https://doc.babylonjs.com/features/scene\r\n */\n\nvar Scene =\n/** @class */\nfunction (_super) {\n  __extends(Scene, _super);\n  /**\r\n   * Creates a new Scene\r\n   * @param engine defines the engine to use to render this scene\r\n   * @param options defines the scene options\r\n   */\n\n\n  function Scene(engine, options) {\n    var _this = _super.call(this) || this; // Members\n\n    /** @hidden */\n\n\n    _this._inputManager = new InputManager(_this);\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n\n    _this.cameraToUseForPointers = null;\n    /** @hidden */\n\n    _this._isScene = true;\n    /** @hidden */\n\n    _this._blockEntityCollection = false;\n    /**\r\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\r\n     */\n\n    _this.autoClear = true;\n    /**\r\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\r\n     */\n\n    _this.autoClearDepthAndStencil = true;\n    /**\r\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\r\n     */\n\n    _this.clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n    /**\r\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\r\n     */\n\n    _this.ambientColor = new Color3(0, 0, 0);\n    /** @hidden */\n\n    _this._environmentIntensity = 1;\n    _this._forceWireframe = false;\n    _this._skipFrustumClipping = false;\n    _this._forcePointsCloud = false;\n    /**\r\n     * Gets or sets a boolean indicating if animations are enabled\r\n     */\n\n    _this.animationsEnabled = true;\n    _this._animationPropertiesOverride = null;\n    /**\r\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\r\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\r\n     */\n\n    _this.useConstantAnimationDeltaTime = false;\n    /**\r\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\r\n     * Please note that it requires to run a ray cast through the scene on every frame\r\n     */\n\n    _this.constantlyUpdateMeshUnderPointer = false;\n    /**\r\n     * Defines the HTML cursor to use when hovering over interactive elements\r\n     */\n\n    _this.hoverCursor = \"pointer\";\n    /**\r\n     * Defines the HTML default cursor to use (empty by default)\r\n     */\n\n    _this.defaultCursor = \"\";\n    /**\r\n     * Defines whether cursors are handled by the scene.\r\n     */\n\n    _this.doNotHandleCursors = false;\n    /**\r\n     * This is used to call preventDefault() on pointer down\r\n     * in order to block unwanted artifacts like system double clicks\r\n     */\n\n    _this.preventDefaultOnPointerDown = true;\n    /**\r\n     * This is used to call preventDefault() on pointer up\r\n     * in order to block unwanted artifacts like system double clicks\r\n     */\n\n    _this.preventDefaultOnPointerUp = true; // Metadata\n\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\n\n    _this.metadata = null;\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\n\n    _this.reservedDataStore = null;\n    /**\r\n     * Use this array to add regular expressions used to disable offline support for specific urls\r\n     */\n\n    _this.disableOfflineSupportExceptionRules = new Array();\n    /**\r\n    * An event triggered when the scene is disposed.\r\n    */\n\n    _this.onDisposeObservable = new Observable();\n    _this._onDisposeObserver = null;\n    /**\r\n    * An event triggered before rendering the scene (right after animations and physics)\r\n    */\n\n    _this.onBeforeRenderObservable = new Observable();\n    _this._onBeforeRenderObserver = null;\n    /**\r\n    * An event triggered after rendering the scene\r\n    */\n\n    _this.onAfterRenderObservable = new Observable();\n    /**\r\n    * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\r\n    */\n\n    _this.onAfterRenderCameraObservable = new Observable();\n    _this._onAfterRenderObserver = null;\n    /**\r\n    * An event triggered before animating the scene\r\n    */\n\n    _this.onBeforeAnimationsObservable = new Observable();\n    /**\r\n    * An event triggered after animations processing\r\n    */\n\n    _this.onAfterAnimationsObservable = new Observable();\n    /**\r\n    * An event triggered before draw calls are ready to be sent\r\n    */\n\n    _this.onBeforeDrawPhaseObservable = new Observable();\n    /**\r\n    * An event triggered after draw calls have been sent\r\n    */\n\n    _this.onAfterDrawPhaseObservable = new Observable();\n    /**\r\n    * An event triggered when the scene is ready\r\n    */\n\n    _this.onReadyObservable = new Observable();\n    /**\r\n    * An event triggered before rendering a camera\r\n    */\n\n    _this.onBeforeCameraRenderObservable = new Observable();\n    _this._onBeforeCameraRenderObserver = null;\n    /**\r\n    * An event triggered after rendering a camera\r\n    */\n\n    _this.onAfterCameraRenderObservable = new Observable();\n    _this._onAfterCameraRenderObserver = null;\n    /**\r\n    * An event triggered when active meshes evaluation is about to start\r\n    */\n\n    _this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n    /**\r\n    * An event triggered when active meshes evaluation is done\r\n    */\n\n    _this.onAfterActiveMeshesEvaluationObservable = new Observable();\n    /**\r\n    * An event triggered when particles rendering is about to start\r\n    * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\r\n    */\n\n    _this.onBeforeParticlesRenderingObservable = new Observable();\n    /**\r\n    * An event triggered when particles rendering is done\r\n    * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\r\n    */\n\n    _this.onAfterParticlesRenderingObservable = new Observable();\n    /**\r\n    * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\r\n    */\n\n    _this.onDataLoadedObservable = new Observable();\n    /**\r\n    * An event triggered when a camera is created\r\n    */\n\n    _this.onNewCameraAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a camera is removed\r\n    */\n\n    _this.onCameraRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a light is created\r\n    */\n\n    _this.onNewLightAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a light is removed\r\n    */\n\n    _this.onLightRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a geometry is created\r\n    */\n\n    _this.onNewGeometryAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a geometry is removed\r\n    */\n\n    _this.onGeometryRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a transform node is created\r\n    */\n\n    _this.onNewTransformNodeAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a transform node is removed\r\n    */\n\n    _this.onTransformNodeRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a mesh is created\r\n    */\n\n    _this.onNewMeshAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a mesh is removed\r\n    */\n\n    _this.onMeshRemovedObservable = new Observable();\n    /**\r\n     * An event triggered when a skeleton is created\r\n     */\n\n    _this.onNewSkeletonAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a skeleton is removed\r\n    */\n\n    _this.onSkeletonRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a material is created\r\n    */\n\n    _this.onNewMaterialAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a multi material is created\r\n    */\n\n    _this.onNewMultiMaterialAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a material is removed\r\n    */\n\n    _this.onMaterialRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a multi material is removed\r\n    */\n\n    _this.onMultiMaterialRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a texture is created\r\n    */\n\n    _this.onNewTextureAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a texture is removed\r\n    */\n\n    _this.onTextureRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when render targets are about to be rendered\r\n    * Can happen multiple times per frame.\r\n    */\n\n    _this.onBeforeRenderTargetsRenderObservable = new Observable();\n    /**\r\n    * An event triggered when render targets were rendered.\r\n    * Can happen multiple times per frame.\r\n    */\n\n    _this.onAfterRenderTargetsRenderObservable = new Observable();\n    /**\r\n    * An event triggered before calculating deterministic simulation step\r\n    */\n\n    _this.onBeforeStepObservable = new Observable();\n    /**\r\n    * An event triggered after calculating deterministic simulation step\r\n    */\n\n    _this.onAfterStepObservable = new Observable();\n    /**\r\n     * An event triggered when the activeCamera property is updated\r\n     */\n\n    _this.onActiveCameraChanged = new Observable();\n    /**\r\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\r\n     * The RenderinGroupInfo class contains all the information about the context in which the observable is called\r\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\r\n     */\n\n    _this.onBeforeRenderingGroupObservable = new Observable();\n    /**\r\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\r\n     * The RenderinGroupInfo class contains all the information about the context in which the observable is called\r\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\r\n     */\n\n    _this.onAfterRenderingGroupObservable = new Observable();\n    /**\r\n     * This Observable will when a mesh has been imported into the scene.\r\n     */\n\n    _this.onMeshImportedObservable = new Observable();\n    /**\r\n     * This Observable will when an animation file has been imported into the scene.\r\n     */\n\n    _this.onAnimationFileImportedObservable = new Observable(); // Animations\n\n    /** @hidden */\n\n    _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n    /**\r\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\r\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\r\n     */\n\n    _this.onPrePointerObservable = new Observable();\n    /**\r\n     * Observable event triggered each time an input event is received from the rendering canvas\r\n     */\n\n    _this.onPointerObservable = new Observable(); // Keyboard\n\n    /**\r\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\r\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\r\n     */\n\n    _this.onPreKeyboardObservable = new Observable();\n    /**\r\n     * Observable event triggered each time an keyboard event is received from the hosting window\r\n     */\n\n    _this.onKeyboardObservable = new Observable(); // Coordinates system\n\n    _this._useRightHandedSystem = false; // Deterministic lockstep\n\n    _this._timeAccumulator = 0;\n    _this._currentStepId = 0;\n    _this._currentInternalStep = 0; // Fog\n\n    _this._fogEnabled = true;\n    _this._fogMode = Scene.FOGMODE_NONE;\n    /**\r\n    * Gets or sets the fog color to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is Color3(0.2, 0.2, 0.3))\r\n    */\n\n    _this.fogColor = new Color3(0.2, 0.2, 0.3);\n    /**\r\n    * Gets or sets the fog density to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 0.1)\r\n    */\n\n    _this.fogDensity = 0.1;\n    /**\r\n    * Gets or sets the fog start distance to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 0)\r\n    */\n\n    _this.fogStart = 0;\n    /**\r\n    * Gets or sets the fog end distance to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 1000)\r\n    */\n\n    _this.fogEnd = 1000.0;\n    /**\r\n    * Flag indicating that the frame buffer binding is handled by another component\r\n    */\n\n    _this.prePass = false; // Lights\n\n    _this._shadowsEnabled = true;\n    _this._lightsEnabled = true;\n    /** All of the active cameras added to this scene. */\n\n    _this.activeCameras = new Array(); // Textures\n\n    _this._texturesEnabled = true; // Physics\n\n    /**\r\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\r\n     */\n\n    _this.physicsEnabled = true; // Particles\n\n    /**\r\n    * Gets or sets a boolean indicating if particles are enabled on this scene\r\n    */\n\n    _this.particlesEnabled = true; // Sprites\n\n    /**\r\n    * Gets or sets a boolean indicating if sprites are enabled on this scene\r\n    */\n\n    _this.spritesEnabled = true; // Skeletons\n\n    _this._skeletonsEnabled = true; // Lens flares\n\n    /**\r\n    * Gets or sets a boolean indicating if lens flares are enabled on this scene\r\n    */\n\n    _this.lensFlaresEnabled = true; // Collisions\n\n    /**\r\n    * Gets or sets a boolean indicating if collisions are enabled on this scene\r\n    * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n    */\n\n    _this.collisionsEnabled = true;\n    /**\r\n     * Defines the gravity applied to this scene (used only for collisions)\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n\n    _this.gravity = new Vector3(0, -9.807, 0); // Postprocesses\n\n    /**\r\n    * Gets or sets a boolean indicating if postprocesses are enabled on this scene\r\n    */\n\n    _this.postProcessesEnabled = true; // Customs render targets\n\n    /**\r\n    * Gets or sets a boolean indicating if render targets are enabled on this scene\r\n    */\n\n    _this.renderTargetsEnabled = true;\n    /**\r\n    * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\r\n    * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\r\n    */\n\n    _this.dumpNextRenderTargets = false;\n    /**\r\n     * The list of user defined render targets added to the scene\r\n     */\n\n    _this.customRenderTargets = new Array();\n    /**\r\n     * Gets the list of meshes imported to the scene through SceneLoader\r\n     */\n\n    _this.importedMeshesFiles = new Array(); // Probes\n\n    /**\r\n    * Gets or sets a boolean indicating if probes are enabled on this scene\r\n    */\n\n    _this.probesEnabled = true;\n    _this._meshesForIntersections = new SmartArrayNoDuplicate(256); // Procedural textures\n\n    /**\r\n    * Gets or sets a boolean indicating if procedural textures are enabled on this scene\r\n    */\n\n    _this.proceduralTexturesEnabled = true; // Performance counters\n\n    _this._totalVertices = new PerfCounter();\n    /** @hidden */\n\n    _this._activeIndices = new PerfCounter();\n    /** @hidden */\n\n    _this._activeParticles = new PerfCounter();\n    /** @hidden */\n\n    _this._activeBones = new PerfCounter();\n    /** @hidden */\n\n    _this._animationTime = 0;\n    /**\r\n     * Gets or sets a general scale for animation speed\r\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\r\n     */\n\n    _this.animationTimeScale = 1;\n    _this._renderId = 0;\n    _this._frameId = 0;\n    _this._executeWhenReadyTimeoutId = -1;\n    _this._intermediateRendering = false;\n    _this._viewUpdateFlag = -1;\n    _this._projectionUpdateFlag = -1;\n    /** @hidden */\n\n    _this._toBeDisposed = new Array(256);\n    _this._activeRequests = new Array();\n    /** @hidden */\n\n    _this._pendingData = new Array();\n    _this._isDisposed = false;\n    /**\r\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\r\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\r\n     */\n\n    _this.dispatchAllSubMeshesOfActiveMeshes = false;\n    _this._activeMeshes = new SmartArray(256);\n    _this._processedMaterials = new SmartArray(256);\n    _this._renderTargets = new SmartArrayNoDuplicate(256);\n    /** @hidden */\n\n    _this._activeParticleSystems = new SmartArray(256);\n    _this._activeSkeletons = new SmartArrayNoDuplicate(32);\n    _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n    /** @hidden */\n\n    _this._activeAnimatables = new Array();\n    _this._transformMatrix = Matrix.Zero();\n    /**\r\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\r\n     * This is useful if there are more lights that the maximum simulteanous authorized\r\n     */\n\n    _this.requireLightSorting = false;\n    /**\r\n     * @hidden\r\n     * Backing store of defined scene components.\r\n     */\n\n    _this._components = [];\n    /**\r\n     * @hidden\r\n     * Backing store of defined scene components.\r\n     */\n\n    _this._serializableComponents = [];\n    /**\r\n     * List of components to register on the next registration step.\r\n     */\n\n    _this._transientComponents = [];\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before camera updates.\r\n     */\n\n    _this._beforeCameraUpdateStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before clear the canvas.\r\n     */\n\n    _this._beforeClearStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions when collecting render targets for the frame.\r\n     */\n\n    _this._gatherRenderTargetsStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening for one camera in the frame.\r\n     */\n\n    _this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the per mesh ready checks.\r\n     */\n\n    _this._isReadyForMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before evaluate active mesh checks.\r\n     */\n\n    _this._beforeEvaluateActiveMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the evaluate sub mesh checks.\r\n     */\n\n    _this._evaluateSubMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the active mesh stage.\r\n     */\n\n    _this._preActiveMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the per camera render target step.\r\n     */\n\n    _this._cameraDrawRenderTargetStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before the active camera is drawing.\r\n     */\n\n    _this._beforeCameraDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a render target is drawing.\r\n     */\n\n    _this._beforeRenderTargetDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a rendering group is drawing.\r\n     */\n\n    _this._beforeRenderingGroupDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a mesh is drawing.\r\n     */\n\n    _this._beforeRenderingMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a mesh has been drawn.\r\n     */\n\n    _this._afterRenderingMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a rendering group has been drawn.\r\n     */\n\n    _this._afterRenderingGroupDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after the active camera has been drawn.\r\n     */\n\n    _this._afterCameraDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a render target has been drawn.\r\n     */\n\n    _this._afterRenderTargetDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after rendering all cameras and computing intersections.\r\n     */\n\n    _this._afterRenderStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer move event happens.\r\n     */\n\n    _this._pointerMoveStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer down event happens.\r\n     */\n\n    _this._pointerDownStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer up event happens.\r\n     */\n\n    _this._pointerUpStage = Stage.Create();\n    /**\r\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\r\n     */\n\n    _this.geometriesByUniqueId = null;\n    _this._defaultMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._defaultSubMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._preventFreeActiveMeshesAndRenderingGroups = false;\n    /** @hidden */\n\n    _this._activeMeshesFrozen = false;\n    _this._skipEvaluateActiveMeshesCompletely = false;\n    /** @hidden */\n\n    _this._allowPostProcessClearColor = true;\n    /**\r\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\r\n     */\n\n    _this.getDeterministicFrameTime = function () {\n      return _this._engine.getTimeStep();\n    };\n\n    _this._blockMaterialDirtyMechanism = false;\n\n    var fullOptions = __assign({\n      useGeometryUniqueIdsMap: true,\n      useMaterialMeshMap: true,\n      useClonedMeshMap: true,\n      virtual: false\n    }, options);\n\n    _this._engine = engine || EngineStore.LastCreatedEngine;\n\n    if (!fullOptions.virtual) {\n      EngineStore._LastCreatedScene = _this;\n\n      _this._engine.scenes.push(_this);\n    }\n\n    _this._uid = null;\n    _this._renderingManager = new RenderingManager(_this);\n\n    if (PostProcessManager) {\n      _this.postProcessManager = new PostProcessManager(_this);\n    }\n\n    if (DomManagement.IsWindowObjectExist()) {\n      _this.attachControl();\n    } // Uniform Buffer\n\n\n    _this._createUbo(); // Default Image processing definition\n\n\n    if (ImageProcessingConfiguration) {\n      _this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n    }\n\n    _this.setDefaultCandidateProviders();\n\n    if (fullOptions.useGeometryUniqueIdsMap) {\n      _this.geometriesByUniqueId = {};\n    }\n\n    _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n    _this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n\n    if (!options || !options.virtual) {\n      _this._engine.onNewSceneAddedObservable.notifyObservers(_this);\n    }\n\n    return _this;\n  }\n  /**\r\n   * Factory used to create the default material.\r\n   * @param name The name of the material to create\r\n   * @param scene The scene to create the material for\r\n   * @returns The default material\r\n   */\n\n\n  Scene.DefaultMaterialFactory = function (scene) {\n    throw _DevTools.WarnImport(\"StandardMaterial\");\n  };\n  /**\r\n   * Factory used to create the a collision coordinator.\r\n   * @returns The collision coordinator\r\n   */\n\n\n  Scene.CollisionCoordinatorFactory = function () {\n    throw _DevTools.WarnImport(\"DefaultCollisionCoordinator\");\n  };\n\n  Object.defineProperty(Scene.prototype, \"environmentTexture\", {\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\n    get: function get() {\n      return this._environmentTexture;\n    },\n\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to set here than in all the materials.\r\n     */\n    set: function set(value) {\n      if (this._environmentTexture === value) {\n        return;\n      }\n\n      this._environmentTexture = value;\n      this.markAllMaterialsAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"environmentIntensity\", {\n    /**\r\n     * Intensity of the environment in all pbr material.\r\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\n    get: function get() {\n      return this._environmentIntensity;\n    },\n\n    /**\r\n     * Intensity of the environment in all pbr material.\r\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to set here than in all the materials.\r\n     */\n    set: function set(value) {\n      if (this._environmentIntensity === value) {\n        return;\n      }\n\n      this._environmentIntensity = value;\n      this.markAllMaterialsAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"imageProcessingConfiguration\", {\n    /**\r\n     * Default image processing configuration used either in the rendering\r\n     * Forward main pass or through the imageProcessingPostProcess if present.\r\n     * As in the majority of the scene they are the same (exception for multi camera),\r\n     * this is easier to reference from here than from all the materials and post process.\r\n     *\r\n     * No setter as we it is a shared configuration, you can set the values instead.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"forceWireframe\", {\n    get: function get() {\n      return this._forceWireframe;\n    },\n\n    /**\r\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\r\n     */\n    set: function set(value) {\n      if (this._forceWireframe === value) {\n        return;\n      }\n\n      this._forceWireframe = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"skipFrustumClipping\", {\n    get: function get() {\n      return this._skipFrustumClipping;\n    },\n\n    /**\r\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\r\n     */\n    set: function set(value) {\n      if (this._skipFrustumClipping === value) {\n        return;\n      }\n\n      this._skipFrustumClipping = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"forcePointsCloud\", {\n    get: function get() {\n      return this._forcePointsCloud;\n    },\n\n    /**\r\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\r\n     */\n    set: function set(value) {\n      if (this._forcePointsCloud === value) {\n        return;\n      }\n\n      this._forcePointsCloud = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"animationPropertiesOverride\", {\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\n    get: function get() {\n      return this._animationPropertiesOverride;\n    },\n    set: function set(value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onDispose\", {\n    /** Sets a function to be executed when this scene is disposed. */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"beforeRender\", {\n    /** Sets a function to be executed before rendering this scene */\n    set: function set(callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      if (callback) {\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"afterRender\", {\n    /** Sets a function to be executed after rendering this scene */\n    set: function set(callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      if (callback) {\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"beforeCameraRender\", {\n    /** Sets a function to be executed before rendering a camera*/\n    set: function set(callback) {\n      if (this._onBeforeCameraRenderObserver) {\n        this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n      }\n\n      this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"afterCameraRender\", {\n    /** Sets a function to be executed after rendering a camera*/\n    set: function set(callback) {\n      if (this._onAfterCameraRenderObserver) {\n        this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n      }\n\n      this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"unTranslatedPointer\", {\n    /**\r\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\r\n     */\n    get: function get() {\n      return this._inputManager.unTranslatedPointer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"DragMovementThreshold\", {\n    /**\r\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\r\n     */\n    get: function get() {\n      return InputManager.DragMovementThreshold;\n    },\n    set: function set(value) {\n      InputManager.DragMovementThreshold = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"LongPressDelay\", {\n    /**\r\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\r\n     */\n    get: function get() {\n      return InputManager.LongPressDelay;\n    },\n    set: function set(value) {\n      InputManager.LongPressDelay = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"DoubleClickDelay\", {\n    /**\r\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\r\n     */\n    get: function get() {\n      return InputManager.DoubleClickDelay;\n    },\n    set: function set(value) {\n      InputManager.DoubleClickDelay = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"ExclusiveDoubleClickMode\", {\n    /** If you need to check double click without raising a single click at first click, enable this flag */\n    get: function get() {\n      return InputManager.ExclusiveDoubleClickMode;\n    },\n    set: function set(value) {\n      InputManager.ExclusiveDoubleClickMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"useRightHandedSystem\", {\n    get: function get() {\n      return this._useRightHandedSystem;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\r\n    */\n    set: function set(value) {\n      if (this._useRightHandedSystem === value) {\n        return;\n      }\n\n      this._useRightHandedSystem = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the step Id used by deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @param newStepId defines the step Id\r\n   */\n\n  Scene.prototype.setStepId = function (newStepId) {\n    this._currentStepId = newStepId;\n  };\n  /**\r\n   * Gets the step Id used by deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns the step Id\r\n   */\n\n\n  Scene.prototype.getStepId = function () {\n    return this._currentStepId;\n  };\n  /**\r\n   * Gets the internal step used by deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns the internal step\r\n   */\n\n\n  Scene.prototype.getInternalStep = function () {\n    return this._currentInternalStep;\n  };\n\n  Object.defineProperty(Scene.prototype, \"fogEnabled\", {\n    get: function get() {\n      return this._fogEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if fog is enabled on this scene\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is true)\r\n    */\n    set: function set(value) {\n      if (this._fogEnabled === value) {\n        return;\n      }\n\n      this._fogEnabled = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"fogMode\", {\n    get: function get() {\n      return this._fogMode;\n    },\n\n    /**\r\n    * Gets or sets the fog mode to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * | mode | value |\r\n    * | --- | --- |\r\n    * | FOGMODE_NONE | 0 |\r\n    * | FOGMODE_EXP | 1 |\r\n    * | FOGMODE_EXP2 | 2 |\r\n    * | FOGMODE_LINEAR | 3 |\r\n    */\n    set: function set(value) {\n      if (this._fogMode === value) {\n        return;\n      }\n\n      this._fogMode = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"shadowsEnabled\", {\n    get: function get() {\n      return this._shadowsEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if shadows are enabled on this scene\r\n    */\n    set: function set(value) {\n      if (this._shadowsEnabled === value) {\n        return;\n      }\n\n      this._shadowsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"lightsEnabled\", {\n    get: function get() {\n      return this._lightsEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if lights are enabled on this scene\r\n    */\n    set: function set(value) {\n      if (this._lightsEnabled === value) {\n        return;\n      }\n\n      this._lightsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"activeCamera\", {\n    /** Gets or sets the current active camera */\n    get: function get() {\n      return this._activeCamera;\n    },\n    set: function set(value) {\n      if (value === this._activeCamera) {\n        return;\n      }\n\n      this._activeCamera = value;\n      this.onActiveCameraChanged.notifyObservers(this);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"defaultMaterial\", {\n    /** The default material used on meshes when no material is affected */\n    get: function get() {\n      if (!this._defaultMaterial) {\n        this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n      }\n\n      return this._defaultMaterial;\n    },\n\n    /** The default material used on meshes when no material is affected */\n    set: function set(value) {\n      this._defaultMaterial = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"texturesEnabled\", {\n    get: function get() {\n      return this._texturesEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if textures are enabled on this scene\r\n    */\n    set: function set(value) {\n      if (this._texturesEnabled === value) {\n        return;\n      }\n\n      this._texturesEnabled = value;\n      this.markAllMaterialsAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"skeletonsEnabled\", {\n    get: function get() {\n      return this._skeletonsEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if skeletons are enabled on this scene\r\n    */\n    set: function set(value) {\n      if (this._skeletonsEnabled === value) {\n        return;\n      }\n\n      this._skeletonsEnabled = value;\n      this.markAllMaterialsAsDirty(8);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"collisionCoordinator\", {\n    /** @hidden */\n    get: function get() {\n      if (!this._collisionCoordinator) {\n        this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n\n        this._collisionCoordinator.init(this);\n      }\n\n      return this._collisionCoordinator;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"frustumPlanes\", {\n    /**\r\n     * Gets the list of frustum planes (built from the active camera)\r\n     */\n    get: function get() {\n      return this._frustumPlanes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Registers the transient components if needed.\r\n   */\n\n  Scene.prototype._registerTransientComponents = function () {\n    // Register components that have been associated lately to the scene.\n    if (this._transientComponents.length > 0) {\n      for (var _i = 0, _a = this._transientComponents; _i < _a.length; _i++) {\n        var component = _a[_i];\n        component.register();\n      }\n\n      this._transientComponents = [];\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Add a component to the scene.\r\n   * Note that the ccomponent could be registered on th next frame if this is called after\r\n   * the register component stage.\r\n   * @param component Defines the component to add to the scene\r\n   */\n\n\n  Scene.prototype._addComponent = function (component) {\n    this._components.push(component);\n\n    this._transientComponents.push(component);\n\n    var serializableComponent = component;\n\n    if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n      this._serializableComponents.push(serializableComponent);\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Gets a component from the scene.\r\n   * @param name defines the name of the component to retrieve\r\n   * @returns the component or null if not present\r\n   */\n\n\n  Scene.prototype._getComponent = function (name) {\n    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {\n      var component = _a[_i];\n\n      if (component.name === name) {\n        return component;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"Scene\" string\r\n   */\n\n\n  Scene.prototype.getClassName = function () {\n    return \"Scene\";\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  Scene.prototype._getDefaultMeshCandidates = function () {\n    this._defaultMeshCandidates.data = this.meshes;\n    this._defaultMeshCandidates.length = this.meshes.length;\n    return this._defaultMeshCandidates;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  Scene.prototype._getDefaultSubMeshCandidates = function (mesh) {\n    this._defaultSubMeshCandidates.data = mesh.subMeshes;\n    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n    return this._defaultSubMeshCandidates;\n  };\n  /**\r\n   * Sets the default candidate providers for the scene.\r\n   * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\r\n   * and getCollidingSubMeshCandidates to their default function\r\n   */\n\n\n  Scene.prototype.setDefaultCandidateProviders = function () {\n    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\n    this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n  };\n\n  Object.defineProperty(Scene.prototype, \"meshUnderPointer\", {\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     */\n    get: function get() {\n      return this._inputManager.meshUnderPointer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"pointerX\", {\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     */\n    get: function get() {\n      return this._inputManager.pointerX;\n    },\n    set: function set(value) {\n      this._inputManager.pointerX = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"pointerY\", {\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     */\n    get: function get() {\n      return this._inputManager.pointerY;\n    },\n    set: function set(value) {\n      this._inputManager.pointerY = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the cached material (ie. the latest rendered one)\r\n   * @returns the cached material\r\n   */\n\n  Scene.prototype.getCachedMaterial = function () {\n    return this._cachedMaterial;\n  };\n  /**\r\n   * Gets the cached effect (ie. the latest rendered one)\r\n   * @returns the cached effect\r\n   */\n\n\n  Scene.prototype.getCachedEffect = function () {\n    return this._cachedEffect;\n  };\n  /**\r\n   * Gets the cached visibility state (ie. the latest rendered one)\r\n   * @returns the cached visibility state\r\n   */\n\n\n  Scene.prototype.getCachedVisibility = function () {\n    return this._cachedVisibility;\n  };\n  /**\r\n   * Gets a boolean indicating if the current material / effect / visibility must be bind again\r\n   * @param material defines the current material\r\n   * @param effect defines the current effect\r\n   * @param visibility defines the current visibility state\r\n   * @returns true if one parameter is not cached\r\n   */\n\n\n  Scene.prototype.isCachedMaterialInvalid = function (material, effect, visibility) {\n    if (visibility === void 0) {\n      visibility = 1;\n    }\n\n    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n  };\n  /**\r\n   * Gets the engine associated with the scene\r\n   * @returns an Engine\r\n   */\n\n\n  Scene.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * Gets the total number of vertices rendered per frame\r\n   * @returns the total number of vertices rendered per frame\r\n   */\n\n\n  Scene.prototype.getTotalVertices = function () {\n    return this._totalVertices.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"totalVerticesPerfCounter\", {\n    /**\r\n     * Gets the performance counter for total vertices\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\n    get: function get() {\n      return this._totalVertices;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\r\n   * @returns the total number of active indices rendered per frame\r\n   */\n\n  Scene.prototype.getActiveIndices = function () {\n    return this._activeIndices.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"totalActiveIndicesPerfCounter\", {\n    /**\r\n     * Gets the performance counter for active indices\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\n    get: function get() {\n      return this._activeIndices;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the total number of active particles rendered per frame\r\n   * @returns the total number of active particles rendered per frame\r\n   */\n\n  Scene.prototype.getActiveParticles = function () {\n    return this._activeParticles.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"activeParticlesPerfCounter\", {\n    /**\r\n     * Gets the performance counter for active particles\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\n    get: function get() {\n      return this._activeParticles;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the total number of active bones rendered per frame\r\n   * @returns the total number of active bones rendered per frame\r\n   */\n\n  Scene.prototype.getActiveBones = function () {\n    return this._activeBones.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"activeBonesPerfCounter\", {\n    /**\r\n     * Gets the performance counter for active bones\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\n    get: function get() {\n      return this._activeBones;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the array of active meshes\r\n   * @returns an array of AbstractMesh\r\n   */\n\n  Scene.prototype.getActiveMeshes = function () {\n    return this._activeMeshes;\n  };\n  /**\r\n   * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\r\n   * @returns a number\r\n   */\n\n\n  Scene.prototype.getAnimationRatio = function () {\n    return this._animationRatio !== undefined ? this._animationRatio : 1;\n  };\n  /**\r\n   * Gets an unique Id for the current render phase\r\n   * @returns a number\r\n   */\n\n\n  Scene.prototype.getRenderId = function () {\n    return this._renderId;\n  };\n  /**\r\n   * Gets an unique Id for the current frame\r\n   * @returns a number\r\n   */\n\n\n  Scene.prototype.getFrameId = function () {\n    return this._frameId;\n  };\n  /** Call this function if you want to manually increment the render Id*/\n\n\n  Scene.prototype.incrementRenderId = function () {\n    this._renderId++;\n  };\n\n  Scene.prototype._createUbo = function () {\n    this._sceneUbo = new UniformBuffer(this._engine, undefined, true);\n\n    this._sceneUbo.addUniform(\"viewProjection\", 16);\n\n    this._sceneUbo.addUniform(\"view\", 16);\n  };\n  /**\r\n   * Use this method to simulate a pointer move on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.simulatePointerMove = function (pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n\n    return this;\n  };\n  /**\r\n   * Use this method to simulate a pointer down on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.simulatePointerDown = function (pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n\n    return this;\n  };\n  /**\r\n   * Use this method to simulate a pointer up on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.simulatePointerUp = function (pickResult, pointerEventInit, doubleTap) {\n    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n\n    return this;\n  };\n  /**\r\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\r\n   * @returns true if the pointer was captured\r\n   */\n\n\n  Scene.prototype.isPointerCaptured = function (pointerId) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    }\n\n    return this._inputManager.isPointerCaptured(pointerId);\n  };\n  /**\r\n  * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n  * @param attachUp defines if you want to attach events to pointerup\r\n  * @param attachDown defines if you want to attach events to pointerdown\r\n  * @param attachMove defines if you want to attach events to pointermove\r\n  */\n\n\n  Scene.prototype.attachControl = function (attachUp, attachDown, attachMove) {\n    if (attachUp === void 0) {\n      attachUp = true;\n    }\n\n    if (attachDown === void 0) {\n      attachDown = true;\n    }\n\n    if (attachMove === void 0) {\n      attachMove = true;\n    }\n\n    this._inputManager.attachControl(attachUp, attachDown, attachMove);\n  };\n  /** Detaches all event handlers*/\n\n\n  Scene.prototype.detachControl = function () {\n    this._inputManager.detachControl();\n  };\n  /**\r\n   * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\r\n   * Delay loaded resources are not taking in account\r\n   * @return true if all required resources are ready\r\n   */\n\n\n  Scene.prototype.isReady = function () {\n    if (this._isDisposed) {\n      return false;\n    }\n\n    var index;\n    var engine = this.getEngine(); // Effects\n\n    if (!engine.areAllEffectsReady()) {\n      return false;\n    } // Pending data\n\n\n    if (this._pendingData.length > 0) {\n      return false;\n    } // Meshes\n\n\n    for (index = 0; index < this.meshes.length; index++) {\n      var mesh = this.meshes[index];\n\n      if (!mesh.isEnabled()) {\n        continue;\n      }\n\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n        continue;\n      }\n\n      if (!mesh.isReady(true)) {\n        return false;\n      }\n\n      var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === \"InstancedMesh\" || mesh.getClassName() === \"InstancedLinesMesh\" || engine.getCaps().instancedArrays && mesh.instances.length > 0; // Is Ready For Mesh\n\n      for (var _i = 0, _a = this._isReadyForMeshStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n\n        if (!step.action(mesh, hardwareInstancedRendering)) {\n          return false;\n        }\n      }\n    } // Geometries\n\n\n    for (index = 0; index < this.geometries.length; index++) {\n      var geometry = this.geometries[index];\n\n      if (geometry.delayLoadState === 2) {\n        return false;\n      }\n    } // Post-processes\n\n\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (var _b = 0, _c = this.activeCameras; _b < _c.length; _b++) {\n        var camera = _c[_b];\n\n        if (!camera.isReady(true)) {\n          return false;\n        }\n      }\n    } else if (this.activeCamera) {\n      if (!this.activeCamera.isReady(true)) {\n        return false;\n      }\n    } // Particles\n\n\n    for (var _d = 0, _e = this.particleSystems; _d < _e.length; _d++) {\n      var particleSystem = _e[_d];\n\n      if (!particleSystem.isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /** Resets all cached information relative to material (including effect and visibility) */\n\n\n  Scene.prototype.resetCachedMaterial = function () {\n    this._cachedMaterial = null;\n    this._cachedEffect = null;\n    this._cachedVisibility = null;\n  };\n  /**\r\n   * Registers a function to be called before every frame render\r\n   * @param func defines the function to register\r\n   */\n\n\n  Scene.prototype.registerBeforeRender = function (func) {\n    this.onBeforeRenderObservable.add(func);\n  };\n  /**\r\n   * Unregisters a function called before every frame render\r\n   * @param func defines the function to unregister\r\n   */\n\n\n  Scene.prototype.unregisterBeforeRender = function (func) {\n    this.onBeforeRenderObservable.removeCallback(func);\n  };\n  /**\r\n   * Registers a function to be called after every frame render\r\n   * @param func defines the function to register\r\n   */\n\n\n  Scene.prototype.registerAfterRender = function (func) {\n    this.onAfterRenderObservable.add(func);\n  };\n  /**\r\n   * Unregisters a function called after every frame render\r\n   * @param func defines the function to unregister\r\n   */\n\n\n  Scene.prototype.unregisterAfterRender = function (func) {\n    this.onAfterRenderObservable.removeCallback(func);\n  };\n\n  Scene.prototype._executeOnceBeforeRender = function (func) {\n    var _this = this;\n\n    var execFunc = function execFunc() {\n      func();\n      setTimeout(function () {\n        _this.unregisterBeforeRender(execFunc);\n      });\n    };\n\n    this.registerBeforeRender(execFunc);\n  };\n  /**\r\n   * The provided function will run before render once and will be disposed afterwards.\r\n   * A timeout delay can be provided so that the function will be executed in N ms.\r\n   * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\r\n   * @param func The function to be executed.\r\n   * @param timeout optional delay in ms\r\n   */\n\n\n  Scene.prototype.executeOnceBeforeRender = function (func, timeout) {\n    var _this = this;\n\n    if (timeout !== undefined) {\n      setTimeout(function () {\n        _this._executeOnceBeforeRender(func);\n      }, timeout);\n    } else {\n      this._executeOnceBeforeRender(func);\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._addPendingData = function (data) {\n    this._pendingData.push(data);\n  };\n  /** @hidden */\n\n\n  Scene.prototype._removePendingData = function (data) {\n    var wasLoading = this.isLoading;\n\n    var index = this._pendingData.indexOf(data);\n\n    if (index !== -1) {\n      this._pendingData.splice(index, 1);\n    }\n\n    if (wasLoading && !this.isLoading) {\n      this.onDataLoadedObservable.notifyObservers(this);\n    }\n  };\n  /**\r\n   * Returns the number of items waiting to be loaded\r\n   * @returns the number of items waiting to be loaded\r\n   */\n\n\n  Scene.prototype.getWaitingItemsCount = function () {\n    return this._pendingData.length;\n  };\n\n  Object.defineProperty(Scene.prototype, \"isLoading\", {\n    /**\r\n     * Returns a boolean indicating if the scene is still loading data\r\n     */\n    get: function get() {\n      return this._pendingData.length > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Registers a function to be executed when the scene is ready\r\n   * @param {Function} func - the function to be executed\r\n   */\n\n  Scene.prototype.executeWhenReady = function (func) {\n    var _this = this;\n\n    this.onReadyObservable.add(func);\n\n    if (this._executeWhenReadyTimeoutId !== -1) {\n      return;\n    }\n\n    this._executeWhenReadyTimeoutId = setTimeout(function () {\n      _this._checkIsReady();\n    }, 150);\n  };\n  /**\r\n   * Returns a promise that resolves when the scene is ready\r\n   * @returns A promise that resolves when the scene is ready\r\n   */\n\n\n  Scene.prototype.whenReadyAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve) {\n      _this.executeWhenReady(function () {\n        resolve();\n      });\n    });\n  };\n  /** @hidden */\n\n\n  Scene.prototype._checkIsReady = function () {\n    var _this = this;\n\n    this._registerTransientComponents();\n\n    if (this.isReady()) {\n      this.onReadyObservable.notifyObservers(this);\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = -1;\n      return;\n    }\n\n    if (this._isDisposed) {\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = -1;\n      return;\n    }\n\n    this._executeWhenReadyTimeoutId = setTimeout(function () {\n      _this._checkIsReady();\n    }, 150);\n  };\n\n  Object.defineProperty(Scene.prototype, \"animatables\", {\n    /**\r\n     * Gets all animatable attached to the scene\r\n     */\n    get: function get() {\n      return this._activeAnimatables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets the last animation time frame.\r\n   * Useful to override when animations start running when loading a scene for the first time.\r\n   */\n\n  Scene.prototype.resetLastAnimationTimeFrame = function () {\n    this._animationTimeLast = PrecisionDate.Now;\n  }; // Matrix\n\n  /**\r\n   * Gets the current view matrix\r\n   * @returns a Matrix\r\n   */\n\n\n  Scene.prototype.getViewMatrix = function () {\n    return this._viewMatrix;\n  };\n  /**\r\n   * Gets the current projection matrix\r\n   * @returns a Matrix\r\n   */\n\n\n  Scene.prototype.getProjectionMatrix = function () {\n    return this._projectionMatrix;\n  };\n  /**\r\n   * Gets the current transform matrix\r\n   * @returns a Matrix made of View * Projection\r\n   */\n\n\n  Scene.prototype.getTransformMatrix = function () {\n    return this._transformMatrix;\n  };\n  /**\r\n   * Sets the current transform matrix\r\n   * @param viewL defines the View matrix to use\r\n   * @param projectionL defines the Projection matrix to use\r\n   * @param viewR defines the right View matrix to use (if provided)\r\n   * @param projectionR defines the right Projection matrix to use (if provided)\r\n   */\n\n\n  Scene.prototype.setTransformMatrix = function (viewL, projectionL, viewR, projectionR) {\n    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n      return;\n    }\n\n    this._viewUpdateFlag = viewL.updateFlag;\n    this._projectionUpdateFlag = projectionL.updateFlag;\n    this._viewMatrix = viewL;\n    this._projectionMatrix = projectionL;\n\n    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix); // Update frustum\n\n\n    if (!this._frustumPlanes) {\n      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n    } else {\n      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n    }\n\n    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n      this._updateMultiviewUbo(viewR, projectionR);\n    } else if (this._sceneUbo.useUbo) {\n      this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n\n      this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n\n      this._sceneUbo.update();\n    }\n  };\n  /**\r\n   * Gets the uniform buffer used to store scene data\r\n   * @returns a UniformBuffer\r\n   */\n\n\n  Scene.prototype.getSceneUniformBuffer = function () {\n    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n  };\n  /**\r\n   * Gets an unique (relatively to the current scene) Id\r\n   * @returns an unique number for the scene\r\n   */\n\n\n  Scene.prototype.getUniqueId = function () {\n    return UniqueIdGenerator.UniqueId;\n  };\n  /**\r\n   * Add a mesh to the list of scene's meshes\r\n   * @param newMesh defines the mesh to add\r\n   * @param recursive if all child meshes should also be added to the scene\r\n   */\n\n\n  Scene.prototype.addMesh = function (newMesh, recursive) {\n    var _this = this;\n\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.meshes.push(newMesh);\n\n    newMesh._resyncLightSources();\n\n    if (!newMesh.parent) {\n      newMesh._addToSceneRootNodes();\n    }\n\n    this.onNewMeshAddedObservable.notifyObservers(newMesh);\n\n    if (recursive) {\n      newMesh.getChildMeshes().forEach(function (m) {\n        _this.addMesh(m);\n      });\n    }\n  };\n  /**\r\n   * Remove a mesh for the list of scene's meshes\r\n   * @param toRemove defines the mesh to remove\r\n   * @param recursive if all child meshes should also be removed from the scene\r\n   * @returns the index where the mesh was in the mesh list\r\n   */\n\n\n  Scene.prototype.removeMesh = function (toRemove, recursive) {\n    var _this = this;\n\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    var index = this.meshes.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.meshes[index] = this.meshes[this.meshes.length - 1];\n      this.meshes.pop();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this.onMeshRemovedObservable.notifyObservers(toRemove);\n\n    if (recursive) {\n      toRemove.getChildMeshes().forEach(function (m) {\n        _this.removeMesh(m);\n      });\n    }\n\n    return index;\n  };\n  /**\r\n   * Add a transform node to the list of scene's transform nodes\r\n   * @param newTransformNode defines the transform node to add\r\n   */\n\n\n  Scene.prototype.addTransformNode = function (newTransformNode) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n    this.transformNodes.push(newTransformNode);\n\n    if (!newTransformNode.parent) {\n      newTransformNode._addToSceneRootNodes();\n    }\n\n    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n  };\n  /**\r\n   * Remove a transform node for the list of scene's transform nodes\r\n   * @param toRemove defines the transform node to remove\r\n   * @returns the index where the transform node was in the transform node list\r\n   */\n\n\n  Scene.prototype.removeTransformNode = function (toRemove) {\n    var index = toRemove._indexInSceneTransformNodesArray;\n\n    if (index !== -1) {\n      if (index !== this.transformNodes.length - 1) {\n        var lastNode = this.transformNodes[this.transformNodes.length - 1];\n        this.transformNodes[index] = lastNode;\n        lastNode._indexInSceneTransformNodesArray = index;\n      }\n\n      toRemove._indexInSceneTransformNodesArray = -1;\n      this.transformNodes.pop();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Remove a skeleton for the list of scene's skeletons\r\n   * @param toRemove defines the skeleton to remove\r\n   * @returns the index where the skeleton was in the skeleton list\r\n   */\n\n\n  Scene.prototype.removeSkeleton = function (toRemove) {\n    var index = this.skeletons.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.skeletons.splice(index, 1);\n      this.onSkeletonRemovedObservable.notifyObservers(toRemove);\n    }\n\n    return index;\n  };\n  /**\r\n   * Remove a morph target for the list of scene's morph targets\r\n   * @param toRemove defines the morph target to remove\r\n   * @returns the index where the morph target was in the morph target list\r\n   */\n\n\n  Scene.prototype.removeMorphTargetManager = function (toRemove) {\n    var index = this.morphTargetManagers.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.morphTargetManagers.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Remove a light for the list of scene's lights\r\n   * @param toRemove defines the light to remove\r\n   * @returns the index where the light was in the light list\r\n   */\n\n\n  Scene.prototype.removeLight = function (toRemove) {\n    var index = this.lights.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from meshes\n      for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {\n        var mesh = _a[_i];\n\n        mesh._removeLightSource(toRemove, false);\n      } // Remove from the scene if mesh found\n\n\n      this.lights.splice(index, 1);\n      this.sortLightsByPriority();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this.onLightRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Remove a camera for the list of scene's cameras\r\n   * @param toRemove defines the camera to remove\r\n   * @returns the index where the camera was in the camera list\r\n   */\n\n\n  Scene.prototype.removeCamera = function (toRemove) {\n    var index = this.cameras.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.cameras.splice(index, 1);\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    } // Remove from activeCameras\n\n\n    if (this.activeCameras) {\n      var index2 = this.activeCameras.indexOf(toRemove);\n\n      if (index2 !== -1) {\n        // Remove from the scene if mesh found\n        this.activeCameras.splice(index2, 1);\n      }\n    } // Reset the activeCamera\n\n\n    if (this.activeCamera === toRemove) {\n      if (this.cameras.length > 0) {\n        this.activeCamera = this.cameras[0];\n      } else {\n        this.activeCamera = null;\n      }\n    }\n\n    this.onCameraRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Remove a particle system for the list of scene's particle systems\r\n   * @param toRemove defines the particle system to remove\r\n   * @returns the index where the particle system was in the particle system list\r\n   */\n\n\n  Scene.prototype.removeParticleSystem = function (toRemove) {\n    var index = this.particleSystems.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.particleSystems.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Remove a animation for the list of scene's animations\r\n   * @param toRemove defines the animation to remove\r\n   * @returns the index where the animation was in the animation list\r\n   */\n\n\n  Scene.prototype.removeAnimation = function (toRemove) {\n    var index = this.animations.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.animations.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Will stop the animation of the given target\r\n   * @param target - the target\r\n   * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n   */\n\n\n  Scene.prototype.stopAnimation = function (target, animationName, targetMask) {// Do nothing as code will be provided by animation component\n  };\n  /**\r\n   * Removes the given animation group from this scene.\r\n   * @param toRemove The animation group to remove\r\n   * @returns The index of the removed animation group\r\n   */\n\n\n  Scene.prototype.removeAnimationGroup = function (toRemove) {\n    var index = this.animationGroups.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.animationGroups.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Removes the given multi-material from this scene.\r\n   * @param toRemove The multi-material to remove\r\n   * @returns The index of the removed multi-material\r\n   */\n\n\n  Scene.prototype.removeMultiMaterial = function (toRemove) {\n    var index = this.multiMaterials.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.multiMaterials.splice(index, 1);\n    }\n\n    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Removes the given material from this scene.\r\n   * @param toRemove The material to remove\r\n   * @returns The index of the removed material\r\n   */\n\n\n  Scene.prototype.removeMaterial = function (toRemove) {\n    var index = toRemove._indexInSceneMaterialArray;\n\n    if (index !== -1 && index < this.materials.length) {\n      if (index !== this.materials.length - 1) {\n        var lastMaterial = this.materials[this.materials.length - 1];\n        this.materials[index] = lastMaterial;\n        lastMaterial._indexInSceneMaterialArray = index;\n      }\n\n      toRemove._indexInSceneMaterialArray = -1;\n      this.materials.pop();\n    }\n\n    this.onMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Removes the given action manager from this scene.\r\n   * @param toRemove The action manager to remove\r\n   * @returns The index of the removed action manager\r\n   */\n\n\n  Scene.prototype.removeActionManager = function (toRemove) {\n    var index = this.actionManagers.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.actionManagers.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Removes the given texture from this scene.\r\n   * @param toRemove The texture to remove\r\n   * @returns The index of the removed texture\r\n   */\n\n\n  Scene.prototype.removeTexture = function (toRemove) {\n    var index = this.textures.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.textures.splice(index, 1);\n    }\n\n    this.onTextureRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Adds the given light to this scene\r\n   * @param newLight The light to add\r\n   */\n\n\n  Scene.prototype.addLight = function (newLight) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.lights.push(newLight);\n    this.sortLightsByPriority();\n\n    if (!newLight.parent) {\n      newLight._addToSceneRootNodes();\n    } // Add light to all meshes (To support if the light is removed and then re-added)\n\n\n    for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.lightSources.indexOf(newLight) === -1) {\n        mesh.lightSources.push(newLight);\n\n        mesh._resyncLightSources();\n      }\n    }\n\n    this.onNewLightAddedObservable.notifyObservers(newLight);\n  };\n  /**\r\n   * Sorts the list list based on light priorities\r\n   */\n\n\n  Scene.prototype.sortLightsByPriority = function () {\n    if (this.requireLightSorting) {\n      this.lights.sort(Light.CompareLightsPriority);\n    }\n  };\n  /**\r\n   * Adds the given camera to this scene\r\n   * @param newCamera The camera to add\r\n   */\n\n\n  Scene.prototype.addCamera = function (newCamera) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.cameras.push(newCamera);\n    this.onNewCameraAddedObservable.notifyObservers(newCamera);\n\n    if (!newCamera.parent) {\n      newCamera._addToSceneRootNodes();\n    }\n  };\n  /**\r\n   * Adds the given skeleton to this scene\r\n   * @param newSkeleton The skeleton to add\r\n   */\n\n\n  Scene.prototype.addSkeleton = function (newSkeleton) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.skeletons.push(newSkeleton);\n    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n  };\n  /**\r\n   * Adds the given particle system to this scene\r\n   * @param newParticleSystem The particle system to add\r\n   */\n\n\n  Scene.prototype.addParticleSystem = function (newParticleSystem) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.particleSystems.push(newParticleSystem);\n  };\n  /**\r\n   * Adds the given animation to this scene\r\n   * @param newAnimation The animation to add\r\n   */\n\n\n  Scene.prototype.addAnimation = function (newAnimation) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.animations.push(newAnimation);\n  };\n  /**\r\n   * Adds the given animation group to this scene.\r\n   * @param newAnimationGroup The animation group to add\r\n   */\n\n\n  Scene.prototype.addAnimationGroup = function (newAnimationGroup) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.animationGroups.push(newAnimationGroup);\n  };\n  /**\r\n   * Adds the given multi-material to this scene\r\n   * @param newMultiMaterial The multi-material to add\r\n   */\n\n\n  Scene.prototype.addMultiMaterial = function (newMultiMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.multiMaterials.push(newMultiMaterial);\n    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n  };\n  /**\r\n   * Adds the given material to this scene\r\n   * @param newMaterial The material to add\r\n   */\n\n\n  Scene.prototype.addMaterial = function (newMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    newMaterial._indexInSceneMaterialArray = this.materials.length;\n    this.materials.push(newMaterial);\n    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n  };\n  /**\r\n   * Adds the given morph target to this scene\r\n   * @param newMorphTargetManager The morph target to add\r\n   */\n\n\n  Scene.prototype.addMorphTargetManager = function (newMorphTargetManager) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.morphTargetManagers.push(newMorphTargetManager);\n  };\n  /**\r\n   * Adds the given geometry to this scene\r\n   * @param newGeometry The geometry to add\r\n   */\n\n\n  Scene.prototype.addGeometry = function (newGeometry) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    if (this.geometriesByUniqueId) {\n      this.geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n    }\n\n    this.geometries.push(newGeometry);\n  };\n  /**\r\n   * Adds the given action manager to this scene\r\n   * @param newActionManager The action manager to add\r\n   */\n\n\n  Scene.prototype.addActionManager = function (newActionManager) {\n    this.actionManagers.push(newActionManager);\n  };\n  /**\r\n   * Adds the given texture to this scene.\r\n   * @param newTexture The texture to add\r\n   */\n\n\n  Scene.prototype.addTexture = function (newTexture) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.textures.push(newTexture);\n    this.onNewTextureAddedObservable.notifyObservers(newTexture);\n  };\n  /**\r\n   * Switch active camera\r\n   * @param newCamera defines the new active camera\r\n   * @param attachControl defines if attachControl must be called for the new active camera (default: true)\r\n   */\n\n\n  Scene.prototype.switchActiveCamera = function (newCamera, attachControl) {\n    if (attachControl === void 0) {\n      attachControl = true;\n    }\n\n    var canvas = this._engine.getInputElement();\n\n    if (!canvas) {\n      return;\n    }\n\n    if (this.activeCamera) {\n      this.activeCamera.detachControl();\n    }\n\n    this.activeCamera = newCamera;\n\n    if (attachControl) {\n      newCamera.attachControl();\n    }\n  };\n  /**\r\n   * sets the active camera of the scene using its ID\r\n   * @param id defines the camera's ID\r\n   * @return the new active camera or null if none found.\r\n   */\n\n\n  Scene.prototype.setActiveCameraByID = function (id) {\n    var camera = this.getCameraByID(id);\n\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n\n    return null;\n  };\n  /**\r\n   * sets the active camera of the scene using its name\r\n   * @param name defines the camera's name\r\n   * @returns the new active camera or null if none found.\r\n   */\n\n\n  Scene.prototype.setActiveCameraByName = function (name) {\n    var camera = this.getCameraByName(name);\n\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n\n    return null;\n  };\n  /**\r\n   * get an animation group using its name\r\n   * @param name defines the material's name\r\n   * @return the animation group or null if none found.\r\n   */\n\n\n  Scene.prototype.getAnimationGroupByName = function (name) {\n    for (var index = 0; index < this.animationGroups.length; index++) {\n      if (this.animationGroups[index].name === name) {\n        return this.animationGroups[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Get a material using its unique id\r\n   * @param uniqueId defines the material's unique id\r\n   * @return the material or null if none found.\r\n   */\n\n\n  Scene.prototype.getMaterialByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].uniqueId === uniqueId) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * get a material using its id\r\n   * @param id defines the material's ID\r\n   * @return the material or null if none found.\r\n   */\n\n\n  Scene.prototype.getMaterialByID = function (id) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].id === id) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a the last added material using a given id\r\n   * @param id defines the material's ID\r\n   * @return the last material with the given id or null if none found.\r\n   */\n\n\n  Scene.prototype.getLastMaterialByID = function (id) {\n    for (var index = this.materials.length - 1; index >= 0; index--) {\n      if (this.materials[index].id === id) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a material using its name\r\n   * @param name defines the material's name\r\n   * @return the material or null if none found.\r\n   */\n\n\n  Scene.prototype.getMaterialByName = function (name) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].name === name) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Get a texture using its unique id\r\n   * @param uniqueId defines the texture's unique id\r\n   * @return the texture or null if none found.\r\n   */\n\n\n  Scene.prototype.getTextureByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.textures.length; index++) {\n      if (this.textures[index].uniqueId === uniqueId) {\n        return this.textures[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a camera using its id\r\n   * @param id defines the id to look for\r\n   * @returns the camera or null if not found\r\n   */\n\n\n  Scene.prototype.getCameraByID = function (id) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a camera using its unique id\r\n   * @param uniqueId defines the unique id to look for\r\n   * @returns the camera or null if not found\r\n   */\n\n\n  Scene.prototype.getCameraByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].uniqueId === uniqueId) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a camera using its name\r\n   * @param name defines the camera's name\r\n   * @return the camera or null if none found.\r\n   */\n\n\n  Scene.prototype.getCameraByName = function (name) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].name === name) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a bone using its id\r\n   * @param id defines the bone's id\r\n   * @return the bone or null if not found\r\n   */\n\n\n  Scene.prototype.getBoneByID = function (id) {\n    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      var skeleton = this.skeletons[skeletonIndex];\n\n      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].id === id) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n  * Gets a bone using its id\r\n  * @param name defines the bone's name\r\n  * @return the bone or null if not found\r\n  */\n\n\n  Scene.prototype.getBoneByName = function (name) {\n    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      var skeleton = this.skeletons[skeletonIndex];\n\n      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].name === name) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a light node using its name\r\n   * @param name defines the the light's name\r\n   * @return the light or null if none found.\r\n   */\n\n\n  Scene.prototype.getLightByName = function (name) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].name === name) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a light node using its id\r\n   * @param id defines the light's id\r\n   * @return the light or null if none found.\r\n   */\n\n\n  Scene.prototype.getLightByID = function (id) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a light node using its scene-generated unique ID\r\n   * @param uniqueId defines the light's unique id\r\n   * @return the light or null if none found.\r\n   */\n\n\n  Scene.prototype.getLightByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].uniqueId === uniqueId) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a particle system by id\r\n   * @param id defines the particle system id\r\n   * @return the corresponding system or null if none found\r\n   */\n\n\n  Scene.prototype.getParticleSystemByID = function (id) {\n    for (var index = 0; index < this.particleSystems.length; index++) {\n      if (this.particleSystems[index].id === id) {\n        return this.particleSystems[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a geometry using its ID\r\n   * @param id defines the geometry's id\r\n   * @return the geometry or null if none found.\r\n   */\n\n\n  Scene.prototype.getGeometryByID = function (id) {\n    for (var index = 0; index < this.geometries.length; index++) {\n      if (this.geometries[index].id === id) {\n        return this.geometries[index];\n      }\n    }\n\n    return null;\n  };\n\n  Scene.prototype._getGeometryByUniqueID = function (uniqueId) {\n    if (this.geometriesByUniqueId) {\n      var index_1 = this.geometriesByUniqueId[uniqueId];\n\n      if (index_1 !== undefined) {\n        return this.geometries[index_1];\n      }\n    } else {\n      for (var index = 0; index < this.geometries.length; index++) {\n        if (this.geometries[index].uniqueId === uniqueId) {\n          return this.geometries[index];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Add a new geometry to this scene\r\n   * @param geometry defines the geometry to be added to the scene.\r\n   * @param force defines if the geometry must be pushed even if a geometry with this id already exists\r\n   * @return a boolean defining if the geometry was added or not\r\n   */\n\n\n  Scene.prototype.pushGeometry = function (geometry, force) {\n    if (!force && this._getGeometryByUniqueID(geometry.uniqueId)) {\n      return false;\n    }\n\n    this.addGeometry(geometry);\n    this.onNewGeometryAddedObservable.notifyObservers(geometry);\n    return true;\n  };\n  /**\r\n   * Removes an existing geometry\r\n   * @param geometry defines the geometry to be removed from the scene\r\n   * @return a boolean defining if the geometry was removed or not\r\n   */\n\n\n  Scene.prototype.removeGeometry = function (geometry) {\n    var index;\n\n    if (this.geometriesByUniqueId) {\n      index = this.geometriesByUniqueId[geometry.uniqueId];\n\n      if (index === undefined) {\n        return false;\n      }\n    } else {\n      index = this.geometries.indexOf(geometry);\n\n      if (index < 0) {\n        return false;\n      }\n    }\n\n    if (index !== this.geometries.length - 1) {\n      var lastGeometry = this.geometries[this.geometries.length - 1];\n\n      if (lastGeometry) {\n        this.geometries[index] = lastGeometry;\n\n        if (this.geometriesByUniqueId) {\n          this.geometriesByUniqueId[lastGeometry.uniqueId] = index;\n          this.geometriesByUniqueId[geometry.uniqueId] = undefined;\n        }\n      }\n    }\n\n    this.geometries.pop();\n    this.onGeometryRemovedObservable.notifyObservers(geometry);\n    return true;\n  };\n  /**\r\n   * Gets the list of geometries attached to the scene\r\n   * @returns an array of Geometry\r\n   */\n\n\n  Scene.prototype.getGeometries = function () {\n    return this.geometries;\n  };\n  /**\r\n   * Gets the first added mesh found of a given ID\r\n   * @param id defines the id to search for\r\n   * @return the mesh found or null if not found at all\r\n   */\n\n\n  Scene.prototype.getMeshByID = function (id) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a list of meshes using their id\r\n   * @param id defines the id to search for\r\n   * @returns a list of meshes\r\n   */\n\n\n  Scene.prototype.getMeshesByID = function (id) {\n    return this.meshes.filter(function (m) {\n      return m.id === id;\n    });\n  };\n  /**\r\n   * Gets the first added transform node found of a given ID\r\n   * @param id defines the id to search for\r\n   * @return the found transform node or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getTransformNodeByID = function (id) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a transform node with its auto-generated unique id\r\n   * @param uniqueId efines the unique id to search for\r\n   * @return the found transform node or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getTransformNodeByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].uniqueId === uniqueId) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a list of transform nodes using their id\r\n   * @param id defines the id to search for\r\n   * @returns a list of transform nodes\r\n   */\n\n\n  Scene.prototype.getTransformNodesByID = function (id) {\n    return this.transformNodes.filter(function (m) {\n      return m.id === id;\n    });\n  };\n  /**\r\n   * Gets a mesh with its auto-generated unique id\r\n   * @param uniqueId defines the unique id to search for\r\n   * @return the found mesh or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMeshByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].uniqueId === uniqueId) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a the last added mesh using a given id\r\n   * @param id defines the id to search for\r\n   * @return the found mesh or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getLastMeshByID = function (id) {\n    for (var index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a the last added node (Mesh, Camera, Light) using a given id\r\n   * @param id defines the id to search for\r\n   * @return the found node or null if not found at all\r\n   */\n\n\n  Scene.prototype.getLastEntryByID = function (id) {\n    var index;\n\n    for (index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    for (index = this.transformNodes.length - 1; index >= 0; index--) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n\n    for (index = this.cameras.length - 1; index >= 0; index--) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n\n    for (index = this.lights.length - 1; index >= 0; index--) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a node (Mesh, Camera, Light) using a given id\r\n   * @param id defines the id to search for\r\n   * @return the found node or null if not found at all\r\n   */\n\n\n  Scene.prototype.getNodeByID = function (id) {\n    var mesh = this.getMeshByID(id);\n\n    if (mesh) {\n      return mesh;\n    }\n\n    var transformNode = this.getTransformNodeByID(id);\n\n    if (transformNode) {\n      return transformNode;\n    }\n\n    var light = this.getLightByID(id);\n\n    if (light) {\n      return light;\n    }\n\n    var camera = this.getCameraByID(id);\n\n    if (camera) {\n      return camera;\n    }\n\n    var bone = this.getBoneByID(id);\n\n    if (bone) {\n      return bone;\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a node (Mesh, Camera, Light) using a given name\r\n   * @param name defines the name to search for\r\n   * @return the found node or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getNodeByName = function (name) {\n    var mesh = this.getMeshByName(name);\n\n    if (mesh) {\n      return mesh;\n    }\n\n    var transformNode = this.getTransformNodeByName(name);\n\n    if (transformNode) {\n      return transformNode;\n    }\n\n    var light = this.getLightByName(name);\n\n    if (light) {\n      return light;\n    }\n\n    var camera = this.getCameraByName(name);\n\n    if (camera) {\n      return camera;\n    }\n\n    var bone = this.getBoneByName(name);\n\n    if (bone) {\n      return bone;\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a mesh using a given name\r\n   * @param name defines the name to search for\r\n   * @return the found mesh or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMeshByName = function (name) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].name === name) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a transform node using a given name\r\n   * @param name defines the name to search for\r\n   * @return the found transform node or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getTransformNodeByName = function (name) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].name === name) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a skeleton using a given id (if many are found, this function will pick the last one)\r\n   * @param id defines the id to search for\r\n   * @return the found skeleton or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getLastSkeletonByID = function (id) {\n    for (var index = this.skeletons.length - 1; index >= 0; index--) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a skeleton using a given auto generated unique id\r\n   * @param  uniqueId defines the unique id to search for\r\n   * @return the found skeleton or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getSkeletonByUniqueId = function (uniqueId) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].uniqueId === uniqueId) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a skeleton using a given id (if many are found, this function will pick the first one)\r\n   * @param id defines the id to search for\r\n   * @return the found skeleton or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getSkeletonById = function (id) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a skeleton using a given name\r\n   * @param name defines the name to search for\r\n   * @return the found skeleton or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getSkeletonByName = function (name) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].name === name) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\r\n   * @param id defines the id to search for\r\n   * @return the found morph target manager or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMorphTargetManagerById = function (id) {\n    for (var index = 0; index < this.morphTargetManagers.length; index++) {\n      if (this.morphTargetManagers[index].uniqueId === id) {\n        return this.morphTargetManagers[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a morph target using a given id (if many are found, this function will pick the first one)\r\n   * @param id defines the id to search for\r\n   * @return the found morph target or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMorphTargetById = function (id) {\n    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      var morphTargetManager = this.morphTargetManagers[managerIndex];\n\n      for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n        var target = morphTargetManager.getTarget(index);\n\n        if (target.id === id) {\n          return target;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a morph target using a given name (if many are found, this function will pick the first one)\r\n   * @param name defines the name to search for\r\n   * @return the found morph target or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMorphTargetByName = function (name) {\n    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      var morphTargetManager = this.morphTargetManagers[managerIndex];\n\n      for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n        var target = morphTargetManager.getTarget(index);\n\n        if (target.name === name) {\n          return target;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a post process using a given name (if many are found, this function will pick the first one)\r\n   * @param name defines the name to search for\r\n   * @return the found post process or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getPostProcessByName = function (name) {\n    for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n      var postProcess = this.postProcesses[postProcessIndex];\n\n      if (postProcess.name === name) {\n        return postProcess;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a boolean indicating if the given mesh is active\r\n   * @param mesh defines the mesh to look for\r\n   * @returns true if the mesh is in the active list\r\n   */\n\n\n  Scene.prototype.isActiveMesh = function (mesh) {\n    return this._activeMeshes.indexOf(mesh) !== -1;\n  };\n\n  Object.defineProperty(Scene.prototype, \"uid\", {\n    /**\r\n     * Return a unique id as a string which can serve as an identifier for the scene\r\n     */\n    get: function get() {\n      if (!this._uid) {\n        this._uid = Tools.RandomId();\n      }\n\n      return this._uid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Add an externaly attached data from its key.\r\n   * This method call will fail and return false, if such key already exists.\r\n   * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\r\n   * @param key the unique key that identifies the data\r\n   * @param data the data object to associate to the key for this Engine instance\r\n   * @return true if no such key were already present and the data was added successfully, false otherwise\r\n   */\n\n  Scene.prototype.addExternalData = function (key, data) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n\n    return this._externalData.add(key, data);\n  };\n  /**\r\n   * Get an externaly attached data from its key\r\n   * @param key the unique key that identifies the data\r\n   * @return the associated data, if present (can be null), or undefined if not present\r\n   */\n\n\n  Scene.prototype.getExternalData = function (key) {\n    if (!this._externalData) {\n      return null;\n    }\n\n    return this._externalData.get(key);\n  };\n  /**\r\n   * Get an externaly attached data from its key, create it using a factory if it's not already present\r\n   * @param key the unique key that identifies the data\r\n   * @param factory the factory that will be called to create the instance if and only if it doesn't exists\r\n   * @return the associated data, can be null if the factory returned null.\r\n   */\n\n\n  Scene.prototype.getOrAddExternalDataWithFactory = function (key, factory) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n\n    return this._externalData.getOrAddWithFactory(key, factory);\n  };\n  /**\r\n   * Remove an externaly attached data from the Engine instance\r\n   * @param key the unique key that identifies the data\r\n   * @return true if the data was successfully removed, false if it doesn't exist\r\n   */\n\n\n  Scene.prototype.removeExternalData = function (key) {\n    return this._externalData.remove(key);\n  };\n\n  Scene.prototype._evaluateSubMesh = function (subMesh, mesh, initialMesh) {\n    if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {\n      for (var _i = 0, _a = this._evaluateSubMeshStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        step.action(mesh, subMesh);\n      }\n\n      var material = subMesh.getMaterial();\n\n      if (material !== null && material !== undefined) {\n        // Render targets\n        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n          if (this._processedMaterials.indexOf(material) === -1) {\n            this._processedMaterials.push(material);\n\n            this._renderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n          }\n        } // Dispatch\n\n\n        this._renderingManager.dispatch(subMesh, mesh, material);\n      }\n    }\n  };\n  /**\r\n   * Clear the processed materials smart array preventing retention point in material dispose.\r\n   */\n\n\n  Scene.prototype.freeProcessedMaterials = function () {\n    this._processedMaterials.dispose();\n  };\n\n  Object.defineProperty(Scene.prototype, \"blockfreeActiveMeshesAndRenderingGroups\", {\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\r\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\r\n     * when disposing several meshes in a row or a hierarchy of meshes.\r\n     * When used, it is the responsability of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\r\n     */\n    get: function get() {\n      return this._preventFreeActiveMeshesAndRenderingGroups;\n    },\n    set: function set(value) {\n      if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n        return;\n      }\n\n      if (value) {\n        this.freeActiveMeshes();\n        this.freeRenderingGroups();\n      }\n\n      this._preventFreeActiveMeshesAndRenderingGroups = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Clear the active meshes smart array preventing retention point in mesh dispose.\r\n   */\n\n  Scene.prototype.freeActiveMeshes = function () {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n\n    this._activeMeshes.dispose();\n\n    if (this.activeCamera && this.activeCamera._activeMeshes) {\n      this.activeCamera._activeMeshes.dispose();\n    }\n\n    if (this.activeCameras) {\n      for (var i = 0; i < this.activeCameras.length; i++) {\n        var activeCamera = this.activeCameras[i];\n\n        if (activeCamera && activeCamera._activeMeshes) {\n          activeCamera._activeMeshes.dispose();\n        }\n      }\n    }\n  };\n  /**\r\n   * Clear the info related to rendering groups preventing retention points during dispose.\r\n   */\n\n\n  Scene.prototype.freeRenderingGroups = function () {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n\n    if (this._renderingManager) {\n      this._renderingManager.freeRenderingGroups();\n    }\n\n    if (this.textures) {\n      for (var i = 0; i < this.textures.length; i++) {\n        var texture = this.textures[i];\n\n        if (texture && texture.renderList) {\n          texture.freeRenderingGroups();\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._isInIntermediateRendering = function () {\n    return this._intermediateRendering;\n  };\n  /**\r\n   * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\r\n   * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\r\n   * @param onSuccess optional success callback\r\n   * @param onError optional error callback\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.freezeActiveMeshes = function (skipEvaluateActiveMeshes, onSuccess, onError) {\n    var _this = this;\n\n    if (skipEvaluateActiveMeshes === void 0) {\n      skipEvaluateActiveMeshes = false;\n    }\n\n    this.executeWhenReady(function () {\n      if (!_this.activeCamera) {\n        onError && onError('No active camera found');\n        return;\n      }\n\n      if (!_this._frustumPlanes) {\n        _this.setTransformMatrix(_this.activeCamera.getViewMatrix(), _this.activeCamera.getProjectionMatrix());\n      }\n\n      _this._evaluateActiveMeshes();\n\n      _this._activeMeshesFrozen = true;\n      _this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n\n      for (var index = 0; index < _this._activeMeshes.length; index++) {\n        _this._activeMeshes.data[index]._freeze();\n      }\n\n      onSuccess && onSuccess();\n    });\n    return this;\n  };\n  /**\r\n   * Use this function to restart evaluating active meshes on every frame\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.unfreezeActiveMeshes = function () {\n    for (var index = 0; index < this.meshes.length; index++) {\n      var mesh = this.meshes[index];\n\n      if (mesh._internalAbstractMeshDataInfo) {\n        mesh._internalAbstractMeshDataInfo._isActive = false;\n      }\n    }\n\n    for (var index = 0; index < this._activeMeshes.length; index++) {\n      this._activeMeshes.data[index]._unFreeze();\n    }\n\n    this._activeMeshesFrozen = false;\n    return this;\n  };\n\n  Scene.prototype._evaluateActiveMeshes = function () {\n    if (this._activeMeshesFrozen && this._activeMeshes.length) {\n      if (!this._skipEvaluateActiveMeshesCompletely) {\n        var len_1 = this._activeMeshes.length;\n\n        for (var i = 0; i < len_1; i++) {\n          var mesh = this._activeMeshes.data[i];\n          mesh.computeWorldMatrix();\n        }\n      }\n\n      if (this._activeParticleSystems) {\n        var psLength = this._activeParticleSystems.length;\n\n        for (var i = 0; i < psLength; i++) {\n          this._activeParticleSystems.data[i].animate();\n        }\n      }\n\n      return;\n    }\n\n    if (!this.activeCamera) {\n      return;\n    }\n\n    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n\n    this.activeCamera._activeMeshes.reset();\n\n    this._activeMeshes.reset();\n\n    this._renderingManager.reset();\n\n    this._processedMaterials.reset();\n\n    this._activeParticleSystems.reset();\n\n    this._activeSkeletons.reset();\n\n    this._softwareSkinnedMeshes.reset();\n\n    for (var _i = 0, _a = this._beforeEvaluateActiveMeshStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      step.action();\n    } // Determine mesh candidates\n\n\n    var meshes = this.getActiveMeshCandidates(); // Check each mesh\n\n    var len = meshes.length;\n\n    for (var i = 0; i < len; i++) {\n      var mesh = meshes.data[i];\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n\n      if (mesh.isBlocked) {\n        continue;\n      }\n\n      this._totalVertices.addCount(mesh.getTotalVertices(), false);\n\n      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.lengthSquared() === 0) {\n        continue;\n      }\n\n      mesh.computeWorldMatrix(); // Intersections\n\n      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n        this._meshesForIntersections.pushNoDuplicate(mesh);\n      } // Switch to current LOD\n\n\n      var meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\n      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n\n      if (meshToRender === undefined || meshToRender === null) {\n        continue;\n      } // Compute world matrix if LOD is billboard\n\n\n      if (meshToRender !== mesh && meshToRender.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n        meshToRender.computeWorldMatrix();\n      }\n\n      mesh._preActivate();\n\n      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\n        this._activeMeshes.push(mesh);\n\n        this.activeCamera._activeMeshes.push(mesh);\n\n        if (meshToRender !== mesh) {\n          meshToRender._activate(this._renderId, false);\n        }\n\n        for (var _b = 0, _c = this._preActiveMeshStage; _b < _c.length; _b++) {\n          var step = _c[_b];\n          step.action(mesh);\n        }\n\n        if (mesh._activate(this._renderId, false)) {\n          if (!mesh.isAnInstance) {\n            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n          } else {\n            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n              meshToRender = mesh;\n            }\n          }\n\n          meshToRender._internalAbstractMeshDataInfo._isActive = true;\n\n          this._activeMesh(mesh, meshToRender);\n        }\n\n        mesh._postActivate();\n      }\n    }\n\n    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this); // Particle systems\n\n    if (this.particlesEnabled) {\n      this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n\n      for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n        var particleSystem = this.particleSystems[particleIndex];\n\n        if (!particleSystem.isStarted() || !particleSystem.emitter) {\n          continue;\n        }\n\n        var emitter = particleSystem.emitter;\n\n        if (!emitter.position || emitter.isEnabled()) {\n          this._activeParticleSystems.push(particleSystem);\n\n          particleSystem.animate();\n\n          this._renderingManager.dispatchParticles(particleSystem);\n        }\n      }\n\n      this.onAfterParticlesRenderingObservable.notifyObservers(this);\n    }\n  };\n\n  Scene.prototype._activeMesh = function (sourceMesh, mesh) {\n    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n        mesh.skeleton.prepare();\n      }\n\n      if (!mesh.computeBonesUsingShaders) {\n        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n      }\n    }\n\n    if (mesh !== undefined && mesh !== null && mesh.subMeshes !== undefined && mesh.subMeshes !== null && mesh.subMeshes.length > 0) {\n      var subMeshes = this.getActiveSubMeshCandidates(mesh);\n      var len = subMeshes.length;\n\n      for (var i = 0; i < len; i++) {\n        var subMesh = subMeshes.data[i];\n\n        this._evaluateSubMesh(subMesh, mesh, sourceMesh);\n      }\n    }\n  };\n  /**\r\n   * Update the transform matrix to update from the current active camera\r\n   * @param force defines a boolean used to force the update even if cache is up to date\r\n   */\n\n\n  Scene.prototype.updateTransformMatrix = function (force) {\n    if (!this.activeCamera) {\n      return;\n    }\n\n    this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n  };\n\n  Scene.prototype._bindFrameBuffer = function () {\n    if (this.activeCamera && this.activeCamera._multiviewTexture) {\n      this.activeCamera._multiviewTexture._bindFrameBuffer();\n    } else if (this.activeCamera && this.activeCamera.outputRenderTarget) {\n      var useMultiview = this.getEngine().getCaps().multiview && this.activeCamera.outputRenderTarget && this.activeCamera.outputRenderTarget.getViewCount() > 1;\n\n      if (useMultiview) {\n        this.activeCamera.outputRenderTarget._bindFrameBuffer();\n      } else {\n        var internalTexture = this.activeCamera.outputRenderTarget.getInternalTexture();\n\n        if (internalTexture) {\n          this.getEngine().bindFramebuffer(internalTexture);\n        } else {\n          Logger.Error(\"Camera contains invalid customDefaultRenderTarget\");\n        }\n      }\n    } else {\n      this.getEngine().restoreDefaultFramebuffer(); // Restore back buffer if needed\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._renderForCamera = function (camera, rigParent) {\n    if (camera && camera._skipRendering) {\n      return;\n    }\n\n    var engine = this._engine; // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n\n    this._activeCamera = camera;\n\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    } // Viewport\n\n\n    engine.setViewport(this.activeCamera.viewport); // Camera\n\n    this.resetCachedMaterial();\n    this._renderId++;\n    var useMultiview = this.getEngine().getCaps().multiview && camera.outputRenderTarget && camera.outputRenderTarget.getViewCount() > 1;\n\n    if (useMultiview) {\n      this.setTransformMatrix(camera._rigCameras[0].getViewMatrix(), camera._rigCameras[0].getProjectionMatrix(), camera._rigCameras[1].getViewMatrix(), camera._rigCameras[1].getProjectionMatrix());\n    } else {\n      this.updateTransformMatrix();\n    }\n\n    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera); // Meshes\n\n    this._evaluateActiveMeshes(); // Software skinning\n\n\n    for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n      var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n      mesh.applySkeleton(mesh.skeleton);\n    } // Render targets\n\n\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n\n    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n    }\n\n    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n    } // Collects render targets from external components.\n\n\n    for (var _i = 0, _a = this._gatherActiveCameraRenderTargetsStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      step.action(this._renderTargets);\n    }\n\n    var needRebind = false;\n\n    if (this.renderTargetsEnabled) {\n      this._intermediateRendering = true;\n\n      if (this._renderTargets.length > 0) {\n        Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n\n        for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n          var renderTarget = this._renderTargets.data[renderIndex];\n\n          if (renderTarget._shouldRender()) {\n            this._renderId++;\n            var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n            needRebind = true;\n          }\n        }\n\n        Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n        this._renderId++;\n      }\n\n      for (var _b = 0, _c = this._cameraDrawRenderTargetStage; _b < _c.length; _b++) {\n        var step = _c[_b];\n        needRebind = step.action(this.activeCamera) || needRebind;\n      }\n\n      this._intermediateRendering = false; // Need to bind if sub-camera has an outputRenderTarget eg. for webXR\n\n      if (this.activeCamera && this.activeCamera.outputRenderTarget) {\n        needRebind = true;\n      }\n    } // Restore framebuffer after rendering to targets\n\n\n    if (needRebind && !this.prePass) {\n      this._bindFrameBuffer();\n    }\n\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this); // Prepare Frame\n\n    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n      this.postProcessManager._prepareFrame();\n    } // Before Camera Draw\n\n\n    for (var _d = 0, _e = this._beforeCameraDrawStage; _d < _e.length; _d++) {\n      var step = _e[_d];\n      step.action(this.activeCamera);\n    } // Render\n\n\n    this.onBeforeDrawPhaseObservable.notifyObservers(this);\n\n    this._renderingManager.render(null, null, true, true);\n\n    this.onAfterDrawPhaseObservable.notifyObservers(this); // After Camera Draw\n\n    for (var _f = 0, _g = this._afterCameraDrawStage; _f < _g.length; _f++) {\n      var step = _g[_f];\n      step.action(this.activeCamera);\n    } // Finalize frame\n\n\n    if (this.postProcessManager && !camera._multiviewTexture) {\n      // if the camera has an output render target, render the post process to the render target\n      var texture = camera.outputRenderTarget ? camera.outputRenderTarget.getInternalTexture() : undefined;\n\n      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n    } // Reset some special arrays\n\n\n    this._renderTargets.reset();\n\n    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n  };\n\n  Scene.prototype._processSubCameras = function (camera) {\n    if (camera.cameraRigMode === Camera.RIG_MODE_NONE || camera.outputRenderTarget && camera.outputRenderTarget.getViewCount() > 1 && this.getEngine().getCaps().multiview) {\n      this._renderForCamera(camera);\n\n      this.onAfterRenderCameraObservable.notifyObservers(camera);\n      return;\n    }\n\n    if (camera._useMultiviewToSingleView) {\n      this._renderMultiviewToSingleView(camera);\n    } else {\n      // rig cameras\n      for (var index = 0; index < camera._rigCameras.length; index++) {\n        this._renderForCamera(camera._rigCameras[index], camera);\n      }\n    } // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n\n\n    this._activeCamera = camera;\n    this.setTransformMatrix(this._activeCamera.getViewMatrix(), this._activeCamera.getProjectionMatrix());\n    this.onAfterRenderCameraObservable.notifyObservers(camera);\n  };\n\n  Scene.prototype._checkIntersections = function () {\n    for (var index = 0; index < this._meshesForIntersections.length; index++) {\n      var sourceMesh = this._meshesForIntersections.data[index];\n\n      if (!sourceMesh.actionManager) {\n        continue;\n      }\n\n      for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n        var action = sourceMesh.actionManager.actions[actionIndex];\n\n        if (action.trigger === 12 || action.trigger === 13) {\n          var parameters = action.getTriggerParameter();\n          var otherMesh = parameters instanceof AbstractMesh ? parameters : parameters.mesh;\n          var areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n\n          var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n\n          if (areIntersecting && currentIntersectionInProgress === -1) {\n            if (action.trigger === 12) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n\n              sourceMesh._intersectionsInProgress.push(otherMesh);\n            } else if (action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.push(otherMesh);\n            }\n          } else if (!areIntersecting && currentIntersectionInProgress > -1) {\n            //They intersected, and now they don't.\n            //is this trigger an exit trigger? execute an event.\n            if (action.trigger === 13) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n            } //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n\n\n            if (!sourceMesh.actionManager.hasSpecificTrigger(13, function (parameter) {\n              var parameterMesh = parameter instanceof AbstractMesh ? parameter : parameter.mesh;\n              return otherMesh === parameterMesh;\n            }) || action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n            }\n          }\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._advancePhysicsEngineStep = function (step) {// Do nothing. Code will be replaced if physics engine component is referenced\n  };\n  /** @hidden */\n\n\n  Scene.prototype._animate = function () {// Nothing to do as long as Animatable have not been imported.\n  };\n  /** Execute all animations (for a frame) */\n\n\n  Scene.prototype.animate = function () {\n    if (this._engine.isDeterministicLockStep()) {\n      var deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n\n      var defaultFrameTime = this._engine.getTimeStep();\n\n      var defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n      var stepsTaken = 0;\n\n      var maxSubSteps = this._engine.getLockstepMaxSteps();\n\n      var internalSteps = Math.floor(deltaTime / defaultFrameTime);\n      internalSteps = Math.min(internalSteps, maxSubSteps);\n\n      while (deltaTime > 0 && stepsTaken < internalSteps) {\n        this.onBeforeStepObservable.notifyObservers(this); // Animations\n\n        this._animationRatio = defaultFrameTime * defaultFPS;\n\n        this._animate();\n\n        this.onAfterAnimationsObservable.notifyObservers(this); // Physics\n\n        if (this.physicsEnabled) {\n          this._advancePhysicsEngineStep(defaultFrameTime);\n        }\n\n        this.onAfterStepObservable.notifyObservers(this);\n        this._currentStepId++;\n        stepsTaken++;\n        deltaTime -= defaultFrameTime;\n      }\n\n      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n    } else {\n      // Animations\n      var deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n      this._animationRatio = deltaTime * (60.0 / 1000.0);\n\n      this._animate();\n\n      this.onAfterAnimationsObservable.notifyObservers(this); // Physics\n\n      if (this.physicsEnabled) {\n        this._advancePhysicsEngineStep(deltaTime);\n      }\n    }\n  };\n  /**\r\n   * Render the scene\r\n   * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\r\n   * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\r\n   */\n\n\n  Scene.prototype.render = function (updateCameras, ignoreAnimations) {\n    if (updateCameras === void 0) {\n      updateCameras = true;\n    }\n\n    if (ignoreAnimations === void 0) {\n      ignoreAnimations = false;\n    }\n\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === -1) {\n      this._checkIsReady();\n    }\n\n    this._frameId++; // Register components that have been associated lately to the scene.\n\n    this._registerTransientComponents();\n\n    this._activeParticles.fetchNewFrame();\n\n    this._totalVertices.fetchNewFrame();\n\n    this._activeIndices.fetchNewFrame();\n\n    this._activeBones.fetchNewFrame();\n\n    this._meshesForIntersections.reset();\n\n    this.resetCachedMaterial();\n    this.onBeforeAnimationsObservable.notifyObservers(this); // Actions\n\n    if (this.actionManager) {\n      this.actionManager.processTrigger(11);\n    } // Animations\n\n\n    if (!ignoreAnimations) {\n      this.animate();\n    } // Before camera update steps\n\n\n    for (var _i = 0, _a = this._beforeCameraUpdateStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      step.action();\n    } // Update Cameras\n\n\n    if (updateCameras) {\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n          var camera = this.activeCameras[cameraIndex];\n          camera.update();\n\n          if (camera.cameraRigMode !== Camera.RIG_MODE_NONE) {\n            // rig cameras\n            for (var index = 0; index < camera._rigCameras.length; index++) {\n              camera._rigCameras[index].update();\n            }\n          }\n        }\n      } else if (this.activeCamera) {\n        this.activeCamera.update();\n\n        if (this.activeCamera.cameraRigMode !== Camera.RIG_MODE_NONE) {\n          // rig cameras\n          for (var index = 0; index < this.activeCamera._rigCameras.length; index++) {\n            this.activeCamera._rigCameras[index].update();\n          }\n        }\n      }\n    } // Before render\n\n\n    this.onBeforeRenderObservable.notifyObservers(this); // Customs render targets\n\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n    var engine = this.getEngine();\n    var currentActiveCamera = this.activeCamera;\n\n    if (this.renderTargetsEnabled) {\n      Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = true;\n\n      for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n        var renderTarget = this.customRenderTargets[customIndex];\n\n        if (renderTarget._shouldRender()) {\n          this._renderId++;\n          this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n\n          if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n          } // Viewport\n\n\n          engine.setViewport(this.activeCamera.viewport); // Camera\n\n          this.updateTransformMatrix();\n          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n        }\n      }\n\n      Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = false;\n      this._renderId++;\n    } // Restore back buffer\n\n\n    this.activeCamera = currentActiveCamera;\n\n    if (this._activeCamera && this._activeCamera.cameraRigMode !== Camera.RIG_MODE_CUSTOM && !this.prePass) {\n      this._bindFrameBuffer();\n    }\n\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n\n    for (var _b = 0, _c = this._beforeClearStage; _b < _c.length; _b++) {\n      var step = _c[_b];\n      step.action();\n    } // Clear\n\n\n    if ((this.autoClearDepthAndStencil || this.autoClear) && !this.prePass) {\n      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n    } // Collects render targets from external components.\n\n\n    for (var _d = 0, _e = this._gatherRenderTargetsStage; _d < _e.length; _d++) {\n      var step = _e[_d];\n      step.action(this._renderTargets);\n    } // Multi-cameras?\n\n\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n        if (cameraIndex > 0) {\n          this._engine.clear(null, false, true, true);\n        }\n\n        this._processSubCameras(this.activeCameras[cameraIndex]);\n      }\n    } else {\n      if (!this.activeCamera) {\n        throw new Error(\"No camera defined\");\n      }\n\n      this._processSubCameras(this.activeCamera);\n    } // Intersection checks\n\n\n    this._checkIntersections(); // Executes the after render stage actions.\n\n\n    for (var _f = 0, _g = this._afterRenderStage; _f < _g.length; _f++) {\n      var step = _g[_f];\n      step.action();\n    } // After render\n\n\n    if (this.afterRender) {\n      this.afterRender();\n    }\n\n    this.onAfterRenderObservable.notifyObservers(this); // Cleaning\n\n    if (this._toBeDisposed.length) {\n      for (var index = 0; index < this._toBeDisposed.length; index++) {\n        var data = this._toBeDisposed[index];\n\n        if (data) {\n          data.dispose();\n        }\n      }\n\n      this._toBeDisposed = [];\n    }\n\n    if (this.dumpNextRenderTargets) {\n      this.dumpNextRenderTargets = false;\n    }\n\n    this._activeBones.addCount(0, true);\n\n    this._activeIndices.addCount(0, true);\n\n    this._activeParticles.addCount(0, true);\n  };\n  /**\r\n   * Freeze all materials\r\n   * A frozen material will not be updatable but should be faster to render\r\n   */\n\n\n  Scene.prototype.freezeMaterials = function () {\n    for (var i = 0; i < this.materials.length; i++) {\n      this.materials[i].freeze();\n    }\n  };\n  /**\r\n   * Unfreeze all materials\r\n   * A frozen material will not be updatable but should be faster to render\r\n   */\n\n\n  Scene.prototype.unfreezeMaterials = function () {\n    for (var i = 0; i < this.materials.length; i++) {\n      this.materials[i].unfreeze();\n    }\n  };\n  /**\r\n   * Releases all held ressources\r\n   */\n\n\n  Scene.prototype.dispose = function () {\n    this.beforeRender = null;\n    this.afterRender = null;\n\n    if (EngineStore._LastCreatedScene === this) {\n      EngineStore._LastCreatedScene = null;\n    }\n\n    this.skeletons = [];\n    this.morphTargetManagers = [];\n    this._transientComponents = [];\n\n    this._isReadyForMeshStage.clear();\n\n    this._beforeEvaluateActiveMeshStage.clear();\n\n    this._evaluateSubMeshStage.clear();\n\n    this._preActiveMeshStage.clear();\n\n    this._cameraDrawRenderTargetStage.clear();\n\n    this._beforeCameraDrawStage.clear();\n\n    this._beforeRenderTargetDrawStage.clear();\n\n    this._beforeRenderingGroupDrawStage.clear();\n\n    this._beforeRenderingMeshStage.clear();\n\n    this._afterRenderingMeshStage.clear();\n\n    this._afterRenderingGroupDrawStage.clear();\n\n    this._afterCameraDrawStage.clear();\n\n    this._afterRenderTargetDrawStage.clear();\n\n    this._afterRenderStage.clear();\n\n    this._beforeCameraUpdateStage.clear();\n\n    this._beforeClearStage.clear();\n\n    this._gatherRenderTargetsStage.clear();\n\n    this._gatherActiveCameraRenderTargetsStage.clear();\n\n    this._pointerMoveStage.clear();\n\n    this._pointerDownStage.clear();\n\n    this._pointerUpStage.clear();\n\n    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {\n      var component = _a[_i];\n      component.dispose();\n    }\n\n    this.importedMeshesFiles = new Array();\n\n    if (this.stopAllAnimations) {\n      this.stopAllAnimations();\n    }\n\n    this.resetCachedMaterial(); // Smart arrays\n\n    if (this.activeCamera) {\n      this.activeCamera._activeMeshes.dispose();\n\n      this.activeCamera = null;\n    }\n\n    this._activeMeshes.dispose();\n\n    this._renderingManager.dispose();\n\n    this._processedMaterials.dispose();\n\n    this._activeParticleSystems.dispose();\n\n    this._activeSkeletons.dispose();\n\n    this._softwareSkinnedMeshes.dispose();\n\n    this._renderTargets.dispose();\n\n    this._registeredForLateAnimationBindings.dispose();\n\n    this._meshesForIntersections.dispose();\n\n    this._toBeDisposed = []; // Abort active requests\n\n    for (var _b = 0, _c = this._activeRequests; _b < _c.length; _b++) {\n      var request = _c[_b];\n      request.abort();\n    } // Events\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderTargetsRenderObservable.clear();\n    this.onAfterRenderTargetsRenderObservable.clear();\n    this.onAfterStepObservable.clear();\n    this.onBeforeStepObservable.clear();\n    this.onBeforeActiveMeshesEvaluationObservable.clear();\n    this.onAfterActiveMeshesEvaluationObservable.clear();\n    this.onBeforeParticlesRenderingObservable.clear();\n    this.onAfterParticlesRenderingObservable.clear();\n    this.onBeforeDrawPhaseObservable.clear();\n    this.onAfterDrawPhaseObservable.clear();\n    this.onBeforeAnimationsObservable.clear();\n    this.onAfterAnimationsObservable.clear();\n    this.onDataLoadedObservable.clear();\n    this.onBeforeRenderingGroupObservable.clear();\n    this.onAfterRenderingGroupObservable.clear();\n    this.onMeshImportedObservable.clear();\n    this.onBeforeCameraRenderObservable.clear();\n    this.onAfterCameraRenderObservable.clear();\n    this.onReadyObservable.clear();\n    this.onNewCameraAddedObservable.clear();\n    this.onCameraRemovedObservable.clear();\n    this.onNewLightAddedObservable.clear();\n    this.onLightRemovedObservable.clear();\n    this.onNewGeometryAddedObservable.clear();\n    this.onGeometryRemovedObservable.clear();\n    this.onNewTransformNodeAddedObservable.clear();\n    this.onTransformNodeRemovedObservable.clear();\n    this.onNewMeshAddedObservable.clear();\n    this.onMeshRemovedObservable.clear();\n    this.onNewSkeletonAddedObservable.clear();\n    this.onSkeletonRemovedObservable.clear();\n    this.onNewMaterialAddedObservable.clear();\n    this.onNewMultiMaterialAddedObservable.clear();\n    this.onMaterialRemovedObservable.clear();\n    this.onMultiMaterialRemovedObservable.clear();\n    this.onNewTextureAddedObservable.clear();\n    this.onTextureRemovedObservable.clear();\n    this.onPrePointerObservable.clear();\n    this.onPointerObservable.clear();\n    this.onPreKeyboardObservable.clear();\n    this.onKeyboardObservable.clear();\n    this.onActiveCameraChanged.clear();\n    this.detachControl(); // Detach cameras\n\n    var canvas = this._engine.getInputElement();\n\n    if (canvas) {\n      var index;\n\n      for (index = 0; index < this.cameras.length; index++) {\n        this.cameras[index].detachControl();\n      }\n    } // Release animation groups\n\n\n    while (this.animationGroups.length) {\n      this.animationGroups[0].dispose();\n    } // Release lights\n\n\n    while (this.lights.length) {\n      this.lights[0].dispose();\n    } // Release meshes\n\n\n    while (this.meshes.length) {\n      this.meshes[0].dispose(true);\n    }\n\n    while (this.transformNodes.length) {\n      this.transformNodes[0].dispose(true);\n    } // Release cameras\n\n\n    while (this.cameras.length) {\n      this.cameras[0].dispose();\n    } // Release materials\n\n\n    if (this._defaultMaterial) {\n      this._defaultMaterial.dispose();\n    }\n\n    while (this.multiMaterials.length) {\n      this.multiMaterials[0].dispose();\n    }\n\n    while (this.materials.length) {\n      this.materials[0].dispose();\n    } // Release particles\n\n\n    while (this.particleSystems.length) {\n      this.particleSystems[0].dispose();\n    } // Release postProcesses\n\n\n    while (this.postProcesses.length) {\n      this.postProcesses[0].dispose();\n    } // Release textures\n\n\n    while (this.textures.length) {\n      this.textures[0].dispose();\n    } // Release UBO\n\n\n    this._sceneUbo.dispose();\n\n    if (this._multiviewSceneUbo) {\n      this._multiviewSceneUbo.dispose();\n    } // Post-processes\n\n\n    this.postProcessManager.dispose(); // Remove from engine\n\n    index = this._engine.scenes.indexOf(this);\n\n    if (index > -1) {\n      this._engine.scenes.splice(index, 1);\n    }\n\n    this._engine.wipeCaches(true);\n\n    this._isDisposed = true;\n  };\n\n  Object.defineProperty(Scene.prototype, \"isDisposed\", {\n    /**\r\n     * Gets if the scene is already disposed\r\n     */\n    get: function get() {\n      return this._isDisposed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Call this function to reduce memory footprint of the scene.\r\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n   */\n\n  Scene.prototype.clearCachedVertexData = function () {\n    for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n      var mesh = this.meshes[meshIndex];\n      var geometry = mesh.geometry;\n\n      if (geometry) {\n        geometry._indices = [];\n\n        for (var vbName in geometry._vertexBuffers) {\n          if (!geometry._vertexBuffers.hasOwnProperty(vbName)) {\n            continue;\n          }\n\n          geometry._vertexBuffers[vbName]._buffer._data = null;\n        }\n      }\n    }\n  };\n  /**\r\n   * This function will remove the local cached buffer data from texture.\r\n   * It will save memory but will prevent the texture from being rebuilt\r\n   */\n\n\n  Scene.prototype.cleanCachedTextureBuffer = function () {\n    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {\n      var baseTexture = _a[_i];\n      var buffer = baseTexture._buffer;\n\n      if (buffer) {\n        baseTexture._buffer = null;\n      }\n    }\n  };\n  /**\r\n   * Get the world extend vectors with an optional filter\r\n   *\r\n   * @param filterPredicate the predicate - which meshes should be included when calculating the world size\r\n   * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\r\n   */\n\n\n  Scene.prototype.getWorldExtends = function (filterPredicate) {\n    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    filterPredicate = filterPredicate || function () {\n      return true;\n    };\n\n    this.meshes.filter(filterPredicate).forEach(function (mesh) {\n      mesh.computeWorldMatrix(true);\n\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n        return;\n      }\n\n      var boundingInfo = mesh.getBoundingInfo();\n      var minBox = boundingInfo.boundingBox.minimumWorld;\n      var maxBox = boundingInfo.boundingBox.maximumWorld;\n      Vector3.CheckExtends(minBox, min, max);\n      Vector3.CheckExtends(maxBox, min, max);\n    });\n    return {\n      min: min,\n      max: max\n    };\n  }; // Picking\n\n  /**\r\n   * Creates a ray that can be used to pick in the scene\r\n   * @param x defines the x coordinate of the origin (on-screen)\r\n   * @param y defines the y coordinate of the origin (on-screen)\r\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n   * @param camera defines the camera to use for the picking\r\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n   * @returns a Ray\r\n   */\n\n\n  Scene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace) {\n    if (cameraViewSpace === void 0) {\n      cameraViewSpace = false;\n    }\n\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Creates a ray that can be used to pick in the scene\r\n   * @param x defines the x coordinate of the origin (on-screen)\r\n   * @param y defines the y coordinate of the origin (on-screen)\r\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n   * @param result defines the ray where to store the picking ray\r\n   * @param camera defines the camera to use for the picking\r\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace) {\n    if (cameraViewSpace === void 0) {\n      cameraViewSpace = false;\n    }\n\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Creates a ray that can be used to pick in the scene\r\n   * @param x defines the x coordinate of the origin (on-screen)\r\n   * @param y defines the y coordinate of the origin (on-screen)\r\n   * @param camera defines the camera to use for the picking\r\n   * @returns a Ray\r\n   */\n\n\n  Scene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Creates a ray that can be used to pick in the scene\r\n   * @param x defines the x coordinate of the origin (on-screen)\r\n   * @param y defines the y coordinate of the origin (on-screen)\r\n   * @param result defines the ray where to store the picking ray\r\n   * @param camera defines the camera to use for the picking\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /** Launch a ray to try to pick a mesh in the scene\r\n   * @param x position on screen\r\n   * @param y position on screen\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns a PickingInfo\r\n   */\n\n\n  Scene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate) {\n    // Dummy info if picking as not been imported\n    var pi = new PickingInfo();\n    pi._pickingUnavailable = true;\n    return pi;\n  };\n  /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\r\n   * @param x position on screen\r\n   * @param y position on screen\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n   * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\r\n   */\n\n\n  Scene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n    // Dummy info if picking as not been imported\n    var pi = new PickingInfo();\n    pi._pickingUnavailable = true;\n    return pi;\n  };\n  /** Use the given ray to pick a mesh in the scene\r\n   * @param ray The ray to use to pick meshes\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns a PickingInfo\r\n   */\n\n\n  Scene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Launch a ray to try to pick a mesh in the scene\r\n   * @param x X position on screen\r\n   * @param y Y position on screen\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n   * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns an array of PickingInfo\r\n   */\n\n\n  Scene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Launch a ray to try to pick a mesh in the scene\r\n   * @param ray Ray to use\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns an array of PickingInfo\r\n   */\n\n\n  Scene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Force the value of meshUnderPointer\r\n   * @param mesh defines the mesh to use\r\n   * @param pointerId optional pointer id when using more than one pointer\r\n   */\n\n\n  Scene.prototype.setPointerOverMesh = function (mesh, pointerId) {\n    this._inputManager.setPointerOverMesh(mesh, pointerId);\n  };\n  /**\r\n   * Gets the mesh under the pointer\r\n   * @returns a Mesh or null if no mesh is under the pointer\r\n   */\n\n\n  Scene.prototype.getPointerOverMesh = function () {\n    return this._inputManager.getPointerOverMesh();\n  }; // Misc.\n\n  /** @hidden */\n\n\n  Scene.prototype._rebuildGeometries = function () {\n    for (var _i = 0, _a = this.geometries; _i < _a.length; _i++) {\n      var geometry = _a[_i];\n\n      geometry._rebuild();\n    }\n\n    for (var _b = 0, _c = this.meshes; _b < _c.length; _b++) {\n      var mesh = _c[_b];\n\n      mesh._rebuild();\n    }\n\n    if (this.postProcessManager) {\n      this.postProcessManager._rebuild();\n    }\n\n    for (var _d = 0, _e = this._components; _d < _e.length; _d++) {\n      var component = _e[_d];\n      component.rebuild();\n    }\n\n    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {\n      var system = _g[_f];\n      system.rebuild();\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._rebuildTextures = function () {\n    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {\n      var texture = _a[_i];\n\n      texture._rebuild();\n    }\n\n    this.markAllMaterialsAsDirty(1);\n  }; // Tags\n\n\n  Scene.prototype._getByTags = function (list, tagsQuery, forEach) {\n    if (tagsQuery === undefined) {\n      // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n      return list;\n    }\n\n    var listByTags = [];\n\n    forEach = forEach || function (item) {\n      return;\n    };\n\n    for (var i in list) {\n      var item = list[i];\n\n      if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\n        listByTags.push(item);\n        forEach(item);\n      }\n    }\n\n    return listByTags;\n  };\n  /**\r\n   * Get a list of meshes by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of Mesh\r\n   */\n\n\n  Scene.prototype.getMeshesByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.meshes, tagsQuery, forEach);\n  };\n  /**\r\n   * Get a list of cameras by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of Camera\r\n   */\n\n\n  Scene.prototype.getCamerasByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.cameras, tagsQuery, forEach);\n  };\n  /**\r\n   * Get a list of lights by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of Light\r\n   */\n\n\n  Scene.prototype.getLightsByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.lights, tagsQuery, forEach);\n  };\n  /**\r\n   * Get a list of materials by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of Material\r\n   */\n\n\n  Scene.prototype.getMaterialByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n  };\n  /**\r\n   * Get a list of transform nodes by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of TransformNode\r\n   */\n\n\n  Scene.prototype.getTransformNodesByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.transformNodes, tagsQuery, forEach);\n  };\n  /**\r\n   * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n   * This allowed control for front to back rendering or reversly depending of the special needs.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n   */\n\n\n  Scene.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n  };\n  /**\r\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n   */\n\n\n  Scene.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n  };\n  /**\r\n   * Gets the current auto clear configuration for one rendering group of the rendering\r\n   * manager.\r\n   * @param index the rendering group index to get the information for\r\n   * @returns The auto clear setup for the requested rendering group\r\n   */\n\n\n  Scene.prototype.getAutoClearDepthStencilSetup = function (index) {\n    return this._renderingManager.getAutoClearDepthStencilSetup(index);\n  };\n\n  Object.defineProperty(Scene.prototype, \"blockMaterialDirtyMechanism\", {\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n    get: function get() {\n      return this._blockMaterialDirtyMechanism;\n    },\n    set: function set(value) {\n      if (this._blockMaterialDirtyMechanism === value) {\n        return;\n      }\n\n      this._blockMaterialDirtyMechanism = value;\n\n      if (!value) {\n        // Do a complete update\n        this.markAllMaterialsAsDirty(63);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Will flag all materials as dirty to trigger new shader compilation\r\n   * @param flag defines the flag used to specify which material part must be marked as dirty\r\n   * @param predicate If not null, it will be used to specifiy if a material has to be marked as dirty\r\n   */\n\n  Scene.prototype.markAllMaterialsAsDirty = function (flag, predicate) {\n    if (this._blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.materials; _i < _a.length; _i++) {\n      var material = _a[_i];\n\n      if (predicate && !predicate(material)) {\n        continue;\n      }\n\n      material.markAsDirty(flag);\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._loadFile = function (url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError) {\n    var _this = this;\n\n    var request = FileTools.LoadFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /** @hidden */\n\n\n  Scene.prototype._loadFileAsync = function (url, onProgress, useOfflineSupport, useArrayBuffer) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._loadFile(url, function (data) {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, function (request, exception) {\n        reject(exception);\n      });\n    });\n  };\n  /** @hidden */\n\n\n  Scene.prototype._requestFile = function (url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n    var _this = this;\n\n    var request = FileTools.RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /** @hidden */\n\n\n  Scene.prototype._requestFileAsync = function (url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._requestFile(url, function (data) {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, function (error) {\n        reject(error);\n      }, onOpened);\n    });\n  };\n  /** @hidden */\n\n\n  Scene.prototype._readFile = function (file, onSuccess, onProgress, useArrayBuffer, onError) {\n    var _this = this;\n\n    var request = FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /** @hidden */\n\n\n  Scene.prototype._readFileAsync = function (file, onProgress, useArrayBuffer) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._readFile(file, function (data) {\n        resolve(data);\n      }, onProgress, useArrayBuffer, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /** The fog is deactivated */\n\n\n  Scene.FOGMODE_NONE = 0;\n  /** The fog density is following an exponential function */\n\n  Scene.FOGMODE_EXP = 1;\n  /** The fog density is following an exponential function faster than FOGMODE_EXP */\n\n  Scene.FOGMODE_EXP2 = 2;\n  /** The fog density is following a linear function. */\n\n  Scene.FOGMODE_LINEAR = 3;\n  /**\r\n   * Gets or sets the minimum deltatime when deterministic lock step is enabled\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   */\n\n  Scene.MinDeltaTime = 1.0;\n  /**\r\n   * Gets or sets the maximum deltatime when deterministic lock step is enabled\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   */\n\n  Scene.MaxDeltaTime = 1000.0;\n  return Scene;\n}(AbstractScene);\n\nexport { Scene };","map":null,"metadata":{},"sourceType":"module"}