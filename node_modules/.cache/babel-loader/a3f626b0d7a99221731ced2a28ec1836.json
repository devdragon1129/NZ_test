{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../Misc/decorators\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\nimport { PostProcess } from \"./postProcess\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport \"../Shaders/imageProcessing.fragment\";\nimport \"../Shaders/postprocess.vertex\";\n/**\r\n * ImageProcessingPostProcess\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#imageprocessing\r\n */\n\nvar ImageProcessingPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(ImageProcessingPostProcess, _super);\n\n  function ImageProcessingPostProcess(name, options, camera, samplingMode, engine, reusable, textureType, imageProcessingConfiguration) {\n    if (camera === void 0) {\n      camera = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var _this = _super.call(this, name, \"imageProcessing\", [], [], options, camera, samplingMode, engine, reusable, null, textureType, \"postprocess\", null, true) || this;\n\n    _this._fromLinearSpace = true;\n    /**\r\n     * Defines cache preventing GC.\r\n     */\n\n    _this._defines = {\n      IMAGEPROCESSING: false,\n      VIGNETTE: false,\n      VIGNETTEBLENDMODEMULTIPLY: false,\n      VIGNETTEBLENDMODEOPAQUE: false,\n      TONEMAPPING: false,\n      TONEMAPPING_ACES: false,\n      CONTRAST: false,\n      COLORCURVES: false,\n      COLORGRADING: false,\n      COLORGRADING3D: false,\n      FROMLINEARSPACE: false,\n      SAMPLER3DGREENDEPTH: false,\n      SAMPLER3DBGRMAP: false,\n      IMAGEPROCESSINGPOSTPROCESS: false,\n      EXPOSURE: false\n    }; // Setup the configuration as forced by the constructor. This would then not force the\n    // scene materials output in linear space and let untouched the default forward pass.\n\n    if (imageProcessingConfiguration) {\n      imageProcessingConfiguration.applyByPostProcess = true;\n\n      _this._attachImageProcessingConfiguration(imageProcessingConfiguration, true); // This will cause the shader to be compiled\n\n\n      _this.fromLinearSpace = false;\n    } // Setup the default processing configuration to the scene.\n    else {\n      _this._attachImageProcessingConfiguration(null, true);\n\n      _this.imageProcessingConfiguration.applyByPostProcess = true;\n    }\n\n    _this.onApply = function (effect) {\n      _this.imageProcessingConfiguration.bind(effect, _this.aspectRatio);\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"imageProcessingConfiguration\", {\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration;\n    },\n\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\n    set: function set(value) {\n      // We are almost sure it is applied by post process as\n      // We are in the post process :-)\n      value.applyByPostProcess = true;\n\n      this._attachImageProcessingConfiguration(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Attaches a new image processing configuration to the PBR Material.\r\n   * @param configuration\r\n   */\n\n  ImageProcessingPostProcess.prototype._attachImageProcessingConfiguration = function (configuration, doNotBuild) {\n    var _this = this;\n\n    if (doNotBuild === void 0) {\n      doNotBuild = false;\n    }\n\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    } // Detaches observer.\n\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    } // Pick the scene configuration if needed.\n\n\n    if (!configuration) {\n      var scene = null;\n      var engine = this.getEngine();\n      var camera = this.getCamera();\n\n      if (camera) {\n        scene = camera.getScene();\n      } else if (engine && engine.scenes) {\n        var scenes = engine.scenes;\n        scene = scenes[scenes.length - 1];\n      } else {\n        scene = EngineStore.LastCreatedScene;\n      }\n\n      if (scene) {\n        this._imageProcessingConfiguration = scene.imageProcessingConfiguration;\n      } else {\n        this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n      }\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    } // Attaches observer.\n\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {\n        _this._updateParameters();\n      });\n    } // Ensure the effect will be rebuilt.\n\n\n    if (!doNotBuild) {\n      this._updateParameters();\n    }\n  };\n\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"isSupported\", {\n    /**\r\n     * If the post process is supported.\r\n     */\n    get: function get() {\n      var effect = this.getEffect();\n      return !effect || effect.isSupported;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"colorCurves\", {\n    /**\r\n     * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.colorCurves;\n    },\n\n    /**\r\n     * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.colorCurves = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"colorCurvesEnabled\", {\n    /**\r\n     * Gets wether the color curves effect is enabled.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.colorCurvesEnabled;\n    },\n\n    /**\r\n     * Sets wether the color curves effect is enabled.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.colorCurvesEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"colorGradingTexture\", {\n    /**\r\n     * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.colorGradingTexture;\n    },\n\n    /**\r\n     * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.colorGradingTexture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"colorGradingEnabled\", {\n    /**\r\n     * Gets wether the color grading effect is enabled.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.colorGradingEnabled;\n    },\n\n    /**\r\n     * Gets wether the color grading effect is enabled.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.colorGradingEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"exposure\", {\n    /**\r\n     * Gets exposure used in the effect.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.exposure;\n    },\n\n    /**\r\n     * Sets exposure used in the effect.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.exposure = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"toneMappingEnabled\", {\n    /**\r\n     * Gets wether tonemapping is enabled or not.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration.toneMappingEnabled;\n    },\n\n    /**\r\n     * Sets wether tonemapping is enabled or not\r\n     */\n    set: function set(value) {\n      this._imageProcessingConfiguration.toneMappingEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"toneMappingType\", {\n    /**\r\n     * Gets the type of tone mapping effect.\r\n     */\n    get: function get() {\n      return this._imageProcessingConfiguration.toneMappingType;\n    },\n\n    /**\r\n     * Sets the type of tone mapping effect.\r\n     */\n    set: function set(value) {\n      this._imageProcessingConfiguration.toneMappingType = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"contrast\", {\n    /**\r\n     * Gets contrast used in the effect.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.contrast;\n    },\n\n    /**\r\n     * Sets contrast used in the effect.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.contrast = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteStretch\", {\n    /**\r\n     * Gets Vignette stretch size.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.vignetteStretch;\n    },\n\n    /**\r\n     * Sets Vignette stretch size.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.vignetteStretch = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteCentreX\", {\n    /**\r\n     * Gets Vignette centre X Offset.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.vignetteCentreX;\n    },\n\n    /**\r\n     * Sets Vignette centre X Offset.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.vignetteCentreX = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteCentreY\", {\n    /**\r\n     * Gets Vignette centre Y Offset.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.vignetteCentreY;\n    },\n\n    /**\r\n     * Sets Vignette centre Y Offset.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.vignetteCentreY = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteWeight\", {\n    /**\r\n     * Gets Vignette weight or intensity of the vignette effect.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.vignetteWeight;\n    },\n\n    /**\r\n     * Sets Vignette weight or intensity of the vignette effect.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.vignetteWeight = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteColor\", {\n    /**\r\n     * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\r\n     * if vignetteEnabled is set to true.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.vignetteColor;\n    },\n\n    /**\r\n     * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\r\n     * if vignetteEnabled is set to true.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.vignetteColor = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteCameraFov\", {\n    /**\r\n     * Gets Camera field of view used by the Vignette effect.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.vignetteCameraFov;\n    },\n\n    /**\r\n     * Sets Camera field of view used by the Vignette effect.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.vignetteCameraFov = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteBlendMode\", {\n    /**\r\n     * Gets the vignette blend mode allowing different kind of effect.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.vignetteBlendMode;\n    },\n\n    /**\r\n     * Sets the vignette blend mode allowing different kind of effect.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.vignetteBlendMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteEnabled\", {\n    /**\r\n     * Gets wether the vignette effect is enabled.\r\n     */\n    get: function get() {\n      return this.imageProcessingConfiguration.vignetteEnabled;\n    },\n\n    /**\r\n     * Sets wether the vignette effect is enabled.\r\n     */\n    set: function set(value) {\n      this.imageProcessingConfiguration.vignetteEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ImageProcessingPostProcess.prototype, \"fromLinearSpace\", {\n    /**\r\n     * Gets wether the input of the processing is in Gamma or Linear Space.\r\n     */\n    get: function get() {\n      return this._fromLinearSpace;\n    },\n\n    /**\r\n     * Sets wether the input of the processing is in Gamma or Linear Space.\r\n     */\n    set: function set(value) {\n      if (this._fromLinearSpace === value) {\n        return;\n      }\n\n      this._fromLinearSpace = value;\n\n      this._updateParameters();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   *  \"ImageProcessingPostProcess\"\r\n   * @returns \"ImageProcessingPostProcess\"\r\n   */\n\n  ImageProcessingPostProcess.prototype.getClassName = function () {\n    return \"ImageProcessingPostProcess\";\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  ImageProcessingPostProcess.prototype._updateParameters = function () {\n    this._defines.FROMLINEARSPACE = this._fromLinearSpace;\n    this.imageProcessingConfiguration.prepareDefines(this._defines, true);\n    var defines = \"\";\n\n    for (var define in this._defines) {\n      if (this._defines[define]) {\n        defines += \"#define \" + define + \";\\r\\n\";\n      }\n    }\n\n    var samplers = [\"textureSampler\"];\n    var uniforms = [\"scale\"];\n\n    if (ImageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);\n    }\n\n    this.updateEffect(defines, uniforms, samplers);\n  };\n\n  ImageProcessingPostProcess.prototype.dispose = function (camera) {\n    _super.prototype.dispose.call(this, camera);\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n\n    if (this._imageProcessingConfiguration) {\n      this.imageProcessingConfiguration.applyByPostProcess = false;\n    }\n  };\n\n  __decorate([serialize()], ImageProcessingPostProcess.prototype, \"_fromLinearSpace\", void 0);\n\n  return ImageProcessingPostProcess;\n}(PostProcess);\n\nexport { ImageProcessingPostProcess };","map":null,"metadata":{},"sourceType":"module"}