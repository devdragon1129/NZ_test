{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Tools } from \"../../Misc/tools\";\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n */\n\nvar WebXRHitTestLegacy =\n/** @class */\nfunction (_super) {\n  __extends(WebXRHitTestLegacy, _super);\n  /**\r\n   * Creates a new instance of the (legacy version) hit test feature\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param options options to use when constructing this feature\r\n   */\n\n\n  function WebXRHitTestLegacy(_xrSessionManager,\n  /**\r\n   * options to use when constructing this feature\r\n   */\n  options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options; // in XR space z-forward is negative\n\n    _this._direction = new Vector3(0, 0, -1);\n    _this._mat = new Matrix();\n    _this._onSelectEnabled = false;\n    _this._origin = new Vector3(0, 0, 0);\n    /**\r\n     * Populated with the last native XR Hit Results\r\n     */\n\n    _this.lastNativeXRHitResults = [];\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     */\n\n    _this.onHitTestResultObservable = new Observable();\n\n    _this._onHitTestResults = function (xrResults) {\n      var mats = xrResults.map(function (result) {\n        var mat = Matrix.FromArray(result.hitMatrix);\n\n        if (!_this._xrSessionManager.scene.useRightHandedSystem) {\n          mat.toggleModelMatrixHandInPlace();\n        } // if (this.options.coordinatesSpace === Space.WORLD) {\n\n\n        if (_this.options.worldParentNode) {\n          mat.multiplyToRef(_this.options.worldParentNode.getWorldMatrix(), mat);\n        }\n\n        return {\n          xrHitResult: result,\n          transformationMatrix: mat\n        };\n      });\n      _this.lastNativeXRHitResults = xrResults;\n\n      _this.onHitTestResultObservable.notifyObservers(mats);\n    }; // can be done using pointerdown event, and xrSessionManager.currentFrame\n\n\n    _this._onSelect = function (event) {\n      if (!_this._onSelectEnabled) {\n        return;\n      }\n\n      WebXRHitTestLegacy.XRHitTestWithSelectEvent(event, _this._xrSessionManager.referenceSpace);\n    };\n\n    _this.xrNativeFeatureName = \"hit-test\";\n    Tools.Warn(\"A newer version of this plugin is available\");\n    return _this;\n  }\n  /**\r\n   * execute a hit test with an XR Ray\r\n   *\r\n   * @param xrSession a native xrSession that will execute this hit test\r\n   * @param xrRay the ray (position and direction) to use for ray-casting\r\n   * @param referenceSpace native XR reference space to use for the hit-test\r\n   * @param filter filter function that will filter the results\r\n   * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\r\n   */\n\n\n  WebXRHitTestLegacy.XRHitTestWithRay = function (xrSession, xrRay, referenceSpace, filter) {\n    return xrSession.requestHitTest(xrRay, referenceSpace).then(function (results) {\n      var filterFunction = filter || function (result) {\n        return !!result.hitMatrix;\n      };\n\n      return results.filter(filterFunction);\n    });\n  };\n  /**\r\n   * Execute a hit test on the current running session using a select event returned from a transient input (such as touch)\r\n   * @param event the (select) event to use to select with\r\n   * @param referenceSpace the reference space to use for this hit test\r\n   * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\r\n   */\n\n\n  WebXRHitTestLegacy.XRHitTestWithSelectEvent = function (event, referenceSpace) {\n    var targetRayPose = event.frame.getPose(event.inputSource.targetRaySpace, referenceSpace);\n\n    if (!targetRayPose) {\n      return Promise.resolve([]);\n    }\n\n    var targetRay = new XRRay(targetRayPose.transform);\n    return this.XRHitTestWithRay(event.frame.session, targetRay, referenceSpace);\n  };\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHitTestLegacy.prototype.attach = function () {\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    if (this.options.testOnPointerDownOnly) {\n      this._xrSessionManager.session.addEventListener(\"select\", this._onSelect, false);\n    }\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHitTestLegacy.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    } // disable select\n\n\n    this._onSelectEnabled = false;\n\n    this._xrSessionManager.session.removeEventListener(\"select\", this._onSelect);\n\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRHitTestLegacy.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onHitTestResultObservable.clear();\n  };\n\n  WebXRHitTestLegacy.prototype._onXRFrame = function (frame) {\n    // make sure we do nothing if (async) not attached\n    if (!this.attached || this.options.testOnPointerDownOnly) {\n      return;\n    }\n\n    var pose = frame.getViewerPose(this._xrSessionManager.referenceSpace);\n\n    if (!pose) {\n      return;\n    }\n\n    Matrix.FromArrayToRef(pose.transform.matrix, 0, this._mat);\n    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, this._mat, this._origin);\n    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, -1, this._mat, this._direction);\n\n    this._direction.subtractInPlace(this._origin);\n\n    this._direction.normalize();\n\n    var ray = new XRRay({\n      x: this._origin.x,\n      y: this._origin.y,\n      z: this._origin.z,\n      w: 0\n    }, {\n      x: this._direction.x,\n      y: this._direction.y,\n      z: this._direction.z,\n      w: 0\n    });\n    WebXRHitTestLegacy.XRHitTestWithRay(this._xrSessionManager.session, ray, this._xrSessionManager.referenceSpace).then(this._onHitTestResults);\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRHitTestLegacy.Name = WebXRFeatureName.HIT_TEST;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRHitTestLegacy.Version = 1;\n  return WebXRHitTestLegacy;\n}(WebXRAbstractFeature);\n\nexport { WebXRHitTestLegacy }; //register the plugin versions\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTestLegacy.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRHitTestLegacy(xrSessionManager, options);\n  };\n}, WebXRHitTestLegacy.Version, false);","map":null,"metadata":{},"sourceType":"module"}