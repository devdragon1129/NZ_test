{"ast":null,"code":"import { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { AnimationEvent } from \"@babylonjs/core/Animations/animationEvent\";\nimport { Sound } from \"@babylonjs/core/Audio/sound\";\nimport { WeightedSound } from \"@babylonjs/core/Audio/weightedsound\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nvar NAME = \"MSFT_audio_emitter\";\n/**\r\n * [Specification](https://github.com/najadojo/glTF/tree/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter)\r\n */\n\nvar MSFT_audio_emitter =\n/** @class */\nfunction () {\n  /** @hidden */\n  function MSFT_audio_emitter(loader) {\n    /**\r\n     * The name of this extension.\r\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @hidden */\n\n\n  MSFT_audio_emitter.prototype.dispose = function () {\n    this._loader = null;\n    this._clips = null;\n    this._emitters = null;\n  };\n  /** @hidden */\n\n\n  MSFT_audio_emitter.prototype.onLoading = function () {\n    var extensions = this._loader.gltf.extensions;\n\n    if (extensions && extensions[this.name]) {\n      var extension = extensions[this.name];\n      this._clips = extension.clips;\n      this._emitters = extension.emitters;\n      ArrayItem.Assign(this._clips);\n      ArrayItem.Assign(this._emitters);\n    }\n  };\n  /** @hidden */\n\n\n  MSFT_audio_emitter.prototype.loadSceneAsync = function (context, scene) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, scene, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      promises.push(_this._loader.loadSceneAsync(context, scene));\n\n      for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {\n        var emitterIndex = _a[_i];\n        var emitter = ArrayItem.Get(extensionContext + \"/emitters\", _this._emitters, emitterIndex);\n\n        if (emitter.refDistance != undefined || emitter.maxDistance != undefined || emitter.rolloffFactor != undefined || emitter.distanceModel != undefined || emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n          throw new Error(extensionContext + \": Direction or Distance properties are not allowed on emitters attached to a scene\");\n        }\n\n        promises.push(_this._loadEmitterAsync(extensionContext + \"/emitters/\" + emitter.index, emitter));\n      }\n\n      return Promise.all(promises).then(function () {});\n    });\n  };\n  /** @hidden */\n\n\n  MSFT_audio_emitter.prototype.loadNodeAsync = function (context, node, assign) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      return _this._loader.loadNodeAsync(extensionContext, node, function (babylonMesh) {\n        var _loop_1 = function _loop_1(emitterIndex) {\n          var emitter = ArrayItem.Get(extensionContext + \"/emitters\", _this._emitters, emitterIndex);\n          promises.push(_this._loadEmitterAsync(extensionContext + \"/emitters/\" + emitter.index, emitter).then(function () {\n            for (var _i = 0, _a = emitter._babylonSounds; _i < _a.length; _i++) {\n              var sound = _a[_i];\n              sound.attachToMesh(babylonMesh);\n\n              if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                sound.setLocalDirectionToMesh(Vector3.Forward());\n                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);\n              }\n            }\n          }));\n        };\n\n        for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {\n          var emitterIndex = _a[_i];\n\n          _loop_1(emitterIndex);\n        }\n\n        assign(babylonMesh);\n      }).then(function (babylonMesh) {\n        return Promise.all(promises).then(function () {\n          return babylonMesh;\n        });\n      });\n    });\n  };\n  /** @hidden */\n\n\n  MSFT_audio_emitter.prototype.loadAnimationAsync = function (context, animation) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, animation, this.name, function (extensionContext, extension) {\n      return _this._loader.loadAnimationAsync(context, animation).then(function (babylonAnimationGroup) {\n        var promises = new Array();\n        ArrayItem.Assign(extension.events);\n\n        for (var _i = 0, _a = extension.events; _i < _a.length; _i++) {\n          var event_1 = _a[_i];\n          promises.push(_this._loadAnimationEventAsync(extensionContext + \"/events/\" + event_1.index, context, animation, event_1, babylonAnimationGroup));\n        }\n\n        return Promise.all(promises).then(function () {\n          return babylonAnimationGroup;\n        });\n      });\n    });\n  };\n\n  MSFT_audio_emitter.prototype._loadClipAsync = function (context, clip) {\n    if (clip._objectURL) {\n      return clip._objectURL;\n    }\n\n    var promise;\n\n    if (clip.uri) {\n      promise = this._loader.loadUriAsync(context, clip, clip.uri);\n    } else {\n      var bufferView = ArrayItem.Get(context + \"/bufferView\", this._loader.gltf.bufferViews, clip.bufferView);\n      promise = this._loader.loadBufferViewAsync(\"/bufferViews/\" + bufferView.index, bufferView);\n    }\n\n    clip._objectURL = promise.then(function (data) {\n      return URL.createObjectURL(new Blob([data], {\n        type: clip.mimeType\n      }));\n    });\n    return clip._objectURL;\n  };\n\n  MSFT_audio_emitter.prototype._loadEmitterAsync = function (context, emitter) {\n    var _this = this;\n\n    emitter._babylonSounds = emitter._babylonSounds || [];\n\n    if (!emitter._babylonData) {\n      var clipPromises = new Array();\n      var name_1 = emitter.name || \"emitter\" + emitter.index;\n      var options_1 = {\n        loop: false,\n        autoplay: false,\n        volume: emitter.volume == undefined ? 1 : emitter.volume\n      };\n\n      var _loop_2 = function _loop_2(i) {\n        var clipContext = \"/extensions/\" + this_1.name + \"/clips\";\n        var clip = ArrayItem.Get(clipContext, this_1._clips, emitter.clips[i].clip);\n        clipPromises.push(this_1._loadClipAsync(clipContext + \"/\" + emitter.clips[i].clip, clip).then(function (objectURL) {\n          var sound = emitter._babylonSounds[i] = new Sound(name_1, objectURL, _this._loader.babylonScene, null, options_1);\n          sound.refDistance = emitter.refDistance || 1;\n          sound.maxDistance = emitter.maxDistance || 256;\n          sound.rolloffFactor = emitter.rolloffFactor || 1;\n          sound.distanceModel = emitter.distanceModel || 'exponential';\n          sound._positionInEmitterSpace = true;\n        }));\n      };\n\n      var this_1 = this;\n\n      for (var i = 0; i < emitter.clips.length; i++) {\n        _loop_2(i);\n      }\n\n      var promise = Promise.all(clipPromises).then(function () {\n        var weights = emitter.clips.map(function (clip) {\n          return clip.weight || 1;\n        });\n        var weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n\n        if (emitter.innerAngle) {\n          weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\n        }\n\n        if (emitter.outerAngle) {\n          weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\n        }\n\n        if (emitter.volume) {\n          weightedSound.volume = emitter.volume;\n        }\n\n        emitter._babylonData.sound = weightedSound;\n      });\n      emitter._babylonData = {\n        loaded: promise\n      };\n    }\n\n    return emitter._babylonData.loaded;\n  };\n\n  MSFT_audio_emitter.prototype._getEventAction = function (context, sound, action, time, startOffset) {\n    switch (action) {\n      case \"play\"\n      /* play */\n      :\n        {\n          return function (currentFrame) {\n            var frameOffset = (startOffset || 0) + (currentFrame - time);\n            sound.play(frameOffset);\n          };\n        }\n\n      case \"stop\"\n      /* stop */\n      :\n        {\n          return function (currentFrame) {\n            sound.stop();\n          };\n        }\n\n      case \"pause\"\n      /* pause */\n      :\n        {\n          return function (currentFrame) {\n            sound.pause();\n          };\n        }\n\n      default:\n        {\n          throw new Error(context + \": Unsupported action \" + action);\n        }\n    }\n  };\n\n  MSFT_audio_emitter.prototype._loadAnimationEventAsync = function (context, animationContext, animation, event, babylonAnimationGroup) {\n    var _this = this;\n\n    if (babylonAnimationGroup.targetedAnimations.length == 0) {\n      return Promise.resolve();\n    }\n\n    var babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n    var emitterIndex = event.emitter;\n    var emitter = ArrayItem.Get(\"/extensions/\" + this.name + \"/emitters\", this._emitters, emitterIndex);\n    return this._loadEmitterAsync(context, emitter).then(function () {\n      var sound = emitter._babylonData.sound;\n\n      if (sound) {\n        var babylonAnimationEvent = new AnimationEvent(event.time, _this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n        babylonAnimation.animation.addEvent(babylonAnimationEvent); // Make sure all started audio stops when this animation is terminated.\n\n        babylonAnimationGroup.onAnimationGroupEndObservable.add(function () {\n          sound.stop();\n        });\n        babylonAnimationGroup.onAnimationGroupPauseObservable.add(function () {\n          sound.pause();\n        });\n      }\n    });\n  };\n\n  return MSFT_audio_emitter;\n}();\n\nexport { MSFT_audio_emitter };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new MSFT_audio_emitter(loader);\n});","map":null,"metadata":{},"sourceType":"module"}