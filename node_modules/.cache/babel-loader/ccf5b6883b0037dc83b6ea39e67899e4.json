{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { GLTFLoader } from \"../glTFLoader\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { RenderTargetTexture } from \"@babylonjs/core/Materials/Textures/renderTargetTexture\";\nimport { Observable } from \"@babylonjs/core/Misc/observable\";\n/**\r\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\r\n */\n\nvar TransmissionHelper =\n/** @class */\nfunction () {\n  /**\r\n   * constructor\r\n   * @param options Defines the options we want to customize the helper\r\n   * @param scene The scene to add the material to\r\n   */\n  function TransmissionHelper(options, scene) {\n    var _this = this;\n\n    this._opaqueRenderTarget = null;\n    this._opaqueMeshesCache = [];\n    this._transparentMeshesCache = [];\n    this._options = __assign(__assign({}, TransmissionHelper._getDefaultOptions()), options);\n    this._scene = scene;\n    this._scene._transmissionHelper = this;\n    this.onErrorObservable = new Observable();\n\n    this._scene.onDisposeObservable.addOnce(function (scene) {\n      _this.dispose();\n    });\n\n    this._parseScene();\n\n    this._setupRenderTargets();\n  }\n  /**\r\n   * Creates the default options for the helper.\r\n   */\n\n\n  TransmissionHelper._getDefaultOptions = function () {\n    return {\n      renderSize: 512\n    };\n  };\n  /**\r\n   * Updates the background according to the new options\r\n   * @param options\r\n   */\n\n\n  TransmissionHelper.prototype.updateOptions = function (options) {\n    var _this = this; // First check if any options are actually being changed. If not, exit.\n\n\n    var newValues = Object.keys(options).filter(function (key) {\n      return _this._options[key] !== options[key];\n    });\n\n    if (!newValues.length) {\n      return;\n    }\n\n    var newOptions = __assign(__assign({}, this._options), options);\n\n    var oldOptions = this._options;\n    this._options = newOptions; // If size changes, recreate everything\n\n    if (newOptions.renderSize !== oldOptions.renderSize) {\n      this._setupRenderTargets();\n    }\n  };\n\n  TransmissionHelper.prototype.getOpaqueTarget = function () {\n    return this._opaqueRenderTarget;\n  };\n\n  TransmissionHelper.prototype.shouldRenderAsTransmission = function (material) {\n    if (!material) {\n      return false;\n    }\n\n    if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\n      return true;\n    }\n\n    return false;\n  };\n\n  TransmissionHelper.prototype._addMesh = function (mesh) {\n    if (mesh instanceof Mesh) {\n      mesh.onMaterialChangedObservable.add(this.onMeshMaterialChanged.bind(this));\n\n      if (this.shouldRenderAsTransmission(mesh.material)) {\n        this._transparentMeshesCache.push(mesh);\n      } else {\n        this._opaqueMeshesCache.push(mesh);\n      }\n    }\n  };\n\n  TransmissionHelper.prototype._removeMesh = function (mesh) {\n    if (mesh instanceof Mesh) {\n      mesh.onMaterialChangedObservable.remove(this.onMeshMaterialChanged.bind(this));\n\n      var idx = this._transparentMeshesCache.indexOf(mesh);\n\n      if (idx !== -1) {\n        this._transparentMeshesCache.splice(idx, 1);\n      }\n\n      idx = this._opaqueMeshesCache.indexOf(mesh);\n\n      if (idx !== -1) {\n        this._opaqueMeshesCache.splice(idx, 1);\n      }\n    }\n  };\n\n  TransmissionHelper.prototype._parseScene = function () {\n    this._scene.meshes.forEach(this._addMesh.bind(this)); // Listen for when a mesh is added to the scene and add it to our cache lists.\n\n\n    this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this)); // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\n\n\n    this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\n  }; // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\n\n\n  TransmissionHelper.prototype.onMeshMaterialChanged = function (mesh) {\n    if (mesh instanceof Mesh) {\n      var transparentIdx = this._transparentMeshesCache.indexOf(mesh);\n\n      var opaqueIdx = this._opaqueMeshesCache.indexOf(mesh); // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\n\n\n      var useTransmission = this.shouldRenderAsTransmission(mesh.material);\n\n      if (useTransmission) {\n        if (mesh.material instanceof PBRMaterial) {\n          mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\n        }\n\n        if (opaqueIdx !== -1) {\n          this._opaqueMeshesCache.splice(opaqueIdx, 1);\n\n          this._transparentMeshesCache.push(mesh);\n        } else if (transparentIdx === -1) {\n          this._transparentMeshesCache.push(mesh);\n        } // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\n\n      } else {\n        if (transparentIdx !== -1) {\n          this._transparentMeshesCache.splice(transparentIdx, 1);\n\n          this._opaqueMeshesCache.push(mesh);\n        } else if (opaqueIdx === -1) {\n          this._opaqueMeshesCache.push(mesh);\n        }\n      }\n    }\n  };\n  /**\r\n   * Setup the render targets according to the specified options.\r\n   */\n\n\n  TransmissionHelper.prototype._setupRenderTargets = function () {\n    var _this = this;\n\n    var opaqueRTIndex = -1; // Remove any layers rendering to the opaque scene.\n\n    if (this._scene.layers && this._opaqueRenderTarget) {\n      for (var _i = 0, _a = this._scene.layers; _i < _a.length; _i++) {\n        var layer = _a[_i];\n        var idx = layer.renderTargetTextures.indexOf(this._opaqueRenderTarget);\n\n        if (idx >= 0) {\n          layer.renderTargetTextures.splice(idx, 1);\n        }\n      }\n    } // Remove opaque render target\n\n\n    if (this._opaqueRenderTarget) {\n      opaqueRTIndex = this._scene.customRenderTargets.indexOf(this._opaqueRenderTarget);\n\n      this._opaqueRenderTarget.dispose();\n    }\n\n    this._opaqueRenderTarget = new RenderTargetTexture(\"opaqueSceneTexture\", this._options.renderSize, this._scene, true);\n    this._opaqueRenderTarget.renderList = this._opaqueMeshesCache; // this._opaqueRenderTarget.clearColor = new Color4(0.0, 0.0, 0.0, 0.0);\n\n    this._opaqueRenderTarget.gammaSpace = true;\n    this._opaqueRenderTarget.lodGenerationScale = 1;\n    this._opaqueRenderTarget.lodGenerationOffset = -4;\n\n    if (opaqueRTIndex >= 0) {\n      this._scene.customRenderTargets.splice(opaqueRTIndex, 0, this._opaqueRenderTarget);\n    } else {\n      opaqueRTIndex = this._scene.customRenderTargets.length;\n\n      this._scene.customRenderTargets.push(this._opaqueRenderTarget);\n    } // If there are other layers, they should be included in the render of the opaque background.\n\n\n    if (this._scene.layers && this._opaqueRenderTarget) {\n      for (var _b = 0, _c = this._scene.layers; _b < _c.length; _b++) {\n        var layer = _c[_b];\n        layer.renderTargetTextures.push(this._opaqueRenderTarget);\n      }\n    }\n\n    this._transparentMeshesCache.forEach(function (mesh) {\n      if (_this.shouldRenderAsTransmission(mesh.material) && mesh.material instanceof PBRMaterial) {\n        mesh.material.refractionTexture = _this._opaqueRenderTarget;\n      }\n    });\n  };\n  /**\r\n   * Dispose all the elements created by the Helper.\r\n   */\n\n\n  TransmissionHelper.prototype.dispose = function () {\n    this._scene._transmissionHelper = undefined;\n\n    if (this._opaqueRenderTarget) {\n      this._opaqueRenderTarget.dispose();\n\n      this._opaqueRenderTarget = null;\n    }\n\n    this._transparentMeshesCache = [];\n    this._opaqueMeshesCache = [];\n  };\n\n  return TransmissionHelper;\n}();\n\nvar NAME = \"KHR_materials_transmission\";\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1698)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\n\nvar KHR_materials_transmission =\n/** @class */\nfunction () {\n  /** @hidden */\n  function KHR_materials_transmission(loader) {\n    /**\r\n     * The name of this extension.\r\n     */\n    this.name = NAME;\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\n\n    this.order = 175;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n\n    if (this.enabled) {\n      loader.parent.transparencyAsCoverage = true;\n    }\n  }\n  /** @hidden */\n\n\n  KHR_materials_transmission.prototype.dispose = function () {\n    this._loader = null;\n  };\n  /** @hidden */\n\n\n  KHR_materials_transmission.prototype.loadMaterialPropertiesAsync = function (context, material, babylonMaterial) {\n    var _this = this;\n\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, function (extensionContext, extension) {\n      var promises = new Array();\n      promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n      promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n      promises.push(_this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\n      return Promise.all(promises).then(function () {});\n    });\n  };\n\n  KHR_materials_transmission.prototype._loadTransparentPropertiesAsync = function (context, material, babylonMaterial, extension) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(context + \": Material type not supported\");\n    }\n\n    var pbrMaterial = babylonMaterial; // Enables \"refraction\" texture which represents transmitted light.\n\n    pbrMaterial.subSurface.isRefractionEnabled = true; // Since this extension models thin-surface transmission only, we must make IOR = 1.0\n\n    pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0; // Albedo colour will tint transmission.\n\n    pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\n\n    if (extension.transmissionFactor !== undefined) {\n      pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\n      var scene = pbrMaterial.getScene();\n\n      if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\n        new TransmissionHelper({}, pbrMaterial.getScene());\n      }\n    } else {\n      pbrMaterial.subSurface.refractionIntensity = 0.0;\n      pbrMaterial.subSurface.isRefractionEnabled = false;\n      return Promise.resolve();\n    }\n\n    if (extension.transmissionTexture) {\n      extension.transmissionTexture.nonColorData = true;\n      return this._loader.loadTextureInfoAsync(context + \"/transmissionTexture\", extension.transmissionTexture, undefined).then(function (texture) {\n        pbrMaterial.subSurface.thicknessTexture = texture;\n        pbrMaterial.subSurface.useMaskFromThicknessTextureGltf = true;\n      });\n    } else {\n      return Promise.resolve();\n    }\n  };\n\n  return KHR_materials_transmission;\n}();\n\nexport { KHR_materials_transmission };\nGLTFLoader.RegisterExtension(NAME, function (loader) {\n  return new KHR_materials_transmission(loader);\n});","map":null,"metadata":{},"sourceType":"module"}