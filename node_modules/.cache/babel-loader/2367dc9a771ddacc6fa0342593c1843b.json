{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport { Color4 } from '../Maths/math.color';\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Material } from \"../Materials/material\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { LayerSceneComponent } from \"./layerSceneComponent\";\nimport \"../Shaders/layer.fragment\";\nimport \"../Shaders/layer.vertex\";\n/**\r\n * This represents a full screen 2d layer.\r\n * This can be useful to display a picture in the  background of your scene for instance.\r\n * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n */\n\nvar Layer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new layer.\r\n   * This represents a full screen 2d layer.\r\n   * This can be useful to display a picture in the  background of your scene for instance.\r\n   * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n   * @param name Define the name of the layer in the scene\r\n   * @param imgUrl Define the url of the texture to display in the layer\r\n   * @param scene Define the scene the layer belongs to\r\n   * @param isBackground Defines whether the layer is displayed in front or behind the scene\r\n   * @param color Defines a color for the layer\r\n   */\n  function Layer(\n  /**\r\n   * Define the name of the layer.\r\n   */\n  name, imgUrl, scene, isBackground, color) {\n    this.name = name;\n    /**\r\n     * Define the scale of the layer in order to zoom in out of the texture.\r\n     */\n\n    this.scale = new Vector2(1, 1);\n    /**\r\n     * Define an offset for the layer in order to shift the texture.\r\n     */\n\n    this.offset = new Vector2(0, 0);\n    /**\r\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\r\n     */\n\n    this.alphaBlendingMode = 2;\n    /**\r\n     * Define a mask to restrict the layer to only some of the scene cameras.\r\n     */\n\n    this.layerMask = 0x0FFFFFFF;\n    /**\r\n     * Define the list of render target the layer is visible into.\r\n     */\n\n    this.renderTargetTextures = [];\n    /**\r\n     * Define if the layer is only used in renderTarget or if it also\r\n     * renders in the main frame buffer of the canvas.\r\n     */\n\n    this.renderOnlyInRenderTargetTextures = false;\n    this._vertexBuffers = {};\n    /**\r\n     * An event triggered when the layer is disposed.\r\n     */\n\n    this.onDisposeObservable = new Observable();\n    /**\r\n    * An event triggered before rendering the scene\r\n    */\n\n    this.onBeforeRenderObservable = new Observable();\n    /**\r\n    * An event triggered after rendering the scene\r\n    */\n\n    this.onAfterRenderObservable = new Observable();\n    this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\n    this.isBackground = isBackground === undefined ? true : isBackground;\n    this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    var layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);\n\n    if (!layerComponent) {\n      layerComponent = new LayerSceneComponent(this._scene);\n\n      this._scene._addComponent(layerComponent);\n    }\n\n    this._scene.layers.push(this);\n\n    var engine = this._scene.getEngine(); // VBO\n\n\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    var vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n\n    this._createIndexBuffer();\n  }\n\n  Object.defineProperty(Layer.prototype, \"onDispose\", {\n    /**\r\n     * Back compatibility with callback before the onDisposeObservable existed.\r\n     * The set callback will be triggered when the layer has been disposed.\r\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Layer.prototype, \"onBeforeRender\", {\n    /**\r\n     * Back compatibility with callback before the onBeforeRenderObservable existed.\r\n     * The set callback will be triggered just before rendering the layer.\r\n     */\n    set: function set(callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Layer.prototype, \"onAfterRender\", {\n    /**\r\n     * Back compatibility with callback before the onAfterRenderObservable existed.\r\n     * The set callback will be triggered just after rendering the layer.\r\n     */\n    set: function set(callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Layer.prototype._createIndexBuffer = function () {\n    var engine = this._scene.getEngine(); // Indices\n\n\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  };\n  /** @hidden */\n\n\n  Layer.prototype._rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._createIndexBuffer();\n  };\n  /**\r\n   * Renders the layer in the scene.\r\n   */\n\n\n  Layer.prototype.render = function () {\n    var engine = this._scene.getEngine();\n\n    var defines = \"\";\n\n    if (this.alphaTest) {\n      defines = \"#define ALPHATEST\";\n    }\n\n    if (this.texture && !this.texture.gammaSpace) {\n      defines += \"\\r\\n#define LINEAR\";\n    }\n\n    if (this._previousDefines !== defines) {\n      this._previousDefines = defines;\n      this._effect = engine.createEffect(\"layer\", [VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], defines);\n    }\n\n    var currentEffect = this._effect; // Check\n\n    if (!currentEffect || !currentEffect.isReady() || !this.texture || !this.texture.isReady()) {\n      return;\n    }\n\n    var engine = this._scene.getEngine();\n\n    this.onBeforeRenderObservable.notifyObservers(this); // Render\n\n    engine.enableEffect(currentEffect);\n    engine.setState(false); // Texture\n\n    currentEffect.setTexture(\"textureSampler\", this.texture);\n    currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix()); // Color\n\n    currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a); // Scale / offset\n\n    currentEffect.setVector2(\"offset\", this.offset);\n    currentEffect.setVector2(\"scale\", this.scale); // VBOs\n\n    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect); // Draw order\n\n    if (!this.alphaTest) {\n      engine.setAlphaMode(this.alphaBlendingMode);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n      engine.setAlphaMode(0);\n    } else {\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n\n    this.onAfterRenderObservable.notifyObservers(this);\n  };\n  /**\r\n   * Disposes and releases the associated ressources.\r\n   */\n\n\n  Layer.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    } // Clean RTT list\n\n\n    this.renderTargetTextures = []; // Remove from scene\n\n    var index = this._scene.layers.indexOf(this);\n\n    this._scene.layers.splice(index, 1); // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderObservable.clear();\n  };\n\n  return Layer;\n}();\n\nexport { Layer };","map":null,"metadata":{},"sourceType":"module"}