{"ast":null,"code":"import { ShaderCodeNode } from './shaderCodeNode';\nimport { ShaderCodeCursor } from './shaderCodeCursor';\nimport { ShaderCodeConditionNode } from './shaderCodeConditionNode';\nimport { ShaderCodeTestNode } from './shaderCodeTestNode';\nimport { ShaderDefineIsDefinedOperator } from './Expressions/Operators/shaderDefineIsDefinedOperator';\nimport { ShaderDefineOrOperator } from './Expressions/Operators/shaderDefineOrOperator';\nimport { ShaderDefineAndOperator } from './Expressions/Operators/shaderDefineAndOperator';\nimport { ShaderDefineExpression } from './Expressions/shaderDefineExpression';\nimport { ShaderDefineArithmeticOperator } from './Expressions/Operators/shaderDefineArithmeticOperator';\nimport { _DevTools } from '../../Misc/devTools';\nvar regexSE = /defined\\s*?\\((.+?)\\)/g;\nvar regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\n/** @hidden */\n\nvar ShaderProcessor =\n/** @class */\nfunction () {\n  function ShaderProcessor() {}\n\n  ShaderProcessor.Process = function (sourceCode, options, callback, engine) {\n    var _this = this;\n\n    this._ProcessIncludes(sourceCode, options, function (codeWithIncludes) {\n      var migratedCode = _this._ProcessShaderConversion(codeWithIncludes, options, engine);\n\n      callback(migratedCode);\n    });\n  };\n\n  ShaderProcessor._ProcessPrecision = function (source, options) {\n    var shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\n\n    if (source.indexOf(\"precision highp float\") === -1) {\n      if (!shouldUseHighPrecisionShader) {\n        source = \"precision mediump float;\\n\" + source;\n      } else {\n        source = \"precision highp float;\\n\" + source;\n      }\n    } else {\n      if (!shouldUseHighPrecisionShader) {\n        // Moving highp to mediump\n        source = source.replace(\"precision highp float\", \"precision mediump float\");\n      }\n    }\n\n    return source;\n  };\n\n  ShaderProcessor._ExtractOperation = function (expression) {\n    var regex = /defined\\((.+)\\)/;\n    var match = regex.exec(expression);\n\n    if (match && match.length) {\n      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\n    }\n\n    var operators = [\"==\", \">=\", \"<=\", \"<\", \">\"];\n    var operator = \"\";\n    var indexOperator = 0;\n\n    for (var _i = 0, operators_1 = operators; _i < operators_1.length; _i++) {\n      operator = operators_1[_i];\n      indexOperator = expression.indexOf(operator);\n\n      if (indexOperator > -1) {\n        break;\n      }\n    }\n\n    if (indexOperator === -1) {\n      return new ShaderDefineIsDefinedOperator(expression);\n    }\n\n    var define = expression.substring(0, indexOperator).trim();\n    var value = expression.substring(indexOperator + operator.length).trim();\n    return new ShaderDefineArithmeticOperator(define, operator, value);\n  };\n\n  ShaderProcessor._BuildSubExpression = function (expression) {\n    expression = expression.replace(regexSE, \"defined[$1]\");\n    var postfix = ShaderDefineExpression.infixToPostfix(expression);\n    var stack = [];\n\n    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {\n      var c = postfix_1[_i];\n\n      if (c !== '||' && c !== '&&') {\n        stack.push(c);\n      } else if (stack.length >= 2) {\n        var v1 = stack[stack.length - 1],\n            v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        var operator = c == '&&' ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\n\n        if (typeof v1 === 'string') {\n          v1 = v1.replace(regexSERevert, \"defined($1)\");\n        }\n\n        if (typeof v2 === 'string') {\n          v2 = v2.replace(regexSERevert, \"defined($1)\");\n        }\n\n        operator.leftOperand = typeof v2 === 'string' ? this._ExtractOperation(v2) : v2;\n        operator.rightOperand = typeof v1 === 'string' ? this._ExtractOperation(v1) : v1;\n        stack.push(operator);\n      }\n    }\n\n    var result = stack[stack.length - 1];\n\n    if (typeof result === 'string') {\n      result = result.replace(regexSERevert, \"defined($1)\");\n    } // note: stack.length !== 1 if there was an error in the parsing\n\n\n    return typeof result === 'string' ? this._ExtractOperation(result) : result;\n  };\n\n  ShaderProcessor._BuildExpression = function (line, start) {\n    var node = new ShaderCodeTestNode();\n    var command = line.substring(0, start);\n    var expression = line.substring(start);\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\n\n    if (command === \"#ifdef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression);\n    } else if (command === \"#ifndef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\n    } else {\n      node.testExpression = this._BuildSubExpression(expression);\n    }\n\n    return node;\n  };\n\n  ShaderProcessor._MoveCursorWithinIf = function (cursor, rootNode, ifNode) {\n    var line = cursor.currentLine;\n\n    while (this._MoveCursor(cursor, ifNode)) {\n      line = cursor.currentLine;\n      var first5 = line.substring(0, 5).toLowerCase();\n\n      if (first5 === \"#else\") {\n        var elseNode = new ShaderCodeNode();\n        rootNode.children.push(elseNode);\n\n        this._MoveCursor(cursor, elseNode);\n\n        return;\n      } else if (first5 === \"#elif\") {\n        var elifNode = this._BuildExpression(line, 5);\n\n        rootNode.children.push(elifNode);\n        ifNode = elifNode;\n      }\n    }\n  };\n\n  ShaderProcessor._MoveCursor = function (cursor, rootNode) {\n    while (cursor.canRead) {\n      cursor.lineIndex++;\n      var line = cursor.currentLine;\n      var keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\n      var matches = keywords.exec(line);\n\n      if (matches && matches.length) {\n        var keyword = matches[0];\n\n        switch (keyword) {\n          case \"#ifdef\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n              rootNode.children.push(newRootNode);\n\n              var ifNode = this._BuildExpression(line, 6);\n\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n\n          case \"#else\":\n          case \"#elif\":\n            return true;\n\n          case \"#endif\":\n            return false;\n\n          case \"#ifndef\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n              rootNode.children.push(newRootNode);\n\n              var ifNode = this._BuildExpression(line, 7);\n\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n\n          case \"#if\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n\n              var ifNode = this._BuildExpression(line, 3);\n\n              rootNode.children.push(newRootNode);\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n        }\n      } else {\n        var newNode = new ShaderCodeNode();\n        newNode.line = line;\n        rootNode.children.push(newNode); // Detect additional defines\n\n        if (line[0] === \"#\" && line[1] === \"d\") {\n          var split = line.replace(\";\", \"\").split(\" \");\n          newNode.additionalDefineKey = split[1];\n\n          if (split.length === 3) {\n            newNode.additionalDefineValue = split[2];\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  ShaderProcessor._EvaluatePreProcessors = function (sourceCode, preprocessors, options) {\n    var rootNode = new ShaderCodeNode();\n    var cursor = new ShaderCodeCursor();\n    cursor.lineIndex = -1;\n    cursor.lines = sourceCode.split(\"\\n\"); // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\n\n    this._MoveCursor(cursor, rootNode); // Recompose\n\n\n    return rootNode.process(preprocessors, options);\n  };\n\n  ShaderProcessor._PreparePreProcessors = function (options) {\n    var defines = options.defines;\n    var preprocessors = {};\n\n    for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {\n      var define = defines_1[_i];\n      var keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\n      var split = keyValue.split(\" \");\n      preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\n    }\n\n    preprocessors[\"GL_ES\"] = \"true\";\n    preprocessors[\"__VERSION__\"] = options.version;\n    preprocessors[options.platformName] = \"true\";\n    return preprocessors;\n  };\n\n  ShaderProcessor._ProcessShaderConversion = function (sourceCode, options, engine) {\n    var preparedSourceCode = this._ProcessPrecision(sourceCode, options);\n\n    if (!options.processor) {\n      return preparedSourceCode;\n    } // Already converted\n\n\n    if (preparedSourceCode.indexOf(\"#version 3\") !== -1) {\n      return preparedSourceCode.replace(\"#version 300 es\", \"\");\n    }\n\n    var defines = options.defines;\n\n    var preprocessors = this._PreparePreProcessors(options); // General pre processing\n\n\n    if (options.processor.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment);\n    }\n\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options); // Post processing\n\n    if (options.processor.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, engine);\n    }\n\n    return preparedSourceCode;\n  };\n\n  ShaderProcessor._ProcessIncludes = function (sourceCode, options, callback) {\n    var _this = this;\n\n    var regex = /#include<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\n    var match = regex.exec(sourceCode);\n    var returnValue = new String(sourceCode);\n    var keepProcessing = false;\n\n    while (match != null) {\n      var includeFile = match[1]; // Uniform declaration\n\n      if (includeFile.indexOf(\"__decl__\") !== -1) {\n        includeFile = includeFile.replace(/__decl__/, \"\");\n\n        if (options.supportsUniformBuffers) {\n          includeFile = includeFile.replace(/Vertex/, \"Ubo\");\n          includeFile = includeFile.replace(/Fragment/, \"Ubo\");\n        }\n\n        includeFile = includeFile + \"Declaration\";\n      }\n\n      if (options.includesShadersStore[includeFile]) {\n        // Substitution\n        var includeContent = options.includesShadersStore[includeFile];\n\n        if (match[2]) {\n          var splits = match[3].split(\",\");\n\n          for (var index = 0; index < splits.length; index += 2) {\n            var source = new RegExp(splits[index], \"g\");\n            var dest = splits[index + 1];\n            includeContent = includeContent.replace(source, dest);\n          }\n        }\n\n        if (match[4]) {\n          var indexString = match[5];\n\n          if (indexString.indexOf(\"..\") !== -1) {\n            var indexSplits = indexString.split(\"..\");\n            var minIndex = parseInt(indexSplits[0]);\n            var maxIndex = parseInt(indexSplits[1]);\n            var sourceIncludeContent = includeContent.slice(0);\n            includeContent = \"\";\n\n            if (isNaN(maxIndex)) {\n              maxIndex = options.indexParameters[indexSplits[1]];\n            }\n\n            for (var i = minIndex; i < maxIndex; i++) {\n              if (!options.supportsUniformBuffers) {\n                // Ubo replacement\n                sourceIncludeContent = sourceIncludeContent.replace(/light\\{X\\}.(\\w*)/g, function (str, p1) {\n                  return p1 + \"{X}\";\n                });\n              }\n\n              includeContent += sourceIncludeContent.replace(/\\{X\\}/g, i.toString()) + \"\\n\";\n            }\n          } else {\n            if (!options.supportsUniformBuffers) {\n              // Ubo replacement\n              includeContent = includeContent.replace(/light\\{X\\}.(\\w*)/g, function (str, p1) {\n                return p1 + \"{X}\";\n              });\n            }\n\n            includeContent = includeContent.replace(/\\{X\\}/g, indexString);\n          }\n        } // Replace\n\n\n        returnValue = returnValue.replace(match[0], includeContent);\n        keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0;\n      } else {\n        var includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\n\n        ShaderProcessor._FileToolsLoadFile(includeShaderUrl, function (fileContent) {\n          options.includesShadersStore[includeFile] = fileContent;\n\n          _this._ProcessIncludes(returnValue, options, callback);\n        });\n\n        return;\n      }\n\n      match = regex.exec(sourceCode);\n    }\n\n    if (keepProcessing) {\n      this._ProcessIncludes(returnValue.toString(), options, callback);\n    } else {\n      callback(returnValue);\n    }\n  };\n  /**\r\n   * Loads a file from a url\r\n   * @param url url to load\r\n   * @param onSuccess callback called when the file successfully loads\r\n   * @param onProgress callback called while file is loading (if the server supports this mode)\r\n   * @param offlineProvider defines the offline provider for caching\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @param onError callback called when the file fails to load\r\n   * @returns a file request object\r\n   * @hidden\r\n   */\n\n\n  ShaderProcessor._FileToolsLoadFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    throw _DevTools.WarnImport(\"FileTools\");\n  };\n\n  return ShaderProcessor;\n}();\n\nexport { ShaderProcessor };","map":null,"metadata":{},"sourceType":"module"}