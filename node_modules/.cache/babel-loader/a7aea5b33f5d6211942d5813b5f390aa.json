{"ast":null,"code":"import { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateDisc = function (options) {\n  var positions = new Array();\n  var indices = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var radius = options.radius || 0.5;\n  var tessellation = options.tessellation || 64;\n  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // positions and uvs\n\n  positions.push(0, 0, 0); // disc center first\n\n  uvs.push(0.5, 0.5);\n  var theta = Math.PI * 2 * arc;\n  var step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\n  var a = 0;\n\n  for (var t = 0; t < tessellation; t++) {\n    var x = Math.cos(a);\n    var y = Math.sin(a);\n    var u = (x + 1) / 2;\n    var v = (1 - y) / 2;\n    positions.push(radius * x, radius * y, 0);\n    uvs.push(u, v);\n    a += step;\n  }\n\n  if (arc === 1) {\n    positions.push(positions[3], positions[4], positions[5]); // close the circle\n\n    uvs.push(uvs[2], uvs[3]);\n  } //indices\n\n\n  var vertexNb = positions.length / 3;\n\n  for (var i = 1; i < vertexNb - 1; i++) {\n    indices.push(i + 1, 0, i);\n  } // result\n\n\n  VertexData.ComputeNormals(positions, indices, normals);\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nMesh.CreateDisc = function (name, radius, tessellation, scene, updatable, sideOrientation) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    radius: radius,\n    tessellation: tessellation,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return DiscBuilder.CreateDisc(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar DiscBuilder =\n/** @class */\nfunction () {\n  function DiscBuilder() {}\n  /**\r\n   * Creates a plane polygonal mesh.  By default, this is a disc\r\n   * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n   * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n   * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the plane polygonal mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon\r\n   */\n\n\n  DiscBuilder.CreateDisc = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var disc = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    disc._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateDisc(options);\n    vertexData.applyToMesh(disc, options.updatable);\n    return disc;\n  };\n\n  return DiscBuilder;\n}();\n\nexport { DiscBuilder };","map":null,"metadata":{},"sourceType":"module"}