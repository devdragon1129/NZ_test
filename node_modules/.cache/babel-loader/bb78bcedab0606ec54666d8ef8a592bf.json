{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Tools } from \"../../Misc/tools\";\nimport { serialize } from \"../../Misc/decorators\";\n/**\r\n * PostProcessRenderPipeline\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\n\nvar PostProcessRenderPipeline =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes a PostProcessRenderPipeline\r\n   * @param engine engine to add the pipeline to\r\n   * @param name name of the pipeline\r\n   */\n  function PostProcessRenderPipeline(engine, name) {\n    this.engine = engine;\n    this._name = name;\n    this._renderEffects = {};\n    this._renderEffectsForIsolatedPass = new Array();\n    this._cameras = [];\n  }\n\n  Object.defineProperty(PostProcessRenderPipeline.prototype, \"name\", {\n    /**\r\n     * Gets pipeline name\r\n     */\n    get: function get() {\n      return this._name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcessRenderPipeline.prototype, \"cameras\", {\n    /** Gets the list of attached cameras */\n    get: function get() {\n      return this._cameras;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the class name\r\n   * @returns \"PostProcessRenderPipeline\"\r\n   */\n\n  PostProcessRenderPipeline.prototype.getClassName = function () {\n    return \"PostProcessRenderPipeline\";\n  };\n\n  Object.defineProperty(PostProcessRenderPipeline.prototype, \"isSupported\", {\n    /**\r\n     * If all the render effects in the pipeline are supported\r\n     */\n    get: function get() {\n      for (var renderEffectName in this._renderEffects) {\n        if (this._renderEffects.hasOwnProperty(renderEffectName)) {\n          if (!this._renderEffects[renderEffectName].isSupported) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Adds an effect to the pipeline\r\n   * @param renderEffect the effect to add\r\n   */\n\n  PostProcessRenderPipeline.prototype.addEffect = function (renderEffect) {\n    this._renderEffects[renderEffect._name] = renderEffect;\n  }; // private\n\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._rebuild = function () {};\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._enableEffect = function (renderEffectName, cameras) {\n    var renderEffects = this._renderEffects[renderEffectName];\n\n    if (!renderEffects) {\n      return;\n    }\n\n    renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._disableEffect = function (renderEffectName, cameras) {\n    var renderEffects = this._renderEffects[renderEffectName];\n\n    if (!renderEffects) {\n      return;\n    }\n\n    renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._attachCameras = function (cameras, unique) {\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    var indicesToDelete = [];\n    var i;\n\n    for (i = 0; i < cams.length; i++) {\n      var camera = cams[i];\n\n      if (!camera) {\n        continue;\n      }\n\n      var cameraName = camera.name;\n\n      if (this._cameras.indexOf(camera) === -1) {\n        this._cameras[cameraName] = camera;\n      } else if (unique) {\n        indicesToDelete.push(i);\n      }\n    }\n\n    for (i = 0; i < indicesToDelete.length; i++) {\n      cameras.splice(indicesToDelete[i], 1);\n    }\n\n    for (var renderEffectName in this._renderEffects) {\n      if (this._renderEffects.hasOwnProperty(renderEffectName)) {\n        this._renderEffects[renderEffectName]._attachCameras(cams);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._detachCameras = function (cameras) {\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    for (var renderEffectName in this._renderEffects) {\n      if (this._renderEffects.hasOwnProperty(renderEffectName)) {\n        this._renderEffects[renderEffectName]._detachCameras(cams);\n      }\n    }\n\n    for (var i = 0; i < cams.length; i++) {\n      this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\n    }\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._update = function () {\n    for (var renderEffectName in this._renderEffects) {\n      if (this._renderEffects.hasOwnProperty(renderEffectName)) {\n        this._renderEffects[renderEffectName]._update();\n      }\n    }\n\n    for (var i = 0; i < this._cameras.length; i++) {\n      if (!this._cameras[i]) {\n        continue;\n      }\n\n      var cameraName = this._cameras[i].name;\n\n      if (this._renderEffectsForIsolatedPass[cameraName]) {\n        this._renderEffectsForIsolatedPass[cameraName]._update();\n      }\n    }\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._reset = function () {\n    this._renderEffects = {};\n    this._renderEffectsForIsolatedPass = new Array();\n  };\n\n  PostProcessRenderPipeline.prototype._enableMSAAOnFirstPostProcess = function (sampleCount) {\n    if (this.engine.webGLVersion === 1) {\n      return false;\n    } // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\n\n\n    var effectKeys = Object.keys(this._renderEffects);\n\n    if (effectKeys.length > 0) {\n      var postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\n\n      if (postProcesses) {\n        postProcesses[0].samples = sampleCount;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Sets the required values to the prepass renderer.\r\n   * @param prePassRenderer defines the prepass renderer to setup.\r\n   * @returns true if the pre pass is needed.\r\n   */\n\n\n  PostProcessRenderPipeline.prototype.setPrePassRenderer = function (prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  };\n  /**\r\n   * Disposes of the pipeline\r\n   */\n\n\n  PostProcessRenderPipeline.prototype.dispose = function () {// Must be implemented by children\n  };\n\n  __decorate([serialize()], PostProcessRenderPipeline.prototype, \"_name\", void 0);\n\n  return PostProcessRenderPipeline;\n}();\n\nexport { PostProcessRenderPipeline };","map":null,"metadata":{},"sourceType":"module"}