{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\"; // This implementation was based on the original MIT-licensed TRACE repository\n// from https://github.com/septagon/TRACE.\n\n/**\r\n * Generic implementation of Levenshtein distance.\r\n */\n\nvar Levenshtein;\n\n(function (Levenshtein) {\n  /**\r\n   * Alphabet from which to construct sequences to be compared using Levenshtein\r\n   * distance.\r\n   */\n  var Alphabet =\n  /** @class */\n  function () {\n    /**\r\n     * Create a new Alphabet.\r\n     * @param characters characters of the alphabet\r\n     * @param charToInsertionCost function mapping characters to insertion costs\r\n     * @param charToDeletionCost function mapping characters to deletion costs\r\n     * @param charsToSubstitutionCost function mapping character pairs to substitution costs\r\n     */\n    function Alphabet(characters, charToInsertionCost, charToDeletionCost, charsToSubstitutionCost) {\n      if (charToInsertionCost === void 0) {\n        charToInsertionCost = null;\n      }\n\n      if (charToDeletionCost === void 0) {\n        charToDeletionCost = null;\n      }\n\n      if (charsToSubstitutionCost === void 0) {\n        charsToSubstitutionCost = null;\n      }\n\n      charToInsertionCost = charToInsertionCost !== null && charToInsertionCost !== void 0 ? charToInsertionCost : function () {\n        return 1;\n      };\n      charToDeletionCost = charToDeletionCost !== null && charToDeletionCost !== void 0 ? charToDeletionCost : function () {\n        return 1;\n      };\n      charsToSubstitutionCost = charsToSubstitutionCost !== null && charsToSubstitutionCost !== void 0 ? charsToSubstitutionCost : function (a, b) {\n        return a === b ? 0 : 1;\n      };\n      this._characterToIdx = new Map();\n      this._insertionCosts = new Array(characters.length);\n      this._deletionCosts = new Array(characters.length);\n      this._substitutionCosts = new Array(characters.length);\n      var c;\n\n      for (var outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\n        c = characters[outerIdx];\n\n        this._characterToIdx.set(c, outerIdx);\n\n        this._insertionCosts[outerIdx] = charToInsertionCost(c);\n        this._deletionCosts[outerIdx] = charToDeletionCost(c);\n        this._substitutionCosts[outerIdx] = new Array(characters.length);\n\n        for (var innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\n          this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\n        }\n      }\n    }\n    /**\r\n     * Serialize the Alphabet to JSON string.\r\n     * @returns JSON serialization\r\n     */\n\n\n    Alphabet.prototype.serialize = function () {\n      var jsonObject = {};\n      var characters = new Array(this._characterToIdx.size);\n\n      this._characterToIdx.forEach(function (v, k) {\n        characters[v] = k;\n      });\n\n      jsonObject[\"characters\"] = characters;\n      jsonObject[\"insertionCosts\"] = this._insertionCosts;\n      jsonObject[\"deletionCosts\"] = this._deletionCosts;\n      jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\n      return JSON.stringify(jsonObject);\n    };\n    /**\r\n     * Parse an Alphabet from a JSON serialization.\r\n     * @param json JSON string to deserialize\r\n     * @returns deserialized Alphabet\r\n     */\n\n\n    Alphabet.Deserialize = function (json) {\n      var jsonObject = JSON.parse(json);\n      var alphabet = new Alphabet(jsonObject[\"characters\"]);\n      alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\n      alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\n      alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\n      return alphabet;\n    };\n    /**\r\n     * Get the index (internally-assigned number) for a character.\r\n     * @param char character\r\n     * @returns index\r\n     */\n\n\n    Alphabet.prototype.getCharacterIdx = function (char) {\n      return this._characterToIdx.get(char);\n    };\n    /**\r\n     * Get the insertion cost of a character from its index.\r\n     * @param idx character index\r\n     * @returns insertion cost\r\n     */\n\n\n    Alphabet.prototype.getInsertionCost = function (idx) {\n      return this._insertionCosts[idx];\n    };\n    /**\r\n     * Get the deletion cost of a character from its index.\r\n     * @param idx character index\r\n     * @returns deletion cost\r\n     */\n\n\n    Alphabet.prototype.getDeletionCost = function (idx) {\n      return this._deletionCosts[idx];\n    };\n    /**\r\n     * Gets the cost to substitute two characters. NOTE: this cost is\r\n     * required to be bi-directional, meaning it cannot matter which of\r\n     * the provided characters is being removed and which is being inserted.\r\n     * @param idx1 the first character index\r\n     * @param idx2 the second character index\r\n     * @returns substitution cost\r\n     */\n\n\n    Alphabet.prototype.getSubstitutionCost = function (idx1, idx2) {\n      var min = Math.min(idx1, idx2);\n      var max = Math.max(idx1, idx2);\n      return this._substitutionCosts[min][max];\n    };\n\n    return Alphabet;\n  }();\n\n  Levenshtein.Alphabet = Alphabet;\n  /**\r\n   * Character sequence intended to be compared against other Sequences created\r\n   * with the same Alphabet in order to compute Levenshtein distance.\r\n   */\n\n  var Sequence =\n  /** @class */\n  function () {\n    /**\r\n     * Create a new Sequence.\r\n     * @param characters characters in the new Sequence\r\n     * @param alphabet Alphabet, which must include all used characters\r\n     */\n    function Sequence(characters, alphabet) {\n      var _this = this;\n\n      if (characters.length > Sequence.MAX_SEQUENCE_LENGTH) {\n        throw new Error(\"Sequences longer than \" + Sequence.MAX_SEQUENCE_LENGTH + \" not supported.\");\n      }\n\n      this._alphabet = alphabet;\n      this._characters = characters.map(function (c) {\n        return _this._alphabet.getCharacterIdx(c);\n      });\n    }\n    /**\r\n     * Serialize to JSON string. JSON representation does NOT include the Alphabet\r\n     * from which this Sequence was created; Alphabet must be independently\r\n     * serialized.\r\n     * @returns JSON string\r\n     */\n\n\n    Sequence.prototype.serialize = function () {\n      return JSON.stringify(this._characters);\n    };\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the Sequence was originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON string representation of Sequence\r\n     * @param alphabet Alphabet from which Sequence was originally created\r\n     * @returns Sequence\r\n     */\n\n\n    Sequence.Deserialize = function (json, alphabet) {\n      var sequence = new Sequence([], alphabet);\n      sequence._characters = JSON.parse(json);\n      return sequence;\n    };\n    /**\r\n     * Get the distance between this Sequence and another.\r\n     * @param other sequence to compare to\r\n     * @returns Levenshtein distance\r\n     */\n\n\n    Sequence.prototype.distance = function (other) {\n      return Sequence._distance(this, other);\n    };\n    /**\r\n     * Compute the Levenshtein distance between two Sequences.\r\n     * @param a first Sequence\r\n     * @param b second Sequence\r\n     * @returns Levenshtein distance\r\n     */\n\n\n    Sequence._distance = function (a, b) {\n      var alphabet = a._alphabet;\n\n      if (alphabet !== b._alphabet) {\n        throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\n      }\n\n      var aChars = a._characters;\n      var bChars = b._characters;\n      var aLength = aChars.length;\n      var bLength = bChars.length;\n      var costMatrix = Sequence._costMatrix;\n      costMatrix[0][0] = 0;\n\n      for (var idx = 0; idx < aLength; ++idx) {\n        costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\n      }\n\n      for (var idx = 0; idx < bLength; ++idx) {\n        costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\n      }\n\n      for (var aIdx = 0; aIdx < aLength; ++aIdx) {\n        for (var bIdx = 0; bIdx < bLength; ++bIdx) {\n          Sequence._insertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\n          Sequence._deletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\n          Sequence._substitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\n          costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._insertionCost, Sequence._deletionCost, Sequence._substitutionCost);\n        }\n      }\n\n      return costMatrix[aLength][bLength];\n    }; // Scratch values\n\n\n    Sequence.MAX_SEQUENCE_LENGTH = 256;\n    Sequence._costMatrix = __spreadArrays(Array(Sequence.MAX_SEQUENCE_LENGTH + 1)).map(function (n) {\n      return new Array(Sequence.MAX_SEQUENCE_LENGTH + 1);\n    });\n    return Sequence;\n  }();\n\n  Levenshtein.Sequence = Sequence;\n})(Levenshtein || (Levenshtein = {}));\n/**\r\n * A 3D trajectory consisting of an order list of vectors describing a\r\n * path of motion through 3D space.\r\n */\n\n\nvar Trajectory =\n/** @class */\nfunction () {\n  /**\r\n   * Create a new empty Trajectory.\r\n   * @param segmentLength radius of discretization for Trajectory points\r\n   */\n  function Trajectory(segmentLength) {\n    if (segmentLength === void 0) {\n      segmentLength = 0.01;\n    }\n\n    this._points = [];\n    this._segmentLength = segmentLength;\n  }\n  /**\r\n   * Serialize to JSON.\r\n   * @returns serialized JSON string\r\n   */\n\n\n  Trajectory.prototype.serialize = function () {\n    return JSON.stringify(this);\n  };\n  /**\r\n   * Deserialize from JSON.\r\n   * @param json serialized JSON string\r\n   * @returns deserialized Trajectory\r\n   */\n\n\n  Trajectory.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\n    trajectory._points = jsonObject[\"_points\"].map(function (pt) {\n      return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\n    });\n    return trajectory;\n  };\n  /**\r\n   * Get the length of the Trajectory.\r\n   * @returns length of the Trajectory\r\n   */\n\n\n  Trajectory.prototype.getLength = function () {\n    return this._points.length * this._segmentLength;\n  };\n  /**\r\n   * Append a new point to the Trajectory.\r\n   * NOTE: This implementation has many allocations.\r\n   * @param point point to append to the Trajectory\r\n   */\n\n\n  Trajectory.prototype.add = function (point) {\n    var _this = this;\n\n    var numPoints = this._points.length;\n\n    if (numPoints === 0) {\n      this._points.push(point.clone());\n    } else {\n      var getT = function getT() {\n        return _this._segmentLength / Vector3.Distance(_this._points[numPoints - 1], point);\n      };\n\n      for (var t = getT(); t <= 1.0; t = getT()) {\n        var newPoint = this._points[numPoints - 1].scale(1.0 - t);\n\n        point.scaleAndAddToRef(t, newPoint);\n\n        this._points.push(newPoint);\n\n        ++numPoints;\n      }\n    }\n  };\n  /**\r\n   * Create a new Trajectory with a segment length chosen to make it\r\n   * probable that the new Trajectory will have a specified number of\r\n   * segments. This operation is imprecise.\r\n   * @param targetResolution number of segments desired\r\n   * @returns new Trajectory with approximately the requested number of segments\r\n   */\n\n\n  Trajectory.prototype.resampleAtTargetResolution = function (targetResolution) {\n    var resampled = new Trajectory(this.getLength() / targetResolution);\n\n    this._points.forEach(function (pt) {\n      resampled.add(pt);\n    });\n\n    return resampled;\n  };\n  /**\r\n   * Convert Trajectory segments into tokenized representation. This\r\n   * representation is an array of numbers where each nth number is the\r\n   * index of the token which is most similar to the nth segment of the\r\n   * Trajectory.\r\n   * @param tokens list of vectors which serve as discrete tokens\r\n   * @returns list of indices of most similar token per segment\r\n   */\n\n\n  Trajectory.prototype.tokenize = function (tokens) {\n    var tokenization = [];\n    var segmentDir = new Vector3();\n\n    for (var idx = 2; idx < this._points.length; ++idx) {\n      if (Trajectory._transformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\n        tokenization.push(Trajectory._tokenizeSegment(segmentDir, tokens));\n      }\n    }\n\n    return tokenization;\n  };\n  /**\r\n   * Transform the rotation (i.e., direction) of a segment to isolate\r\n   * the relative transformation represented by the segment. This operation\r\n   * may or may not succeed due to singularities in the equations that define\r\n   * motion relativity in this context.\r\n   * @param priorVec the origin of the prior segment\r\n   * @param fromVec the origin of the current segment\r\n   * @param toVec the destination of the current segment\r\n   * @param result reference to output variable\r\n   * @returns whether or not transformation was successful\r\n   */\n\n\n  Trajectory._transformSegmentDirToRef = function (priorVec, fromVec, toVec, result) {\n    var DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\n    fromVec.subtractToRef(priorVec, Trajectory._forwardDir);\n\n    Trajectory._forwardDir.normalize();\n\n    fromVec.scaleToRef(-1, Trajectory._inverseFromVec);\n\n    Trajectory._inverseFromVec.normalize();\n\n    if (Math.abs(Vector3.Dot(Trajectory._forwardDir, Trajectory._inverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\n      return false;\n    }\n\n    Vector3.CrossToRef(Trajectory._forwardDir, Trajectory._inverseFromVec, Trajectory._upDir);\n\n    Trajectory._upDir.normalize();\n\n    Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._upDir, Trajectory._lookMatrix);\n    toVec.subtractToRef(fromVec, Trajectory._fromToVec);\n\n    Trajectory._fromToVec.normalize();\n\n    Vector3.TransformNormalToRef(Trajectory._fromToVec, Trajectory._lookMatrix, result);\n    return true;\n  };\n  /**\r\n   * Determine which token vector is most similar to the\r\n   * segment vector.\r\n   * @param segment segment vector\r\n   * @param tokens token vector list\r\n   * @returns index of the most similar token to the segment\r\n   */\n\n\n  Trajectory._tokenizeSegment = function (segment, tokens) {\n    Trajectory._bestMatch = 0;\n    Trajectory._score = Vector3.Dot(segment, tokens[0]);\n    Trajectory._bestScore = Trajectory._score;\n\n    for (var idx = 1; idx < tokens.length; ++idx) {\n      Trajectory._score = Vector3.Dot(segment, tokens[idx]);\n\n      if (Trajectory._score > Trajectory._bestScore) {\n        Trajectory._bestMatch = idx;\n        Trajectory._bestScore = Trajectory._score;\n      }\n    }\n\n    return Trajectory._bestMatch;\n  };\n\n  Trajectory._forwardDir = new Vector3();\n  Trajectory._inverseFromVec = new Vector3();\n  Trajectory._upDir = new Vector3();\n  Trajectory._fromToVec = new Vector3();\n  Trajectory._lookMatrix = new Matrix();\n  return Trajectory;\n}();\n\nexport { Trajectory };\n/**\r\n * Collection of vectors intended to be used as the basis of Trajectory\r\n * tokenization for Levenshtein distance comparison. Canonically, a\r\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\r\n * roughly evenly over the surface of the unit sphere.\r\n */\n\nvar Vector3Alphabet =\n/** @class */\nfunction () {\n  function Vector3Alphabet(size) {\n    this.chars = new Array(size);\n  }\n  /**\r\n   * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\r\n   * optimize-from-random strategy to space points around the unit sphere\r\n   * surface as a simple alternative to really doing the math to tile the\r\n   * sphere.\r\n   * @param alphabetSize size of the desired alphabet\r\n   * @param iterations number of iterations over which to optimize the \"spikeball\"\r\n   * @param startingStepSize distance factor to move points in early optimization iterations\r\n   * @param endingStepSize distance factor to move points in late optimization iterations\r\n   * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\r\n   * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\r\n   */\n\n\n  Vector3Alphabet.Generate = function (alphabetSize, iterations, startingStepSize, endingStepSize, fixedValues) {\n    if (alphabetSize === void 0) {\n      alphabetSize = 64;\n    }\n\n    if (iterations === void 0) {\n      iterations = 256;\n    }\n\n    if (startingStepSize === void 0) {\n      startingStepSize = 0.1;\n    }\n\n    if (endingStepSize === void 0) {\n      endingStepSize = 0.001;\n    }\n\n    if (fixedValues === void 0) {\n      fixedValues = [];\n    }\n\n    var EPSILON = 0.001;\n    var EPSILON_SQUARED = EPSILON * EPSILON;\n    var alphabet = new Vector3Alphabet(alphabetSize);\n\n    for (var idx = 0; idx < alphabetSize; ++idx) {\n      alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n      alphabet.chars[idx].normalize();\n    }\n\n    for (var idx = 0; idx < fixedValues.length; ++idx) {\n      alphabet.chars[idx].copyFrom(fixedValues[idx]);\n    }\n\n    var stepSize;\n    var distSq;\n    var force = new Vector3();\n    var scratch = new Vector3();\n\n    var lerp = function lerp(l, r, t) {\n      return (1.0 - t) * l + t * r;\n    };\n\n    for (var iteration = 0; iteration < iterations; ++iteration) {\n      stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\n\n      var _loop_1 = function _loop_1(idx) {\n        force.copyFromFloats(0, 0, 0);\n        alphabet.chars.forEach(function (pt) {\n          alphabet.chars[idx].subtractToRef(pt, scratch);\n          distSq = scratch.lengthSquared();\n\n          if (distSq > EPSILON_SQUARED) {\n            scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\n          }\n        });\n        force.scaleInPlace(stepSize);\n        alphabet.chars[idx].addInPlace(force);\n        alphabet.chars[idx].normalize();\n      };\n\n      for (var idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\n        _loop_1(idx);\n      }\n    }\n\n    return alphabet;\n  };\n  /**\r\n   * Serialize to JSON.\r\n   * @returns JSON serialization\r\n   */\n\n\n  Vector3Alphabet.prototype.serialize = function () {\n    return JSON.stringify(this.chars);\n  };\n  /**\r\n   * Deserialize from JSON.\r\n   * @param json JSON serialization\r\n   * @returns deserialized Vector3Alphabet\r\n   */\n\n\n  Vector3Alphabet.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var alphabet = new Vector3Alphabet(jsonObject.length);\n\n    for (var idx = 0; idx < jsonObject.length; ++idx) {\n      alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\n    }\n\n    return alphabet;\n  };\n\n  return Vector3Alphabet;\n}();\n/**\r\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\r\n * describe a Trajectory. This class houses the functionality which determines what\r\n * attributes of Trajectories are and are not considered important, such as scale.\r\n */\n\n\nvar TrajectoryDescriptor =\n/** @class */\nfunction () {\n  function TrajectoryDescriptor() {\n    this._sequences = [];\n  }\n  /**\r\n   * Serialize to JSON.\r\n   * @returns JSON serialization\r\n   */\n\n\n  TrajectoryDescriptor.prototype.serialize = function () {\n    return JSON.stringify(this._sequences.map(function (sequence) {\n      return sequence.serialize();\n    }));\n  };\n  /**\r\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n   * from which the descriptor was originally created, which must be serialized and\r\n   * deserialized independently so that it can be passed in here.\r\n   * @param json JSON serialization\r\n   * @param alphabet Alphabet from which descriptor was originally created\r\n   * @returns deserialized TrajectoryDescriptor\r\n   */\n\n\n  TrajectoryDescriptor.Deserialize = function (json, alphabet) {\n    var descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = JSON.parse(json).map(function (s) {\n      return Levenshtein.Sequence.Deserialize(s, alphabet);\n    });\n    return descriptor;\n  };\n  /**\r\n   * Create a new TrajectoryDescriptor to describe a provided Trajectory according\r\n   * to the provided alphabets.\r\n   * @param trajectory Trajectory to be described\r\n   * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\r\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\r\n   * @returns TrajectoryDescriptor describing provided Trajectory\r\n   */\n\n\n  TrajectoryDescriptor.CreateFromTrajectory = function (trajectory, vector3Alphabet, levenshteinAlphabet) {\n    return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._getTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\n  };\n  /**\r\n   * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\r\n   * NOTE: This function exists to support an outdated serialization mechanism and should\r\n   * be deleted if it is no longer useful.\r\n   * @param pyramid tokenization pyramid\r\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\r\n   * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\r\n   */\n\n\n  TrajectoryDescriptor.CreateFromTokenizationPyramid = function (pyramid, levenshteinAlphabet) {\n    var descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = pyramid.map(function (tokens) {\n      return new Levenshtein.Sequence(tokens, levenshteinAlphabet);\n    });\n    return descriptor;\n  };\n  /**\r\n   * Create the tokenization pyramid for the provided Trajectory according to the given\r\n   * Vector3Alphabet.\r\n   * @param trajectory Trajectory to be tokenized\r\n   * @param alphabet Vector3Alphabet containing tokens\r\n   * @param targetResolution finest resolution of descriptor\r\n   * @returns tokenization pyramid for Trajectory\r\n   */\n\n\n  TrajectoryDescriptor._getTokenizationPyramid = function (trajectory, alphabet, targetResolution) {\n    if (targetResolution === void 0) {\n      targetResolution = TrajectoryDescriptor.FINEST_DESCRIPTOR_RESOLUTION;\n    }\n\n    var pyramid = [];\n\n    for (var res = targetResolution; res > 4; res = Math.floor(res / 2)) {\n      pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\n    }\n\n    return pyramid;\n  };\n  /**\r\n   * Calculate a distance metric between this TrajectoryDescriptor and another. This is\r\n   * essentially a similarity score and does not directly represent Euclidean distance,\r\n   * edit distance, or any other formal distance metric.\r\n   * @param other TrajectoryDescriptor from which to determine distance\r\n   * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\r\n   */\n\n\n  TrajectoryDescriptor.prototype.distance = function (other) {\n    var totalDistance = 0;\n    var weight;\n\n    for (var idx = 0; idx < this._sequences.length; ++idx) {\n      weight = Math.pow(2, idx);\n      totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\n    }\n\n    return totalDistance;\n  };\n\n  TrajectoryDescriptor.FINEST_DESCRIPTOR_RESOLUTION = 32;\n  return TrajectoryDescriptor;\n}();\n/**\r\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\r\n * class to facilitate methods of Trajectory clustering.\r\n */\n\n\nvar TrajectoryClass =\n/** @class */\nfunction () {\n  /**\r\n   * Create a new DescribedTrajectory.\r\n   * @param descriptors currently-known TrajectoryDescriptors, if any\r\n   */\n  function TrajectoryClass(descriptors) {\n    if (descriptors === void 0) {\n      descriptors = [];\n    }\n\n    this._descriptors = descriptors;\n    this._centroidIdx = -1;\n    this._averageDistance = 0;\n\n    this._refreshDescription();\n  }\n  /**\r\n   * Serialize to JSON.\r\n   * @returns JSON serialization\r\n   */\n\n\n  TrajectoryClass.prototype.serialize = function () {\n    var jsonObject = {};\n    jsonObject.descriptors = this._descriptors.map(function (desc) {\n      return desc.serialize();\n    });\n    jsonObject.centroidIdx = this._centroidIdx;\n    jsonObject.averageDistance = this._averageDistance;\n    return JSON.stringify(jsonObject);\n  };\n  /**\r\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n   * from which the descriptors were originally created, which must be serialized and\r\n   * deserialized independently so that it can be passed in here.\r\n   * @param json JSON string representation\r\n   * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\r\n   * @returns deserialized TrajectoryDescriptor\r\n   */\n\n\n  TrajectoryClass.Deserialize = function (json, alphabet) {\n    var jsonObject = JSON.parse(json);\n    var described = new TrajectoryClass();\n    described._descriptors = jsonObject.descriptors.map(function (s) {\n      return TrajectoryDescriptor.Deserialize(s, alphabet);\n    });\n    described._centroidIdx = jsonObject.centroidIdx;\n    described._averageDistance = jsonObject.averageDistance;\n    return described;\n  };\n  /**\r\n   * Add a new TrajectoryDescriptor to the list of descriptors known to describe\r\n   * this same DescribedTrajectory.\r\n   * @param descriptor descriptor to be added\r\n   */\n\n\n  TrajectoryClass.prototype.add = function (descriptor) {\n    this._descriptors.push(descriptor);\n\n    this._refreshDescription();\n  };\n  /**\r\n   * Compute the cost, which is inversely related to the likelihood that the provided\r\n   * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\r\n   * the class represented by this DescribedTrajectory.\r\n   * @param descriptor the descriptor to be costed\r\n   * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimiliarity\r\n   */\n\n\n  TrajectoryClass.prototype.getMatchCost = function (descriptor) {\n    return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\n  };\n  /**\r\n   * Compute the minimum distance between the queried TrajectoryDescriptor and a\r\n   * descriptor which is a member of this collection. This is an alternative way of\r\n   * conceptualizing match cost from getMatchCost(), and it serves a different function.\r\n   * @param descriptor the descriptor to find the minimum distance to\r\n   * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\r\n   */\n\n\n  TrajectoryClass.prototype.getMatchMinimumDistance = function (descriptor) {\n    return Math.min.apply(Math, this._descriptors.map(function (desc) {\n      return desc.distance(descriptor);\n    }));\n  };\n  /**\r\n   * Refreshes the internal representation of this DescribedTrajectory.\r\n   */\n\n\n  TrajectoryClass.prototype._refreshDescription = function () {\n    var _this = this;\n\n    this._centroidIdx = -1;\n    var sum;\n\n    var distances = this._descriptors.map(function (a) {\n      sum = 0;\n\n      _this._descriptors.forEach(function (b) {\n        sum += a.distance(b);\n      });\n\n      return sum;\n    });\n\n    for (var idx = 0; idx < distances.length; ++idx) {\n      if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\n        this._centroidIdx = idx;\n      }\n    }\n\n    this._averageDistance = 0;\n\n    this._descriptors.forEach(function (desc) {\n      _this._averageDistance += desc.distance(_this._descriptors[_this._centroidIdx]);\n    });\n\n    if (this._descriptors.length > 0) {\n      this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass.MIN_AVERAGE_DISTANCE);\n    }\n  };\n\n  TrajectoryClass.MIN_AVERAGE_DISTANCE = 1;\n  return TrajectoryClass;\n}();\n/**\r\n * Class representing a set of known, named trajectories to which Trajectories can be\r\n * added and using which Trajectories can be recognized.\r\n */\n\n\nvar TrajectoryClassifier =\n/** @class */\nfunction () {\n  function TrajectoryClassifier() {\n    this._maximumAllowableMatchCost = 4;\n    this._nameToDescribedTrajectory = new Map();\n  }\n  /**\r\n   * Serialize to JSON.\r\n   * @returns JSON serialization\r\n   */\n\n\n  TrajectoryClassifier.prototype.serialize = function () {\n    var jsonObject = {};\n    jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\n    jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\n    jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\n    jsonObject.nameToDescribedTrajectory = [];\n\n    this._nameToDescribedTrajectory.forEach(function (described, name) {\n      jsonObject.nameToDescribedTrajectory.push(name);\n      jsonObject.nameToDescribedTrajectory.push(described.serialize());\n    });\n\n    return JSON.stringify(jsonObject);\n  };\n  /**\r\n   * Deserialize from JSON.\r\n   * @param json JSON serialization\r\n   * @returns deserialized TrajectorySet\r\n   */\n\n\n  TrajectoryClassifier.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var classifier = new TrajectoryClassifier();\n    classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\n    classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\n    classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);\n\n    for (var idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\n      classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));\n    }\n\n    return classifier;\n  };\n  /**\r\n   * Initialize a new empty TrajectorySet with auto-generated Alphabets.\r\n   * VERY naive, need to be generating these things from known\r\n   * sets. Better version later, probably eliminating this one.\r\n   * @returns auto-generated TrajectorySet\r\n   */\n\n\n  TrajectoryClassifier.Generate = function () {\n    var vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\n    var charIdxs = new Array(vecs.chars.length);\n\n    for (var idx = 0; idx < charIdxs.length; ++idx) {\n      charIdxs[idx] = idx;\n    }\n\n    var alphabet = new Levenshtein.Alphabet(charIdxs, function (idx) {\n      return idx === 0 ? 0 : 1;\n    }, function (idx) {\n      return idx === 0 ? 0 : 1;\n    }, function (a, b) {\n      return Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1);\n    });\n    var trajectorySet = new TrajectoryClassifier();\n    trajectorySet._vector3Alphabet = vecs;\n    trajectorySet._levenshteinAlphabet = alphabet;\n    return trajectorySet;\n  };\n  /**\r\n   * Add a new Trajectory to the set with a given name.\r\n   * @param trajectory new Trajectory to be added\r\n   * @param classification name to which to add the Trajectory\r\n   */\n\n\n  TrajectoryClassifier.prototype.addTrajectoryToClassification = function (trajectory, classification) {\n    if (!this._nameToDescribedTrajectory.has(classification)) {\n      this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\n    }\n\n    this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\n  };\n  /**\r\n   * Remove a known named trajectory and all Trajectories associated with it.\r\n   * @param classification name to remove\r\n   * @returns whether anything was removed\r\n   */\n\n\n  TrajectoryClassifier.prototype.deleteClassification = function (classification) {\n    return this._nameToDescribedTrajectory.delete(classification);\n  };\n  /**\r\n   * Attempt to recognize a Trajectory from among all the classifications\r\n   * already known to the classifier.\r\n   * @param trajectory Trajectory to be recognized\r\n   * @returns classification of Trajectory if recognized, null otherwise\r\n   */\n\n\n  TrajectoryClassifier.prototype.classifyTrajectory = function (trajectory) {\n    var _this = this;\n\n    var descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\n    var allowableMatches = [];\n\n    this._nameToDescribedTrajectory.forEach(function (trajectoryClass, classification) {\n      if (trajectoryClass.getMatchCost(descriptor) < _this._maximumAllowableMatchCost) {\n        allowableMatches.push(classification);\n      }\n    });\n\n    if (allowableMatches.length === 0) {\n      return null;\n    }\n\n    var bestIdx = 0;\n\n    var bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);\n\n    var match;\n\n    for (var idx = 0; idx < allowableMatches.length; ++idx) {\n      match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);\n\n      if (match < bestMatch) {\n        bestMatch = match;\n        bestIdx = idx;\n      }\n    }\n\n    return allowableMatches[bestIdx];\n  };\n\n  return TrajectoryClassifier;\n}();\n\nexport { TrajectoryClassifier };","map":null,"metadata":{},"sourceType":"module"}