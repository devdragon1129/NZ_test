{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { NodeMaterial } from '../../nodeMaterial';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { Texture } from '../../../Textures/texture';\nimport { NodeMaterialModes } from '../../Enums/nodeMaterialModes';\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\n/**\r\n * Block used to read a texture from a sampler\r\n */\n\nvar TextureBlock =\n/** @class */\nfunction (_super) {\n  __extends(TextureBlock, _super);\n  /**\r\n   * Create a new TextureBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function TextureBlock(name, fragmentOnly) {\n    if (fragmentOnly === void 0) {\n      fragmentOnly = false;\n    }\n\n    var _this = _super.call(this, name, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment) || this;\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\n\n\n    _this.convertToGammaSpace = false;\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\n\n    _this.convertToLinearSpace = false;\n    _this._fragmentOnly = fragmentOnly;\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\n\n    _this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this._inputs[0]._prioritizeVertex = !fragmentOnly;\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  TextureBlock.prototype.getClassName = function () {\n    return \"TextureBlock\";\n  };\n\n  Object.defineProperty(TextureBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the uv input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"rgba\", {\n    /**\r\n     * Gets the rgba output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"rgb\", {\n    /**\r\n     * Gets the rgb output component\r\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"r\", {\n    /**\r\n     * Gets the r output component\r\n     */\n    get: function get() {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"g\", {\n    /**\r\n     * Gets the g output component\r\n     */\n    get: function get() {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"b\", {\n    /**\r\n     * Gets the b output component\r\n     */\n    get: function get() {\n      return this._outputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"a\", {\n    /**\r\n     * Gets the a output component\r\n     */\n    get: function get() {\n      return this._outputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"target\", {\n    get: function get() {\n      if (this._fragmentOnly) {\n        return NodeMaterialBlockTargets.Fragment;\n      } // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.\n      // But we need to detect uvs coming from fragment then\n\n\n      if (!this.uv.isConnected) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      if (this.uv.sourceBlock.isInput) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      var parent = this.uv.connectedPoint;\n\n      while (parent) {\n        if (parent.target === NodeMaterialBlockTargets.Fragment) {\n          return NodeMaterialBlockTargets.Fragment;\n        }\n\n        if (parent.target === NodeMaterialBlockTargets.Vertex) {\n          return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n\n        if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {\n          var parentBlock = parent.ownerBlock;\n          parent = null;\n\n          for (var _i = 0, _a = parentBlock.inputs; _i < _a.length; _i++) {\n            var input = _a[_i];\n\n            if (input.connectedPoint) {\n              parent = input.connectedPoint;\n              break;\n            }\n          }\n        }\n      }\n\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureBlock.prototype.autoConfigure = function (material) {\n    if (!this.uv.isConnected) {\n      if (material.mode === NodeMaterialModes.PostProcess) {\n        var uvInput = material.getBlockByPredicate(function (b) {\n          return b.name === \"uv\";\n        });\n\n        if (uvInput) {\n          uvInput.connectTo(this);\n        }\n      } else {\n        var attributeName_1 = material.mode === NodeMaterialModes.Particle ? \"particle_uv\" : \"uv\";\n        var uvInput = material.getInputBlockByPredicate(function (b) {\n          return b.isAttribute && b.name === attributeName_1;\n        });\n\n        if (!uvInput) {\n          uvInput = new InputBlock(\"uv\");\n          uvInput.setAsAttribute(attributeName_1);\n        }\n\n        uvInput.output.connectTo(this.uv);\n      }\n    }\n  };\n\n  TextureBlock.prototype.initializeDefines = function (mesh, nodeMaterial, defines, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    defines.setValue(this._mainUVDefineName, false);\n  };\n\n  TextureBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    if (!this.texture || !this.texture.getTextureMatrix) {\n      defines.setValue(this._defineName, false);\n      defines.setValue(this._mainUVDefineName, true);\n      return;\n    }\n\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace);\n\n    if (this._isMixed) {\n      if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {\n        defines.setValue(this._defineName, true);\n      } else {\n        defines.setValue(this._defineName, false);\n        defines.setValue(this._mainUVDefineName, true);\n      }\n    }\n  };\n\n  TextureBlock.prototype.isReady = function () {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  TextureBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (!this.texture) {\n      return;\n    }\n\n    if (this._isMixed) {\n      effect.setFloat(this._textureInfoName, this.texture.level);\n      effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());\n    }\n\n    effect.setTexture(this._samplerName, this.texture);\n  };\n\n  Object.defineProperty(TextureBlock.prototype, \"_isMixed\", {\n    get: function get() {\n      return this.target !== NodeMaterialBlockTargets.Fragment;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureBlock.prototype._injectVertexCode = function (state) {\n    var uvInput = this.uv; // Inject code in vertex\n\n    this._defineName = state._getFreeDefineName(\"UVTRANSFORM\");\n    this._mainUVDefineName = \"VMAIN\" + uvInput.associatedVariableName.toUpperCase();\n\n    if (uvInput.connectedPoint.ownerBlock.isInput) {\n      var uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n\n      if (!uvInputOwnerBlock.isAttribute) {\n        state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\n      }\n    }\n\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n    this._transformedUVName = state._getFreeVariableName(\"transformedUV\");\n    this._textureTransformName = state._getFreeVariableName(\"textureTransform\");\n    this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\n\n    state._emitVaryingFromString(this._transformedUVName, \"vec2\", this._defineName);\n\n    state._emitVaryingFromString(this._mainUVName, \"vec2\", this._mainUVDefineName);\n\n    state._emitUniformFromString(this._textureTransformName, \"mat4\", this._defineName);\n\n    state.compilationString += \"#ifdef \" + this._defineName + \"\\r\\n\";\n    state.compilationString += this._transformedUVName + \" = vec2(\" + this._textureTransformName + \" * vec4(\" + uvInput.associatedVariableName + \".xy, 1.0, 0.0));\\r\\n\";\n    state.compilationString += \"#elif defined(\" + this._mainUVDefineName + \")\\r\\n\";\n    state.compilationString += this._mainUVName + \" = \" + uvInput.associatedVariableName + \".xy;\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInVertexShader;\n    })) {\n      return;\n    }\n\n    this._writeTextureRead(state, true);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name, true);\n      }\n    }\n  };\n\n  TextureBlock.prototype._writeTextureRead = function (state, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    var uvInput = this.uv;\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + uvInput.associatedVariableName + \");\\r\\n\";\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + uvInput.associatedVariableName + \");\\r\\n\";\n      return;\n    }\n\n    state.compilationString += \"#ifdef \" + this._defineName + \"\\r\\n\";\n    state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + this._transformedUVName + \");\\r\\n\";\n    state.compilationString += \"#elif defined(\" + this._mainUVDefineName + \")\\r\\n\";\n    state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + this._mainUVName + \");\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n  };\n\n  TextureBlock.prototype._writeOutput = function (state, output, swizzle, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n      return;\n    }\n\n    var complement = \" * \" + this._textureInfoName;\n    state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + complement + \";\\r\\n\";\n\n    if (swizzle !== 'a') {\n      // no conversion if the output is \"a\" (alpha)\n      state.compilationString += \"#ifdef \" + this._linearDefineName + \"\\r\\n\";\n      state.compilationString += output.associatedVariableName + \" = toGammaSpace(\" + output.associatedVariableName + \");\\r\\n\";\n      state.compilationString += \"#endif\\r\\n\";\n      state.compilationString += \"#ifdef \" + this._gammaDefineName + \"\\r\\n\";\n      state.compilationString += output.associatedVariableName + \" = toLinearSpace(\" + output.associatedVariableName + \");\\r\\n\";\n      state.compilationString += \"#endif\\r\\n\";\n    }\n  };\n\n  TextureBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly) {\n      this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    }\n\n    if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {\n      this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n\n      state._emit2DSampler(this._samplerName); // Declarations\n\n\n      state.sharedData.blockingBlocks.push(this);\n      state.sharedData.textureBlocks.push(this);\n      state.sharedData.blocksWithDefines.push(this);\n      state.sharedData.bindableBlocks.push(this);\n    }\n\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n\n      return;\n    } // Fragment\n\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInFragmentShader;\n    })) {\n      return;\n    }\n\n    if (this._isMixed) {\n      // Reexport the sampler\n      state._emit2DSampler(this._samplerName);\n    }\n\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    var comments = \"//\" + this.name;\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    if (this._isMixed) {\n      state._emitUniformFromString(this._textureInfoName, \"float\");\n    }\n\n    this._writeTextureRead(state);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n\n    return this;\n  };\n\n  TextureBlock.prototype._dumpPropertiesCode = function () {\n    if (!this.texture) {\n      return \"\";\n    }\n\n    var codeString = this._codeVariableName + \".texture = new BABYLON.Texture(\\\"\" + this.texture.name + \"\\\", null);\\r\\n\";\n    codeString += this._codeVariableName + \".texture.wrapU = \" + this.texture.wrapU + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.wrapV = \" + this.texture.wrapV + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.uAng = \" + this.texture.uAng + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.vAng = \" + this.texture.vAng + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.wAng = \" + this.texture.wAng + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.uOffset = \" + this.texture.uOffset + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.vOffset = \" + this.texture.vOffset + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.uScale = \" + this.texture.uScale + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.vScale = \" + this.texture.vScale + \";\\r\\n\";\n    codeString += this._codeVariableName + \".convertToGammaSpace = \" + this.convertToGammaSpace + \";\\r\\n\";\n    codeString += this._codeVariableName + \".convertToLinearSpace = \" + this.convertToLinearSpace + \";\\r\\n\";\n    return codeString;\n  };\n\n  TextureBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.fragmentOnly = this._fragmentOnly;\n\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  TextureBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    this._fragmentOnly = !!serializationObject.fragmentOnly;\n\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  };\n\n  return TextureBlock;\n}(NodeMaterialBlock);\n\nexport { TextureBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.TextureBlock\"] = TextureBlock;","map":null,"metadata":{},"sourceType":"module"}