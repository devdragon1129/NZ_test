{"ast":null,"code":"import { Observable } from \"@babylonjs/core/Misc/observable\";\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer\";\nimport { Logger } from '@babylonjs/core/Misc/logger';\nimport { DataReader } from '@babylonjs/core/Misc/dataReader';\nimport { GLTFValidation } from './glTFValidation';\nimport { StringTools } from '@babylonjs/core/Misc/stringTools';\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\n\nexport var GLTFLoaderCoordinateSystemMode;\n\n(function (GLTFLoaderCoordinateSystemMode) {\n  /**\r\n   * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n   */\n  GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode[\"AUTO\"] = 0] = \"AUTO\";\n  /**\r\n   * Sets the useRightHandedSystem flag on the scene.\r\n   */\n\n  GLTFLoaderCoordinateSystemMode[GLTFLoaderCoordinateSystemMode[\"FORCE_RIGHT_HANDED\"] = 1] = \"FORCE_RIGHT_HANDED\";\n})(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));\n/**\r\n * Mode that determines what animations will start.\r\n */\n\n\nexport var GLTFLoaderAnimationStartMode;\n\n(function (GLTFLoaderAnimationStartMode) {\n  /**\r\n   * No animation will start.\r\n   */\n  GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"NONE\"] = 0] = \"NONE\";\n  /**\r\n   * The first animation will start.\r\n   */\n\n  GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"FIRST\"] = 1] = \"FIRST\";\n  /**\r\n   * All animations will start.\r\n   */\n\n  GLTFLoaderAnimationStartMode[GLTFLoaderAnimationStartMode[\"ALL\"] = 2] = \"ALL\";\n})(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));\n/**\r\n * Loader state.\r\n */\n\n\nexport var GLTFLoaderState;\n\n(function (GLTFLoaderState) {\n  /**\r\n   * The asset is loading.\r\n   */\n  GLTFLoaderState[GLTFLoaderState[\"LOADING\"] = 0] = \"LOADING\";\n  /**\r\n   * The asset is ready for rendering.\r\n   */\n\n  GLTFLoaderState[GLTFLoaderState[\"READY\"] = 1] = \"READY\";\n  /**\r\n   * The asset is completely loaded.\r\n   */\n\n  GLTFLoaderState[GLTFLoaderState[\"COMPLETE\"] = 2] = \"COMPLETE\";\n})(GLTFLoaderState || (GLTFLoaderState = {}));\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\n\n\nvar GLTFFileLoader =\n/** @class */\nfunction () {\n  function GLTFFileLoader() {\n    // --------------\n    // Common options\n    // --------------\n\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\n    this.onParsedObservable = new Observable(); // ----------\n    // V2 options\n    // ----------\n\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\n\n    this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\n    /**\r\n    * The animation start mode. Defaults to FIRST.\r\n    */\n\n    this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\n\n    this.compileMaterials = false;\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\n\n    this.useClipPlane = false;\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\n\n    this.compileShadowGenerators = false;\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\n\n    this.transparencyAsCoverage = false;\n    /**\r\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\r\n     * Enabling will disable offline support and glTF validator.\r\n     * Defaults to false.\r\n     */\n\n    this.useRangeRequests = false;\n    /**\r\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\r\n     */\n\n    this.createInstances = true;\n    /**\r\n     * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\r\n     */\n\n    this.alwaysComputeBoundingBox = false;\n    /**\r\n     * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\r\n     */\n\n    this.loadAllMaterials = false;\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     */\n\n    this.preprocessUrlAsync = function (url) {\n      return Promise.resolve(url);\n    };\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\n\n\n    this.onMeshLoadedObservable = new Observable();\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\n\n    this.onTextureLoadedObservable = new Observable();\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\n\n    this.onMaterialLoadedObservable = new Observable();\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\n\n    this.onCameraLoadedObservable = new Observable();\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\n\n    this.onCompleteObservable = new Observable();\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\n\n    this.onErrorObservable = new Observable();\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\n\n    this.onDisposeObservable = new Observable();\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\n\n    this.onExtensionLoadedObservable = new Observable();\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\n\n    this.validate = false;\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\n\n    this.onValidatedObservable = new Observable();\n    this._loader = null;\n    this._requests = new Array();\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\n\n    this.name = \"gltf\";\n    /** @hidden */\n\n    this.extensions = {\n      \".gltf\": {\n        isBinary: false\n      },\n      \".glb\": {\n        isBinary: true\n      }\n    };\n    this._logIndentLevel = 0;\n    this._loggingEnabled = false;\n    /** @hidden */\n\n    this._log = this._logDisabled;\n    this._capturePerformanceCounters = false;\n    /** @hidden */\n\n    this._startPerformanceCounter = this._startPerformanceCounterDisabled;\n    /** @hidden */\n\n    this._endPerformanceCounter = this._endPerformanceCounterDisabled;\n  }\n\n  Object.defineProperty(GLTFFileLoader.prototype, \"onParsed\", {\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\n    set: function set(callback) {\n      if (this._onParsedObserver) {\n        this.onParsedObservable.remove(this._onParsedObserver);\n      }\n\n      this._onParsedObserver = this.onParsedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onMeshLoaded\", {\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\n    set: function set(callback) {\n      if (this._onMeshLoadedObserver) {\n        this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\n      }\n\n      this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onTextureLoaded\", {\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\n    set: function set(callback) {\n      if (this._onTextureLoadedObserver) {\n        this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\n      }\n\n      this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onMaterialLoaded\", {\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\n    set: function set(callback) {\n      if (this._onMaterialLoadedObserver) {\n        this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\n      }\n\n      this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onCameraLoaded\", {\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\n    set: function set(callback) {\n      if (this._onCameraLoadedObserver) {\n        this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\n      }\n\n      this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onComplete\", {\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\n    set: function set(callback) {\n      if (this._onCompleteObserver) {\n        this.onCompleteObservable.remove(this._onCompleteObserver);\n      }\n\n      this._onCompleteObserver = this.onCompleteObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onError\", {\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\n    set: function set(callback) {\n      if (this._onErrorObserver) {\n        this.onErrorObservable.remove(this._onErrorObserver);\n      }\n\n      this._onErrorObserver = this.onErrorObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onDispose\", {\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onExtensionLoaded\", {\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\n    set: function set(callback) {\n      if (this._onExtensionLoadedObserver) {\n        this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\n      }\n\n      this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"loggingEnabled\", {\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\n    get: function get() {\n      return this._loggingEnabled;\n    },\n    set: function set(value) {\n      if (this._loggingEnabled === value) {\n        return;\n      }\n\n      this._loggingEnabled = value;\n\n      if (this._loggingEnabled) {\n        this._log = this._logEnabled;\n      } else {\n        this._log = this._logDisabled;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"capturePerformanceCounters\", {\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\n    get: function get() {\n      return this._capturePerformanceCounters;\n    },\n    set: function set(value) {\n      if (this._capturePerformanceCounters === value) {\n        return;\n      }\n\n      this._capturePerformanceCounters = value;\n\n      if (this._capturePerformanceCounters) {\n        this._startPerformanceCounter = this._startPerformanceCounterEnabled;\n        this._endPerformanceCounter = this._endPerformanceCounterEnabled;\n      } else {\n        this._startPerformanceCounter = this._startPerformanceCounterDisabled;\n        this._endPerformanceCounter = this._endPerformanceCounterDisabled;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GLTFFileLoader.prototype, \"onValidated\", {\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\n    set: function set(callback) {\n      if (this._onValidatedObserver) {\n        this.onValidatedObservable.remove(this._onValidatedObserver);\n      }\n\n      this._onValidatedObserver = this.onValidatedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n   */\n\n  GLTFFileLoader.prototype.dispose = function () {\n    if (this._loader) {\n      this._loader.dispose();\n\n      this._loader = null;\n    }\n\n    for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {\n      var request = _a[_i];\n      request.abort();\n    }\n\n    this._requests.length = 0;\n    delete this._progressCallback;\n\n    this.preprocessUrlAsync = function (url) {\n      return Promise.resolve(url);\n    };\n\n    this.onMeshLoadedObservable.clear();\n    this.onTextureLoadedObservable.clear();\n    this.onMaterialLoadedObservable.clear();\n    this.onCameraLoadedObservable.clear();\n    this.onCompleteObservable.clear();\n    this.onExtensionLoadedObservable.clear();\n    this.onDisposeObservable.notifyObservers(undefined);\n    this.onDisposeObservable.clear();\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.requestFile = function (scene, url, onSuccess, onProgress, useArrayBuffer, onError) {\n    var _this = this;\n\n    this._progressCallback = onProgress;\n\n    if (useArrayBuffer) {\n      if (this.useRangeRequests) {\n        if (this.validate) {\n          Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\n        }\n\n        var fileRequest_1 = {\n          abort: function abort() {},\n          onCompleteObservable: new Observable()\n        };\n        var dataBuffer = {\n          readAsync: function readAsync(byteOffset, byteLength) {\n            return new Promise(function (resolve, reject) {\n              _this._requestFile(url, scene, function (data) {\n                resolve(new Uint8Array(data));\n              }, true, function (error) {\n                reject(error);\n              }, function (webRequest) {\n                webRequest.setRequestHeader(\"Range\", \"bytes=\" + byteOffset + \"-\" + (byteOffset + byteLength - 1));\n              });\n            });\n          },\n          byteLength: 0\n        };\n\n        this._unpackBinaryAsync(new DataReader(dataBuffer)).then(function (loaderData) {\n          fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);\n          onSuccess(loaderData);\n        }, onError);\n\n        return fileRequest_1;\n      }\n\n      return this._requestFile(url, scene, function (data, request) {\n        var arrayBuffer = data;\n\n        _this._unpackBinaryAsync(new DataReader({\n          readAsync: function readAsync(byteOffset, byteLength) {\n            return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\n          },\n          byteLength: arrayBuffer.byteLength\n        })).then(function (loaderData) {\n          onSuccess(loaderData, request);\n        }, onError);\n      }, true, onError);\n    }\n\n    return this._requestFile(url, scene, function (data, request) {\n      _this._validate(scene, data, Tools.GetFolderPath(url), Tools.GetFilename(url));\n\n      onSuccess({\n        json: _this._parseJson(data)\n      }, request);\n    }, useArrayBuffer, onError);\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.readFile = function (scene, file, onSuccess, onProgress, useArrayBuffer, onError) {\n    var _this = this;\n\n    return scene._readFile(file, function (data) {\n      _this._validate(scene, data, \"file:\", file.name);\n\n      if (useArrayBuffer) {\n        var arrayBuffer_1 = data;\n\n        _this._unpackBinaryAsync(new DataReader({\n          readAsync: function readAsync(byteOffset, byteLength) {\n            return Promise.resolve(new Uint8Array(arrayBuffer_1, byteOffset, byteLength));\n          },\n          byteLength: arrayBuffer_1.byteLength\n        })).then(onSuccess, onError);\n      } else {\n        onSuccess({\n          json: _this._parseJson(data)\n        });\n      }\n    }, onProgress, useArrayBuffer, onError);\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this.onParsedObservable.notifyObservers(data);\n\n      _this.onParsedObservable.clear();\n\n      _this._log(\"Loading \" + (fileName || \"\"));\n\n      _this._loader = _this._getLoader(data);\n      return _this._loader.importMeshAsync(meshesNames, scene, false, data, rootUrl, onProgress, fileName);\n    });\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this.onParsedObservable.notifyObservers(data);\n\n      _this.onParsedObservable.clear();\n\n      _this._log(\"Loading \" + (fileName || \"\"));\n\n      _this._loader = _this._getLoader(data);\n      return _this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\n    });\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.loadAssetContainerAsync = function (scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      _this.onParsedObservable.notifyObservers(data);\n\n      _this.onParsedObservable.clear();\n\n      _this._log(\"Loading \" + (fileName || \"\"));\n\n      _this._loader = _this._getLoader(data); // Prepare the asset container.\n\n      var container = new AssetContainer(scene); // Get materials/textures when loading to add to container\n\n      var materials = [];\n\n      _this.onMaterialLoadedObservable.add(function (material) {\n        materials.push(material);\n        material.onDisposeObservable.addOnce(function () {\n          var index = container.materials.indexOf(material);\n\n          if (index > -1) {\n            container.materials.splice(index, 1);\n          }\n\n          index = materials.indexOf(material);\n\n          if (index > -1) {\n            materials.splice(index, 1);\n          }\n        });\n      });\n\n      var textures = [];\n\n      _this.onTextureLoadedObservable.add(function (texture) {\n        textures.push(texture);\n        texture.onDisposeObservable.addOnce(function () {\n          var index = container.textures.indexOf(texture);\n\n          if (index > -1) {\n            container.textures.splice(index, 1);\n          }\n\n          index = textures.indexOf(texture);\n\n          if (index > -1) {\n            textures.splice(index, 1);\n          }\n        });\n      });\n\n      var cameras = [];\n\n      _this.onCameraLoadedObservable.add(function (camera) {\n        cameras.push(camera);\n      });\n\n      return _this._loader.importMeshAsync(null, scene, true, data, rootUrl, onProgress, fileName).then(function (result) {\n        Array.prototype.push.apply(container.geometries, result.geometries);\n        Array.prototype.push.apply(container.meshes, result.meshes);\n        Array.prototype.push.apply(container.particleSystems, result.particleSystems);\n        Array.prototype.push.apply(container.skeletons, result.skeletons);\n        Array.prototype.push.apply(container.animationGroups, result.animationGroups);\n        Array.prototype.push.apply(container.materials, materials);\n        Array.prototype.push.apply(container.textures, textures);\n        Array.prototype.push.apply(container.lights, result.lights);\n        Array.prototype.push.apply(container.transformNodes, result.transformNodes);\n        Array.prototype.push.apply(container.cameras, cameras);\n        return container;\n      });\n    });\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.canDirectLoad = function (data) {\n    return data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1 || StringTools.StartsWith(data, \"data:base64,\" + GLTFFileLoader.magicBase64Encoded) || StringTools.StartsWith(data, \"data:application/octet-stream;base64,\" + GLTFFileLoader.magicBase64Encoded) || StringTools.StartsWith(data, \"data:model/gltf-binary;base64,\" + GLTFFileLoader.magicBase64Encoded);\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.directLoad = function (scene, data) {\n    if (StringTools.StartsWith(data, \"base64,\" + GLTFFileLoader.magicBase64Encoded) || StringTools.StartsWith(data, \"application/octet-stream;base64,\" + GLTFFileLoader.magicBase64Encoded) || StringTools.StartsWith(data, \"model/gltf-binary;base64,\" + GLTFFileLoader.magicBase64Encoded)) {\n      var arrayBuffer_2 = Tools.DecodeBase64(data);\n\n      this._validate(scene, arrayBuffer_2);\n\n      return this._unpackBinaryAsync(new DataReader({\n        readAsync: function readAsync(byteOffset, byteLength) {\n          return Promise.resolve(new Uint8Array(arrayBuffer_2, byteOffset, byteLength));\n        },\n        byteLength: arrayBuffer_2.byteLength\n      }));\n    }\n\n    this._validate(scene, data);\n\n    return Promise.resolve({\n      json: this._parseJson(data)\n    });\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype.createPlugin = function () {\n    return new GLTFFileLoader();\n  };\n\n  Object.defineProperty(GLTFFileLoader.prototype, \"loaderState\", {\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\n    get: function get() {\n      return this._loader ? this._loader.state : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns a promise that resolves when the asset is completely loaded.\r\n   * @returns a promise that resolves when the asset is completely loaded.\r\n   */\n\n  GLTFFileLoader.prototype.whenCompleteAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.onCompleteObservable.addOnce(function () {\n        resolve();\n      });\n\n      _this.onErrorObservable.addOnce(function (reason) {\n        reject(reason);\n      });\n    });\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype._loadFile = function (url, scene, onSuccess, useArrayBuffer, onError) {\n    var _this = this;\n\n    var request = scene._loadFile(url, onSuccess, function (event) {\n      _this._onProgress(event, request);\n    }, undefined, useArrayBuffer, onError);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._requests.splice(_this._requests.indexOf(request), 1);\n    });\n\n    this._requests.push(request);\n\n    return request;\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype._requestFile = function (url, scene, onSuccess, useArrayBuffer, onError, onOpened) {\n    var _this = this;\n\n    var request = scene._requestFile(url, onSuccess, function (event) {\n      _this._onProgress(event, request);\n    }, undefined, useArrayBuffer, onError, onOpened);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._requests.splice(_this._requests.indexOf(request), 1);\n    });\n\n    this._requests.push(request);\n\n    return request;\n  };\n\n  GLTFFileLoader.prototype._onProgress = function (event, request) {\n    if (!this._progressCallback) {\n      return;\n    }\n\n    request._lengthComputable = event.lengthComputable;\n    request._loaded = event.loaded;\n    request._total = event.total;\n    var lengthComputable = true;\n    var loaded = 0;\n    var total = 0;\n\n    for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {\n      var request_1 = _a[_i];\n\n      if (request_1._lengthComputable === undefined || request_1._loaded === undefined || request_1._total === undefined) {\n        return;\n      }\n\n      lengthComputable = lengthComputable && request_1._lengthComputable;\n      loaded += request_1._loaded;\n      total += request_1._total;\n    }\n\n    this._progressCallback({\n      lengthComputable: lengthComputable,\n      loaded: loaded,\n      total: lengthComputable ? total : 0\n    });\n  };\n\n  GLTFFileLoader.prototype._validate = function (scene, data, rootUrl, fileName) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (fileName === void 0) {\n      fileName = \"\";\n    }\n\n    if (!this.validate) {\n      return;\n    }\n\n    this._startPerformanceCounter(\"Validate JSON\");\n\n    GLTFValidation.ValidateAsync(data, rootUrl, fileName, function (uri) {\n      return _this.preprocessUrlAsync(rootUrl + uri).then(function (url) {\n        return scene._loadFileAsync(url, undefined, true, true);\n      });\n    }).then(function (result) {\n      _this._endPerformanceCounter(\"Validate JSON\");\n\n      _this.onValidatedObservable.notifyObservers(result);\n\n      _this.onValidatedObservable.clear();\n    }, function (reason) {\n      _this._endPerformanceCounter(\"Validate JSON\");\n\n      Tools.Warn(\"Failed to validate: \" + reason.message);\n\n      _this.onValidatedObservable.clear();\n    });\n  };\n\n  GLTFFileLoader.prototype._getLoader = function (loaderData) {\n    var asset = loaderData.json.asset || {};\n\n    this._log(\"Asset version: \" + asset.version);\n\n    asset.minVersion && this._log(\"Asset minimum version: \" + asset.minVersion);\n    asset.generator && this._log(\"Asset generator: \" + asset.generator);\n\n    var version = GLTFFileLoader._parseVersion(asset.version);\n\n    if (!version) {\n      throw new Error(\"Invalid version: \" + asset.version);\n    }\n\n    if (asset.minVersion !== undefined) {\n      var minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\n\n      if (!minVersion) {\n        throw new Error(\"Invalid minimum version: \" + asset.minVersion);\n      }\n\n      if (GLTFFileLoader._compareVersion(minVersion, {\n        major: 2,\n        minor: 0\n      }) > 0) {\n        throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\n      }\n    }\n\n    var createLoaders = {\n      1: GLTFFileLoader._CreateGLTF1Loader,\n      2: GLTFFileLoader._CreateGLTF2Loader\n    };\n    var createLoader = createLoaders[version.major];\n\n    if (!createLoader) {\n      throw new Error(\"Unsupported version: \" + asset.version);\n    }\n\n    return createLoader(this);\n  };\n\n  GLTFFileLoader.prototype._parseJson = function (json) {\n    this._startPerformanceCounter(\"Parse JSON\");\n\n    this._log(\"JSON length: \" + json.length);\n\n    var parsed = JSON.parse(json);\n\n    this._endPerformanceCounter(\"Parse JSON\");\n\n    return parsed;\n  };\n\n  GLTFFileLoader.prototype._unpackBinaryAsync = function (dataReader) {\n    var _this = this;\n\n    this._startPerformanceCounter(\"Unpack Binary\"); // Read magic + version + length + json length + json format\n\n\n    return dataReader.loadAsync(20).then(function () {\n      var Binary = {\n        Magic: 0x46546C67\n      };\n      var magic = dataReader.readUint32();\n\n      if (magic !== Binary.Magic) {\n        throw new Error(\"Unexpected magic: \" + magic);\n      }\n\n      var version = dataReader.readUint32();\n\n      if (_this.loggingEnabled) {\n        _this._log(\"Binary version: \" + version);\n      }\n\n      var length = dataReader.readUint32();\n\n      if (dataReader.buffer.byteLength !== 0 && length !== dataReader.buffer.byteLength) {\n        throw new Error(\"Length in header does not match actual data length: \" + length + \" != \" + dataReader.buffer.byteLength);\n      }\n\n      var unpacked;\n\n      switch (version) {\n        case 1:\n          {\n            unpacked = _this._unpackBinaryV1Async(dataReader, length);\n            break;\n          }\n\n        case 2:\n          {\n            unpacked = _this._unpackBinaryV2Async(dataReader, length);\n            break;\n          }\n\n        default:\n          {\n            throw new Error(\"Unsupported version: \" + version);\n          }\n      }\n\n      _this._endPerformanceCounter(\"Unpack Binary\");\n\n      return unpacked;\n    });\n  };\n\n  GLTFFileLoader.prototype._unpackBinaryV1Async = function (dataReader, length) {\n    var ContentFormat = {\n      JSON: 0\n    };\n    var contentLength = dataReader.readUint32();\n    var contentFormat = dataReader.readUint32();\n\n    if (contentFormat !== ContentFormat.JSON) {\n      throw new Error(\"Unexpected content format: \" + contentFormat);\n    }\n\n    var bodyLength = length - dataReader.byteOffset;\n    var data = {\n      json: this._parseJson(dataReader.readString(contentLength)),\n      bin: null\n    };\n\n    if (bodyLength !== 0) {\n      var startByteOffset_1 = dataReader.byteOffset;\n      data.bin = {\n        readAsync: function readAsync(byteOffset, byteLength) {\n          return dataReader.buffer.readAsync(startByteOffset_1 + byteOffset, byteLength);\n        },\n        byteLength: bodyLength\n      };\n    }\n\n    return Promise.resolve(data);\n  };\n\n  GLTFFileLoader.prototype._unpackBinaryV2Async = function (dataReader, length) {\n    var _this = this;\n\n    var ChunkFormat = {\n      JSON: 0x4E4F534A,\n      BIN: 0x004E4942\n    }; // Read the JSON chunk header.\n\n    var chunkLength = dataReader.readUint32();\n    var chunkFormat = dataReader.readUint32();\n\n    if (chunkFormat !== ChunkFormat.JSON) {\n      throw new Error(\"First chunk format is not JSON\");\n    } // Bail if there are no other chunks.\n\n\n    if (dataReader.byteOffset + chunkLength === length) {\n      return dataReader.loadAsync(chunkLength).then(function () {\n        return {\n          json: _this._parseJson(dataReader.readString(chunkLength)),\n          bin: null\n        };\n      });\n    } // Read the JSON chunk and the length and type of the next chunk.\n\n\n    return dataReader.loadAsync(chunkLength + 8).then(function () {\n      var data = {\n        json: _this._parseJson(dataReader.readString(chunkLength)),\n        bin: null\n      };\n\n      var readAsync = function readAsync() {\n        var chunkLength = dataReader.readUint32();\n        var chunkFormat = dataReader.readUint32();\n\n        switch (chunkFormat) {\n          case ChunkFormat.JSON:\n            {\n              throw new Error(\"Unexpected JSON chunk\");\n            }\n\n          case ChunkFormat.BIN:\n            {\n              var startByteOffset_2 = dataReader.byteOffset;\n              data.bin = {\n                readAsync: function readAsync(byteOffset, byteLength) {\n                  return dataReader.buffer.readAsync(startByteOffset_2 + byteOffset, byteLength);\n                },\n                byteLength: chunkLength\n              };\n              dataReader.skipBytes(chunkLength);\n              break;\n            }\n\n          default:\n            {\n              // ignore unrecognized chunkFormat\n              dataReader.skipBytes(chunkLength);\n              break;\n            }\n        }\n\n        if (dataReader.byteOffset !== length) {\n          return dataReader.loadAsync(8).then(readAsync);\n        }\n\n        return Promise.resolve(data);\n      };\n\n      return readAsync();\n    });\n  };\n\n  GLTFFileLoader._parseVersion = function (version) {\n    if (version === \"1.0\" || version === \"1.0.1\") {\n      return {\n        major: 1,\n        minor: 0\n      };\n    }\n\n    var match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\n\n    if (!match) {\n      return null;\n    }\n\n    return {\n      major: parseInt(match[1]),\n      minor: parseInt(match[2])\n    };\n  };\n\n  GLTFFileLoader._compareVersion = function (a, b) {\n    if (a.major > b.major) {\n      return 1;\n    }\n\n    if (a.major < b.major) {\n      return -1;\n    }\n\n    if (a.minor > b.minor) {\n      return 1;\n    }\n\n    if (a.minor < b.minor) {\n      return -1;\n    }\n\n    return 0;\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype._logOpen = function (message) {\n    this._log(message);\n\n    this._logIndentLevel++;\n  };\n  /** @hidden */\n\n\n  GLTFFileLoader.prototype._logClose = function () {\n    --this._logIndentLevel;\n  };\n\n  GLTFFileLoader.prototype._logEnabled = function (message) {\n    var spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);\n\n    Logger.Log(\"\" + spaces + message);\n  };\n\n  GLTFFileLoader.prototype._logDisabled = function (message) {};\n\n  GLTFFileLoader.prototype._startPerformanceCounterEnabled = function (counterName) {\n    Tools.StartPerformanceCounter(counterName);\n  };\n\n  GLTFFileLoader.prototype._startPerformanceCounterDisabled = function (counterName) {};\n\n  GLTFFileLoader.prototype._endPerformanceCounterEnabled = function (counterName) {\n    Tools.EndPerformanceCounter(counterName);\n  };\n\n  GLTFFileLoader.prototype._endPerformanceCounterDisabled = function (counterName) {}; // ----------\n  // V1 options\n  // ----------\n\n  /**\r\n   * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n   * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n   * Defaults to true.\r\n   * @hidden\r\n   */\n\n\n  GLTFFileLoader.IncrementalLoading = true;\n  /**\r\n   * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n   * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n   * @hidden\r\n   */\n\n  GLTFFileLoader.HomogeneousCoordinates = false;\n  GLTFFileLoader.magicBase64Encoded = \"Z2xURg\"; // \"glTF\" base64 encoded (without the quotes!)\n\n  GLTFFileLoader._logSpaces = \"                                \";\n  return GLTFFileLoader;\n}();\n\nexport { GLTFFileLoader };\n\nif (SceneLoader) {\n  SceneLoader.RegisterPlugin(new GLTFFileLoader());\n}","map":null,"metadata":{},"sourceType":"module"}