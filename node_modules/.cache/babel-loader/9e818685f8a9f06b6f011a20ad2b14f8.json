{"ast":null,"code":"import { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\nimport { AbstractActionManager } from \"../Actions/abstractActionManager\";\nimport { Vector2, Matrix } from \"../Maths/math.vector\";\nimport { ActionEvent } from \"../Actions/actionEvent\";\nimport { Tools } from \"../Misc/tools\";\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents\";\n/** @hidden */\n\nvar _ClickInfo =\n/** @class */\nfunction () {\n  function _ClickInfo() {\n    this._singleClick = false;\n    this._doubleClick = false;\n    this._hasSwiped = false;\n    this._ignore = false;\n  }\n\n  Object.defineProperty(_ClickInfo.prototype, \"singleClick\", {\n    get: function get() {\n      return this._singleClick;\n    },\n    set: function set(b) {\n      this._singleClick = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"doubleClick\", {\n    get: function get() {\n      return this._doubleClick;\n    },\n    set: function set(b) {\n      this._doubleClick = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"hasSwiped\", {\n    get: function get() {\n      return this._hasSwiped;\n    },\n    set: function set(b) {\n      this._hasSwiped = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"ignore\", {\n    get: function get() {\n      return this._ignore;\n    },\n    set: function set(b) {\n      this._ignore = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return _ClickInfo;\n}();\n/**\r\n * Class used to manage all inputs for the scene.\r\n */\n\n\nvar InputManager =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new InputManager\r\n   * @param scene defines the hosting scene\r\n   */\n  function InputManager(scene) {\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\n    this._alreadyAttached = false; // Pointers\n\n    this._wheelEventName = \"\";\n    this._meshPickProceed = false;\n    this._currentPickResult = null;\n    this._previousPickResult = null;\n    this._totalPointersPressed = 0;\n    this._doubleClickOccured = false;\n    this._pointerX = 0;\n    this._pointerY = 0;\n    this._startingPointerPosition = new Vector2(0, 0);\n    this._previousStartingPointerPosition = new Vector2(0, 0);\n    this._startingPointerTime = 0;\n    this._previousStartingPointerTime = 0;\n    this._pointerCaptures = {};\n    this._meshUnderPointerId = [];\n    this._keyboardIsAttached = false;\n    this._scene = scene;\n  }\n\n  Object.defineProperty(InputManager.prototype, \"meshUnderPointer\", {\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     */\n    get: function get() {\n      return this._pointerOverMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\r\n   * @param pointerId the pointer id to use\r\n   * @returns The mesh under this pointer id or null if not found\r\n   */\n\n  InputManager.prototype.getMeshUnderPointerByPointerId = function (pointerId) {\n    return this._meshUnderPointerId[pointerId];\n  };\n\n  Object.defineProperty(InputManager.prototype, \"unTranslatedPointer\", {\n    /**\r\n     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\r\n     */\n    get: function get() {\n      return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputManager.prototype, \"pointerX\", {\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     */\n    get: function get() {\n      return this._pointerX;\n    },\n    set: function set(value) {\n      this._pointerX = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputManager.prototype, \"pointerY\", {\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     */\n    get: function get() {\n      return this._pointerY;\n    },\n    set: function set(value) {\n      this._pointerY = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InputManager.prototype._updatePointerPosition = function (evt) {\n    var canvasRect = this._scene.getEngine().getInputElementClientRect();\n\n    if (!canvasRect) {\n      return;\n    }\n\n    this._pointerX = evt.clientX - canvasRect.left;\n    this._pointerY = evt.clientY - canvasRect.top;\n    this._unTranslatedPointerX = this._pointerX;\n    this._unTranslatedPointerY = this._pointerY;\n  };\n\n  InputManager.prototype._processPointerMove = function (pickResult, evt) {\n    var scene = this._scene;\n    var engine = scene.getEngine();\n    var canvas = engine.getInputElement();\n\n    if (!canvas) {\n      return;\n    }\n\n    canvas.tabIndex = engine.canvasTabIndex; // Restore pointer\n\n    if (!scene.doNotHandleCursors) {\n      canvas.style.cursor = scene.defaultCursor;\n    }\n\n    var isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;\n\n    if (isMeshPicked) {\n      scene.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId);\n\n      if (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers) {\n        if (!scene.doNotHandleCursors) {\n          if (this._pointerOverMesh.actionManager.hoverCursor) {\n            canvas.style.cursor = this._pointerOverMesh.actionManager.hoverCursor;\n          } else {\n            canvas.style.cursor = scene.hoverCursor;\n          }\n        }\n      }\n    } else {\n      scene.setPointerOverMesh(null, evt.pointerId);\n    }\n\n    for (var _i = 0, _a = scene._pointerMoveStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\n    }\n\n    if (pickResult) {\n      var type = evt.type === this._wheelEventName ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\n\n      if (scene.onPointerMove) {\n        scene.onPointerMove(evt, pickResult, type);\n      }\n\n      if (scene.onPointerObservable.hasObservers()) {\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n  }; // Pointers handling\n\n\n  InputManager.prototype._setRayOnPointerInfo = function (pointerInfo) {\n    var scene = this._scene;\n\n    if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {\n      if (!pointerInfo.pickInfo.ray) {\n        pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);\n      }\n    }\n  };\n\n  InputManager.prototype._checkPrePointerObservable = function (pickResult, evt, type) {\n    var scene = this._scene;\n    var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n\n    if (pickResult) {\n      pi.ray = pickResult.ray;\n    }\n\n    scene.onPrePointerObservable.notifyObservers(pi, type);\n\n    if (pi.skipOnPointerObservable) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Use this method to simulate a pointer move on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   */\n\n\n  InputManager.prototype.simulatePointerMove = function (pickResult, pointerEventInit) {\n    var evt = new PointerEvent(\"pointermove\", pointerEventInit);\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\n      return;\n    }\n\n    this._processPointerMove(pickResult, evt);\n  };\n  /**\r\n   * Use this method to simulate a pointer down on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   */\n\n\n  InputManager.prototype.simulatePointerDown = function (pickResult, pointerEventInit) {\n    var evt = new PointerEvent(\"pointerdown\", pointerEventInit);\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\n      return;\n    }\n\n    this._processPointerDown(pickResult, evt);\n  };\n\n  InputManager.prototype._processPointerDown = function (pickResult, evt) {\n    var _this = this;\n\n    var scene = this._scene;\n\n    if (pickResult && pickResult.hit && pickResult.pickedMesh) {\n      this._pickedDownMesh = pickResult.pickedMesh;\n\n      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n\n      if (actionManager) {\n        if (actionManager.hasPickTriggers) {\n          actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n\n          switch (evt.button) {\n            case 0:\n              actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n\n            case 1:\n              actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n\n            case 2:\n              actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n          }\n        }\n\n        if (actionManager.hasSpecificTrigger(8)) {\n          window.setTimeout(function () {\n            var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, function (mesh) {\n              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh == _this._pickedDownMesh;\n            }, false, scene.cameraToUseForPointers);\n\n            if (pickResult && pickResult.hit && pickResult.pickedMesh && actionManager) {\n              if (_this._totalPointersPressed !== 0 && Date.now() - _this._startingPointerTime > InputManager.LongPressDelay && !_this._isPointerSwiping()) {\n                _this._startingPointerTime = 0;\n                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              }\n            }\n          }, InputManager.LongPressDelay);\n        }\n      }\n    } else {\n      for (var _i = 0, _a = scene._pointerDownStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\n      }\n    }\n\n    if (pickResult) {\n      var type = PointerEventTypes.POINTERDOWN;\n\n      if (scene.onPointerDown) {\n        scene.onPointerDown(evt, pickResult, type);\n      }\n\n      if (scene.onPointerObservable.hasObservers()) {\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  InputManager.prototype._isPointerSwiping = function () {\n    return Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\n  };\n  /**\r\n   * Use this method to simulate a pointer up on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\r\n   */\n\n\n  InputManager.prototype.simulatePointerUp = function (pickResult, pointerEventInit, doubleTap) {\n    var evt = new PointerEvent(\"pointerup\", pointerEventInit);\n    var clickInfo = new _ClickInfo();\n\n    if (doubleTap) {\n      clickInfo.doubleClick = true;\n    } else {\n      clickInfo.singleClick = true;\n    }\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\n      return;\n    }\n\n    this._processPointerUp(pickResult, evt, clickInfo);\n  };\n\n  InputManager.prototype._processPointerUp = function (pickResult, evt, clickInfo) {\n    var scene = this._scene;\n\n    if (pickResult && pickResult && pickResult.pickedMesh) {\n      this._pickedUpMesh = pickResult.pickedMesh;\n\n      if (this._pickedDownMesh === this._pickedUpMesh) {\n        if (scene.onPointerPick) {\n          scene.onPointerPick(evt, pickResult);\n        }\n\n        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {\n          var type_1 = PointerEventTypes.POINTERPICK;\n          var pi = new PointerInfo(type_1, evt, pickResult);\n\n          this._setRayOnPointerInfo(pi);\n\n          scene.onPointerObservable.notifyObservers(pi, type_1);\n        }\n      }\n\n      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n\n      if (actionManager && !clickInfo.ignore) {\n        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n\n        if (!clickInfo.hasSwiped && clickInfo.singleClick) {\n          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n        }\n\n        var doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);\n\n        if (clickInfo.doubleClick && doubleClickActionManager) {\n          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n        }\n      }\n    } else {\n      if (!clickInfo.ignore) {\n        for (var _i = 0, _a = scene._pointerUpStage; _i < _a.length; _i++) {\n          var step = _a[_i];\n          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\n        }\n      }\n    }\n\n    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\n      var pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);\n\n      if (pickedDownActionManager) {\n        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));\n      }\n    }\n\n    var type = 0;\n\n    if (scene.onPointerObservable.hasObservers()) {\n      if (!clickInfo.ignore && !clickInfo.hasSwiped) {\n        if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n          type = PointerEventTypes.POINTERTAP;\n        } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n          type = PointerEventTypes.POINTERDOUBLETAP;\n        }\n\n        if (type) {\n          var pi = new PointerInfo(type, evt, pickResult);\n\n          this._setRayOnPointerInfo(pi);\n\n          scene.onPointerObservable.notifyObservers(pi, type);\n        }\n      }\n\n      if (!clickInfo.ignore) {\n        type = PointerEventTypes.POINTERUP;\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n\n    if (scene.onPointerUp && !clickInfo.ignore) {\n      scene.onPointerUp(evt, pickResult, type);\n    }\n  };\n  /**\r\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\r\n   * @returns true if the pointer was captured\r\n   */\n\n\n  InputManager.prototype.isPointerCaptured = function (pointerId) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    }\n\n    return this._pointerCaptures[pointerId];\n  };\n  /**\r\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n   * @param attachUp defines if you want to attach events to pointerup\r\n   * @param attachDown defines if you want to attach events to pointerdown\r\n   * @param attachMove defines if you want to attach events to pointermove\r\n   * @param elementToAttachTo defines the target DOM element to attach to (will use the canvas by default)\r\n   */\n\n\n  InputManager.prototype.attachControl = function (attachUp, attachDown, attachMove, elementToAttachTo) {\n    var _this = this;\n\n    if (attachUp === void 0) {\n      attachUp = true;\n    }\n\n    if (attachDown === void 0) {\n      attachDown = true;\n    }\n\n    if (attachMove === void 0) {\n      attachMove = true;\n    }\n\n    if (elementToAttachTo === void 0) {\n      elementToAttachTo = null;\n    }\n\n    var scene = this._scene;\n\n    if (!elementToAttachTo) {\n      elementToAttachTo = scene.getEngine().getInputElement();\n    }\n\n    if (!elementToAttachTo) {\n      return;\n    }\n\n    if (this._alreadyAttached) {\n      this.detachControl();\n    }\n\n    this._alreadyAttachedTo = elementToAttachTo;\n    var engine = scene.getEngine();\n\n    this._initActionManager = function (act, clickInfo) {\n      if (!_this._meshPickProceed) {\n        var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\n        _this._currentPickResult = pickResult;\n\n        if (pickResult) {\n          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\n        }\n\n        _this._meshPickProceed = true;\n      }\n\n      return act;\n    };\n\n    this._delayedSimpleClick = function (btn, clickInfo, cb) {\n      // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\n      if (Date.now() - _this._previousStartingPointerTime > InputManager.DoubleClickDelay && !_this._doubleClickOccured || btn !== _this._previousButtonPressed) {\n        _this._doubleClickOccured = false;\n        clickInfo.singleClick = true;\n        clickInfo.ignore = false;\n        cb(clickInfo, _this._currentPickResult);\n      }\n    };\n\n    this._initClickEvent = function (obs1, obs2, evt, cb) {\n      var clickInfo = new _ClickInfo();\n      _this._currentPickResult = null;\n      var act = null;\n      var checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n      if (!checkPicking && AbstractActionManager) {\n        act = _this._initActionManager(act, clickInfo);\n\n        if (act) {\n          checkPicking = act.hasPickTriggers;\n        }\n      }\n\n      var needToIgnoreNext = false;\n\n      if (checkPicking) {\n        var btn = evt.button;\n        clickInfo.hasSwiped = _this._isPointerSwiping();\n\n        if (!clickInfo.hasSwiped) {\n          var checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\n\n          if (!checkSingleClickImmediately) {\n            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {\n              act = _this._initActionManager(act, clickInfo);\n\n              if (act) {\n                checkSingleClickImmediately = !act.hasSpecificTrigger(6);\n              }\n            }\n          }\n\n          if (checkSingleClickImmediately) {\n            // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\n            if (Date.now() - _this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== _this._previousButtonPressed) {\n              clickInfo.singleClick = true;\n              cb(clickInfo, _this._currentPickResult);\n              needToIgnoreNext = true;\n            }\n          } // at least one double click is required to be check and exclusive double click is enabled\n          else {\n            // wait that no double click has been raised during the double click delay\n            _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n            _this._delayedSimpleClickTimeout = window.setTimeout(_this._delayedSimpleClick.bind(_this, btn, clickInfo, cb), InputManager.DoubleClickDelay);\n          }\n\n          var checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {\n            act = _this._initActionManager(act, clickInfo);\n\n            if (act) {\n              checkDoubleClick = act.hasSpecificTrigger(6);\n            }\n          }\n\n          if (checkDoubleClick) {\n            // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\n            if (btn === _this._previousButtonPressed && Date.now() - _this._previousStartingPointerTime < InputManager.DoubleClickDelay && !_this._doubleClickOccured) {\n              // pointer has not moved for 2 clicks, it's a double click\n              if (!clickInfo.hasSwiped && !_this._isPointerSwiping()) {\n                _this._previousStartingPointerTime = 0;\n                _this._doubleClickOccured = true;\n                clickInfo.doubleClick = true;\n                clickInfo.ignore = false;\n\n                if (InputManager.ExclusiveDoubleClickMode && _this._previousDelayedSimpleClickTimeout) {\n                  clearTimeout(_this._previousDelayedSimpleClickTimeout);\n                }\n\n                _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                cb(clickInfo, _this._currentPickResult);\n              } // if the two successive clicks are too far, it's just two simple clicks\n              else {\n                _this._doubleClickOccured = false;\n                _this._previousStartingPointerTime = _this._startingPointerTime;\n                _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;\n                _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;\n                _this._previousButtonPressed = btn;\n\n                if (InputManager.ExclusiveDoubleClickMode) {\n                  if (_this._previousDelayedSimpleClickTimeout) {\n                    clearTimeout(_this._previousDelayedSimpleClickTimeout);\n                  }\n\n                  _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                  cb(clickInfo, _this._previousPickResult);\n                } else {\n                  cb(clickInfo, _this._currentPickResult);\n                }\n              }\n\n              needToIgnoreNext = true;\n            } // just the first click of the double has been raised\n            else {\n              _this._doubleClickOccured = false;\n              _this._previousStartingPointerTime = _this._startingPointerTime;\n              _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;\n              _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;\n              _this._previousButtonPressed = btn;\n            }\n          }\n        }\n      }\n\n      if (!needToIgnoreNext) {\n        cb(clickInfo, _this._currentPickResult);\n      }\n    };\n\n    this._onPointerMove = function (evt) {\n      // preserve compatibility with Safari when pointerId is not present\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt); // PreObservable support\n\n\n      if (_this._checkPrePointerObservable(null, evt, evt.type === _this._wheelEventName ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {\n        return;\n      }\n\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n\n      if (!scene.pointerMovePredicate) {\n        scene.pointerMovePredicate = function (mesh) {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() != null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      } // Meshes\n\n\n      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers);\n\n      _this._processPointerMove(pickResult, evt);\n    };\n\n    this._onPointerDown = function (evt) {\n      _this._totalPointersPressed++;\n      _this._pickedDownMesh = null;\n      _this._meshPickProceed = false; // preserve compatibility with Safari when pointerId is not present\n\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt);\n\n      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n\n      _this._startingPointerPosition.x = _this._pointerX;\n      _this._startingPointerPosition.y = _this._pointerY;\n      _this._startingPointerTime = Date.now(); // PreObservable support\n\n      if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\n        return;\n      }\n\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n\n      _this._pointerCaptures[evt.pointerId] = true;\n\n      if (!scene.pointerDownPredicate) {\n        scene.pointerDownPredicate = function (mesh) {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      } // Meshes\n\n\n      _this._pickedDownMesh = null;\n      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\n\n      _this._processPointerDown(pickResult, evt);\n    };\n\n    this._onPointerUp = function (evt) {\n      if (_this._totalPointersPressed === 0) {\n        // We are attaching the pointer up to windows because of a bug in FF\n        return; // So we need to test it the pointer down was pressed before.\n      }\n\n      _this._totalPointersPressed--;\n      _this._pickedUpMesh = null;\n      _this._meshPickProceed = false; // preserve compatibility with Safari when pointerId is not present\n\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt);\n\n      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n\n      _this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, function (clickInfo, pickResult) {\n        // PreObservable support\n        if (scene.onPrePointerObservable.hasObservers()) {\n          if (!clickInfo.ignore) {\n            if (!clickInfo.hasSwiped) {\n              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\n                  return;\n                }\n              }\n\n              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\n                  return;\n                }\n              }\n            }\n\n            if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\n              return;\n            }\n          }\n        }\n\n        if (!_this._pointerCaptures[evt.pointerId]) {\n          return;\n        }\n\n        _this._pointerCaptures[evt.pointerId] = false;\n\n        if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n          return;\n        }\n\n        if (!scene.pointerUpPredicate) {\n          scene.pointerUpPredicate = function (mesh) {\n            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n          };\n        } // Meshes\n\n\n        if (!_this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || scene.onPointerObservable.hasObservers())) {\n          _this._initActionManager(null, clickInfo);\n        }\n\n        if (!pickResult) {\n          pickResult = _this._currentPickResult;\n        }\n\n        _this._processPointerUp(pickResult, evt, clickInfo);\n\n        _this._previousPickResult = _this._currentPickResult;\n      });\n    };\n\n    this._onKeyDown = function (evt) {\n      var type = KeyboardEventTypes.KEYDOWN;\n\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n\n        if (pi.skipOnPointerObservable) {\n          return;\n        }\n      }\n\n      if (scene.onKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n\n    this._onKeyUp = function (evt) {\n      var type = KeyboardEventTypes.KEYUP;\n\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n\n        if (pi.skipOnPointerObservable) {\n          return;\n        }\n      }\n\n      if (scene.onKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n\n    var attachedFunction = function attachedFunction() {\n      if (!elementToAttachTo || _this._keyboardIsAttached) {\n        return;\n      }\n\n      elementToAttachTo.addEventListener(\"keydown\", _this._onKeyDown, false);\n      elementToAttachTo.addEventListener(\"keyup\", _this._onKeyUp, false);\n      _this._keyboardIsAttached = true;\n    }; // Keyboard events\n\n\n    this._onCanvasFocusObserver = engine.onCanvasFocusObservable.add(function () {\n      if (document.activeElement === elementToAttachTo) {\n        attachedFunction();\n      }\n\n      return attachedFunction;\n    }());\n    this._onCanvasBlurObserver = engine.onCanvasBlurObservable.add(function () {\n      if (!elementToAttachTo) {\n        return;\n      }\n\n      elementToAttachTo.removeEventListener(\"keydown\", _this._onKeyDown);\n      elementToAttachTo.removeEventListener(\"keyup\", _this._onKeyUp);\n      _this._keyboardIsAttached = false;\n    });\n    attachedFunction(); // Pointer events\n\n    var eventPrefix = Tools.GetPointerPrefix(engine);\n\n    if (attachMove) {\n      elementToAttachTo.addEventListener(eventPrefix + \"move\", this._onPointerMove, false); // Wheel\n\n      this._wheelEventName = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" // Modern browsers support \"wheel\"\n      : document.onmousewheel !== undefined ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n      : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\n      elementToAttachTo.addEventListener(this._wheelEventName, this._onPointerMove, false);\n    }\n\n    if (attachDown) {\n      elementToAttachTo.addEventListener(eventPrefix + \"down\", this._onPointerDown, false);\n    }\n\n    if (attachUp) {\n      var hostWindow = scene.getEngine().getHostWindow();\n\n      if (hostWindow) {\n        hostWindow.addEventListener(eventPrefix + \"up\", this._onPointerUp, false);\n      }\n    }\n\n    this._alreadyAttached = true;\n  };\n  /**\r\n   * Detaches all event handlers\r\n   */\n\n\n  InputManager.prototype.detachControl = function () {\n    var engine = this._scene.getEngine();\n\n    var eventPrefix = Tools.GetPointerPrefix(engine);\n\n    if (!this._alreadyAttachedTo) {\n      return;\n    }\n\n    if (!this._alreadyAttached) {\n      return;\n    } // Pointer\n\n\n    this._alreadyAttachedTo.removeEventListener(eventPrefix + \"move\", this._onPointerMove);\n\n    this._alreadyAttachedTo.removeEventListener(this._wheelEventName, this._onPointerMove);\n\n    this._alreadyAttachedTo.removeEventListener(eventPrefix + \"down\", this._onPointerDown);\n\n    window.removeEventListener(eventPrefix + \"up\", this._onPointerUp); // Blur / Focus\n\n    if (this._onCanvasBlurObserver) {\n      engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\n    }\n\n    if (this._onCanvasFocusObserver) {\n      engine.onCanvasFocusObservable.remove(this._onCanvasFocusObserver);\n    } // Keyboard\n\n\n    this._alreadyAttachedTo.removeEventListener(\"keydown\", this._onKeyDown);\n\n    this._alreadyAttachedTo.removeEventListener(\"keyup\", this._onKeyUp); // Cursor\n\n\n    if (!this._scene.doNotHandleCursors) {\n      this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\n    }\n\n    this._alreadyAttached = false;\n  };\n  /**\r\n   * Force the value of meshUnderPointer\r\n   * @param mesh defines the mesh to use\r\n   * @param pointerId optional pointer id when using more than one pointer. Defaults to 0\r\n   */\n\n\n  InputManager.prototype.setPointerOverMesh = function (mesh, pointerId) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    } // Sanity check\n\n\n    if (pointerId < 0) {\n      pointerId = 0;\n    }\n\n    if (this._meshUnderPointerId[pointerId] === mesh) {\n      return;\n    }\n\n    var underPointerMesh = this._meshUnderPointerId[pointerId];\n    var actionManager;\n\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(10);\n\n      if (actionManager) {\n        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, undefined, {\n          pointerId: pointerId\n        }));\n      }\n    }\n\n    this._meshUnderPointerId[pointerId] = mesh;\n    this._pointerOverMesh = mesh;\n    underPointerMesh = this._meshUnderPointerId[pointerId];\n\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(9);\n\n      if (actionManager) {\n        actionManager.processTrigger(9, ActionEvent.CreateNew(underPointerMesh, undefined, {\n          pointerId: pointerId\n        }));\n      }\n    }\n  };\n  /**\r\n   * Gets the mesh under the pointer\r\n   * @returns a Mesh or null if no mesh is under the pointer\r\n   */\n\n\n  InputManager.prototype.getPointerOverMesh = function () {\n    return this._pointerOverMesh;\n  };\n  /** The distance in pixel that you have to move to prevent some events */\n\n\n  InputManager.DragMovementThreshold = 10; // in pixels\n\n  /** Time in milliseconds to wait to raise long press events if button is still pressed */\n\n  InputManager.LongPressDelay = 500; // in milliseconds\n\n  /** Time in milliseconds with two consecutive clicks will be considered as a double click */\n\n  InputManager.DoubleClickDelay = 300; // in milliseconds\n\n  /** If you need to check double click without raising a single click at first click, enable this flag */\n\n  InputManager.ExclusiveDoubleClickMode = false;\n  return InputManager;\n}();\n\nexport { InputManager };","map":null,"metadata":{},"sourceType":"module"}