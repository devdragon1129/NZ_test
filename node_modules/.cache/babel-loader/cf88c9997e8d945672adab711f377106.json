{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\n\nVertexData.CreateLineSystem = function (options) {\n  var indices = [];\n  var positions = [];\n  var lines = options.lines;\n  var colors = options.colors;\n  var vertexColors = [];\n  var idx = 0;\n\n  for (var l = 0; l < lines.length; l++) {\n    var points = lines[l];\n\n    for (var index = 0; index < points.length; index++) {\n      positions.push(points[index].x, points[index].y, points[index].z);\n\n      if (colors) {\n        var color = colors[l];\n        vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\n      }\n\n      if (index > 0) {\n        indices.push(idx - 1);\n        indices.push(idx);\n      }\n\n      idx++;\n    }\n  }\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n\n  if (colors) {\n    vertexData.colors = vertexColors;\n  }\n\n  return vertexData;\n};\n\nVertexData.CreateDashedLines = function (options) {\n  var dashSize = options.dashSize || 3;\n  var gapSize = options.gapSize || 1;\n  var dashNb = options.dashNb || 200;\n  var points = options.points;\n  var positions = new Array();\n  var indices = new Array();\n  var curvect = Vector3.Zero();\n  var lg = 0;\n  var nb = 0;\n  var shft = 0;\n  var dashshft = 0;\n  var curshft = 0;\n  var idx = 0;\n  var i = 0;\n\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    lg += curvect.length();\n  }\n\n  shft = lg / dashNb;\n  dashshft = dashSize * shft / (dashSize + gapSize);\n\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    nb = Math.floor(curvect.length() / shft);\n    curvect.normalize();\n\n    for (var j = 0; j < nb; j++) {\n      curshft = shft * j;\n      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\n      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\n      indices.push(idx, idx + 1);\n      idx += 2;\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  return vertexData;\n};\n\nMesh.CreateLines = function (name, points, scene, updatable, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  if (updatable === void 0) {\n    updatable = false;\n  }\n\n  if (instance === void 0) {\n    instance = null;\n  }\n\n  var options = {\n    points: points,\n    updatable: updatable,\n    instance: instance\n  };\n  return LinesBuilder.CreateLines(name, options, scene);\n};\n\nMesh.CreateDashedLines = function (name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    points: points,\n    dashSize: dashSize,\n    gapSize: gapSize,\n    dashNb: dashNb,\n    updatable: updatable,\n    instance: instance\n  };\n  return LinesBuilder.CreateDashedLines(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar LinesBuilder =\n/** @class */\nfunction () {\n  function LinesBuilder() {}\n  /**\r\n   * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n   * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n   * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n   * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n   * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n   * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n   * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n   * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n   * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n   * @param name defines the name of the new line system\r\n   * @param options defines the options used to create the line system\r\n   * @param scene defines the hosting scene\r\n   * @returns a new line system mesh\r\n   */\n\n\n  LinesBuilder.CreateLineSystem = function (name, options, scene) {\n    var instance = options.instance;\n    var lines = options.lines;\n    var colors = options.colors;\n\n    if (instance) {\n      // lines update\n      var positions = instance.getVerticesData(VertexBuffer.PositionKind);\n      var vertexColor;\n      var lineColors;\n\n      if (colors) {\n        vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);\n      }\n\n      var i = 0;\n      var c = 0;\n\n      for (var l = 0; l < lines.length; l++) {\n        var points = lines[l];\n\n        for (var p = 0; p < points.length; p++) {\n          positions[i] = points[p].x;\n          positions[i + 1] = points[p].y;\n          positions[i + 2] = points[p].z;\n\n          if (colors && vertexColor) {\n            lineColors = colors[l];\n            vertexColor[c] = lineColors[p].r;\n            vertexColor[c + 1] = lineColors[p].g;\n            vertexColor[c + 2] = lineColors[p].b;\n            vertexColor[c + 3] = lineColors[p].a;\n            c += 4;\n          }\n\n          i += 3;\n        }\n      }\n\n      instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n\n      if (colors && vertexColor) {\n        instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\n      }\n\n      return instance;\n    } // line system creation\n\n\n    var useVertexColor = colors ? true : false;\n    var lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha);\n    var vertexData = VertexData.CreateLineSystem(options);\n    vertexData.applyToMesh(lineSystem, options.updatable);\n    return lineSystem;\n  };\n  /**\r\n   * Creates a line mesh\r\n   * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n   * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n   * * The parameter `points` is an array successive Vector3\r\n   * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n   * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n   * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n   * * When updating an instance, remember that only point positions can change, not the number of points\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n   * @param name defines the name of the new line system\r\n   * @param options defines the options used to create the line system\r\n   * @param scene defines the hosting scene\r\n   * @returns a new line mesh\r\n   */\n\n\n  LinesBuilder.CreateLines = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var colors = options.colors ? [options.colors] : null;\n    var lines = LinesBuilder.CreateLineSystem(name, {\n      lines: [options.points],\n      updatable: options.updatable,\n      instance: options.instance,\n      colors: colors,\n      useVertexAlpha: options.useVertexAlpha\n    }, scene);\n    return lines;\n  };\n  /**\r\n   * Creates a dashed line mesh\r\n   * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n   * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n   * * The parameter `points` is an array successive Vector3\r\n   * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n   * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n   * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n   * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n   * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n   * * When updating an instance, remember that only point positions can change, not the number of points\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the dashed line mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n   */\n\n\n  LinesBuilder.CreateDashedLines = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var points = options.points;\n    var instance = options.instance;\n    var gapSize = options.gapSize || 1;\n    var dashSize = options.dashSize || 3;\n\n    if (instance) {\n      //  dashed lines update\n      var positionFunction = function positionFunction(positions) {\n        var curvect = Vector3.Zero();\n        var nbSeg = positions.length / 6;\n        var lg = 0;\n        var nb = 0;\n        var shft = 0;\n        var dashshft = 0;\n        var curshft = 0;\n        var p = 0;\n        var i = 0;\n        var j = 0;\n\n        for (i = 0; i < points.length - 1; i++) {\n          points[i + 1].subtractToRef(points[i], curvect);\n          lg += curvect.length();\n        }\n\n        shft = lg / nbSeg;\n        var dashSize = instance._creationDataStorage.dashSize;\n        var gapSize = instance._creationDataStorage.gapSize;\n        dashshft = dashSize * shft / (dashSize + gapSize);\n\n        for (i = 0; i < points.length - 1; i++) {\n          points[i + 1].subtractToRef(points[i], curvect);\n          nb = Math.floor(curvect.length() / shft);\n          curvect.normalize();\n          j = 0;\n\n          while (j < nb && p < positions.length) {\n            curshft = shft * j;\n            positions[p] = points[i].x + curshft * curvect.x;\n            positions[p + 1] = points[i].y + curshft * curvect.y;\n            positions[p + 2] = points[i].z + curshft * curvect.z;\n            positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\n            positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\n            positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\n            p += 6;\n            j++;\n          }\n        }\n\n        while (p < positions.length) {\n          positions[p] = points[i].x;\n          positions[p + 1] = points[i].y;\n          positions[p + 2] = points[i].z;\n          p += 3;\n        }\n      };\n\n      instance.updateMeshPositions(positionFunction, false);\n      return instance;\n    } // dashed lines creation\n\n\n    var dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha);\n    var vertexData = VertexData.CreateDashedLines(options);\n    vertexData.applyToMesh(dashedLines, options.updatable);\n    dashedLines._creationDataStorage = new _CreationDataStorage();\n    dashedLines._creationDataStorage.dashSize = dashSize;\n    dashedLines._creationDataStorage.gapSize = gapSize;\n    return dashedLines;\n  };\n\n  return LinesBuilder;\n}();\n\nexport { LinesBuilder };","map":null,"metadata":{},"sourceType":"module"}