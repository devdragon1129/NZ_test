{"ast":null,"code":"import _regeneratorRuntime from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(getSceneByProjectId);\n\nimport { select, put, race, take } from 'redux-saga/effects';\nimport { loadManifestRequest, LOAD_MANIFEST_SUCCESS, LOAD_MANIFEST_FAILURE } from 'modules/project/actions';\nimport { getData as getPools } from 'modules/pool/selectors';\nimport { getData as getProjects } from 'modules/project/selectors';\nimport { getData as getScenes } from 'modules/scene/selectors';\nimport { SCRIPT_INSTANCE_NAME } from 'modules/project/export';\nimport { AssetParameterType, GROUND_CATEGORY } from 'modules/asset/types';\nimport { PreviewType } from 'modules/editor/types';\nimport { ComponentType } from './types';\n/**\n * Returns a new random position bound to y: 0\n * Can be overriden using the position argument\n */\n\nexport function getRandomPosition() {\n  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var x = Math.floor(Math.random() * 6) + 1;\n  var z = Math.floor(Math.random() * 6) + 1;\n  return _objectSpread({\n    x: x,\n    y: 0,\n    z: z\n  }, position);\n}\nexport function isWithinBounds(position, bounds) {\n  return position.x <= bounds.x && position.y <= bounds.y && position.z <= bounds.z && position.x >= 0 && position.y >= 0 && position.z >= 0;\n} // Note: if we start making extensive use of scene cloning we may replace this by a proper deep clone\n\nexport function cloneEntities(scene) {\n  return Object.keys(scene.entities).reduce(function (entities, entityId) {\n    return _objectSpread({}, entities, _defineProperty({}, entityId, _objectSpread({}, scene.entities[entityId], {\n      components: _toConsumableArray(scene.entities[entityId].components)\n    })));\n  }, {});\n}\nexport function filterEntitiesWithComponent(componentId, entities) {\n  var newEntities = {};\n\n  for (var id in entities) {\n    var entity = entities[id];\n    var index = entity.components.indexOf(componentId);\n\n    if (index === -1) {\n      newEntities[id] = entity;\n    }\n  }\n\n  return newEntities;\n}\nexport function getExceededMetrics(metrics, limits) {\n  var metricsExceeded = [];\n\n  for (var key in metrics) {\n    var metric = key;\n\n    if (metrics[metric] > limits[metric]) {\n      if (!metricsExceeded.includes(metric)) {\n        metricsExceeded.push(metric);\n      }\n    }\n  }\n\n  return metricsExceeded;\n}\nexport function snapToGrid(position) {\n  var grid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n  return {\n    x: Math.round(position.x / grid) * grid,\n    y: Math.round(position.y / grid) * grid,\n    z: Math.round(position.z / grid) * grid\n  };\n}\nexport function snapToBounds(position, bounds) {\n  return {\n    x: Math.max(Math.min(position.x, bounds.x), 0),\n    y: Math.max(Math.min(position.y, bounds.y), 0),\n    z: Math.max(Math.min(position.z, bounds.z), 0)\n  };\n}\nexport function areEqualMappings() {\n  var mappingsA = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var mappingsB = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  for (var _i = 0, _Object$keys = Object.keys(mappingsA); _i < _Object$keys.length; _i++) {\n    var keyA = _Object$keys[_i];\n\n    if (mappingsA[keyA] !== mappingsB[keyA]) {\n      return false;\n    }\n  }\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(mappingsB); _i2 < _Object$keys2.length; _i2++) {\n    var keyB = _Object$keys2[_i2];\n\n    if (mappingsA[keyB] !== mappingsB[keyB]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function getSceneByProjectId(projectId) {\n  var type,\n      projects,\n      pools,\n      scenes,\n      project,\n      scene,\n      result,\n      _args = arguments;\n  return _regeneratorRuntime.wrap(function getSceneByProjectId$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          type = _args.length > 1 && _args[1] !== undefined ? _args[1] : PreviewType.PROJECT;\n          _context.next = 3;\n          return select(getProjects);\n\n        case 3:\n          projects = _context.sent;\n          _context.next = 6;\n          return select(getPools);\n\n        case 6:\n          pools = _context.sent;\n          _context.next = 9;\n          return select(getScenes);\n\n        case 9:\n          scenes = _context.sent;\n          project = projects[projectId] || pools[projectId];\n          scene = project && scenes[project.sceneId];\n\n          if (scene) {\n            _context.next = 24;\n            break;\n          }\n\n          _context.next = 15;\n          return put(loadManifestRequest(projectId, type));\n\n        case 15:\n          _context.next = 17;\n          return race({\n            success: take(LOAD_MANIFEST_SUCCESS),\n            failure: take(LOAD_MANIFEST_FAILURE)\n          });\n\n        case 17:\n          result = _context.sent;\n\n          if (!result.success) {\n            _context.next = 22;\n            break;\n          }\n\n          scene = result.success.payload.manifest.scene;\n          _context.next = 24;\n          break;\n\n        case 22:\n          if (!result.failure) {\n            _context.next = 24;\n            break;\n          }\n\n          throw new Error(result.failure.payload.error);\n\n        case 24:\n          return _context.abrupt(\"return\", scene);\n\n        case 25:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\nexport function getEntityName(scene, entityComponents, assets) {\n  var takenNames = new Set();\n  var components = entityComponents.map(function (id) {\n    return scene.components[id];\n  });\n\n  for (var entityId in scene.entities) {\n    var entity = scene.entities[entityId];\n    takenNames.add(entity.name);\n  }\n\n  return getUniqueName(components, takenNames, assets);\n}\nexport function getUniqueName(components, takenNames, assets) {\n  var attempts = 1;\n  var rawName = 'entity';\n\n  var _iterator = _createForOfIteratorHelper(components),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var component = _step.value;\n\n      try {\n        if (component.type === ComponentType.GLTFShape) {\n          var asset = assets[component.data.assetId];\n\n          if (asset) {\n            var match = asset.name.match(/[A-Za-z]+/g);\n            rawName = convertToCamelCase(match ? match.join('_') : rawName);\n          }\n        } else if (component.type === ComponentType.NFTShape) {\n          rawName = 'nft';\n        }\n      } catch (e) {// swallow\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var name = rawName;\n\n  while (takenNames.has(name)) {\n    name = \"\".concat(rawName).concat(++attempts);\n  }\n\n  return name;\n}\nexport function convertToCamelCase(name) {\n  return name.replace(/\\s/g, '_').split('_').map(function (part, i) {\n    if (part.length === 0) return '';\n\n    if (i === 0) {\n      return part.toLowerCase();\n    } else {\n      if (part.length === 1) {\n        return part.toUpperCase();\n      }\n\n      return part.charAt(0).toUpperCase() + part.slice(1);\n    }\n  }).join('');\n}\nexport function getGLTFShapeName(component) {\n  var src = component.data.src;\n\n  if (!src) {\n    throw Error('Invalid name');\n  }\n\n  var name = convertToCamelCase(src // path/to/ModelName.glb\n  .split('/') // [\"path\", \"to\", \"ModelName.glb\"]\n  .pop() // \"ModelName.glb\"\n  .split('.') // [\"ModelName\", \"glb\"]\n  .shift() // \"ModelName\"\n  .replace(/\\d*$/, ''));\n\n  if (!name || name === SCRIPT_INSTANCE_NAME) {\n    throw Error('Invalid name');\n  }\n\n  return name;\n}\nexport function getDefaultValues(entityName, parameters, assetsByEntityName) {\n  var out = {};\n\n  var _iterator2 = _createForOfIteratorHelper(parameters),\n      _step2;\n\n  try {\n    var _loop = function _loop() {\n      var parameter = _step2.value;\n      var hasDefault = parameter.default !== undefined && parameter.default !== '';\n\n      if (parameter.type === AssetParameterType.ACTIONS) {\n        if (hasDefault) {\n          var asset = assetsByEntityName[entityName];\n          var action = asset && asset.actions.find(function (action) {\n            return action.id === parameter.id;\n          });\n          out[parameter.id] = [{\n            entityName: entityName,\n            actionId: parameter.default,\n            values: action ? getDefaultValues(entityName, action.parameters, assetsByEntityName) : {}\n          }];\n        }\n      } else if (parameter.type === AssetParameterType.ENTITY) {\n        var name = Object.keys(assetsByEntityName).find(function (entity) {\n          if (assetsByEntityName[entity]) {\n            return entity !== entityName && assetsByEntityName[entity].category !== GROUND_CATEGORY;\n          }\n\n          return false;\n        });\n        out[parameter.id] = name || entityName;\n      } else {\n        if (hasDefault) {\n          out[parameter.id] = parameter.default;\n        }\n      }\n    };\n\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return out;\n}\n/**\n * Swaps all references to `oldName` for `newName` inside a script's actions.\n *\n * Mutates the object.\n *\n * @param parameters The Asset parameters\n * @param values The AssetParameterValues corresponding to the script component data or any of the child action values\n * @param oldName The entity name to be changed\n * @param newName The entity name that will replace `oldName`\n */\n\nexport function renameEntity(parameters, values, oldName, newName) {\n  var _iterator3 = _createForOfIteratorHelper(parameters),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var parameter = _step3.value;\n\n      if (parameter.type === AssetParameterType.ACTIONS) {\n        var value = values[parameter.id];\n\n        if (value) {\n          for (var i = 0; i < value.length; i++) {\n            var action = value[i];\n\n            if (action.entityName === oldName) {\n              action.entityName = newName;\n            }\n\n            renameEntity(parameters, action.values, oldName, newName);\n          }\n        }\n      } else if (parameter.type === AssetParameterType.ENTITY) {\n        if (values[parameter.id] === oldName) {\n          values[parameter.id] = newName;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n/**\n * Removes all actions that depend on the provided entity name\n *\n * Mutates the object.\n *\n * @param parameters The Asset parameters\n * @param values The AssetParameterValues corresponding to the script component data or any of the child action values\n * @param oldName The entity name\n */\n\nexport function removeEntityReferences(parameters, values, entityName) {\n  var _iterator4 = _createForOfIteratorHelper(parameters),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var parameter = _step4.value;\n\n      if (parameter.type === AssetParameterType.ACTIONS) {\n        var value = values[parameter.id];\n\n        if (value) {\n          for (var i = 0; i < value.length; i++) {\n            var action = value[i];\n\n            if (action.entityName === entityName) {\n              value.splice(i, 1);\n              continue;\n            }\n\n            removeEntityReferences(parameters, action.values, entityName);\n          }\n        }\n      } else if (parameter.type === AssetParameterType.ENTITY) {\n        if (values[parameter.id] === entityName) {\n          delete values[parameter.id];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/scene/utils.ts"],"names":["getSceneByProjectId","select","put","race","take","loadManifestRequest","LOAD_MANIFEST_SUCCESS","LOAD_MANIFEST_FAILURE","getData","getPools","getProjects","getScenes","SCRIPT_INSTANCE_NAME","AssetParameterType","GROUND_CATEGORY","PreviewType","ComponentType","getRandomPosition","position","x","Math","floor","random","z","y","isWithinBounds","bounds","cloneEntities","scene","Object","keys","entities","reduce","entityId","components","filterEntitiesWithComponent","componentId","newEntities","id","entity","index","indexOf","getExceededMetrics","metrics","limits","metricsExceeded","key","metric","includes","push","snapToGrid","grid","round","snapToBounds","max","min","areEqualMappings","mappingsA","mappingsB","keyA","keyB","projectId","type","PROJECT","projects","pools","scenes","project","sceneId","success","failure","result","payload","manifest","Error","error","getEntityName","entityComponents","assets","takenNames","Set","map","add","name","getUniqueName","attempts","rawName","component","GLTFShape","asset","data","assetId","match","convertToCamelCase","join","NFTShape","e","has","replace","split","part","i","length","toLowerCase","toUpperCase","charAt","slice","getGLTFShapeName","src","pop","shift","getDefaultValues","entityName","parameters","assetsByEntityName","out","parameter","hasDefault","default","undefined","ACTIONS","action","actions","find","actionId","values","ENTITY","category","renameEntity","oldName","newName","value","removeEntityReferences","splice"],"mappings":"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","sourcesContent":["import { select, put, race, take } from 'redux-saga/effects'\nimport {\n  loadManifestRequest,\n  LoadManifestFailureAction,\n  LoadManifestSuccessAction,\n  LOAD_MANIFEST_SUCCESS,\n  LOAD_MANIFEST_FAILURE\n} from 'modules/project/actions'\nimport { getData as getPools } from 'modules/pool/selectors'\nimport { getData as getProjects } from 'modules/project/selectors'\nimport { getData as getScenes } from 'modules/scene/selectors'\nimport { SCRIPT_INSTANCE_NAME } from 'modules/project/export'\nimport { AssetParameter, AssetParameterValues, AssetParameterType, AssetActionValue, Asset, GROUND_CATEGORY } from 'modules/asset/types'\nimport { PreviewType } from 'modules/editor/types'\nimport { ModelMetrics, Vector3 } from 'modules/models/types'\nimport { Scene, ComponentType, ComponentDefinition, AnyComponent, EntityDefinition } from './types'\n\n/**\n * Returns a new random position bound to y: 0\n * Can be overriden using the position argument\n */\nexport function getRandomPosition(position: Partial<Vector3> = {}) {\n  const x = Math.floor(Math.random() * 6) + 1\n  const z = Math.floor(Math.random() * 6) + 1\n  return { x, y: 0, z, ...position }\n}\n\nexport function isWithinBounds(position: Vector3, bounds: Vector3) {\n  return position.x <= bounds.x && position.y <= bounds.y && position.z <= bounds.z && position.x >= 0 && position.y >= 0 && position.z >= 0\n}\n\n// Note: if we start making extensive use of scene cloning we may replace this by a proper deep clone\nexport function cloneEntities(scene: Scene) {\n  return Object.keys(scene.entities).reduce<Scene['entities']>(\n    (entities, entityId) => ({\n      ...entities,\n      [entityId]: { ...scene.entities[entityId], components: [...scene.entities[entityId].components] }\n    }),\n    {}\n  )\n}\n\nexport function filterEntitiesWithComponent(componentId: string, entities: Scene['entities']): Scene['entities'] {\n  const newEntities: Scene['entities'] = {}\n\n  for (let id in entities) {\n    const entity = entities[id]\n    const index = entity.components.indexOf(componentId)\n\n    if (index === -1) {\n      newEntities[id] = entity\n    }\n  }\n\n  return newEntities\n}\n\nexport function getExceededMetrics(metrics: ModelMetrics, limits: ModelMetrics) {\n  const metricsExceeded: (keyof ModelMetrics)[] = []\n\n  for (const key in metrics) {\n    const metric = key as keyof ModelMetrics\n    if (metrics[metric] > limits[metric]) {\n      if (!metricsExceeded.includes(metric)) {\n        metricsExceeded.push(metric)\n      }\n    }\n  }\n\n  return metricsExceeded\n}\n\nexport function snapToGrid(position: Vector3, grid: number = 0.5): Vector3 {\n  return {\n    x: Math.round(position.x / grid) * grid,\n    y: Math.round(position.y / grid) * grid,\n    z: Math.round(position.z / grid) * grid\n  }\n}\n\nexport function snapToBounds(position: Vector3, bounds: Vector3): Vector3 {\n  return {\n    x: Math.max(Math.min(position.x, bounds.x), 0),\n    y: Math.max(Math.min(position.y, bounds.y), 0),\n    z: Math.max(Math.min(position.z, bounds.z), 0)\n  }\n}\n\nexport function areEqualMappings(mappingsA: Record<string, string> = {}, mappingsB: Record<string, string> = {}) {\n  for (const keyA of Object.keys(mappingsA)) {\n    if (mappingsA[keyA] !== mappingsB[keyA]) {\n      return false\n    }\n  }\n  for (const keyB of Object.keys(mappingsB)) {\n    if (mappingsA[keyB] !== mappingsB[keyB]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function* getSceneByProjectId(\n  projectId: string,\n  type: PreviewType.PROJECT | PreviewType.PUBLIC | PreviewType.POOL = PreviewType.PROJECT\n) {\n  const projects: ReturnType<typeof getProjects> = yield select(getProjects)\n  const pools: ReturnType<typeof getPools> = yield select(getPools)\n  const scenes: ReturnType<typeof getScenes> = yield select(getScenes)\n  let project = projects[projectId] || pools[projectId]\n  let scene = project && scenes[project.sceneId]\n\n  if (!scene) {\n    yield put(loadManifestRequest(projectId, type))\n    const result: { success?: LoadManifestSuccessAction; failure?: LoadManifestFailureAction } = yield race({\n      success: take(LOAD_MANIFEST_SUCCESS),\n      failure: take(LOAD_MANIFEST_FAILURE)\n    })\n    if (result.success) {\n      scene = result.success.payload.manifest.scene\n    } else if (result.failure) {\n      throw new Error(result.failure.payload.error)\n    }\n  }\n  return scene\n}\n\nexport function getEntityName(scene: Scene, entityComponents: EntityDefinition['components'], assets: Record<string, Asset>) {\n  const takenNames = new Set<string>()\n  const components = entityComponents.map(id => scene.components[id])\n\n  for (let entityId in scene.entities) {\n    const entity = scene.entities[entityId]\n    takenNames.add(entity.name)\n  }\n  return getUniqueName(components, takenNames, assets)\n}\n\nexport function getUniqueName(components: AnyComponent[], takenNames: Readonly<Set<string>>, assets: Record<string, Asset>) {\n  let attempts = 1\n  let rawName = 'entity'\n\n  for (let component of components) {\n    try {\n      if (component.type === ComponentType.GLTFShape) {\n        const asset = assets[(component as ComponentDefinition<ComponentType.GLTFShape>).data.assetId]\n        if (asset) {\n          const match = asset.name.match(/[A-Za-z]+/g)\n          rawName = convertToCamelCase(match ? match.join('_') : rawName)\n        }\n      } else if (component.type === ComponentType.NFTShape) {\n        rawName = 'nft'\n      }\n    } catch (e) {\n      // swallow\n    }\n  }\n\n  let name = rawName\n  while (takenNames.has(name)) {\n    name = `${rawName}${++attempts}`\n  }\n\n  return name\n}\n\nexport function convertToCamelCase(name: string) {\n  return name\n    .replace(/\\s/g, '_')\n    .split('_')\n    .map((part, i) => {\n      if (part.length === 0) return ''\n\n      if (i === 0) {\n        return part.toLowerCase()\n      } else {\n        if (part.length === 1) {\n          return part.toUpperCase()\n        }\n        return part.charAt(0).toUpperCase() + part.slice(1)\n      }\n    })\n    .join('')\n}\n\nexport function getGLTFShapeName(component: ComponentDefinition<ComponentType.GLTFShape>) {\n  const src = (component.data as any).src\n  if (!src) {\n    throw Error('Invalid name')\n  }\n  const name = convertToCamelCase(\n    src // path/to/ModelName.glb\n      .split('/') // [\"path\", \"to\", \"ModelName.glb\"]\n      .pop()! // \"ModelName.glb\"\n      .split('.') // [\"ModelName\", \"glb\"]\n      .shift()! // \"ModelName\"\n      .replace(/\\d*$/, '')\n  )\n\n  if (!name || name === SCRIPT_INSTANCE_NAME) {\n    throw Error('Invalid name')\n  }\n\n  return name\n}\n\nexport function getDefaultValues(entityName: string, parameters: AssetParameter[], assetsByEntityName: Record<string, Asset>) {\n  const out: AssetParameterValues = {}\n\n  for (let parameter of parameters) {\n    const hasDefault = parameter.default !== undefined && parameter.default !== ''\n\n    if (parameter.type === AssetParameterType.ACTIONS) {\n      if (hasDefault) {\n        const asset = assetsByEntityName[entityName]\n        const action = asset && asset.actions.find(action => action.id === parameter.id)\n        out[parameter.id] = [\n          {\n            entityName,\n            actionId: parameter.default,\n            values: action ? getDefaultValues(entityName, action.parameters, assetsByEntityName) : {}\n          }\n        ] as AssetActionValue[]\n      }\n    } else if (parameter.type === AssetParameterType.ENTITY) {\n      const name = Object.keys(assetsByEntityName).find(entity => {\n        if (assetsByEntityName[entity]) {\n          return entity !== entityName && assetsByEntityName[entity].category !== GROUND_CATEGORY\n        }\n        return false\n      })!\n      out[parameter.id] = name || entityName\n    } else {\n      if (hasDefault) {\n        out[parameter.id] = parameter.default!\n      }\n    }\n  }\n\n  return out\n}\n\n/**\n * Swaps all references to `oldName` for `newName` inside a script's actions.\n *\n * Mutates the object.\n *\n * @param parameters The Asset parameters\n * @param values The AssetParameterValues corresponding to the script component data or any of the child action values\n * @param oldName The entity name to be changed\n * @param newName The entity name that will replace `oldName`\n */\nexport function renameEntity(parameters: AssetParameter[], values: AssetParameterValues, oldName: string, newName: string) {\n  for (let parameter of parameters) {\n    if (parameter.type === AssetParameterType.ACTIONS) {\n      const value = values[parameter.id] as AssetActionValue[] | undefined\n      if (value) {\n        for (let i = 0; i < value.length; i++) {\n          const action = value[i]\n          if (action.entityName === oldName) {\n            action.entityName = newName\n          }\n          renameEntity(parameters, action.values, oldName, newName)\n        }\n      }\n    } else if (parameter.type === AssetParameterType.ENTITY) {\n      if (values[parameter.id] === oldName) {\n        values[parameter.id] = newName\n      }\n    }\n  }\n}\n\n/**\n * Removes all actions that depend on the provided entity name\n *\n * Mutates the object.\n *\n * @param parameters The Asset parameters\n * @param values The AssetParameterValues corresponding to the script component data or any of the child action values\n * @param oldName The entity name\n */\nexport function removeEntityReferences(parameters: AssetParameter[], values: AssetParameterValues, entityName: string) {\n  for (let parameter of parameters) {\n    if (parameter.type === AssetParameterType.ACTIONS) {\n      const value = values[parameter.id] as AssetActionValue[] | undefined\n      if (value) {\n        for (let i = 0; i < value.length; i++) {\n          const action = value[i]\n          if (action.entityName === entityName) {\n            value.splice(i, 1)\n            continue\n          }\n          removeEntityReferences(parameters, action.values, entityName)\n        }\n      }\n    } else if (parameter.type === AssetParameterType.ENTITY) {\n      if (values[parameter.id] === entityName) {\n        delete values[parameter.id]\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}