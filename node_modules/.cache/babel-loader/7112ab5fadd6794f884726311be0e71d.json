{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { PolyhedronBuilder } from \"../Meshes/Builders/polyhedronBuilder\";\nimport { Gizmo } from \"./gizmo\";\nimport { AxisScaleGizmo } from \"./axisScaleGizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\n/**\r\n * Gizmo that enables scaling a mesh along 3 axis\r\n */\n\nvar ScaleGizmo =\n/** @class */\nfunction (_super) {\n  __extends(ScaleGizmo, _super);\n  /**\r\n   * Creates a ScaleGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param thickness display gizmo axis thickness\r\n   */\n\n\n  function ScaleGizmo(gizmoLayer, thickness, gizmoManager) {\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._meshAttached = null;\n    _this._nodeAttached = null;\n    _this._sensitivity = 1;\n    _this._observables = [];\n    /** Node Caching for quick lookup */\n\n    _this._gizmoAxisCache = new Map();\n    /** Fires an event when any of it's sub gizmos are dragged */\n\n    _this.onDragStartObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are released from dragging */\n\n    _this.onDragEndObservable = new Observable();\n    _this.uniformScaleGizmo = _this._createUniformScaleMesh();\n    _this.xGizmo = new AxisScaleGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, _this, thickness);\n    _this.yGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, _this, thickness);\n    _this.zGizmo = new AxisScaleGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, _this, thickness); // Relay drag events\n\n    [_this.xGizmo, _this.yGizmo, _this.zGizmo, _this.uniformScaleGizmo].forEach(function (gizmo) {\n      gizmo.dragBehavior.onDragStartObservable.add(function () {\n        _this.onDragStartObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragEndObservable.add(function () {\n        _this.onDragEndObservable.notifyObservers({});\n      });\n    });\n    _this.attachedMesh = null;\n    _this.attachedNode = null;\n\n    if (gizmoManager) {\n      gizmoManager.addToAxisCache(_this._gizmoAxisCache);\n    } else {\n      // Only subscribe to pointer event if gizmoManager isnt\n      Gizmo.GizmoAxisPointerObserver(gizmoLayer, _this._gizmoAxisCache);\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(ScaleGizmo.prototype, \"attachedMesh\", {\n    get: function get() {\n      return this._meshAttached;\n    },\n    set: function set(mesh) {\n      this._meshAttached = mesh;\n      this._nodeAttached = mesh;\n      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function (gizmo) {\n        if (gizmo.isEnabled) {\n          gizmo.attachedMesh = mesh;\n        } else {\n          gizmo.attachedMesh = null;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScaleGizmo.prototype, \"attachedNode\", {\n    get: function get() {\n      return this._nodeAttached;\n    },\n    set: function set(node) {\n      this._meshAttached = null;\n      this._nodeAttached = node;\n      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function (gizmo) {\n        if (gizmo.isEnabled) {\n          gizmo.attachedNode = node;\n        } else {\n          gizmo.attachedNode = null;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScaleGizmo.prototype, \"isHovered\", {\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\n    get: function get() {\n      var hovered = false;\n      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function (gizmo) {\n        hovered = hovered || gizmo.isHovered;\n      });\n      return hovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Create Geometry for Gizmo */\n\n  ScaleGizmo.prototype._createUniformScaleMesh = function () {\n    this._coloredMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.diffuseColor = Color3.Gray();\n    this._hoverMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n    this._hoverMaterial.diffuseColor = Color3.Yellow();\n    this._disableMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n    this._disableMaterial.diffuseColor = Color3.Gray();\n    this._disableMaterial.alpha = 0.4;\n    var uniformScaleGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Gray().scale(0.5), this.gizmoLayer, this);\n    uniformScaleGizmo.updateGizmoRotationToMatchAttachedMesh = false;\n    uniformScaleGizmo.uniformScaling = true;\n    this._uniformScalingMesh = PolyhedronBuilder.CreatePolyhedron(\"uniform\", {\n      type: 1\n    }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);\n\n    this._uniformScalingMesh.scaling.scaleInPlace(0.01);\n\n    this._uniformScalingMesh.visibility = 0;\n    this._octahedron = PolyhedronBuilder.CreatePolyhedron(\"\", {\n      type: 1\n    }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);\n\n    this._octahedron.scaling.scaleInPlace(0.007);\n\n    this._uniformScalingMesh.addChild(this._octahedron);\n\n    uniformScaleGizmo.setCustomMesh(this._uniformScalingMesh, true);\n\n    var light = this.gizmoLayer._getSharedGizmoLight();\n\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._octahedron);\n    var cache = {\n      gizmoMeshes: [this._octahedron, this._uniformScalingMesh],\n      colliderMeshes: [this._uniformScalingMesh],\n      material: this._coloredMaterial,\n      hoverMaterial: this._hoverMaterial,\n      disableMaterial: this._disableMaterial,\n      active: false\n    };\n    this.addToAxisCache(uniformScaleGizmo._rootMesh, cache);\n    return uniformScaleGizmo;\n  };\n\n  Object.defineProperty(ScaleGizmo.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n    get: function get() {\n      return this._updateGizmoRotationToMatchAttachedMesh;\n    },\n    set: function set(value) {\n      if (!value) {\n        Logger.Warn(\"Setting updateGizmoRotationToMatchAttachedMesh = false on scaling gizmo is not supported.\");\n      } else {\n        this._updateGizmoRotationToMatchAttachedMesh = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function (gizmo) {\n          if (gizmo) {\n            gizmo.updateGizmoRotationToMatchAttachedMesh = value;\n          }\n        });\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScaleGizmo.prototype, \"snapDistance\", {\n    get: function get() {\n      return this._snapDistance;\n    },\n\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\n    set: function set(value) {\n      this._snapDistance = value;\n      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function (gizmo) {\n        if (gizmo) {\n          gizmo.snapDistance = value;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScaleGizmo.prototype, \"scaleRatio\", {\n    get: function get() {\n      return this._scaleRatio;\n    },\n\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\n    set: function set(value) {\n      this._scaleRatio = value;\n      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function (gizmo) {\n        if (gizmo) {\n          gizmo.scaleRatio = value;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScaleGizmo.prototype, \"sensitivity\", {\n    get: function get() {\n      return this._sensitivity;\n    },\n\n    /**\r\n     * Sensitivity factor for dragging (Default: 1)\r\n     */\n    set: function set(value) {\n      this._sensitivity = value;\n      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function (gizmo) {\n        if (gizmo) {\n          gizmo.sensitivity = value;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n   * @param mesh Axis gizmo mesh\r\n   * @param cache Gizmo axis definition used for reactive gizmo UI\r\n   */\n\n  ScaleGizmo.prototype.addToAxisCache = function (mesh, cache) {\n    this._gizmoAxisCache.set(mesh, cache);\n  };\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n\n  ScaleGizmo.prototype.dispose = function () {\n    var _this = this;\n\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(function (gizmo) {\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    });\n\n    this._observables.forEach(function (obs) {\n      _this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n    });\n\n    this.onDragStartObservable.clear();\n    this.onDragEndObservable.clear();\n    [this._uniformScalingMesh, this._octahedron].forEach(function (msh) {\n      if (msh) {\n        msh.dispose();\n      }\n    });\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function (matl) {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n  };\n\n  return ScaleGizmo;\n}(Gizmo);\n\nexport { ScaleGizmo };","map":null,"metadata":{},"sourceType":"module"}