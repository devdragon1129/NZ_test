{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\n/**\r\n * Block used to add support for instances\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n */\n\nvar InstancesBlock =\n/** @class */\nfunction (_super) {\n  __extends(InstancesBlock, _super);\n  /**\r\n   * Creates a new InstancesBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function InstancesBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Vertex) || this;\n\n    _this.registerInput(\"world0\", NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this.registerInput(\"world1\", NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this.registerInput(\"world2\", NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this.registerInput(\"world3\", NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n\n    _this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Matrix);\n\n    _this.registerOutput(\"instanceID\", NodeMaterialBlockConnectionPointTypes.Float);\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  InstancesBlock.prototype.getClassName = function () {\n    return \"InstancesBlock\";\n  };\n\n  Object.defineProperty(InstancesBlock.prototype, \"world0\", {\n    /**\r\n     * Gets the first world row input component\r\n     */\n    get: function get() {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancesBlock.prototype, \"world1\", {\n    /**\r\n     * Gets the second world row input component\r\n     */\n    get: function get() {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancesBlock.prototype, \"world2\", {\n    /**\r\n     * Gets the third world row input component\r\n     */\n    get: function get() {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancesBlock.prototype, \"world3\", {\n    /**\r\n     * Gets the forth world row input component\r\n     */\n    get: function get() {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancesBlock.prototype, \"world\", {\n    /**\r\n     * Gets the world input component\r\n     */\n    get: function get() {\n      return this._inputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancesBlock.prototype, \"output\", {\n    /**\r\n     * Gets the output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancesBlock.prototype, \"instanceID\", {\n    /**\r\n     * Gets the isntanceID component\r\n     */\n    get: function get() {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InstancesBlock.prototype.autoConfigure = function (material) {\n    if (!this.world0.connectedPoint) {\n      var world0Input = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"world0\";\n      });\n\n      if (!world0Input) {\n        world0Input = new InputBlock(\"world0\");\n        world0Input.setAsAttribute(\"world0\");\n      }\n\n      world0Input.output.connectTo(this.world0);\n    }\n\n    if (!this.world1.connectedPoint) {\n      var world1Input = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"world1\";\n      });\n\n      if (!world1Input) {\n        world1Input = new InputBlock(\"world1\");\n        world1Input.setAsAttribute(\"world1\");\n      }\n\n      world1Input.output.connectTo(this.world1);\n    }\n\n    if (!this.world2.connectedPoint) {\n      var world2Input = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"world2\";\n      });\n\n      if (!world2Input) {\n        world2Input = new InputBlock(\"world2\");\n        world2Input.setAsAttribute(\"world2\");\n      }\n\n      world2Input.output.connectTo(this.world2);\n    }\n\n    if (!this.world3.connectedPoint) {\n      var world3Input = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"world3\";\n      });\n\n      if (!world3Input) {\n        world3Input = new InputBlock(\"world3\");\n        world3Input.setAsAttribute(\"world3\");\n      }\n\n      world3Input.output.connectTo(this.world3);\n    }\n\n    if (!this.world.connectedPoint) {\n      var worldInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"world\";\n      });\n\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n\n      worldInput.output.connectTo(this.world);\n    }\n\n    this.world.define = \"!INSTANCES || THIN_INSTANCES\";\n  };\n\n  InstancesBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines, useInstances, subMesh) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    var changed = false;\n\n    if (defines[\"INSTANCES\"] !== useInstances) {\n      defines.setValue(\"INSTANCES\", useInstances);\n      changed = true;\n    }\n\n    if (subMesh && defines[\"THIN_INSTANCES\"] !== !!(subMesh === null || subMesh === void 0 ? void 0 : subMesh.getRenderingMesh().hasThinInstances)) {\n      defines.setValue(\"THIN_INSTANCES\", !!(subMesh === null || subMesh === void 0 ? void 0 : subMesh.getRenderingMesh().hasThinInstances));\n      changed = true;\n    }\n\n    if (changed) {\n      defines.markAsUnprocessed();\n    }\n  };\n\n  InstancesBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state); // Register for defines\n\n\n    state.sharedData.blocksWithDefines.push(this); // Emit code\n\n    var output = this._outputs[0];\n    var instanceID = this._outputs[1];\n    var world0 = this.world0;\n    var world1 = this.world1;\n    var world2 = this.world2;\n    var world3 = this.world3;\n    state.compilationString += \"#ifdef INSTANCES\\r\\n\";\n    state.compilationString += this._declareOutput(output, state) + (\" = mat4(\" + world0.associatedVariableName + \", \" + world1.associatedVariableName + \", \" + world2.associatedVariableName + \", \" + world3.associatedVariableName + \");\\r\\n\");\n    state.compilationString += \"#ifdef THIN_INSTANCES\\r\\n\";\n    state.compilationString += output.associatedVariableName + \" = \" + this.world.associatedVariableName + \" * \" + output.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += this._declareOutput(instanceID, state) + \" = float(gl_InstanceID);\\r\\n\";\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += this._declareOutput(output, state) + (\" = \" + this.world.associatedVariableName + \";\\r\\n\");\n    state.compilationString += this._declareOutput(instanceID, state) + \" = 0.0;\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    return this;\n  };\n\n  return InstancesBlock;\n}(NodeMaterialBlock);\n\nexport { InstancesBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.InstancesBlock\"] = InstancesBlock;","map":null,"metadata":{},"sourceType":"module"}