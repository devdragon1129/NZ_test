{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _toConsumableArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryBuilder = exports.sanitizeUrl = exports.getHeadersWithUserAgent = exports.isNode = exports.convertFiltersToQueryParams = exports.splitValuesIntoManyQueries = exports.splitValuesIntoManyQueryBuilders = exports.splitAndFetchPaginated = exports.splitAndFetch = exports.MAX_URL_LENGTH = exports.addModelToFormData = void 0;\n\nvar dcl_catalyst_commons_1 = require(\"dcl-catalyst-commons\");\n\nvar Environment_1 = require(\"./Environment\");\n\nfunction addModelToFormData(model, form) {\n  var namespace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  var _loop = function _loop(propertyName) {\n    if (!model.hasOwnProperty(propertyName) || model[propertyName] === null || model[propertyName] === undefined) return \"continue\";\n    var formKey = namespace ? \"\".concat(namespace, \"[\").concat(propertyName, \"]\") : propertyName;\n\n    if (model[propertyName] instanceof Date) {\n      form.append(formKey, model[propertyName].toISOString());\n    } else if (model[propertyName] instanceof Array) {\n      model[propertyName].forEach(function (element, index) {\n        var tempFormKey = \"\".concat(formKey, \"[\").concat(index, \"]\");\n        addModelToFormData(element, form, tempFormKey);\n      });\n    } else if (typeof model[propertyName] === 'object') {\n      addModelToFormData(model[propertyName], form, formKey);\n    } else {\n      form.append(formKey, model[propertyName].toString());\n    }\n  };\n\n  for (var propertyName in model) {\n    var _ret = _loop(propertyName);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return form;\n}\n\nexports.addModelToFormData = addModelToFormData;\n\nfunction removeDuplicates(array) {\n  return Array.from(new Set(array));\n}\n/**\n * This method performs one or more fetches to the given server, splitting query params into different queries to avoid exceeding the max length of urls\n */\n\n\nexports.MAX_URL_LENGTH = 2048;\n\nfunction splitAndFetch(_x) {\n  return _splitAndFetch.apply(this, arguments);\n}\n\nfunction _splitAndFetch() {\n  _splitAndFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var baseUrl, path, queryParams, fetcher, uniqueBy, options, queries, results, _iterator6, _step6, query, elements;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            baseUrl = _ref.baseUrl, path = _ref.path, queryParams = _ref.queryParams, fetcher = _ref.fetcher, uniqueBy = _ref.uniqueBy, options = _ref.options;\n            // Adding default\n            fetcher = fetcher ? fetcher : new dcl_catalyst_commons_1.Fetcher(); // Split values into different queries\n\n            queries = splitValuesIntoManyQueries({\n              baseUrl: baseUrl,\n              path: path,\n              queryParams: queryParams\n            });\n            results = new Map();\n            _iterator6 = _createForOfIteratorHelper(queries);\n            _context.prev = 5;\n\n            _iterator6.s();\n\n          case 7:\n            if ((_step6 = _iterator6.n()).done) {\n              _context.next = 15;\n              break;\n            }\n\n            query = _step6.value;\n            _context.next = 11;\n            return fetcher.fetchJson(query, options);\n\n          case 11:\n            elements = _context.sent;\n            // Group by unique property (if set), or add all of them to the map\n            elements.forEach(function (element) {\n              return results.set(uniqueBy ? element[uniqueBy] : results.size, element);\n            });\n\n          case 13:\n            _context.next = 7;\n            break;\n\n          case 15:\n            _context.next = 20;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](5);\n\n            _iterator6.e(_context.t0);\n\n          case 20:\n            _context.prev = 20;\n\n            _iterator6.f();\n\n            return _context.finish(20);\n\n          case 23:\n            return _context.abrupt(\"return\", Array.from(results.values()));\n\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[5, 17, 20, 23]]);\n  }));\n  return _splitAndFetch.apply(this, arguments);\n}\n\nexports.splitAndFetch = splitAndFetch;\nvar CHARS_LEFT_FOR_OFFSET = 7;\n/**\n * This method performs one or more fetches to the given server, splitting query params into different queries to avoid exceeding the max length of urls\n * This method should be used if the result is paginated, and needs to be queries many times\n */\n\nfunction splitAndFetchPaginated(_x2) {\n  return _splitAndFetchPaginated.apply(this, arguments);\n}\n\nfunction _splitAndFetchPaginated() {\n  _splitAndFetchPaginated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var fetcher, baseUrl, path, queryParams, elementsProperty, uniqueBy, options, reservedParams, queries, foundElements, exit, i, url, response, elements, nextRelative;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            fetcher = _ref2.fetcher, baseUrl = _ref2.baseUrl, path = _ref2.path, queryParams = _ref2.queryParams, elementsProperty = _ref2.elementsProperty, uniqueBy = _ref2.uniqueBy, options = _ref2.options;\n            // Set default\n            fetcher = fetcher ? fetcher : new dcl_catalyst_commons_1.Fetcher(); // Reserve a few chars to send the offset\n\n            reservedParams = new Map([['offset', CHARS_LEFT_FOR_OFFSET]]); // Split values into different queries\n\n            queries = splitValuesIntoManyQueries({\n              baseUrl: baseUrl,\n              path: path,\n              queryParams: queryParams,\n              reservedParams: reservedParams\n            }); // Perform the different queries\n\n            foundElements = new Map();\n            exit = false;\n            i = 0;\n\n          case 7:\n            if (!(i < queries.length && !exit)) {\n              _context2.next = 28;\n              break;\n            }\n\n            url = queries[i];\n\n          case 9:\n            if (!(url && !exit)) {\n              _context2.next = 25;\n              break;\n            }\n\n            _context2.prev = 10;\n            _context2.next = 13;\n            return fetcher.fetchJson(url, options);\n\n          case 13:\n            response = _context2.sent;\n            elements = response[elementsProperty];\n            elements.forEach(function (element) {\n              return foundElements.set(element[uniqueBy], element);\n            });\n            nextRelative = response.pagination.next;\n            url = nextRelative ? new URL(nextRelative, url).toString() : undefined;\n            _context2.next = 23;\n            break;\n\n          case 20:\n            _context2.prev = 20;\n            _context2.t0 = _context2[\"catch\"](10);\n            exit = true;\n\n          case 23:\n            _context2.next = 9;\n            break;\n\n          case 25:\n            i++;\n            _context2.next = 7;\n            break;\n\n          case 28:\n            return _context2.abrupt(\"return\", Array.from(foundElements.values()));\n\n          case 29:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[10, 20]]);\n  }));\n  return _splitAndFetchPaginated.apply(this, arguments);\n}\n\nexports.splitAndFetchPaginated = splitAndFetchPaginated;\n\nfunction splitValuesIntoManyQueryBuilders(_ref3) {\n  var queryParams = _ref3.queryParams,\n      baseUrl = _ref3.baseUrl,\n      path = _ref3.path,\n      reservedParams = _ref3.reservedParams;\n  var queryParamsMap = 'name' in queryParams ? new Map([[queryParams.name, queryParams.values]]) : queryParams; // Check that it makes sent to apply the algorithm\n\n  if (queryParamsMap.size === 0) {\n    return [new QueryBuilder(baseUrl + path, queryParamsMap, reservedParams)];\n  } // Remove duplicates\n\n\n  var withoutDuplicates = Array.from(queryParamsMap.entries()).map(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        name = _ref5[0],\n        values = _ref5[1];\n\n    return [name, removeDuplicates(values)];\n  }); // Sort params by amount of values\n\n  var sortedByValues = withoutDuplicates.sort(function (_ref6, _ref7) {\n    var _ref8 = _slicedToArray(_ref6, 2),\n        _ = _ref8[0],\n        values1 = _ref8[1];\n\n    var _ref9 = _slicedToArray(_ref7, 2),\n        __ = _ref9[0],\n        values2 = _ref9[1];\n\n    return values1.length - values2.length;\n  }); // Add all params (except the last one that is the one with the most values) into the url\n\n  var defaultQueryBuilder = new QueryBuilder(baseUrl + path, new Map(), reservedParams);\n\n  for (var i = 0; i < sortedByValues.length - 1; i++) {\n    var _sortedByValues$i = _slicedToArray(sortedByValues[i], 2),\n        paramName = _sortedByValues$i[0],\n        paramValues = _sortedByValues$i[1];\n\n    if (!defaultQueryBuilder.canSetParams(paramName, paramValues)) {\n      throw new Error(\"This library can split one query param into many HTTP requests, but it can't split more than one. You will need to do that on the client side.\");\n    }\n\n    defaultQueryBuilder.setParams(paramName, paramValues);\n  } // Prepare everything\n\n\n  var queryBuilder = QueryBuilder.clone(defaultQueryBuilder);\n\n  var _sortedByValues = _slicedToArray(sortedByValues[sortedByValues.length - 1], 2),\n      lastParamName = _sortedByValues[0],\n      lastParamValues = _sortedByValues[1];\n\n  var result = [];\n\n  var _iterator = _createForOfIteratorHelper(lastParamValues),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n\n      // Check url length\n      if (!queryBuilder.canAddParam(lastParamName, value)) {\n        result.push(queryBuilder);\n        queryBuilder = QueryBuilder.clone(defaultQueryBuilder);\n      }\n\n      queryBuilder.addParam(lastParamName, value);\n    } // Add current builder one last time\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  result.push(queryBuilder);\n  return result;\n}\n\nexports.splitValuesIntoManyQueryBuilders = splitValuesIntoManyQueryBuilders;\n\nfunction splitValuesIntoManyQueries(parameters) {\n  var builders = splitValuesIntoManyQueryBuilders(parameters);\n  return builders.map(function (builder) {\n    return builder.toString();\n  });\n}\n\nexports.splitValuesIntoManyQueries = splitValuesIntoManyQueries;\n\nfunction convertFiltersToQueryParams(filters) {\n  if (!filters) {\n    return new Map();\n  }\n\n  var entries = Object.entries(filters).filter(function (_ref10) {\n    var _ref11 = _slicedToArray(_ref10, 2),\n        _ = _ref11[0],\n        value = _ref11[1];\n\n    return !!value;\n  }).map(function (_ref12) {\n    var _ref13 = _slicedToArray(_ref12, 2),\n        name = _ref13[0],\n        value = _ref13[1];\n\n    var newName = name.endsWith('s') ? name.slice(0, -1) : name;\n    var newValues; // Force coersion of number, boolean, or string into string\n\n    if (Array.isArray(value)) {\n      newValues = _toConsumableArray(value).filter(isValidQueryParamValue).map(function (_) {\n        return \"\".concat(_);\n      });\n    } else if (isValidQueryParamValue(value)) {\n      newValues = [\"\".concat(value)];\n    } else {\n      throw new Error('Query params must be either a string, a number, a boolean or an array of the types just mentioned');\n    }\n\n    return [newName, newValues];\n  }).filter(function (_ref14) {\n    var _ref15 = _slicedToArray(_ref14, 2),\n        _ = _ref15[0],\n        values = _ref15[1];\n\n    return values.length > 0;\n  });\n  return new Map(entries);\n}\n\nexports.convertFiltersToQueryParams = convertFiltersToQueryParams;\n\nfunction isNode() {\n  return Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\n}\n\nexports.isNode = isNode;\n\nfunction getHeadersWithUserAgent(client) {\n  return isNode() ? {\n    'User-Agent': \"\".concat(client, \"/\").concat(Environment_1.RUNNING_VERSION, \" (+https://github.com/decentraland/catalyst-client)\")\n  } : undefined;\n}\n\nexports.getHeadersWithUserAgent = getHeadersWithUserAgent;\n\nfunction isValidQueryParamValue(value) {\n  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';\n}\n/** Remove white spaces and add https if no protocol is specified */\n\n\nfunction sanitizeUrl(url) {\n  // Remove empty spaces\n  url = url.trim(); // Add protocol if necessary\n\n  if (!url.startsWith('https://') && !url.startsWith('http://')) {\n    url = 'https://' + url;\n  } // Remove trailing slash if present\n\n\n  if (url.endsWith('/')) {\n    url = url.slice(0, -1);\n  }\n\n  return url;\n}\n\nexports.sanitizeUrl = sanitizeUrl;\n\nvar QueryBuilder = /*#__PURE__*/function () {\n  function QueryBuilder(baseUrl) {\n    var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n    var reservedParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n\n    _classCallCheck(this, QueryBuilder);\n\n    this.baseUrl = baseUrl;\n    this.queryParams = queryParams;\n    this.reservedParams = reservedParams;\n    this.length = this.calculateUrlLength(queryParams, reservedParams);\n  }\n\n  _createClass(QueryBuilder, [{\n    key: \"canAddParam\",\n    value: function canAddParam(paramName, paramValue) {\n      return this.length + paramName.length + paramValue.length + 2 < exports.MAX_URL_LENGTH;\n    }\n  }, {\n    key: \"addParam\",\n    value: function addParam(paramName, paramValue) {\n      if (!this.canAddParam(paramName, paramValue)) {\n        throw new Error(\"You can't add this parameter '\".concat(paramName, \"', since it would exceed the max url length\"));\n      }\n\n      var queryParam = this.queryParams.get(paramName);\n      var values = queryParam ? queryParam : [];\n      values.push(paramValue);\n      this.queryParams.set(paramName, values);\n      this.length += this.calculateAddedLength(paramName, [paramValue]);\n      return this;\n    }\n  }, {\n    key: \"canSetParams\",\n    value: function canSetParams(paramName, paramValues) {\n      var newQueryParams = new Map([].concat(_toConsumableArray(this.queryParams), [[paramName, paramValues]]));\n      var newLength = this.calculateUrlLength(newQueryParams, this.reservedParams);\n      return newLength < exports.MAX_URL_LENGTH;\n    }\n    /** This action will override whatever configuration there was previously for the given query parameter */\n\n  }, {\n    key: \"setParams\",\n    value: function setParams(paramName, paramValues) {\n      if (!this.canSetParams(paramName, paramValues)) {\n        throw new Error(\"You can't add this parameter '\".concat(paramName, \"', since it would exceed the max url length\"));\n      }\n\n      this.queryParams.set(paramName, paramValues.map(function (value) {\n        return \"\".concat(value);\n      }));\n      this.length = this.calculateUrlLength(this.queryParams, this.reservedParams);\n      return this;\n    }\n    /** This action will override whatever configuration there was previously for the given query parameter */\n\n  }, {\n    key: \"setParam\",\n    value: function setParam(paramName, paramValue) {\n      this.setParams(paramName, [paramValue]);\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var url = this.baseUrl;\n      var addedParamAlready = false;\n\n      var _iterator2 = _createForOfIteratorHelper(this.queryParams),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              paramName = _step2$value[0],\n              paramValues = _step2$value[1];\n\n          var _iterator3 = _createForOfIteratorHelper(paramValues),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var paramValue = _step3.value;\n\n              if (addedParamAlready) {\n                url += \"&\".concat(paramName, \"=\").concat(paramValue);\n              } else {\n                url += \"?\".concat(paramName, \"=\").concat(paramValue);\n                addedParamAlready = true;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return url;\n    }\n  }, {\n    key: \"calculateUrlLength\",\n    value: function calculateUrlLength(queryParams, reservedParams) {\n      var length = this.baseUrl.length;\n\n      var _iterator4 = _createForOfIteratorHelper(reservedParams),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              paramName = _step4$value[0],\n              reserved = _step4$value[1];\n\n          if (!this.queryParams.has(paramName)) {\n            // We will avoid the reserved parameters that already have a value set\n            length += paramName.length + 2 + reserved;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(queryParams),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              _paramName = _step5$value[0],\n              paramValues = _step5$value[1];\n\n          length += this.calculateAddedLength(_paramName, paramValues);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return length;\n    }\n  }, {\n    key: \"calculateAddedLength\",\n    value: function calculateAddedLength(paramName, paramValues) {\n      var valuesLength = this.calculateArrayLength(paramValues);\n      return valuesLength + (paramName.length + 2) * paramValues.length;\n    }\n  }, {\n    key: \"calculateArrayLength\",\n    value: function calculateArrayLength(array) {\n      return array.map(function (value) {\n        return \"\".concat(value);\n      }).reduce(function (accum, curr) {\n        return accum + curr.length;\n      }, 0);\n    }\n  }], [{\n    key: \"clone\",\n    value: function clone(queryBuilder) {\n      return new QueryBuilder(queryBuilder.baseUrl, new Map(queryBuilder.queryParams), queryBuilder.reservedParams);\n    }\n  }]);\n\n  return QueryBuilder;\n}();\n\nexports.QueryBuilder = QueryBuilder;","map":null,"metadata":{},"sourceType":"script"}