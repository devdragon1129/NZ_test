{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Engine } from \"../Engines/engine\";\nimport { Path2 } from '../Maths/math.path';\n/**\r\n * Vector2 wth index property\r\n */\n\nvar IndexedVector2 =\n/** @class */\nfunction (_super) {\n  __extends(IndexedVector2, _super);\n\n  function IndexedVector2(original,\n  /** Index of the vector2 */\n  index) {\n    var _this = _super.call(this, original.x, original.y) || this;\n\n    _this.index = index;\n    return _this;\n  }\n\n  return IndexedVector2;\n}(Vector2);\n/**\r\n * Defines points to create a polygon\r\n */\n\n\nvar PolygonPoints =\n/** @class */\nfunction () {\n  function PolygonPoints() {\n    this.elements = new Array();\n  }\n\n  PolygonPoints.prototype.add = function (originalPoints) {\n    var _this = this;\n\n    var result = new Array();\n    originalPoints.forEach(function (point) {\n      var newPoint = new IndexedVector2(point, _this.elements.length);\n      result.push(newPoint);\n\n      _this.elements.push(newPoint);\n    });\n    return result;\n  };\n\n  PolygonPoints.prototype.computeBounds = function () {\n    var lmin = new Vector2(this.elements[0].x, this.elements[0].y);\n    var lmax = new Vector2(this.elements[0].x, this.elements[0].y);\n    this.elements.forEach(function (point) {\n      // x\n      if (point.x < lmin.x) {\n        lmin.x = point.x;\n      } else if (point.x > lmax.x) {\n        lmax.x = point.x;\n      } // y\n\n\n      if (point.y < lmin.y) {\n        lmin.y = point.y;\n      } else if (point.y > lmax.y) {\n        lmax.y = point.y;\n      }\n    });\n    return {\n      min: lmin,\n      max: lmax,\n      width: lmax.x - lmin.x,\n      height: lmax.y - lmin.y\n    };\n  };\n\n  return PolygonPoints;\n}();\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon\r\n */\n\n\nvar Polygon =\n/** @class */\nfunction () {\n  function Polygon() {}\n  /**\r\n   * Creates a rectangle\r\n   * @param xmin bottom X coord\r\n   * @param ymin bottom Y coord\r\n   * @param xmax top X coord\r\n   * @param ymax top Y coord\r\n   * @returns points that make the resulting rectation\r\n   */\n\n\n  Polygon.Rectangle = function (xmin, ymin, xmax, ymax) {\n    return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\n  };\n  /**\r\n   * Creates a circle\r\n   * @param radius radius of circle\r\n   * @param cx scale in x\r\n   * @param cy scale in y\r\n   * @param numberOfSides number of sides that make up the circle\r\n   * @returns points that make the resulting circle\r\n   */\n\n\n  Polygon.Circle = function (radius, cx, cy, numberOfSides) {\n    if (cx === void 0) {\n      cx = 0;\n    }\n\n    if (cy === void 0) {\n      cy = 0;\n    }\n\n    if (numberOfSides === void 0) {\n      numberOfSides = 32;\n    }\n\n    var result = new Array();\n    var angle = 0;\n    var increment = Math.PI * 2 / numberOfSides;\n\n    for (var i = 0; i < numberOfSides; i++) {\n      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\n      angle -= increment;\n    }\n\n    return result;\n  };\n  /**\r\n   * Creates a polygon from input string\r\n   * @param input Input polygon data\r\n   * @returns the parsed points\r\n   */\n\n\n  Polygon.Parse = function (input) {\n    var floats = input.split(/[^-+eE\\.\\d]+/).map(parseFloat).filter(function (val) {\n      return !isNaN(val);\n    });\n    var i,\n        result = [];\n\n    for (i = 0; i < (floats.length & 0x7FFFFFFE); i += 2) {\n      result.push(new Vector2(floats[i], floats[i + 1]));\n    }\n\n    return result;\n  };\n  /**\r\n   * Starts building a polygon from x and y coordinates\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @returns the started path2\r\n   */\n\n\n  Polygon.StartingAt = function (x, y) {\n    return Path2.StartingAt(x, y);\n  };\n\n  return Polygon;\n}();\n\nexport { Polygon };\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/how_to/polygonmeshbuilder\r\n */\n\nvar PolygonMeshBuilder =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a PolygonMeshBuilder\r\n   * @param name name of the builder\r\n   * @param contours Path of the polygon\r\n   * @param scene scene to add to when creating the mesh\r\n   * @param earcutInjection can be used to inject your own earcut reference\r\n   */\n  function PolygonMeshBuilder(name, contours, scene, earcutInjection) {\n    if (earcutInjection === void 0) {\n      earcutInjection = earcut;\n    }\n\n    this._points = new PolygonPoints();\n    this._outlinepoints = new PolygonPoints();\n    this._holes = new Array();\n    this._epoints = new Array();\n    this._eholes = new Array();\n    this.bjsEarcut = earcutInjection;\n    this._name = name;\n    this._scene = scene || Engine.LastCreatedScene;\n    var points;\n\n    if (contours instanceof Path2) {\n      points = contours.getPoints();\n    } else {\n      points = contours;\n    }\n\n    this._addToepoint(points);\n\n    this._points.add(points);\n\n    this._outlinepoints.add(points);\n\n    if (typeof this.bjsEarcut === 'undefined') {\n      Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\n    }\n  }\n\n  PolygonMeshBuilder.prototype._addToepoint = function (points) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var p = points_1[_i];\n\n      this._epoints.push(p.x, p.y);\n    }\n  };\n  /**\r\n   * Adds a whole within the polygon\r\n   * @param hole Array of points defining the hole\r\n   * @returns this\r\n   */\n\n\n  PolygonMeshBuilder.prototype.addHole = function (hole) {\n    this._points.add(hole);\n\n    var holepoints = new PolygonPoints();\n    holepoints.add(hole);\n\n    this._holes.push(holepoints);\n\n    this._eholes.push(this._epoints.length / 2);\n\n    this._addToepoint(hole);\n\n    return this;\n  };\n  /**\r\n   * Creates the polygon\r\n   * @param updatable If the mesh should be updatable\r\n   * @param depth The depth of the mesh created\r\n   * @returns the created mesh\r\n   */\n\n\n  PolygonMeshBuilder.prototype.build = function (updatable, depth) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    var result = new Mesh(this._name, this._scene);\n    var vertexData = this.buildVertexData(depth);\n    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);\n    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);\n    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);\n    result.setIndices(vertexData.indices);\n    return result;\n  };\n  /**\r\n   * Creates the polygon\r\n   * @param depth The depth of the mesh created\r\n   * @returns the created VertexData\r\n   */\n\n\n  PolygonMeshBuilder.prototype.buildVertexData = function (depth) {\n    var _this = this;\n\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    var result = new VertexData();\n    var normals = new Array();\n    var positions = new Array();\n    var uvs = new Array();\n\n    var bounds = this._points.computeBounds();\n\n    this._points.elements.forEach(function (p) {\n      normals.push(0, 1.0, 0);\n      positions.push(p.x, 0, p.y);\n      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\n    });\n\n    var indices = new Array();\n    var res = this.bjsEarcut(this._epoints, this._eholes, 2);\n\n    for (var i = 0; i < res.length; i++) {\n      indices.push(res[i]);\n    }\n\n    if (depth > 0) {\n      var positionscount = positions.length / 3; //get the current pointcount\n\n      this._points.elements.forEach(function (p) {\n        normals.push(0, -1.0, 0);\n        positions.push(p.x, -depth, p.y);\n        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\n      });\n\n      var totalCount = indices.length;\n\n      for (var i = 0; i < totalCount; i += 3) {\n        var i0 = indices[i + 0];\n        var i1 = indices[i + 1];\n        var i2 = indices[i + 2];\n        indices.push(i2 + positionscount);\n        indices.push(i1 + positionscount);\n        indices.push(i0 + positionscount);\n      } //Add the sides\n\n\n      this.addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false);\n\n      this._holes.forEach(function (hole) {\n        _this.addSide(positions, normals, uvs, indices, bounds, hole, depth, true);\n      });\n    }\n\n    result.indices = indices;\n    result.positions = positions;\n    result.normals = normals;\n    result.uvs = uvs;\n    return result;\n  };\n  /**\r\n   * Adds a side to the polygon\r\n   * @param positions points that make the polygon\r\n   * @param normals normals of the polygon\r\n   * @param uvs uvs of the polygon\r\n   * @param indices indices of the polygon\r\n   * @param bounds bounds of the polygon\r\n   * @param points points of the polygon\r\n   * @param depth depth of the polygon\r\n   * @param flip flip of the polygon\r\n   */\n\n\n  PolygonMeshBuilder.prototype.addSide = function (positions, normals, uvs, indices, bounds, points, depth, flip) {\n    var StartIndex = positions.length / 3;\n    var ulength = 0;\n\n    for (var i = 0; i < points.elements.length; i++) {\n      var p = points.elements[i];\n      var p1;\n\n      if (i + 1 > points.elements.length - 1) {\n        p1 = points.elements[0];\n      } else {\n        p1 = points.elements[i + 1];\n      }\n\n      positions.push(p.x, 0, p.y);\n      positions.push(p.x, -depth, p.y);\n      positions.push(p1.x, 0, p1.y);\n      positions.push(p1.x, -depth, p1.y);\n      var v1 = new Vector3(p.x, 0, p.y);\n      var v2 = new Vector3(p1.x, 0, p1.y);\n      var v3 = v2.subtract(v1);\n      var v4 = new Vector3(0, 1, 0);\n      var vn = Vector3.Cross(v3, v4);\n      vn = vn.normalize();\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n      ulength += v3.length();\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n\n      if (!flip) {\n        normals.push(-vn.x, -vn.y, -vn.z);\n        normals.push(-vn.x, -vn.y, -vn.z);\n        normals.push(-vn.x, -vn.y, -vn.z);\n        normals.push(-vn.x, -vn.y, -vn.z);\n        indices.push(StartIndex);\n        indices.push(StartIndex + 1);\n        indices.push(StartIndex + 2);\n        indices.push(StartIndex + 1);\n        indices.push(StartIndex + 3);\n        indices.push(StartIndex + 2);\n      } else {\n        normals.push(vn.x, vn.y, vn.z);\n        normals.push(vn.x, vn.y, vn.z);\n        normals.push(vn.x, vn.y, vn.z);\n        normals.push(vn.x, vn.y, vn.z);\n        indices.push(StartIndex);\n        indices.push(StartIndex + 2);\n        indices.push(StartIndex + 1);\n        indices.push(StartIndex + 1);\n        indices.push(StartIndex + 2);\n        indices.push(StartIndex + 3);\n      }\n\n      StartIndex += 4;\n    }\n  };\n\n  return PolygonMeshBuilder;\n}();\n\nexport { PolygonMeshBuilder };","map":null,"metadata":{},"sourceType":"module"}