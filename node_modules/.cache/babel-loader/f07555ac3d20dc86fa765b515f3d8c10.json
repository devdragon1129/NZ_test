{"ast":null,"code":"import { Vector3, Vector2 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { SubMesh } from \"../Meshes/subMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Color4 } from '../Maths/math.color';\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\n\nvar currentCSGMeshId = 0;\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\n\nvar Vertex =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the vertex\r\n   * @param pos The position of the vertex\r\n   * @param normal The normal of the vertex\r\n   * @param uv The texture coordinate of the vertex\r\n   * @param vertColor The RGBA color of the vertex\r\n   */\n  function Vertex(\n  /**\r\n   * The position of the vertex\r\n   */\n  pos,\n  /**\r\n   * The normal of the vertex\r\n   */\n  normal,\n  /**\r\n   * The texture coordinate of the vertex\r\n   */\n  uv,\n  /**\r\n   * The texture coordinate of the vertex\r\n   */\n  vertColor) {\n    this.pos = pos;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertColor = vertColor;\n  }\n  /**\r\n   * Make a clone, or deep copy, of the vertex\r\n   * @returns A new Vertex\r\n   */\n\n\n  Vertex.prototype.clone = function () {\n    var _a, _b;\n\n    return new Vertex(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());\n  };\n  /**\r\n   * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n   * orientation of a polygon is flipped.\r\n   */\n\n\n  Vertex.prototype.flip = function () {\n    this.normal = this.normal.scale(-1);\n  };\n  /**\r\n   * Create a new vertex between this vertex and `other` by linearly\r\n   * interpolating all properties using a parameter of `t`. Subclasses should\r\n   * override this to interpolate additional properties.\r\n   * @param other the vertex to interpolate against\r\n   * @param t The factor used to linearly interpolate between the vertices\r\n   */\n\n\n  Vertex.prototype.interpolate = function (other, t) {\n    return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined);\n  };\n\n  return Vertex;\n}();\n/**\r\n * Represents a plane in 3D space.\r\n */\n\n\nvar Plane =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the plane\r\n   * @param normal The normal for the plane\r\n   * @param w\r\n   */\n  function Plane(normal, w) {\n    this.normal = normal;\n    this.w = w;\n  }\n  /**\r\n   * Construct a plane from three points\r\n   * @param a Point a\r\n   * @param b Point b\r\n   * @param c Point c\r\n   */\n\n\n  Plane.FromPoints = function (a, b, c) {\n    var v0 = c.subtract(a);\n    var v1 = b.subtract(a);\n\n    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\n      return null;\n    }\n\n    var n = Vector3.Normalize(Vector3.Cross(v0, v1));\n    return new Plane(n, Vector3.Dot(n, a));\n  };\n  /**\r\n   * Clone, or make a deep copy of the plane\r\n   * @returns a new Plane\r\n   */\n\n\n  Plane.prototype.clone = function () {\n    return new Plane(this.normal.clone(), this.w);\n  };\n  /**\r\n   * Flip the face of the plane\r\n   */\n\n\n  Plane.prototype.flip = function () {\n    this.normal.scaleInPlace(-1);\n    this.w = -this.w;\n  };\n  /**\r\n   * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n   * fragments in the appropriate lists. Coplanar polygons go into either\r\n  `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n   * respect to this plane. Polygons in front or in back of this plane go into\r\n   * either `front` or `back`\r\n   * @param polygon The polygon to be split\r\n   * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n   * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n   * @param front Will contain the polygons in front of the plane\r\n   * @param back Will contain the polygons begind the plane\r\n   */\n\n\n  Plane.prototype.splitPolygon = function (polygon, coplanarFront, coplanarBack, front, back) {\n    var COPLANAR = 0;\n    var FRONT = 1;\n    var BACK = 2;\n    var SPANNING = 3; // Classify each point as well as the entire polygon into one of the above\n    // four classes.\n\n    var polygonType = 0;\n    var types = [];\n    var i;\n    var t;\n\n    for (i = 0; i < polygon.vertices.length; i++) {\n      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\n      var type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n      polygonType |= type;\n      types.push(type);\n    } // Put the polygon in the correct list, splitting it when necessary\n\n\n    switch (polygonType) {\n      case COPLANAR:\n        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n        break;\n\n      case FRONT:\n        front.push(polygon);\n        break;\n\n      case BACK:\n        back.push(polygon);\n        break;\n\n      case SPANNING:\n        var f = [],\n            b = [];\n\n        for (i = 0; i < polygon.vertices.length; i++) {\n          var j = (i + 1) % polygon.vertices.length;\n          var ti = types[i],\n              tj = types[j];\n          var vi = polygon.vertices[i],\n              vj = polygon.vertices[j];\n\n          if (ti !== BACK) {\n            f.push(vi);\n          }\n\n          if (ti !== FRONT) {\n            b.push(ti !== BACK ? vi.clone() : vi);\n          }\n\n          if ((ti | tj) === SPANNING) {\n            t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\n            var v = vi.interpolate(vj, t);\n            f.push(v);\n            b.push(v.clone());\n          }\n        }\n\n        var poly;\n\n        if (f.length >= 3) {\n          poly = new Polygon(f, polygon.shared);\n\n          if (poly.plane) {\n            front.push(poly);\n          }\n        }\n\n        if (b.length >= 3) {\n          poly = new Polygon(b, polygon.shared);\n\n          if (poly.plane) {\n            back.push(poly);\n          }\n        }\n\n        break;\n    }\n  };\n  /**\r\n   * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n   * point is on the plane\r\n   */\n\n\n  Plane.EPSILON = 1e-5;\n  return Plane;\n}();\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\n\n\nvar Polygon =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the polygon\r\n   * @param vertices The vertices of the polygon\r\n   * @param shared The properties shared across all polygons\r\n   */\n  function Polygon(vertices, shared) {\n    this.vertices = vertices;\n    this.shared = shared;\n    this.plane = Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n  }\n  /**\r\n   * Clones, or makes a deep copy, or the polygon\r\n   */\n\n\n  Polygon.prototype.clone = function () {\n    var vertices = this.vertices.map(function (v) {\n      return v.clone();\n    });\n    return new Polygon(vertices, this.shared);\n  };\n  /**\r\n   * Flips the faces of the polygon\r\n   */\n\n\n  Polygon.prototype.flip = function () {\n    this.vertices.reverse().map(function (v) {\n      v.flip();\n    });\n    this.plane.flip();\n  };\n\n  return Polygon;\n}();\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\n\n\nvar Node =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the node\r\n   * @param polygons A collection of polygons held in the node\r\n   */\n  function Node(polygons) {\n    this.plane = null;\n    this.front = null;\n    this.back = null;\n    this.polygons = new Array();\n\n    if (polygons) {\n      this.build(polygons);\n    }\n  }\n  /**\r\n   * Clones, or makes a deep copy, of the node\r\n   * @returns The cloned node\r\n   */\n\n\n  Node.prototype.clone = function () {\n    var node = new Node();\n    node.plane = this.plane && this.plane.clone();\n    node.front = this.front && this.front.clone();\n    node.back = this.back && this.back.clone();\n    node.polygons = this.polygons.map(function (p) {\n      return p.clone();\n    });\n    return node;\n  };\n  /**\r\n   * Convert solid space to empty space and empty space to solid space\r\n   */\n\n\n  Node.prototype.invert = function () {\n    for (var i = 0; i < this.polygons.length; i++) {\n      this.polygons[i].flip();\n    }\n\n    if (this.plane) {\n      this.plane.flip();\n    }\n\n    if (this.front) {\n      this.front.invert();\n    }\n\n    if (this.back) {\n      this.back.invert();\n    }\n\n    var temp = this.front;\n    this.front = this.back;\n    this.back = temp;\n  };\n  /**\r\n   * Recursively remove all polygons in `polygons` that are inside this BSP\r\n   * tree.\r\n   * @param polygons Polygons to remove from the BSP\r\n   * @returns Polygons clipped from the BSP\r\n   */\n\n\n  Node.prototype.clipPolygons = function (polygons) {\n    if (!this.plane) {\n      return polygons.slice();\n    }\n\n    var front = new Array(),\n        back = new Array();\n\n    for (var i = 0; i < polygons.length; i++) {\n      this.plane.splitPolygon(polygons[i], front, back, front, back);\n    }\n\n    if (this.front) {\n      front = this.front.clipPolygons(front);\n    }\n\n    if (this.back) {\n      back = this.back.clipPolygons(back);\n    } else {\n      back = [];\n    }\n\n    return front.concat(back);\n  };\n  /**\r\n   * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n   * `bsp`.\r\n   * @param bsp BSP containing polygons to remove from this BSP\r\n   */\n\n\n  Node.prototype.clipTo = function (bsp) {\n    this.polygons = bsp.clipPolygons(this.polygons);\n\n    if (this.front) {\n      this.front.clipTo(bsp);\n    }\n\n    if (this.back) {\n      this.back.clipTo(bsp);\n    }\n  };\n  /**\r\n   * Return a list of all polygons in this BSP tree\r\n   * @returns List of all polygons in this BSP tree\r\n   */\n\n\n  Node.prototype.allPolygons = function () {\n    var polygons = this.polygons.slice();\n\n    if (this.front) {\n      polygons = polygons.concat(this.front.allPolygons());\n    }\n\n    if (this.back) {\n      polygons = polygons.concat(this.back.allPolygons());\n    }\n\n    return polygons;\n  };\n  /**\r\n   * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n   * new polygons are filtered down to the bottom of the tree and become new\r\n   * nodes there. Each set of polygons is partitioned using the first polygon\r\n   * (no heuristic is used to pick a good split)\r\n   * @param polygons Polygons used to construct the BSP tree\r\n   */\n\n\n  Node.prototype.build = function (polygons) {\n    if (!polygons.length) {\n      return;\n    }\n\n    if (!this.plane) {\n      this.plane = polygons[0].plane.clone();\n    }\n\n    var front = new Array(),\n        back = new Array();\n\n    for (var i = 0; i < polygons.length; i++) {\n      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n    }\n\n    if (front.length) {\n      if (!this.front) {\n        this.front = new Node();\n      }\n\n      this.front.build(front);\n    }\n\n    if (back.length) {\n      if (!this.back) {\n        this.back = new Node();\n      }\n\n      this.back.build(back);\n    }\n  };\n\n  return Node;\n}();\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\n\n\nvar CSG =\n/** @class */\nfunction () {\n  function CSG() {\n    this.polygons = new Array();\n  }\n  /**\r\n   * Convert the Mesh to CSG\r\n   * @param mesh The Mesh to convert to CSG\r\n   * @returns A new CSG from the Mesh\r\n   */\n\n\n  CSG.FromMesh = function (mesh) {\n    var vertex,\n        normal,\n        uv = undefined,\n        position,\n        vertColor = undefined,\n        polygon,\n        polygons = new Array(),\n        vertices;\n    var matrix,\n        meshPosition,\n        meshRotation,\n        meshRotationQuaternion = null,\n        meshScaling;\n\n    if (mesh instanceof Mesh) {\n      mesh.computeWorldMatrix(true);\n      matrix = mesh.getWorldMatrix();\n      meshPosition = mesh.position.clone();\n      meshRotation = mesh.rotation.clone();\n\n      if (mesh.rotationQuaternion) {\n        meshRotationQuaternion = mesh.rotationQuaternion.clone();\n      }\n\n      meshScaling = mesh.scaling.clone();\n    } else {\n      throw 'BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh';\n    }\n\n    var indices = mesh.getIndices(),\n        positions = mesh.getVerticesData(VertexBuffer.PositionKind),\n        normals = mesh.getVerticesData(VertexBuffer.NormalKind),\n        uvs = mesh.getVerticesData(VertexBuffer.UVKind),\n        vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var subMeshes = mesh.subMeshes;\n\n    for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {\n      for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\n        vertices = [];\n\n        for (var j = 0; j < 3; j++) {\n          var sourceNormal = new Vector3(normals[indices[i + j] * 3], normals[indices[i + j] * 3 + 1], normals[indices[i + j] * 3 + 2]);\n\n          if (uvs) {\n            uv = new Vector2(uvs[indices[i + j] * 2], uvs[indices[i + j] * 2 + 1]);\n          }\n\n          if (vertColors) {\n            vertColor = new Color4(vertColors[indices[i + j] * 4], vertColors[indices[i + j] * 4 + 1], vertColors[indices[i + j] * 4 + 2], vertColors[indices[i + j] * 4 + 3]);\n          }\n\n          var sourcePosition = new Vector3(positions[indices[i + j] * 3], positions[indices[i + j] * 3 + 1], positions[indices[i + j] * 3 + 2]);\n          position = Vector3.TransformCoordinates(sourcePosition, matrix);\n          normal = Vector3.TransformNormal(sourceNormal, matrix);\n          vertex = new Vertex(position, normal, uv, vertColor);\n          vertices.push(vertex);\n        }\n\n        polygon = new Polygon(vertices, {\n          subMeshId: sm,\n          meshId: currentCSGMeshId,\n          materialIndex: subMeshes[sm].materialIndex\n        }); // To handle the case of degenerated triangle\n        // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n\n        if (polygon.plane) {\n          polygons.push(polygon);\n        }\n      }\n    }\n\n    var csg = CSG.FromPolygons(polygons);\n    csg.matrix = matrix;\n    csg.position = meshPosition;\n    csg.rotation = meshRotation;\n    csg.scaling = meshScaling;\n    csg.rotationQuaternion = meshRotationQuaternion;\n    currentCSGMeshId++;\n    return csg;\n  };\n  /**\r\n   * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n   * @param polygons Polygons used to construct a CSG solid\r\n   */\n\n\n  CSG.FromPolygons = function (polygons) {\n    var csg = new CSG();\n    csg.polygons = polygons;\n    return csg;\n  };\n  /**\r\n   * Clones, or makes a deep copy, of the CSG\r\n   * @returns A new CSG\r\n   */\n\n\n  CSG.prototype.clone = function () {\n    var csg = new CSG();\n    csg.polygons = this.polygons.map(function (p) {\n      return p.clone();\n    });\n    csg.copyTransformAttributes(this);\n    return csg;\n  };\n  /**\r\n   * Unions this CSG with another CSG\r\n   * @param csg The CSG to union against this CSG\r\n   * @returns The unioned CSG\r\n   */\n\n\n  CSG.prototype.union = function (csg) {\n    var a = new Node(this.clone().polygons);\n    var b = new Node(csg.clone().polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\r\n   * Unions this CSG with another CSG in place\r\n   * @param csg The CSG to union against this CSG\r\n   */\n\n\n  CSG.prototype.unionInPlace = function (csg) {\n    var a = new Node(this.polygons);\n    var b = new Node(csg.polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    this.polygons = a.allPolygons();\n  };\n  /**\r\n   * Subtracts this CSG with another CSG\r\n   * @param csg The CSG to subtract against this CSG\r\n   * @returns A new CSG\r\n   */\n\n\n  CSG.prototype.subtract = function (csg) {\n    var a = new Node(this.clone().polygons);\n    var b = new Node(csg.clone().polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\r\n   * Subtracts this CSG with another CSG in place\r\n   * @param csg The CSG to subtact against this CSG\r\n   */\n\n\n  CSG.prototype.subtractInPlace = function (csg) {\n    var a = new Node(this.polygons);\n    var b = new Node(csg.polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    this.polygons = a.allPolygons();\n  };\n  /**\r\n   * Intersect this CSG with another CSG\r\n   * @param csg The CSG to intersect against this CSG\r\n   * @returns A new CSG\r\n   */\n\n\n  CSG.prototype.intersect = function (csg) {\n    var a = new Node(this.clone().polygons);\n    var b = new Node(csg.clone().polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\r\n   * Intersects this CSG with another CSG in place\r\n   * @param csg The CSG to intersect against this CSG\r\n   */\n\n\n  CSG.prototype.intersectInPlace = function (csg) {\n    var a = new Node(this.polygons);\n    var b = new Node(csg.polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    this.polygons = a.allPolygons();\n  };\n  /**\r\n   * Return a new CSG solid with solid and empty space switched. This solid is\r\n   * not modified.\r\n   * @returns A new CSG solid with solid and empty space switched\r\n   */\n\n\n  CSG.prototype.inverse = function () {\n    var csg = this.clone();\n    csg.inverseInPlace();\n    return csg;\n  };\n  /**\r\n   * Inverses the CSG in place\r\n   */\n\n\n  CSG.prototype.inverseInPlace = function () {\n    this.polygons.map(function (p) {\n      p.flip();\n    });\n  };\n  /**\r\n   * This is used to keep meshes transformations so they can be restored\r\n   * when we build back a Babylon Mesh\r\n   * NB : All CSG operations are performed in world coordinates\r\n   * @param csg The CSG to copy the transform attributes from\r\n   * @returns This CSG\r\n   */\n\n\n  CSG.prototype.copyTransformAttributes = function (csg) {\n    this.matrix = csg.matrix;\n    this.position = csg.position;\n    this.rotation = csg.rotation;\n    this.scaling = csg.scaling;\n    this.rotationQuaternion = csg.rotationQuaternion;\n    return this;\n  };\n  /**\r\n   * Build Raw mesh from CSG\r\n   * Coordinates here are in world space\r\n   * @param name The name of the mesh geometry\r\n   * @param scene The Scene\r\n   * @param keepSubMeshes Specifies if the submeshes should be kept\r\n   * @returns A new Mesh\r\n   */\n\n\n  CSG.prototype.buildMeshGeometry = function (name, scene, keepSubMeshes) {\n    var matrix = this.matrix.clone();\n    matrix.invert();\n    var mesh = new Mesh(name, scene);\n    var vertices = [];\n    var indices = [];\n    var normals = [];\n    var uvs = null;\n    var vertColors = null;\n    var vertex = Vector3.Zero();\n    var normal = Vector3.Zero();\n    var uv = Vector2.Zero();\n    var vertColor = new Color4(0, 0, 0, 0);\n    var polygons = this.polygons;\n    var polygonIndices = [0, 0, 0],\n        polygon;\n    var vertice_dict = {};\n    var vertex_idx;\n    var currentIndex = 0;\n    var subMesh_dict = {};\n    var subMesh_obj;\n\n    if (keepSubMeshes) {\n      // Sort Polygons, since subMeshes are indices range\n      polygons.sort(function (a, b) {\n        if (a.shared.meshId === b.shared.meshId) {\n          return a.shared.subMeshId - b.shared.subMeshId;\n        } else {\n          return a.shared.meshId - b.shared.meshId;\n        }\n      });\n    }\n\n    for (var i = 0, il = polygons.length; i < il; i++) {\n      polygon = polygons[i]; // Building SubMeshes\n\n      if (!subMesh_dict[polygon.shared.meshId]) {\n        subMesh_dict[polygon.shared.meshId] = {};\n      }\n\n      if (!subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId]) {\n        subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId] = {\n          indexStart: +Infinity,\n          indexEnd: -Infinity,\n          materialIndex: polygon.shared.materialIndex\n        };\n      }\n\n      subMesh_obj = subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId];\n\n      for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {\n        polygonIndices[0] = 0;\n        polygonIndices[1] = j - 1;\n        polygonIndices[2] = j;\n\n        for (var k = 0; k < 3; k++) {\n          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\n          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\n\n          if (polygon.vertices[polygonIndices[k]].uv) {\n            if (!uvs) {\n              uvs = [];\n            }\n\n            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\n          }\n\n          if (polygon.vertices[polygonIndices[k]].vertColor) {\n            if (!vertColors) {\n              vertColors = [];\n            }\n\n            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);\n          }\n\n          var localVertex = Vector3.TransformCoordinates(vertex, matrix);\n          var localNormal = Vector3.TransformNormal(normal, matrix);\n          vertex_idx = vertice_dict[localVertex.x + ',' + localVertex.y + ',' + localVertex.z];\n          var areUvsDifferent = false;\n\n          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\n            areUvsDifferent = true;\n          }\n\n          var areColorsDifferent = false;\n\n          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {\n            areColorsDifferent = true;\n          } // Check if 2 points can be merged\n\n\n          if (!(typeof vertex_idx !== 'undefined' && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {\n            vertices.push(localVertex.x, localVertex.y, localVertex.z);\n\n            if (uvs) {\n              uvs.push(uv.x, uv.y);\n            }\n\n            normals.push(normal.x, normal.y, normal.z);\n\n            if (vertColors) {\n              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\n            }\n\n            vertex_idx = vertice_dict[localVertex.x + ',' + localVertex.y + ',' + localVertex.z] = vertices.length / 3 - 1;\n          }\n\n          indices.push(vertex_idx);\n          subMesh_obj.indexStart = Math.min(currentIndex, subMesh_obj.indexStart);\n          subMesh_obj.indexEnd = Math.max(currentIndex, subMesh_obj.indexEnd);\n          currentIndex++;\n        }\n      }\n    }\n\n    mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\n    mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n\n    if (uvs) {\n      mesh.setVerticesData(VertexBuffer.UVKind, uvs);\n    }\n\n    if (vertColors) {\n      mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\n    }\n\n    mesh.setIndices(indices, null);\n\n    if (keepSubMeshes) {\n      // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\n      var materialIndexOffset = 0,\n          materialMaxIndex;\n      mesh.subMeshes = new Array();\n\n      for (var m in subMesh_dict) {\n        materialMaxIndex = -1;\n\n        for (var sm in subMesh_dict[m]) {\n          subMesh_obj = subMesh_dict[m][sm];\n          SubMesh.CreateFromIndices(subMesh_obj.materialIndex + materialIndexOffset, subMesh_obj.indexStart, subMesh_obj.indexEnd - subMesh_obj.indexStart + 1, mesh);\n          materialMaxIndex = Math.max(subMesh_obj.materialIndex, materialMaxIndex);\n        }\n\n        materialIndexOffset += ++materialMaxIndex;\n      }\n    }\n\n    return mesh;\n  };\n  /**\r\n   * Build Mesh from CSG taking material and transforms into account\r\n   * @param name The name of the Mesh\r\n   * @param material The material of the Mesh\r\n   * @param scene The Scene\r\n   * @param keepSubMeshes Specifies if submeshes should be kept\r\n   * @returns The new Mesh\r\n   */\n\n\n  CSG.prototype.toMesh = function (name, material, scene, keepSubMeshes) {\n    if (material === void 0) {\n      material = null;\n    }\n\n    var mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\n    mesh.material = material;\n    mesh.position.copyFrom(this.position);\n    mesh.rotation.copyFrom(this.rotation);\n\n    if (this.rotationQuaternion) {\n      mesh.rotationQuaternion = this.rotationQuaternion.clone();\n    }\n\n    mesh.scaling.copyFrom(this.scaling);\n    mesh.computeWorldMatrix(true);\n    return mesh;\n  };\n\n  return CSG;\n}();\n\nexport { CSG };","map":null,"metadata":{},"sourceType":"module"}