{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\n/**\r\n * Based on jsTGALoader - Javascript loader for TGA file\r\n * By Vincent Thibault\r\n * @see http://blog.robrowser.com/javascript-tga-loader.html\r\n */\n\nvar TGATools =\n/** @class */\nfunction () {\n  function TGATools() {}\n  /**\r\n   * Gets the header of a TGA file\r\n   * @param data defines the TGA data\r\n   * @returns the header\r\n   */\n\n\n  TGATools.GetTGAHeader = function (data) {\n    var offset = 0;\n    var header = {\n      id_length: data[offset++],\n      colormap_type: data[offset++],\n      image_type: data[offset++],\n      colormap_index: data[offset++] | data[offset++] << 8,\n      colormap_length: data[offset++] | data[offset++] << 8,\n      colormap_size: data[offset++],\n      origin: [data[offset++] | data[offset++] << 8, data[offset++] | data[offset++] << 8],\n      width: data[offset++] | data[offset++] << 8,\n      height: data[offset++] | data[offset++] << 8,\n      pixel_size: data[offset++],\n      flags: data[offset++]\n    };\n    return header;\n  };\n  /**\r\n   * Uploads TGA content to a Babylon Texture\r\n   * @hidden\r\n   */\n\n\n  TGATools.UploadContent = function (texture, data) {\n    // Not enough data to contain header ?\n    if (data.length < 19) {\n      Logger.Error(\"Unable to load TGA file - Not enough data to contain header\");\n      return;\n    } // Read Header\n\n\n    var offset = 18;\n    var header = TGATools.GetTGAHeader(data); // Assume it's a valid Targa file.\n\n    if (header.id_length + offset > data.length) {\n      Logger.Error(\"Unable to load TGA file - Not enough data\");\n      return;\n    } // Skip not needed data\n\n\n    offset += header.id_length;\n    var use_rle = false;\n    var use_pal = false;\n    var use_grey = false; // Get some informations.\n\n    switch (header.image_type) {\n      case TGATools._TYPE_RLE_INDEXED:\n        use_rle = true;\n\n      case TGATools._TYPE_INDEXED:\n        use_pal = true;\n        break;\n\n      case TGATools._TYPE_RLE_RGB:\n        use_rle = true;\n\n      case TGATools._TYPE_RGB:\n        // use_rgb = true;\n        break;\n\n      case TGATools._TYPE_RLE_GREY:\n        use_rle = true;\n\n      case TGATools._TYPE_GREY:\n        use_grey = true;\n        break;\n    }\n\n    var pixel_data; // var numAlphaBits = header.flags & 0xf;\n\n    var pixel_size = header.pixel_size >> 3;\n    var pixel_total = header.width * header.height * pixel_size; // Read palettes\n\n    var palettes;\n\n    if (use_pal) {\n      palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n    } // Read LRE\n\n\n    if (use_rle) {\n      pixel_data = new Uint8Array(pixel_total);\n      var c, count, i;\n      var localOffset = 0;\n      var pixels = new Uint8Array(pixel_size);\n\n      while (offset < pixel_total && localOffset < pixel_total) {\n        c = data[offset++];\n        count = (c & 0x7f) + 1; // RLE pixels\n\n        if (c & 0x80) {\n          // Bind pixel tmp array\n          for (i = 0; i < pixel_size; ++i) {\n            pixels[i] = data[offset++];\n          } // Copy pixel array\n\n\n          for (i = 0; i < count; ++i) {\n            pixel_data.set(pixels, localOffset + i * pixel_size);\n          }\n\n          localOffset += pixel_size * count;\n        } // Raw pixels\n        else {\n          count *= pixel_size;\n\n          for (i = 0; i < count; ++i) {\n            pixel_data[localOffset + i] = data[offset++];\n          }\n\n          localOffset += count;\n        }\n      }\n    } // RAW Pixels\n    else {\n      pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n    } // Load to texture\n\n\n    var x_start, y_start, x_step, y_step, y_end, x_end;\n\n    switch ((header.flags & TGATools._ORIGIN_MASK) >> TGATools._ORIGIN_SHIFT) {\n      default:\n      case TGATools._ORIGIN_UL:\n        x_start = 0;\n        x_step = 1;\n        x_end = header.width;\n        y_start = 0;\n        y_step = 1;\n        y_end = header.height;\n        break;\n\n      case TGATools._ORIGIN_BL:\n        x_start = 0;\n        x_step = 1;\n        x_end = header.width;\n        y_start = header.height - 1;\n        y_step = -1;\n        y_end = -1;\n        break;\n\n      case TGATools._ORIGIN_UR:\n        x_start = header.width - 1;\n        x_step = -1;\n        x_end = -1;\n        y_start = 0;\n        y_step = 1;\n        y_end = header.height;\n        break;\n\n      case TGATools._ORIGIN_BR:\n        x_start = header.width - 1;\n        x_step = -1;\n        x_end = -1;\n        y_start = header.height - 1;\n        y_step = -1;\n        y_end = -1;\n        break;\n    } // Load the specify method\n\n\n    var func = '_getImageData' + (use_grey ? 'Grey' : '') + header.pixel_size + 'bits';\n    var imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);\n    var engine = texture.getEngine();\n\n    engine._uploadDataToTextureDirectly(texture, imageData);\n  };\n  /** @hidden */\n\n\n  TGATools._getImageData8bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    var image = pixel_data,\n        colormap = palettes;\n    var width = header.width,\n        height = header.height;\n    var color,\n        i = 0,\n        x,\n        y;\n    var imageData = new Uint8Array(width * height * 4);\n\n    for (y = y_start; y !== y_end; y += y_step) {\n      for (x = x_start; x !== x_end; x += x_step, i++) {\n        color = image[i];\n        imageData[(x + width * y) * 4 + 3] = 255;\n        imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n        imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n        imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n      }\n    }\n\n    return imageData;\n  };\n  /** @hidden */\n\n\n  TGATools._getImageData16bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    var image = pixel_data;\n    var width = header.width,\n        height = header.height;\n    var color,\n        i = 0,\n        x,\n        y;\n    var imageData = new Uint8Array(width * height * 4);\n\n    for (y = y_start; y !== y_end; y += y_step) {\n      for (x = x_start; x !== x_end; x += x_step, i += 2) {\n        color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\n        var r = ((color & 0x7C00) >> 10) * 255 / 0x1F | 0;\n        var g = ((color & 0x03E0) >> 5) * 255 / 0x1F | 0;\n        var b = (color & 0x001F) * 255 / 0x1F | 0;\n        imageData[(x + width * y) * 4 + 0] = r;\n        imageData[(x + width * y) * 4 + 1] = g;\n        imageData[(x + width * y) * 4 + 2] = b;\n        imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n      }\n    }\n\n    return imageData;\n  };\n  /** @hidden */\n\n\n  TGATools._getImageData24bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    var image = pixel_data;\n    var width = header.width,\n        height = header.height;\n    var i = 0,\n        x,\n        y;\n    var imageData = new Uint8Array(width * height * 4);\n\n    for (y = y_start; y !== y_end; y += y_step) {\n      for (x = x_start; x !== x_end; x += x_step, i += 3) {\n        imageData[(x + width * y) * 4 + 3] = 255;\n        imageData[(x + width * y) * 4 + 2] = image[i + 0];\n        imageData[(x + width * y) * 4 + 1] = image[i + 1];\n        imageData[(x + width * y) * 4 + 0] = image[i + 2];\n      }\n    }\n\n    return imageData;\n  };\n  /** @hidden */\n\n\n  TGATools._getImageData32bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    var image = pixel_data;\n    var width = header.width,\n        height = header.height;\n    var i = 0,\n        x,\n        y;\n    var imageData = new Uint8Array(width * height * 4);\n\n    for (y = y_start; y !== y_end; y += y_step) {\n      for (x = x_start; x !== x_end; x += x_step, i += 4) {\n        imageData[(x + width * y) * 4 + 2] = image[i + 0];\n        imageData[(x + width * y) * 4 + 1] = image[i + 1];\n        imageData[(x + width * y) * 4 + 0] = image[i + 2];\n        imageData[(x + width * y) * 4 + 3] = image[i + 3];\n      }\n    }\n\n    return imageData;\n  };\n  /** @hidden */\n\n\n  TGATools._getImageDataGrey8bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    var image = pixel_data;\n    var width = header.width,\n        height = header.height;\n    var color,\n        i = 0,\n        x,\n        y;\n    var imageData = new Uint8Array(width * height * 4);\n\n    for (y = y_start; y !== y_end; y += y_step) {\n      for (x = x_start; x !== x_end; x += x_step, i++) {\n        color = image[i];\n        imageData[(x + width * y) * 4 + 0] = color;\n        imageData[(x + width * y) * 4 + 1] = color;\n        imageData[(x + width * y) * 4 + 2] = color;\n        imageData[(x + width * y) * 4 + 3] = 255;\n      }\n    }\n\n    return imageData;\n  };\n  /** @hidden */\n\n\n  TGATools._getImageDataGrey16bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n    var image = pixel_data;\n    var width = header.width,\n        height = header.height;\n    var i = 0,\n        x,\n        y;\n    var imageData = new Uint8Array(width * height * 4);\n\n    for (y = y_start; y !== y_end; y += y_step) {\n      for (x = x_start; x !== x_end; x += x_step, i += 2) {\n        imageData[(x + width * y) * 4 + 0] = image[i + 0];\n        imageData[(x + width * y) * 4 + 1] = image[i + 0];\n        imageData[(x + width * y) * 4 + 2] = image[i + 0];\n        imageData[(x + width * y) * 4 + 3] = image[i + 1];\n      }\n    }\n\n    return imageData;\n  }; //private static _TYPE_NO_DATA = 0;\n\n\n  TGATools._TYPE_INDEXED = 1;\n  TGATools._TYPE_RGB = 2;\n  TGATools._TYPE_GREY = 3;\n  TGATools._TYPE_RLE_INDEXED = 9;\n  TGATools._TYPE_RLE_RGB = 10;\n  TGATools._TYPE_RLE_GREY = 11;\n  TGATools._ORIGIN_MASK = 0x30;\n  TGATools._ORIGIN_SHIFT = 0x04;\n  TGATools._ORIGIN_BL = 0x00;\n  TGATools._ORIGIN_BR = 0x01;\n  TGATools._ORIGIN_UL = 0x02;\n  TGATools._ORIGIN_UR = 0x03;\n  return TGATools;\n}();\n\nexport { TGATools };","map":null,"metadata":{},"sourceType":"module"}