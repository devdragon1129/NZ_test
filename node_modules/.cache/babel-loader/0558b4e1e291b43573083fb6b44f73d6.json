{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockConnectionPointMode } from '../../Enums/nodeMaterialBlockConnectionPointMode';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport { Matrix, Vector2, Vector3, Vector4 } from '../../../../Maths/math.vector';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { Color3, Color4, TmpColors } from '../../../../Maths/math';\nimport { AnimatedInputBlockTypes } from './animatedInputBlockTypes';\nimport { Observable } from '../../../../Misc/observable';\nimport { MaterialHelper } from '../../../../Materials/materialHelper';\nvar remapAttributeName = {\n  \"position2d\": \"position\",\n  \"particle_uv\": \"vUV\",\n  \"particle_color\": \"vColor\",\n  \"particle_texturemask\": \"textureMask\",\n  \"particle_positionw\": \"vPositionW\"\n};\nvar attributeInFragmentOnly = {\n  \"particle_uv\": true,\n  \"particle_color\": true,\n  \"particle_texturemask\": true,\n  \"particle_positionw\": true\n};\nvar attributeAsUniform = {\n  \"particle_texturemask\": true\n};\n/**\r\n * Block used to expose an input value\r\n */\n\nvar InputBlock =\n/** @class */\nfunction (_super) {\n  __extends(InputBlock, _super);\n  /**\r\n   * Creates a new InputBlock\r\n   * @param name defines the block name\r\n   * @param target defines the target of that block (Vertex by default)\r\n   * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)\r\n   */\n\n\n  function InputBlock(name, target, type) {\n    if (target === void 0) {\n      target = NodeMaterialBlockTargets.Vertex;\n    }\n\n    if (type === void 0) {\n      type = NodeMaterialBlockConnectionPointTypes.AutoDetect;\n    }\n\n    var _this = _super.call(this, name, target, false, true) || this;\n\n    _this._mode = NodeMaterialBlockConnectionPointMode.Undefined;\n    _this._animationType = AnimatedInputBlockTypes.None;\n    /** Gets or set a value used to limit the range of float values */\n\n    _this.min = 0;\n    /** Gets or set a value used to limit the range of float values */\n\n    _this.max = 0;\n    /** Gets or set a value indicating that this input can only get 0 and 1 values */\n\n    _this.isBoolean = false;\n    /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */\n\n    _this.matrixMode = 0;\n    /** @hidden */\n\n    _this._systemValue = null;\n    /** Gets or sets a boolean indicating that the value of this input will not change after a build */\n\n    _this.isConstant = false;\n    /** Gets or sets the group to use to display this block in the Inspector */\n\n    _this.groupInInspector = \"\";\n    /** Gets an observable raised when the value is changed */\n\n    _this.onValueChangedObservable = new Observable();\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space (for color3/4 only) */\n\n    _this.convertToGammaSpace = false;\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space (for color3/4 only) */\n\n    _this.convertToLinearSpace = false;\n    _this._type = type;\n\n    _this.setDefaultValue();\n\n    _this.registerOutput(\"output\", type);\n\n    return _this;\n  }\n\n  Object.defineProperty(InputBlock.prototype, \"type\", {\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\n    get: function get() {\n      if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n        if (this.isUniform && this.value != null) {\n          if (!isNaN(this.value)) {\n            this._type = NodeMaterialBlockConnectionPointTypes.Float;\n            return this._type;\n          }\n\n          switch (this.value.getClassName()) {\n            case \"Vector2\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\n              return this._type;\n\n            case \"Vector3\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n              return this._type;\n\n            case \"Vector4\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n              return this._type;\n\n            case \"Color3\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Color3;\n              return this._type;\n\n            case \"Color4\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Color4;\n              return this._type;\n\n            case \"Matrix\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\n              return this._type;\n          }\n        }\n\n        if (this.isAttribute) {\n          switch (this.name) {\n            case \"position\":\n            case \"normal\":\n            case \"tangent\":\n            case \"particle_positionw\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n              return this._type;\n\n            case \"uv\":\n            case \"uv2\":\n            case \"position2d\":\n            case \"particle_uv\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\n              return this._type;\n\n            case \"matricesIndices\":\n            case \"matricesWeights\":\n            case \"world0\":\n            case \"world1\":\n            case \"world2\":\n            case \"world3\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n              return this._type;\n\n            case \"color\":\n            case \"particle_color\":\n            case \"particle_texturemask\":\n              this._type = NodeMaterialBlockConnectionPointTypes.Color4;\n              return this._type;\n          }\n        }\n\n        if (this.isSystemValue) {\n          switch (this._systemValue) {\n            case NodeMaterialSystemValues.World:\n            case NodeMaterialSystemValues.WorldView:\n            case NodeMaterialSystemValues.WorldViewProjection:\n            case NodeMaterialSystemValues.View:\n            case NodeMaterialSystemValues.ViewProjection:\n            case NodeMaterialSystemValues.Projection:\n              this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\n              return this._type;\n\n            case NodeMaterialSystemValues.CameraPosition:\n              this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n              return this._type;\n\n            case NodeMaterialSystemValues.FogColor:\n              this._type = NodeMaterialBlockConnectionPointTypes.Color3;\n              return this._type;\n\n            case NodeMaterialSystemValues.DeltaTime:\n              this._type = NodeMaterialBlockConnectionPointTypes.Float;\n              return this._type;\n          }\n        }\n      }\n\n      return this._type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n  * Validates if a name is a reserve word.\r\n  * @param newName the new name to be given to the node.\r\n  * @returns false if the name is a reserve word, else true.\r\n  */\n\n  InputBlock.prototype.validateBlockName = function (newName) {\n    if (!this.isAttribute) {\n      return _super.prototype.validateBlockName.call(this, newName);\n    }\n\n    return true;\n  };\n\n  Object.defineProperty(InputBlock.prototype, \"output\", {\n    /**\r\n     * Gets the output component\r\n     */\n    get: function get() {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Set the source of this connection point to a vertex attribute\r\n   * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name\r\n   * @returns the current connection point\r\n   */\n\n  InputBlock.prototype.setAsAttribute = function (attributeName) {\n    this._mode = NodeMaterialBlockConnectionPointMode.Attribute;\n\n    if (attributeName) {\n      this.name = attributeName;\n    }\n\n    return this;\n  };\n  /**\r\n   * Set the source of this connection point to a system value\r\n   * @param value define the system value to use (world, view, etc...) or null to switch to manual value\r\n   * @returns the current connection point\r\n   */\n\n\n  InputBlock.prototype.setAsSystemValue = function (value) {\n    this.systemValue = value;\n    return this;\n  };\n\n  Object.defineProperty(InputBlock.prototype, \"value\", {\n    /**\r\n     * Gets or sets the value of that point.\r\n     * Please note that this value will be ignored if valueCallback is defined\r\n     */\n    get: function get() {\n      return this._storedValue;\n    },\n    set: function set(value) {\n      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n        if (this.isBoolean) {\n          value = value ? 1 : 0;\n        } else if (this.min !== this.max) {\n          value = Math.max(this.min, value);\n          value = Math.min(this.max, value);\n        }\n      }\n\n      this._storedValue = value;\n      this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n      this.onValueChangedObservable.notifyObservers(this);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"valueCallback\", {\n    /**\r\n     * Gets or sets a callback used to get the value of that point.\r\n     * Please note that setting this value will force the connection point to ignore the value property\r\n     */\n    get: function get() {\n      return this._valueCallback;\n    },\n    set: function set(value) {\n      this._valueCallback = value;\n      this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"associatedVariableName\", {\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\n    get: function get() {\n      return this._associatedVariableName;\n    },\n    set: function set(value) {\n      this._associatedVariableName = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"animationType\", {\n    /** Gets or sets the type of animation applied to the input */\n    get: function get() {\n      return this._animationType;\n    },\n    set: function set(value) {\n      this._animationType = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"isUndefined\", {\n    /**\r\n     * Gets a boolean indicating that this connection point not defined yet\r\n     */\n    get: function get() {\n      return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"isUniform\", {\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an uniform.\r\n     * In this case the connection point name must be the name of the uniform to use.\r\n     * Can only be set on inputs\r\n     */\n    get: function get() {\n      return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;\n    },\n    set: function set(value) {\n      this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;\n      this.associatedVariableName = \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"isAttribute\", {\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an attribute.\r\n     * In this case the connection point name must be the name of the attribute to use\r\n     * Can only be set on inputs\r\n     */\n    get: function get() {\n      return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;\n    },\n    set: function set(value) {\n      this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;\n      this.associatedVariableName = \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"isVarying\", {\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is generating a varying variable.\r\n     * Can only be set on exit points\r\n     */\n    get: function get() {\n      return this._mode === NodeMaterialBlockConnectionPointMode.Varying;\n    },\n    set: function set(value) {\n      this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;\n      this.associatedVariableName = \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"isSystemValue\", {\n    /**\r\n     * Gets a boolean indicating that the current connection point is a system value\r\n     */\n    get: function get() {\n      return this._systemValue != null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputBlock.prototype, \"systemValue\", {\n    /**\r\n     * Gets or sets the current well known value or null if not defined as a system value\r\n     */\n    get: function get() {\n      return this._systemValue;\n    },\n    set: function set(value) {\n      this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n      this.associatedVariableName = \"\";\n      this._systemValue = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n  InputBlock.prototype.getClassName = function () {\n    return \"InputBlock\";\n  };\n  /**\r\n   * Animate the input if animationType !== None\r\n   * @param scene defines the rendering scene\r\n   */\n\n\n  InputBlock.prototype.animate = function (scene) {\n    switch (this._animationType) {\n      case AnimatedInputBlockTypes.Time:\n        {\n          if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n            this.value += scene.getAnimationRatio() * 0.01;\n          }\n\n          break;\n        }\n    }\n  };\n\n  InputBlock.prototype._emitDefine = function (define) {\n    if (define[0] === \"!\") {\n      return \"#ifndef \" + define.substring(1) + \"\\r\\n\";\n    }\n\n    return \"#ifdef \" + define + \"\\r\\n\";\n  };\n\n  InputBlock.prototype.initialize = function (state) {\n    this.associatedVariableName = \"\";\n  };\n  /**\r\n   * Set the input block to its default value (based on its type)\r\n   */\n\n\n  InputBlock.prototype.setDefaultValue = function () {\n    switch (this.type) {\n      case NodeMaterialBlockConnectionPointTypes.Float:\n        this.value = 0;\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Vector2:\n        this.value = Vector2.Zero();\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        this.value = Vector3.Zero();\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        this.value = Vector4.Zero();\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        this.value = Color3.White();\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        this.value = new Color4(1, 1, 1, 1);\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Matrix:\n        this.value = Matrix.Identity();\n        break;\n    }\n  };\n\n  InputBlock.prototype._emitConstant = function (state) {\n    switch (this.type) {\n      case NodeMaterialBlockConnectionPointTypes.Float:\n        return \"\" + state._emitFloat(this.value);\n\n      case NodeMaterialBlockConnectionPointTypes.Vector2:\n        return \"vec2(\" + this.value.x + \", \" + this.value.y + \")\";\n\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        return \"vec3(\" + this.value.x + \", \" + this.value.y + \", \" + this.value.z + \")\";\n\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        return \"vec4(\" + this.value.x + \", \" + this.value.y + \", \" + this.value.z + \", \" + this.value.w + \")\";\n\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\n\n        if (this.convertToGammaSpace) {\n          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);\n        }\n\n        if (this.convertToLinearSpace) {\n          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);\n        }\n\n        return \"vec3(\" + TmpColors.Color3[0].r + \", \" + TmpColors.Color3[0].g + \", \" + TmpColors.Color3[0].b + \")\";\n\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\n\n        if (this.convertToGammaSpace) {\n          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);\n        }\n\n        if (this.convertToLinearSpace) {\n          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);\n        }\n\n        return \"vec4(\" + TmpColors.Color4[0].r + \", \" + TmpColors.Color4[0].g + \", \" + TmpColors.Color4[0].b + \", \" + TmpColors.Color4[0].a + \")\";\n    }\n\n    return \"\";\n  };\n\n  Object.defineProperty(InputBlock.prototype, \"_noContextSwitch\", {\n    /** @hidden */\n    get: function get() {\n      return attributeInFragmentOnly[this.name];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InputBlock.prototype._emit = function (state, define) {\n    var _a; // Uniforms\n\n\n    if (this.isUniform) {\n      if (!this.associatedVariableName) {\n        this.associatedVariableName = state._getFreeVariableName(\"u_\" + this.name);\n      }\n\n      if (this.isConstant) {\n        if (state.constants.indexOf(this.associatedVariableName) !== -1) {\n          return;\n        }\n\n        state.constants.push(this.associatedVariableName);\n        state._constantDeclaration += this._declareOutput(this.output, state) + (\" = \" + this._emitConstant(state) + \";\\r\\n\");\n        return;\n      }\n\n      if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {\n        return;\n      }\n\n      state.uniforms.push(this.associatedVariableName);\n\n      if (define) {\n        state._uniformDeclaration += this._emitDefine(define);\n      }\n\n      state._uniformDeclaration += \"uniform \" + state._getGLType(this.type) + \" \" + this.associatedVariableName + \";\\r\\n\";\n\n      if (define) {\n        state._uniformDeclaration += \"#endif\\r\\n\";\n      } // well known\n\n\n      var hints = state.sharedData.hints;\n\n      if (this._systemValue !== null && this._systemValue !== undefined) {\n        switch (this._systemValue) {\n          case NodeMaterialSystemValues.WorldView:\n            hints.needWorldViewMatrix = true;\n            break;\n\n          case NodeMaterialSystemValues.WorldViewProjection:\n            hints.needWorldViewProjectionMatrix = true;\n            break;\n        }\n      } else {\n        if (this._animationType !== AnimatedInputBlockTypes.None) {\n          state.sharedData.animatedInputs.push(this);\n        }\n      }\n\n      return;\n    } // Attribute\n\n\n    if (this.isAttribute) {\n      this.associatedVariableName = (_a = remapAttributeName[this.name]) !== null && _a !== void 0 ? _a : this.name;\n\n      if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {\n        // Attribute for fragment need to be carried over by varyings\n        if (attributeInFragmentOnly[this.name]) {\n          if (attributeAsUniform[this.name]) {\n            state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\n          } else {\n            state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\n          }\n        } else {\n          this._emit(state._vertexState, define);\n        }\n\n        return;\n      }\n\n      if (state.attributes.indexOf(this.associatedVariableName) !== -1) {\n        return;\n      }\n\n      state.attributes.push(this.associatedVariableName);\n\n      if (attributeInFragmentOnly[this.name]) {\n        if (attributeAsUniform[this.name]) {\n          state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\n        } else {\n          state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\n        }\n      } else {\n        if (define) {\n          state._attributeDeclaration += this._emitDefine(define);\n        }\n\n        state._attributeDeclaration += \"attribute \" + state._getGLType(this.type) + \" \" + this.associatedVariableName + \";\\r\\n\";\n\n        if (define) {\n          state._attributeDeclaration += \"#endif\\r\\n\";\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  InputBlock.prototype._transmitWorld = function (effect, world, worldView, worldViewProjection) {\n    if (!this._systemValue) {\n      return;\n    }\n\n    var variableName = this.associatedVariableName;\n\n    switch (this._systemValue) {\n      case NodeMaterialSystemValues.World:\n        effect.setMatrix(variableName, world);\n        break;\n\n      case NodeMaterialSystemValues.WorldView:\n        effect.setMatrix(variableName, worldView);\n        break;\n\n      case NodeMaterialSystemValues.WorldViewProjection:\n        effect.setMatrix(variableName, worldViewProjection);\n        break;\n    }\n  };\n  /** @hidden */\n\n\n  InputBlock.prototype._transmit = function (effect, scene) {\n    if (this.isAttribute) {\n      return;\n    }\n\n    var variableName = this.associatedVariableName;\n\n    if (this._systemValue) {\n      switch (this._systemValue) {\n        case NodeMaterialSystemValues.World:\n        case NodeMaterialSystemValues.WorldView:\n        case NodeMaterialSystemValues.WorldViewProjection:\n          return;\n\n        case NodeMaterialSystemValues.View:\n          effect.setMatrix(variableName, scene.getViewMatrix());\n          break;\n\n        case NodeMaterialSystemValues.Projection:\n          effect.setMatrix(variableName, scene.getProjectionMatrix());\n          break;\n\n        case NodeMaterialSystemValues.ViewProjection:\n          effect.setMatrix(variableName, scene.getTransformMatrix());\n          break;\n\n        case NodeMaterialSystemValues.CameraPosition:\n          MaterialHelper.BindEyePosition(effect, scene, variableName);\n          break;\n\n        case NodeMaterialSystemValues.FogColor:\n          effect.setColor3(variableName, scene.fogColor);\n          break;\n\n        case NodeMaterialSystemValues.DeltaTime:\n          effect.setFloat(variableName, scene.deltaTime / 1000.0);\n      }\n\n      return;\n    }\n\n    var value = this._valueCallback ? this._valueCallback() : this._storedValue;\n\n    if (value === null) {\n      return;\n    }\n\n    switch (this.type) {\n      case NodeMaterialBlockConnectionPointTypes.Float:\n        effect.setFloat(variableName, value);\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Int:\n        effect.setInt(variableName, value);\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\n\n        if (this.convertToGammaSpace) {\n          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0]);\n        }\n\n        if (this.convertToLinearSpace) {\n          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0]);\n        }\n\n        effect.setColor3(variableName, TmpColors.Color3[0]);\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\n\n        if (this.convertToGammaSpace) {\n          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0]);\n        }\n\n        if (this.convertToLinearSpace) {\n          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0]);\n        }\n\n        effect.setDirectColor4(variableName, TmpColors.Color4[0]);\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Vector2:\n        effect.setVector2(variableName, value);\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        effect.setVector3(variableName, value);\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        effect.setVector4(variableName, value);\n        break;\n\n      case NodeMaterialBlockConnectionPointTypes.Matrix:\n        effect.setMatrix(variableName, value);\n        break;\n    }\n  };\n\n  InputBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (this.isUniform || this.isSystemValue) {\n      state.sharedData.inputBlocks.push(this);\n    }\n\n    this._emit(state);\n  };\n\n  InputBlock.prototype._dumpPropertiesCode = function () {\n    var variableName = this._codeVariableName;\n\n    if (this.isAttribute) {\n      return variableName + \".setAsAttribute(\\\"\" + this.name + \"\\\");\\r\\n\";\n    }\n\n    if (this.isSystemValue) {\n      return variableName + \".setAsSystemValue(BABYLON.NodeMaterialSystemValues.\" + NodeMaterialSystemValues[this._systemValue] + \");\\r\\n\";\n    }\n\n    if (this.isUniform) {\n      var codes = [];\n      var valueString = \"\";\n\n      switch (this.type) {\n        case NodeMaterialBlockConnectionPointTypes.Float:\n          valueString = \"\" + this.value;\n          break;\n\n        case NodeMaterialBlockConnectionPointTypes.Vector2:\n          valueString = \"new BABYLON.Vector2(\" + this.value.x + \", \" + this.value.y + \")\";\n          break;\n\n        case NodeMaterialBlockConnectionPointTypes.Vector3:\n          valueString = \"new BABYLON.Vector3(\" + this.value.x + \", \" + this.value.y + \", \" + this.value.z + \")\";\n          break;\n\n        case NodeMaterialBlockConnectionPointTypes.Vector4:\n          valueString = \"new BABYLON.Vector4(\" + this.value.x + \", \" + this.value.y + \", \" + this.value.z + \", \" + this.value.w + \")\";\n          break;\n\n        case NodeMaterialBlockConnectionPointTypes.Color3:\n          valueString = \"new BABYLON.Color3(\" + this.value.r + \", \" + this.value.g + \", \" + this.value.b + \")\";\n\n          if (this.convertToGammaSpace) {\n            valueString += \".toGammaSpace()\";\n          }\n\n          if (this.convertToLinearSpace) {\n            valueString += \".toLinearSpace()\";\n          }\n\n          break;\n\n        case NodeMaterialBlockConnectionPointTypes.Color4:\n          valueString = \"new BABYLON.Color4(\" + this.value.r + \", \" + this.value.g + \", \" + this.value.b + \", \" + this.value.a + \")\";\n\n          if (this.convertToGammaSpace) {\n            valueString += \".toGammaSpace()\";\n          }\n\n          if (this.convertToLinearSpace) {\n            valueString += \".toLinearSpace()\";\n          }\n\n          break;\n\n        case NodeMaterialBlockConnectionPointTypes.Matrix:\n          valueString = \"BABYLON.Matrix.FromArray([\" + this.value.m + \"])\";\n          break;\n      } // Common Property \"Value\"\n\n\n      codes.push(variableName + \".value = \" + valueString); // Float-Value-Specific Properties\n\n      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n        codes.push(variableName + \".min = \" + this.min, variableName + \".max = \" + this.max, variableName + \".isBoolean = \" + this.isBoolean, variableName + \".matrixMode = \" + this.matrixMode, variableName + \".animationType = BABYLON.AnimatedInputBlockTypes.\" + AnimatedInputBlockTypes[this.animationType]);\n      } // Common Property \"Type\"\n\n\n      codes.push(variableName + \".isConstant = \" + this.isConstant);\n      codes.push('');\n      return codes.join(';\\r\\n');\n    }\n\n    return \"\";\n  };\n\n  InputBlock.prototype.dispose = function () {\n    this.onValueChangedObservable.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  InputBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.type = this.type;\n    serializationObject.mode = this._mode;\n    serializationObject.systemValue = this._systemValue;\n    serializationObject.animationType = this._animationType;\n    serializationObject.min = this.min;\n    serializationObject.max = this.max;\n    serializationObject.isBoolean = this.isBoolean;\n    serializationObject.matrixMode = this.matrixMode;\n    serializationObject.isConstant = this.isConstant;\n    serializationObject.groupInInspector = this.groupInInspector;\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n\n    if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {\n      if (this._storedValue.asArray) {\n        serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\n        serializationObject.value = this._storedValue.asArray();\n      } else {\n        serializationObject.valueType = \"number\";\n        serializationObject.value = this._storedValue;\n      }\n    }\n\n    return serializationObject;\n  };\n\n  InputBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    this._mode = serializationObject.mode;\n\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this._type = serializationObject.type;\n    this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;\n    this._animationType = serializationObject.animationType;\n    this.min = serializationObject.min || 0;\n    this.max = serializationObject.max || 0;\n    this.isBoolean = !!serializationObject.isBoolean;\n    this.matrixMode = serializationObject.matrixMode || 0;\n    this.isConstant = !!serializationObject.isConstant;\n    this.groupInInspector = serializationObject.groupInInspector || \"\";\n    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n\n    if (!serializationObject.valueType) {\n      return;\n    }\n\n    if (serializationObject.valueType === \"number\") {\n      this._storedValue = serializationObject.value;\n    } else {\n      var valueType = _TypeStore.GetClass(serializationObject.valueType);\n\n      if (valueType) {\n        this._storedValue = valueType.FromArray(serializationObject.value);\n      }\n    }\n  };\n\n  return InputBlock;\n}(NodeMaterialBlock);\n\nexport { InputBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.InputBlock\"] = InputBlock;","map":null,"metadata":{},"sourceType":"module"}