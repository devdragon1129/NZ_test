{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _taggedTemplateLiteral = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\n\nvar codegen_1 = require(\"./codegen\");\n\nvar code_1 = require(\"./codegen/code\"); // TODO refactor to use Set\n\n\nfunction toHash(arr) {\n  var hash = {};\n\n  var _iterator = _createForOfIteratorHelper(arr),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      hash[item] = true;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return hash;\n}\n\nexports.toHash = toHash;\n\nfunction alwaysValidSchema(it, schema) {\n  if (typeof schema == \"boolean\") return schema;\n  if (Object.keys(schema).length === 0) return true;\n  checkUnknownRules(it, schema);\n  return !schemaHasRules(schema, it.self.RULES.all);\n}\n\nexports.alwaysValidSchema = alwaysValidSchema;\n\nfunction checkUnknownRules(it) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : it.schema;\n  var opts = it.opts,\n      self = it.self;\n  if (!opts.strictSchema) return;\n  if (typeof schema === \"boolean\") return;\n  var rules = self.RULES.keywords;\n\n  for (var key in schema) {\n    if (!rules[key]) checkStrictMode(it, \"unknown keyword: \\\"\".concat(key, \"\\\"\"));\n  }\n}\n\nexports.checkUnknownRules = checkUnknownRules;\n\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (var key in schema) {\n    if (rules[key]) return true;\n  }\n\n  return false;\n}\n\nexports.schemaHasRules = schemaHasRules;\n\nfunction schemaHasRulesButRef(schema, RULES) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (var key in schema) {\n    if (key !== \"$ref\" && RULES.all[key]) return true;\n  }\n\n  return false;\n}\n\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\n\nfunction schemaRefOrVal(_ref, schema, keyword, $data) {\n  var topSchemaRef = _ref.topSchemaRef,\n      schemaPath = _ref.schemaPath;\n\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema;\n    if (typeof schema == \"string\") return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \"\"])), schema);\n  }\n\n  return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\", \"\", \"\"])), topSchemaRef, schemaPath, (0, codegen_1.getProperty)(keyword));\n}\n\nexports.schemaRefOrVal = schemaRefOrVal;\n\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\n\nexports.unescapeFragment = unescapeFragment;\n\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\n\nexports.escapeFragment = escapeFragment;\n\nfunction escapeJsonPointer(str) {\n  if (typeof str == \"number\") return \"\".concat(str);\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n\nexports.escapeJsonPointer = escapeJsonPointer;\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\nexports.unescapeJsonPointer = unescapeJsonPointer;\n\nfunction eachItem(xs, f) {\n  if (Array.isArray(xs)) {\n    var _iterator2 = _createForOfIteratorHelper(xs),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var x = _step2.value;\n        f(x);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } else {\n    f(xs);\n  }\n}\n\nexports.eachItem = eachItem;\n\nfunction makeMergeEvaluated(_ref2) {\n  var mergeNames = _ref2.mergeNames,\n      mergeToName = _ref2.mergeToName,\n      mergeValues = _ref2.mergeValues,\n      resultToName = _ref2.resultToName;\n  return function (gen, from, to, toName) {\n    var res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n    return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n  };\n}\n\nexports.mergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: function mergeNames(gen, from, to) {\n      return gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" !== true && \", \" !== undefined\"])), to, from), function () {\n        gen.if((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === true\"])), from), function () {\n          return gen.assign(to, true);\n        }, function () {\n          return gen.assign(to, (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" || {}\"])), to)).code((0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"Object.assign(\", \", \", \")\"])), to, from));\n        });\n      });\n    },\n    mergeToName: function mergeToName(gen, from, to) {\n      return gen.if((0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \" !== true\"])), to), function () {\n        if (from === true) {\n          gen.assign(to, true);\n        } else {\n          gen.assign(to, (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" || {}\"])), to));\n          setEvaluated(gen, to, from);\n        }\n      });\n    },\n    mergeValues: function mergeValues(from, to) {\n      return from === true ? true : _objectSpread({}, from, to);\n    },\n    resultToName: evaluatedPropsToName\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: function mergeNames(gen, from, to) {\n      return gen.if((0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \" !== true && \", \" !== undefined\"])), to, from), function () {\n        return gen.assign(to, (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" === true ? true : \", \" > \", \" ? \", \" : \", \"\"])), from, to, from, to, from));\n      });\n    },\n    mergeToName: function mergeToName(gen, from, to) {\n      return gen.if((0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \" !== true\"])), to), function () {\n        return gen.assign(to, from === true ? true : (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" > \", \" ? \", \" : \", \"\"])), to, from, to, from));\n      });\n    },\n    mergeValues: function mergeValues(from, to) {\n      return from === true ? true : Math.max(from, to);\n    },\n    resultToName: function resultToName(gen, items) {\n      return gen.var(\"items\", items);\n    }\n  })\n};\n\nfunction evaluatedPropsToName(gen, ps) {\n  if (ps === true) return gen.var(\"props\", true);\n  var props = gen.var(\"props\", (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"{}\"]))));\n  if (ps !== undefined) setEvaluated(gen, props, ps);\n  return props;\n}\n\nexports.evaluatedPropsToName = evaluatedPropsToName;\n\nfunction setEvaluated(gen, props, ps) {\n  Object.keys(ps).forEach(function (p) {\n    return gen.assign((0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \"\", \"\"])), props, (0, codegen_1.getProperty)(p)), true);\n  });\n}\n\nexports.setEvaluated = setEvaluated;\nvar snippets = {};\n\nfunction useFunc(gen, f) {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n  });\n}\n\nexports.useFunc = useFunc;\nvar Type;\n\n(function (Type) {\n  Type[Type[\"Num\"] = 0] = \"Num\";\n  Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\n\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n  // let path\n  if (dataProp instanceof codegen_1.Name) {\n    var isNumber = dataPropType === Type.Num;\n    return jsPropertySyntax ? isNumber ? (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\\\"[\\\" + \", \" + \\\"]\\\"\"])), dataProp) : (0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\\\"['\\\" + \", \" + \\\"']\\\"\"])), dataProp) : isNumber ? (0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\\\"/\\\" + \", \"\"])), dataProp) : (0, codegen_1._)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"\\\"/\\\" + \", \".replace(/~/g, \\\"~0\\\").replace(/\\\\//g, \\\"~1\\\")\"], [\"\\\"/\\\" + \", \".replace(/~/g, \\\"~0\\\").replace(/\\\\\\\\//g, \\\"~1\\\")\"])), dataProp); // TODO maybe use global escapePointer\n  }\n\n  return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\n\nexports.getErrorPath = getErrorPath;\n\nfunction checkStrictMode(it, msg) {\n  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : it.opts.strictSchema;\n  if (!mode) return;\n  msg = \"strict mode: \".concat(msg);\n  if (mode === true) throw new Error(msg);\n  it.self.logger.warn(msg);\n}\n\nexports.checkStrictMode = checkStrictMode;","map":null,"metadata":{},"sourceType":"script"}