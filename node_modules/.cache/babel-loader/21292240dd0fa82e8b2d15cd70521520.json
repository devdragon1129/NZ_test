{"ast":null,"code":"import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { RibbonBuilder } from \"./ribbonBuilder\";\nimport { Path3D } from '../../Maths/math.path';\n\nMesh.ExtrudeShape = function (name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    shape: shape,\n    path: path,\n    scale: scale,\n    rotation: rotation,\n    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n    sideOrientation: sideOrientation,\n    instance: instance,\n    updatable: updatable\n  };\n  return ShapeBuilder.ExtrudeShape(name, options, scene);\n};\n\nMesh.ExtrudeShapeCustom = function (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {\n  var options = {\n    shape: shape,\n    path: path,\n    scaleFunction: scaleFunction,\n    rotationFunction: rotationFunction,\n    ribbonCloseArray: ribbonCloseArray,\n    ribbonClosePath: ribbonClosePath,\n    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n    sideOrientation: sideOrientation,\n    instance: instance,\n    updatable: updatable\n  };\n  return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar ShapeBuilder =\n/** @class */\nfunction () {\n  function ShapeBuilder() {}\n  /**\r\n   * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n   * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n   * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n   * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n   * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n   * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n   * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n   * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the extruded shape mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n   */\n\n\n  ShapeBuilder.ExtrudeShape = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var path = options.path;\n    var shape = options.shape;\n    var scale = options.scale || 1;\n    var rotation = options.rotation || 0;\n    var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n    var updatable = options.updatable;\n\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n    var instance = options.instance || null;\n    var invertUV = options.invertUV || false;\n    return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\n  };\n  /**\r\n   * Creates an custom extruded shape mesh.\r\n   * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n   * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n   * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n   * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n   * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n   * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n   * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n   * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n   * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`\r\n   * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n   * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n   * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the custom extruded shape mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n   */\n\n\n  ShapeBuilder.ExtrudeShapeCustom = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var path = options.path;\n    var shape = options.shape;\n\n    var scaleFunction = options.scaleFunction || function () {\n      return 1;\n    };\n\n    var rotationFunction = options.rotationFunction || function () {\n      return 0;\n    };\n\n    var ribbonCloseArray = options.ribbonCloseArray || false;\n    var ribbonClosePath = options.ribbonClosePath || false;\n    var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n    var updatable = options.updatable;\n\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n    var instance = options.instance;\n    var invertUV = options.invertUV || false;\n    return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\n  };\n\n  ShapeBuilder._ExtrudeShapeGeneric = function (name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs) {\n    // extrusion geometry\n    var extrusionPathArray = function extrusionPathArray(shape, curve, path3D, shapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom) {\n      var tangents = path3D.getTangents();\n      var normals = path3D.getNormals();\n      var binormals = path3D.getBinormals();\n      var distances = path3D.getDistances();\n      var angle = 0;\n\n      var returnScale = function returnScale() {\n        return scale !== null ? scale : 1;\n      };\n\n      var returnRotation = function returnRotation() {\n        return rotation !== null ? rotation : 0;\n      };\n\n      var rotate = custom && rotateFunction ? rotateFunction : returnRotation;\n      var scl = custom && scaleFunction ? scaleFunction : returnScale;\n      var index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n      var rotationMatrix = TmpVectors.Matrix[0];\n\n      for (var i = 0; i < curve.length; i++) {\n        var shapePath = new Array();\n        var angleStep = rotate(i, distances[i]);\n        var scaleRatio = scl(i, distances[i]);\n\n        for (var p = 0; p < shape.length; p++) {\n          Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\n          var planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\n          var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\n          Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\n          rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\n          shapePath[p] = rotated;\n        }\n\n        shapePaths[index] = shapePath;\n        angle += angleStep;\n        index++;\n      } // cap\n\n\n      var capPath = function capPath(shapePath) {\n        var pointCap = Array();\n        var barycenter = Vector3.Zero();\n        var i;\n\n        for (i = 0; i < shapePath.length; i++) {\n          barycenter.addInPlace(shapePath[i]);\n        }\n\n        barycenter.scaleInPlace(1.0 / shapePath.length);\n\n        for (i = 0; i < shapePath.length; i++) {\n          pointCap.push(barycenter);\n        }\n\n        return pointCap;\n      };\n\n      switch (cap) {\n        case Mesh.NO_CAP:\n          break;\n\n        case Mesh.CAP_START:\n          shapePaths[0] = capPath(shapePaths[2]);\n          shapePaths[1] = shapePaths[2];\n          break;\n\n        case Mesh.CAP_END:\n          shapePaths[index] = shapePaths[index - 1];\n          shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n          break;\n\n        case Mesh.CAP_ALL:\n          shapePaths[0] = capPath(shapePaths[2]);\n          shapePaths[1] = shapePaths[2];\n          shapePaths[index] = shapePaths[index - 1];\n          shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n          break;\n\n        default:\n          break;\n      }\n\n      return shapePaths;\n    };\n\n    var path3D;\n    var pathArray;\n\n    if (instance) {\n      // instance update\n      var storage = instance._creationDataStorage;\n      path3D = storage.path3D.update(curve);\n      pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\n      instance = Mesh.CreateRibbon(\"\", pathArray, false, false, 0, scene || undefined, false, 0, instance);\n      return instance;\n    } // extruded shape creation\n\n\n    path3D = new Path3D(curve);\n    var newShapePaths = new Array();\n    cap = cap < 0 || cap > 3 ? 0 : cap;\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\n    var extrudedGeneric = RibbonBuilder.CreateRibbon(name, {\n      pathArray: pathArray,\n      closeArray: rbCA,\n      closePath: rbCP,\n      updatable: updtbl,\n      sideOrientation: side,\n      invertUV: invertUV,\n      frontUVs: frontUVs || undefined,\n      backUVs: backUVs || undefined\n    }, scene);\n    extrudedGeneric._creationDataStorage.pathArray = pathArray;\n    extrudedGeneric._creationDataStorage.path3D = path3D;\n    extrudedGeneric._creationDataStorage.cap = cap;\n    return extrudedGeneric;\n  };\n\n  return ShapeBuilder;\n}();\n\nexport { ShapeBuilder };","map":null,"metadata":{},"sourceType":"module"}