{"ast":null,"code":"import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray\";\nimport { Vector3 } from \"../Maths/math.vector\";\n/**\r\n * This represents the object necessary to create a rendering group.\r\n * This is exclusively used and created by the rendering manager.\r\n * To modify the behavior, you use the available helpers in your scene or meshes.\r\n * @hidden\r\n */\n\nvar RenderingGroup =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new rendering group.\r\n   * @param index The rendering group index\r\n   * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\r\n   * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\r\n   * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\r\n   */\n  function RenderingGroup(index, scene, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this.index = index;\n    this._opaqueSubMeshes = new SmartArray(256);\n    this._transparentSubMeshes = new SmartArray(256);\n    this._alphaTestSubMeshes = new SmartArray(256);\n    this._depthOnlySubMeshes = new SmartArray(256);\n    this._particleSystems = new SmartArray(256);\n    this._spriteManagers = new SmartArray(256);\n    /** @hidden */\n\n    this._edgesRenderers = new SmartArrayNoDuplicate(16);\n    this._scene = scene;\n    this.opaqueSortCompareFn = opaqueSortCompareFn;\n    this.alphaTestSortCompareFn = alphaTestSortCompareFn;\n    this.transparentSortCompareFn = transparentSortCompareFn;\n  }\n\n  Object.defineProperty(RenderingGroup.prototype, \"opaqueSortCompareFn\", {\n    /**\r\n     * Set the opaque sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\n    set: function set(value) {\n      this._opaqueSortCompareFn = value;\n\n      if (value) {\n        this._renderOpaque = this.renderOpaqueSorted;\n      } else {\n        this._renderOpaque = RenderingGroup.renderUnsorted;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderingGroup.prototype, \"alphaTestSortCompareFn\", {\n    /**\r\n     * Set the alpha test sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\n    set: function set(value) {\n      this._alphaTestSortCompareFn = value;\n\n      if (value) {\n        this._renderAlphaTest = this.renderAlphaTestSorted;\n      } else {\n        this._renderAlphaTest = RenderingGroup.renderUnsorted;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderingGroup.prototype, \"transparentSortCompareFn\", {\n    /**\r\n     * Set the transparent sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\n    set: function set(value) {\n      if (value) {\n        this._transparentSortCompareFn = value;\n      } else {\n        this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\n      }\n\n      this._renderTransparent = this.renderTransparentSorted;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Render all the sub meshes contained in the group.\r\n   * @param customRenderFunction Used to override the default render behaviour of the group.\r\n   * @returns true if rendered some submeshes.\r\n   */\n\n  RenderingGroup.prototype.render = function (customRenderFunction, renderSprites, renderParticles, activeMeshes) {\n    if (customRenderFunction) {\n      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\n      return;\n    }\n\n    var engine = this._scene.getEngine(); // Depth only\n\n\n    if (this._depthOnlySubMeshes.length !== 0) {\n      engine.setColorWrite(false);\n\n      this._renderAlphaTest(this._depthOnlySubMeshes);\n\n      engine.setColorWrite(true);\n    } // Opaque\n\n\n    if (this._opaqueSubMeshes.length !== 0) {\n      this._renderOpaque(this._opaqueSubMeshes);\n    } // Alpha test\n\n\n    if (this._alphaTestSubMeshes.length !== 0) {\n      this._renderAlphaTest(this._alphaTestSubMeshes);\n    }\n\n    var stencilState = engine.getStencilBuffer();\n    engine.setStencilBuffer(false); // Sprites\n\n    if (renderSprites) {\n      this._renderSprites();\n    } // Particles\n\n\n    if (renderParticles) {\n      this._renderParticles(activeMeshes);\n    }\n\n    if (this.onBeforeTransparentRendering) {\n      this.onBeforeTransparentRendering();\n    } // Transparent\n\n\n    if (this._transparentSubMeshes.length !== 0) {\n      engine.setStencilBuffer(stencilState);\n\n      this._renderTransparent(this._transparentSubMeshes);\n\n      engine.setAlphaMode(0);\n    } // Set back stencil to false in case it changes before the edge renderer.\n\n\n    engine.setStencilBuffer(false); // Edges\n\n    if (this._edgesRenderers.length) {\n      for (var edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\n        this._edgesRenderers.data[edgesRendererIndex].render();\n      }\n\n      engine.setAlphaMode(0);\n    } // Restore Stencil state.\n\n\n    engine.setStencilBuffer(stencilState);\n  };\n  /**\r\n   * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\r\n   * @param subMeshes The submeshes to render\r\n   */\n\n\n  RenderingGroup.prototype.renderOpaqueSorted = function (subMeshes) {\n    return RenderingGroup.renderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\n  };\n  /**\r\n   * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\r\n   * @param subMeshes The submeshes to render\r\n   */\n\n\n  RenderingGroup.prototype.renderAlphaTestSorted = function (subMeshes) {\n    return RenderingGroup.renderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\n  };\n  /**\r\n   * Renders the opaque submeshes in the order from the transparentSortCompareFn.\r\n   * @param subMeshes The submeshes to render\r\n   */\n\n\n  RenderingGroup.prototype.renderTransparentSorted = function (subMeshes) {\n    return RenderingGroup.renderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\n  };\n  /**\r\n   * Renders the submeshes in a specified order.\r\n   * @param subMeshes The submeshes to sort before render\r\n   * @param sortCompareFn The comparison function use to sort\r\n   * @param cameraPosition The camera position use to preprocess the submeshes to help sorting\r\n   * @param transparent Specifies to activate blending if true\r\n   */\n\n\n  RenderingGroup.renderSorted = function (subMeshes, sortCompareFn, camera, transparent) {\n    var subIndex = 0;\n    var subMesh;\n    var cameraPosition = camera ? camera.globalPosition : RenderingGroup._zeroVector;\n\n    for (; subIndex < subMeshes.length; subIndex++) {\n      subMesh = subMeshes.data[subIndex];\n      subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\n      subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n    }\n\n    var sortedArray = subMeshes.data.slice(0, subMeshes.length);\n\n    if (sortCompareFn) {\n      sortedArray.sort(sortCompareFn);\n    }\n\n    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\n      subMesh = sortedArray[subIndex];\n\n      if (transparent) {\n        var material = subMesh.getMaterial();\n\n        if (material && material.needDepthPrePass) {\n          var engine = material.getScene().getEngine();\n          engine.setColorWrite(false);\n          engine.setAlphaMode(0);\n          subMesh.render(false);\n          engine.setColorWrite(true);\n        }\n      }\n\n      subMesh.render(transparent);\n    }\n  };\n  /**\r\n   * Renders the submeshes in the order they were dispatched (no sort applied).\r\n   * @param subMeshes The submeshes to render\r\n   */\n\n\n  RenderingGroup.renderUnsorted = function (subMeshes) {\n    for (var subIndex = 0; subIndex < subMeshes.length; subIndex++) {\n      var submesh = subMeshes.data[subIndex];\n      submesh.render(false);\n    }\n  };\n  /**\r\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n   * are rendered back to front if in the same alpha index.\r\n   *\r\n   * @param a The first submesh\r\n   * @param b The second submesh\r\n   * @returns The result of the comparison\r\n   */\n\n\n  RenderingGroup.defaultTransparentSortCompare = function (a, b) {\n    // Alpha index first\n    if (a._alphaIndex > b._alphaIndex) {\n      return 1;\n    }\n\n    if (a._alphaIndex < b._alphaIndex) {\n      return -1;\n    } // Then distance to camera\n\n\n    return RenderingGroup.backToFrontSortCompare(a, b);\n  };\n  /**\r\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n   * are rendered back to front.\r\n   *\r\n   * @param a The first submesh\r\n   * @param b The second submesh\r\n   * @returns The result of the comparison\r\n   */\n\n\n  RenderingGroup.backToFrontSortCompare = function (a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return 1;\n    }\n\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return -1;\n    }\n\n    return 0;\n  };\n  /**\r\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n   * are rendered front to back (prevent overdraw).\r\n   *\r\n   * @param a The first submesh\r\n   * @param b The second submesh\r\n   * @returns The result of the comparison\r\n   */\n\n\n  RenderingGroup.frontToBackSortCompare = function (a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return -1;\n    }\n\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return 1;\n    }\n\n    return 0;\n  };\n  /**\r\n   * Resets the different lists of submeshes to prepare a new frame.\r\n   */\n\n\n  RenderingGroup.prototype.prepare = function () {\n    this._opaqueSubMeshes.reset();\n\n    this._transparentSubMeshes.reset();\n\n    this._alphaTestSubMeshes.reset();\n\n    this._depthOnlySubMeshes.reset();\n\n    this._particleSystems.reset();\n\n    this._spriteManagers.reset();\n\n    this._edgesRenderers.reset();\n  };\n\n  RenderingGroup.prototype.dispose = function () {\n    this._opaqueSubMeshes.dispose();\n\n    this._transparentSubMeshes.dispose();\n\n    this._alphaTestSubMeshes.dispose();\n\n    this._depthOnlySubMeshes.dispose();\n\n    this._particleSystems.dispose();\n\n    this._spriteManagers.dispose();\n\n    this._edgesRenderers.dispose();\n  };\n  /**\r\n   * Inserts the submesh in its correct queue depending on its material.\r\n   * @param subMesh The submesh to dispatch\r\n   * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n   * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n   */\n\n\n  RenderingGroup.prototype.dispatch = function (subMesh, mesh, material) {\n    // Get mesh and materials if not provided\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n\n    if (material === undefined) {\n      material = subMesh.getMaterial();\n    }\n\n    if (material === null || material === undefined) {\n      return;\n    }\n\n    if (material.needAlphaBlendingForMesh(mesh)) {\n      // Transparent\n      this._transparentSubMeshes.push(subMesh);\n    } else if (material.needAlphaTesting()) {\n      // Alpha test\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n\n      this._alphaTestSubMeshes.push(subMesh);\n    } else {\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n\n      this._opaqueSubMeshes.push(subMesh); // Opaque\n\n    }\n\n    mesh._renderingGroup = this;\n\n    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\n      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\n    }\n  };\n\n  RenderingGroup.prototype.dispatchSprites = function (spriteManager) {\n    this._spriteManagers.push(spriteManager);\n  };\n\n  RenderingGroup.prototype.dispatchParticles = function (particleSystem) {\n    this._particleSystems.push(particleSystem);\n  };\n\n  RenderingGroup.prototype._renderParticles = function (activeMeshes) {\n    if (this._particleSystems.length === 0) {\n      return;\n    } // Particles\n\n\n    var activeCamera = this._scene.activeCamera;\n\n    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\n\n    for (var particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\n      var particleSystem = this._particleSystems.data[particleIndex];\n\n      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\n        continue;\n      }\n\n      var emitter = particleSystem.emitter;\n\n      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\n        this._scene._activeParticles.addCount(particleSystem.render(), false);\n      }\n    }\n\n    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\n  };\n\n  RenderingGroup.prototype._renderSprites = function () {\n    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\n      return;\n    } // Sprites\n\n\n    var activeCamera = this._scene.activeCamera;\n\n    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\n\n    for (var id = 0; id < this._spriteManagers.length; id++) {\n      var spriteManager = this._spriteManagers.data[id];\n\n      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\n        spriteManager.render();\n      }\n    }\n\n    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\n  };\n\n  RenderingGroup._zeroVector = Vector3.Zero();\n  return RenderingGroup;\n}();\n\nexport { RenderingGroup };","map":null,"metadata":{},"sourceType":"module"}