{"ast":null,"code":"import { Vector3, Vector4 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { _DevTools } from '../Misc/devTools';\nimport { Color4 } from '../Maths/math.color';\nimport { Logger } from '../Misc/logger';\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\n\nvar VertexData =\n/** @class */\nfunction () {\n  function VertexData() {}\n  /**\r\n   * Uses the passed data array to set the set the values for the specified kind of data\r\n   * @param data a linear array of floating numbers\r\n   * @param kind the type of data that is being set, eg positions, colors etc\r\n   */\n\n\n  VertexData.prototype.set = function (data, kind) {\n    if (!data.length) {\n      Logger.Warn(\"Setting vertex data kind '\" + kind + \"' with an empty array\");\n    }\n\n    switch (kind) {\n      case VertexBuffer.PositionKind:\n        this.positions = data;\n        break;\n\n      case VertexBuffer.NormalKind:\n        this.normals = data;\n        break;\n\n      case VertexBuffer.TangentKind:\n        this.tangents = data;\n        break;\n\n      case VertexBuffer.UVKind:\n        this.uvs = data;\n        break;\n\n      case VertexBuffer.UV2Kind:\n        this.uvs2 = data;\n        break;\n\n      case VertexBuffer.UV3Kind:\n        this.uvs3 = data;\n        break;\n\n      case VertexBuffer.UV4Kind:\n        this.uvs4 = data;\n        break;\n\n      case VertexBuffer.UV5Kind:\n        this.uvs5 = data;\n        break;\n\n      case VertexBuffer.UV6Kind:\n        this.uvs6 = data;\n        break;\n\n      case VertexBuffer.ColorKind:\n        this.colors = data;\n        break;\n\n      case VertexBuffer.MatricesIndicesKind:\n        this.matricesIndices = data;\n        break;\n\n      case VertexBuffer.MatricesWeightsKind:\n        this.matricesWeights = data;\n        break;\n\n      case VertexBuffer.MatricesIndicesExtraKind:\n        this.matricesIndicesExtra = data;\n        break;\n\n      case VertexBuffer.MatricesWeightsExtraKind:\n        this.matricesWeightsExtra = data;\n        break;\n    }\n  };\n  /**\r\n   * Associates the vertexData to the passed Mesh.\r\n   * Sets it as updatable or not (default `false`)\r\n   * @param mesh the mesh the vertexData is applied to\r\n   * @param updatable when used and having the value true allows new data to update the vertexData\r\n   * @returns the VertexData\r\n   */\n\n\n  VertexData.prototype.applyToMesh = function (mesh, updatable) {\n    this._applyTo(mesh, updatable);\n\n    return this;\n  };\n  /**\r\n   * Associates the vertexData to the passed Geometry.\r\n   * Sets it as updatable or not (default `false`)\r\n   * @param geometry the geometry the vertexData is applied to\r\n   * @param updatable when used and having the value true allows new data to update the vertexData\r\n   * @returns VertexData\r\n   */\n\n\n  VertexData.prototype.applyToGeometry = function (geometry, updatable) {\n    this._applyTo(geometry, updatable);\n\n    return this;\n  };\n  /**\r\n   * Updates the associated mesh\r\n   * @param mesh the mesh to be updated\r\n   * @param updateExtends when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false\r\n   * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false\r\n   * @returns VertexData\r\n   */\n\n\n  VertexData.prototype.updateMesh = function (mesh) {\n    this._update(mesh);\n\n    return this;\n  };\n  /**\r\n   * Updates the associated geometry\r\n   * @param geometry the geometry to be updated\r\n   * @param updateExtends when true BoundingInfo will be renewed when and if position kind is updated, optional with default false\r\n   * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false\r\n   * @returns VertexData.\r\n   */\n\n\n  VertexData.prototype.updateGeometry = function (geometry) {\n    this._update(geometry);\n\n    return this;\n  };\n\n  VertexData.prototype._applyTo = function (meshOrGeometry, updatable) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (this.positions) {\n      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\n    }\n\n    if (this.normals) {\n      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\n    }\n\n    if (this.tangents) {\n      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\n    }\n\n    if (this.uvs) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\n    }\n\n    if (this.uvs2) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\n    }\n\n    if (this.uvs3) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\n    }\n\n    if (this.uvs4) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\n    }\n\n    if (this.uvs5) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\n    }\n\n    if (this.uvs6) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\n    }\n\n    if (this.colors) {\n      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\n    }\n\n    if (this.matricesIndices) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\n    }\n\n    if (this.matricesWeights) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\n    }\n\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\n    }\n\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\n    }\n\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null, updatable);\n    } else {\n      meshOrGeometry.setIndices([], null);\n    }\n\n    return this;\n  };\n\n  VertexData.prototype._update = function (meshOrGeometry, updateExtends, makeItUnique) {\n    if (this.positions) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\n    }\n\n    if (this.normals) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\n    }\n\n    if (this.tangents) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs2) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs3) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs4) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs5) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs6) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\n    }\n\n    if (this.colors) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesIndices) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesWeights) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\n    }\n\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null);\n    }\n\n    return this;\n  };\n  /**\r\n   * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n   * @param matrix the transforming matrix\r\n   * @returns the VertexData\r\n   */\n\n\n  VertexData.prototype.transform = function (matrix) {\n    var flip = matrix.determinant() < 0;\n    var transformed = Vector3.Zero();\n    var index;\n\n    if (this.positions) {\n      var position = Vector3.Zero();\n\n      for (index = 0; index < this.positions.length; index += 3) {\n        Vector3.FromArrayToRef(this.positions, index, position);\n        Vector3.TransformCoordinatesToRef(position, matrix, transformed);\n        this.positions[index] = transformed.x;\n        this.positions[index + 1] = transformed.y;\n        this.positions[index + 2] = transformed.z;\n      }\n    }\n\n    if (this.normals) {\n      var normal = Vector3.Zero();\n\n      for (index = 0; index < this.normals.length; index += 3) {\n        Vector3.FromArrayToRef(this.normals, index, normal);\n        Vector3.TransformNormalToRef(normal, matrix, transformed);\n        this.normals[index] = transformed.x;\n        this.normals[index + 1] = transformed.y;\n        this.normals[index + 2] = transformed.z;\n      }\n    }\n\n    if (this.tangents) {\n      var tangent = Vector4.Zero();\n      var tangentTransformed = Vector4.Zero();\n\n      for (index = 0; index < this.tangents.length; index += 4) {\n        Vector4.FromArrayToRef(this.tangents, index, tangent);\n        Vector4.TransformNormalToRef(tangent, matrix, tangentTransformed);\n        this.tangents[index] = tangentTransformed.x;\n        this.tangents[index + 1] = tangentTransformed.y;\n        this.tangents[index + 2] = tangentTransformed.z;\n        this.tangents[index + 3] = tangentTransformed.w;\n      }\n    }\n\n    if (flip && this.indices) {\n      for (index = 0; index < this.indices.length; index += 3) {\n        var tmp = this.indices[index + 1];\n        this.indices[index + 1] = this.indices[index + 2];\n        this.indices[index + 2] = tmp;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Merges the passed VertexData into the current one\r\n   * @param other the VertexData to be merged into the current one\r\n   * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n   * @returns the modified VertexData\r\n   */\n\n\n  VertexData.prototype.merge = function (other, use32BitsIndices) {\n    if (use32BitsIndices === void 0) {\n      use32BitsIndices = false;\n    }\n\n    this._validate();\n\n    other._validate();\n\n    if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\n      throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\n    }\n\n    if (other.indices) {\n      if (!this.indices) {\n        this.indices = [];\n      }\n\n      var offset = this.positions ? this.positions.length / 3 : 0;\n      var isSrcTypedArray = this.indices.BYTES_PER_ELEMENT !== undefined;\n\n      if (isSrcTypedArray) {\n        var len = this.indices.length + other.indices.length;\n        var temp = use32BitsIndices || this.indices instanceof Uint32Array ? new Uint32Array(len) : new Uint16Array(len);\n        temp.set(this.indices);\n        var decal = this.indices.length;\n\n        for (var index = 0; index < other.indices.length; index++) {\n          temp[decal + index] = other.indices[index] + offset;\n        }\n\n        this.indices = temp;\n      } else {\n        for (var index = 0; index < other.indices.length; index++) {\n          this.indices.push(other.indices[index] + offset);\n        }\n      }\n    }\n\n    this.positions = this._mergeElement(this.positions, other.positions);\n    this.normals = this._mergeElement(this.normals, other.normals);\n    this.tangents = this._mergeElement(this.tangents, other.tangents);\n    this.uvs = this._mergeElement(this.uvs, other.uvs);\n    this.uvs2 = this._mergeElement(this.uvs2, other.uvs2);\n    this.uvs3 = this._mergeElement(this.uvs3, other.uvs3);\n    this.uvs4 = this._mergeElement(this.uvs4, other.uvs4);\n    this.uvs5 = this._mergeElement(this.uvs5, other.uvs5);\n    this.uvs6 = this._mergeElement(this.uvs6, other.uvs6);\n    this.colors = this._mergeElement(this.colors, other.colors);\n    this.matricesIndices = this._mergeElement(this.matricesIndices, other.matricesIndices);\n    this.matricesWeights = this._mergeElement(this.matricesWeights, other.matricesWeights);\n    this.matricesIndicesExtra = this._mergeElement(this.matricesIndicesExtra, other.matricesIndicesExtra);\n    this.matricesWeightsExtra = this._mergeElement(this.matricesWeightsExtra, other.matricesWeightsExtra);\n    return this;\n  };\n\n  VertexData.prototype._mergeElement = function (source, other) {\n    if (!source) {\n      return other;\n    }\n\n    if (!other) {\n      return source;\n    }\n\n    var len = other.length + source.length;\n    var isSrcTypedArray = source instanceof Float32Array;\n    var isOthTypedArray = other instanceof Float32Array; // use non-loop method when the source is Float32Array\n\n    if (isSrcTypedArray) {\n      var ret32 = new Float32Array(len);\n      ret32.set(source);\n      ret32.set(other, source.length);\n      return ret32; // source is number[], when other is also use concat\n    } else if (!isOthTypedArray) {\n      return source.concat(other); // source is a number[], but other is a Float32Array, loop required\n    } else {\n      var ret = source.slice(0); // copy source to a separate array\n\n      for (var i = 0, len = other.length; i < len; i++) {\n        ret.push(other[i]);\n      }\n\n      return ret;\n    }\n  };\n\n  VertexData.prototype._validate = function () {\n    if (!this.positions) {\n      throw new Error(\"Positions are required\");\n    }\n\n    var getElementCount = function getElementCount(kind, values) {\n      var stride = VertexBuffer.DeduceStride(kind);\n\n      if (values.length % stride !== 0) {\n        throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\n      }\n\n      return values.length / stride;\n    };\n\n    var positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\n\n    var validateElementCount = function validateElementCount(kind, values) {\n      var elementCount = getElementCount(kind, values);\n\n      if (elementCount !== positionsElementCount) {\n        throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\n      }\n    };\n\n    if (this.normals) {\n      validateElementCount(VertexBuffer.NormalKind, this.normals);\n    }\n\n    if (this.tangents) {\n      validateElementCount(VertexBuffer.TangentKind, this.tangents);\n    }\n\n    if (this.uvs) {\n      validateElementCount(VertexBuffer.UVKind, this.uvs);\n    }\n\n    if (this.uvs2) {\n      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\n    }\n\n    if (this.uvs3) {\n      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\n    }\n\n    if (this.uvs4) {\n      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\n    }\n\n    if (this.uvs5) {\n      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\n    }\n\n    if (this.uvs6) {\n      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\n    }\n\n    if (this.colors) {\n      validateElementCount(VertexBuffer.ColorKind, this.colors);\n    }\n\n    if (this.matricesIndices) {\n      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\n    }\n\n    if (this.matricesWeights) {\n      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\n    }\n\n    if (this.matricesIndicesExtra) {\n      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\n    }\n\n    if (this.matricesWeightsExtra) {\n      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\n    }\n  };\n  /**\r\n   * Serializes the VertexData\r\n   * @returns a serialized object\r\n   */\n\n\n  VertexData.prototype.serialize = function () {\n    var serializationObject = this.serialize();\n\n    if (this.positions) {\n      serializationObject.positions = this.positions;\n    }\n\n    if (this.normals) {\n      serializationObject.normals = this.normals;\n    }\n\n    if (this.tangents) {\n      serializationObject.tangents = this.tangents;\n    }\n\n    if (this.uvs) {\n      serializationObject.uvs = this.uvs;\n    }\n\n    if (this.uvs2) {\n      serializationObject.uvs2 = this.uvs2;\n    }\n\n    if (this.uvs3) {\n      serializationObject.uvs3 = this.uvs3;\n    }\n\n    if (this.uvs4) {\n      serializationObject.uvs4 = this.uvs4;\n    }\n\n    if (this.uvs5) {\n      serializationObject.uvs5 = this.uvs5;\n    }\n\n    if (this.uvs6) {\n      serializationObject.uvs6 = this.uvs6;\n    }\n\n    if (this.colors) {\n      serializationObject.colors = this.colors;\n    }\n\n    if (this.matricesIndices) {\n      serializationObject.matricesIndices = this.matricesIndices;\n      serializationObject.matricesIndices._isExpanded = true;\n    }\n\n    if (this.matricesWeights) {\n      serializationObject.matricesWeights = this.matricesWeights;\n    }\n\n    if (this.matricesIndicesExtra) {\n      serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\n      serializationObject.matricesIndicesExtra._isExpanded = true;\n    }\n\n    if (this.matricesWeightsExtra) {\n      serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\n    }\n\n    serializationObject.indices = this.indices;\n    return serializationObject;\n  }; // Statics\n\n  /**\r\n   * Extracts the vertexData from a mesh\r\n   * @param mesh the mesh from which to extract the VertexData\r\n   * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n   * @returns the object VertexData associated to the passed mesh\r\n   */\n\n\n  VertexData.ExtractFromMesh = function (mesh, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\n  };\n  /**\r\n   * Extracts the vertexData from the geometry\r\n   * @param geometry the geometry from which to extract the VertexData\r\n   * @param copyWhenShared defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false\r\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n   * @returns the object VertexData associated to the passed mesh\r\n   */\n\n\n  VertexData.ExtractFromGeometry = function (geometry, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\n  };\n\n  VertexData._ExtractFrom = function (meshOrGeometry, copyWhenShared, forceCopy) {\n    var result = new VertexData();\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\n      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\n    }\n\n    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\n    return result;\n  };\n  /**\r\n   * Creates the VertexData for a Ribbon\r\n   * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n    * * pathArray array of paths, each of which an array of successive Vector3\r\n    * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n    * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n    * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n    * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n    * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n    * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n   * @returns the VertexData of the ribbon\r\n   */\n\n\n  VertexData.CreateRibbon = function (options) {\n    throw _DevTools.WarnImport(\"ribbonBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a box\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n    * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n    * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n    * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n    * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n    * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the box\r\n   */\n\n\n  VertexData.CreateBox = function (options) {\n    throw _DevTools.WarnImport(\"boxBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a tiled box\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n    * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n    * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * @returns the VertexData of the box\r\n   */\n\n\n  VertexData.CreateTiledBox = function (options) {\n    throw _DevTools.WarnImport(\"tiledBoxBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a tiled plane\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * pattern a limited pattern arrangement depending on the number\r\n    * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n    * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n    * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the tiled plane\r\n   */\n\n\n  VertexData.CreateTiledPlane = function (options) {\n    throw _DevTools.WarnImport(\"tiledPlaneBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * segments sets the number of horizontal strips optional, default 32\r\n    * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n    * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n    * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n    * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n    * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n    * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the ellipsoid\r\n   */\n\n\n  VertexData.CreateSphere = function (options) {\n    throw _DevTools.WarnImport(\"sphereBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a cylinder, cone or prism\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * height sets the height (y direction) of the cylinder, optional, default 2\r\n    * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n    * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n    * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n    * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n    * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n    * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n    * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n    * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n    * * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false\r\n    * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the cylinder, cone or prism\r\n   */\n\n\n  VertexData.CreateCylinder = function (options) {\n    throw _DevTools.WarnImport(\"cylinderBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a torus\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * diameter the diameter of the torus, optional default 1\r\n    * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n    * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the torus\r\n   */\n\n\n  VertexData.CreateTorus = function (options) {\n    throw _DevTools.WarnImport(\"torusBuilder\");\n  };\n  /**\r\n   * Creates the VertexData of the LineSystem\r\n   * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n   *  - lines an array of lines, each line being an array of successive Vector3\r\n   *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n   * @returns the VertexData of the LineSystem\r\n   */\n\n\n  VertexData.CreateLineSystem = function (options) {\n    throw _DevTools.WarnImport(\"linesBuilder\");\n  };\n  /**\r\n   * Create the VertexData for a DashedLines\r\n   * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n   *  - points an array successive Vector3\r\n   *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n   *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n   *  - dashNb the intended total number of dashes, optional, default 200\r\n   * @returns the VertexData for the DashedLines\r\n   */\n\n\n  VertexData.CreateDashedLines = function (options) {\n    throw _DevTools.WarnImport(\"linesBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a Ground\r\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n   *  - width the width (x direction) of the ground, optional, default 1\r\n   *  - height the height (z direction) of the ground, optional, default 1\r\n   *  - subdivisions the number of subdivisions per side, optional, default 1\r\n   * @returns the VertexData of the Ground\r\n   */\n\n\n  VertexData.CreateGround = function (options) {\n    throw _DevTools.WarnImport(\"groundBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n    * * xmin the ground minimum X coordinate, optional, default -1\r\n    * * zmin the ground minimum Z coordinate, optional, default -1\r\n    * * xmax the ground maximum X coordinate, optional, default 1\r\n    * * zmax the ground maximum Z coordinate, optional, default 1\r\n    * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n    * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n   * @returns the VertexData of the TiledGround\r\n   */\n\n\n  VertexData.CreateTiledGround = function (options) {\n    throw _DevTools.WarnImport(\"groundBuilder\");\n  };\n  /**\r\n   * Creates the VertexData of the Ground designed from a heightmap\r\n   * @param options an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap\r\n    * * width the width (x direction) of the ground\r\n    * * height the height (z direction) of the ground\r\n    * * subdivisions the number of subdivisions per side\r\n    * * minHeight the minimum altitude on the ground, optional, default 0\r\n    * * maxHeight the maximum altitude on the ground, optional default 1\r\n    * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n    * * buffer the array holding the image color data\r\n    * * bufferWidth the width of image\r\n    * * bufferHeight the height of image\r\n    * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n   * @returns the VertexData of the Ground designed from a heightmap\r\n   */\n\n\n  VertexData.CreateGroundFromHeightMap = function (options) {\n    throw _DevTools.WarnImport(\"groundBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a Plane\r\n   * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n    * * size sets the width and height of the plane to the value of size, optional default 1\r\n    * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n    * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the box\r\n   */\n\n\n  VertexData.CreatePlane = function (options) {\n    throw _DevTools.WarnImport(\"planeBuilder\");\n  };\n  /**\r\n   * Creates the VertexData of the Disc or regular Polygon\r\n   * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n    * * radius the radius of the disc, optional default 0.5\r\n    * * tessellation the number of polygon sides, optional, default 64\r\n    * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the box\r\n   */\n\n\n  VertexData.CreateDisc = function (options) {\n    throw _DevTools.WarnImport(\"discBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n   * All parameters are provided by MeshBuilder.CreatePolygon as needed\r\n   * @param polygon a mesh built from polygonTriangulation.build()\r\n   * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n   * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n   * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n   * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n   * @returns the VertexData of the Polygon\r\n   */\n\n\n  VertexData.CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {\n    throw _DevTools.WarnImport(\"polygonBuilder\");\n  };\n  /**\r\n   * Creates the VertexData of the IcoSphere\r\n   * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n    * * radius the radius of the IcoSphere, optional default 1\r\n    * * radiusX allows stretching in the x direction, optional, default radius\r\n    * * radiusY allows stretching in the y direction, optional, default radius\r\n    * * radiusZ allows stretching in the z direction, optional, default radius\r\n    * * flat when true creates a flat shaded mesh, optional, default true\r\n    * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the IcoSphere\r\n   */\n\n\n  VertexData.CreateIcoSphere = function (options) {\n    throw _DevTools.WarnImport(\"icoSphereBuilder\");\n  }; // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n\n  /**\r\n   * Creates the VertexData for a Polyhedron\r\n   * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n   * * type provided types are:\r\n   *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n   *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n   * * size the size of the IcoSphere, optional default 1\r\n   * * sizeX allows stretching in the x direction, optional, default size\r\n   * * sizeY allows stretching in the y direction, optional, default size\r\n   * * sizeZ allows stretching in the z direction, optional, default size\r\n   * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n   * * flat when true creates a flat shaded mesh, optional, default true\r\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the Polyhedron\r\n   */\n\n\n  VertexData.CreatePolyhedron = function (options) {\n    throw _DevTools.WarnImport(\"polyhedronBuilder\");\n  }; //\n\n  /**\r\n   * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n   * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n   * @returns the VertexData of the Capsule\r\n   */\n\n\n  VertexData.CreateCapsule = function (options) {\n    if (options === void 0) {\n      options = {\n        orientation: Vector3.Up(),\n        subdivisions: 2,\n        tessellation: 16,\n        height: 1,\n        radius: 0.25,\n        capSubdivisions: 6\n      };\n    }\n\n    throw _DevTools.WarnImport(\"capsuleBuilder\");\n  }; // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n\n  /**\r\n   * Creates the VertexData for a TorusKnot\r\n   * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n    * * radius the radius of the torus knot, optional, default 2\r\n    * * tube the thickness of the tube, optional, default 0.5\r\n    * * radialSegments the number of sides on each tube segments, optional, default 32\r\n    * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n    * * p the number of windings around the z axis, optional,  default 2\r\n    * * q the number of windings around the x axis, optional,  default 3\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the Torus Knot\r\n   */\n\n\n  VertexData.CreateTorusKnot = function (options) {\n    throw _DevTools.WarnImport(\"torusKnotBuilder\");\n  }; // Tools\n\n  /**\r\n   * Compute normals for given positions and indices\r\n   * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n   * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n   * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n   * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n    * * facetNormals : optional array of facet normals (vector3)\r\n    * * facetPositions : optional array of facet positions (vector3)\r\n    * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n    * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n    * * bInfo : optional bounding info, required for facetPartitioning computation\r\n    * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n    * * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation\r\n    * * useRightHandedSystem: optional boolean to for right handed system computation\r\n    * * depthSort : optional boolean to enable the facet depth sort computation\r\n    * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n    * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n   */\n\n\n  VertexData.ComputeNormals = function (positions, indices, normals, options) {\n    // temporary scalar variables\n    var index = 0; // facet index\n\n    var p1p2x = 0.0; // p1p2 vector x coordinate\n\n    var p1p2y = 0.0; // p1p2 vector y coordinate\n\n    var p1p2z = 0.0; // p1p2 vector z coordinate\n\n    var p3p2x = 0.0; // p3p2 vector x coordinate\n\n    var p3p2y = 0.0; // p3p2 vector y coordinate\n\n    var p3p2z = 0.0; // p3p2 vector z coordinate\n\n    var faceNormalx = 0.0; // facet normal x coordinate\n\n    var faceNormaly = 0.0; // facet normal y coordinate\n\n    var faceNormalz = 0.0; // facet normal z coordinate\n\n    var length = 0.0; // facet normal length before normalization\n\n    var v1x = 0; // vector1 x index in the positions array\n\n    var v1y = 0; // vector1 y index in the positions array\n\n    var v1z = 0; // vector1 z index in the positions array\n\n    var v2x = 0; // vector2 x index in the positions array\n\n    var v2y = 0; // vector2 y index in the positions array\n\n    var v2z = 0; // vector2 z index in the positions array\n\n    var v3x = 0; // vector3 x index in the positions array\n\n    var v3y = 0; // vector3 y index in the positions array\n\n    var v3z = 0; // vector3 z index in the positions array\n\n    var computeFacetNormals = false;\n    var computeFacetPositions = false;\n    var computeFacetPartitioning = false;\n    var computeDepthSort = false;\n    var faceNormalSign = 1;\n    var ratio = 0;\n    var distanceTo = null;\n\n    if (options) {\n      computeFacetNormals = options.facetNormals ? true : false;\n      computeFacetPositions = options.facetPositions ? true : false;\n      computeFacetPartitioning = options.facetPartitioning ? true : false;\n      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\n      ratio = options.ratio || 0;\n      computeDepthSort = options.depthSort ? true : false;\n      distanceTo = options.distanceTo;\n\n      if (computeDepthSort) {\n        if (distanceTo === undefined) {\n          distanceTo = Vector3.Zero();\n        }\n\n        var depthSortedFacets = options.depthSortedFacets;\n      }\n    } // facetPartitioning reinit if needed\n\n\n    var xSubRatio = 0;\n    var ySubRatio = 0;\n    var zSubRatio = 0;\n    var subSq = 0;\n\n    if (computeFacetPartitioning && options && options.bbSize) {\n      var ox = 0; // X partitioning index for facet position\n\n      var oy = 0; // Y partinioning index for facet position\n\n      var oz = 0; // Z partinioning index for facet position\n\n      var b1x = 0; // X partitioning index for facet v1 vertex\n\n      var b1y = 0; // Y partitioning index for facet v1 vertex\n\n      var b1z = 0; // z partitioning index for facet v1 vertex\n\n      var b2x = 0; // X partitioning index for facet v2 vertex\n\n      var b2y = 0; // Y partitioning index for facet v2 vertex\n\n      var b2z = 0; // Z partitioning index for facet v2 vertex\n\n      var b3x = 0; // X partitioning index for facet v3 vertex\n\n      var b3y = 0; // Y partitioning index for facet v3 vertex\n\n      var b3z = 0; // Z partitioning index for facet v3 vertex\n\n      var block_idx_o = 0; // facet barycenter block index\n\n      var block_idx_v1 = 0; // v1 vertex block index\n\n      var block_idx_v2 = 0; // v2 vertex block index\n\n      var block_idx_v3 = 0; // v3 vertex block index\n\n      var bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\n      bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\n      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;\n      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;\n      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;\n      subSq = options.subDiv.max * options.subDiv.max;\n      options.facetPartitioning.length = 0;\n    } // reset the normals\n\n\n    for (index = 0; index < positions.length; index++) {\n      normals[index] = 0.0;\n    } // Loop : 1 indice triplet = 1 facet\n\n\n    var nbFaces = indices.length / 3 | 0;\n\n    for (index = 0; index < nbFaces; index++) {\n      // get the indexes of the coordinates of each vertex of the facet\n      v1x = indices[index * 3] * 3;\n      v1y = v1x + 1;\n      v1z = v1x + 2;\n      v2x = indices[index * 3 + 1] * 3;\n      v2y = v2x + 1;\n      v2z = v2x + 2;\n      v3x = indices[index * 3 + 2] * 3;\n      v3y = v3x + 1;\n      v3z = v3x + 2;\n      p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n\n      p1p2y = positions[v1y] - positions[v2y];\n      p1p2z = positions[v1z] - positions[v2z];\n      p3p2x = positions[v3x] - positions[v2x];\n      p3p2y = positions[v3y] - positions[v2y];\n      p3p2z = positions[v3z] - positions[v2z]; // compute the face normal with the cross product\n\n      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x); // normalize this normal and store it in the array facetData\n\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n\n      if (computeFacetNormals && options) {\n        options.facetNormals[index].x = faceNormalx;\n        options.facetNormals[index].y = faceNormaly;\n        options.facetNormals[index].z = faceNormalz;\n      }\n\n      if (computeFacetPositions && options) {\n        // compute and the facet barycenter coordinates in the array facetPositions\n        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\n        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\n        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\n      }\n\n      if (computeFacetPartitioning && options) {\n        // store the facet indexes in arrays in the main facetPartitioning array :\n        // compute each facet vertex (+ facet barycenter) index in the partiniong array\n        ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\n        oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\n        oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\n        b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\n        block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\n        block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\n        block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\n        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\n        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\n        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\n        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array(); // push each facet index in each block containing the vertex\n\n        options.facetPartitioning[block_idx_v1].push(index);\n\n        if (block_idx_v2 != block_idx_v1) {\n          options.facetPartitioning[block_idx_v2].push(index);\n        }\n\n        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\n          options.facetPartitioning[block_idx_v3].push(index);\n        }\n\n        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\n          options.facetPartitioning[block_idx_o].push(index);\n        }\n      }\n\n      if (computeDepthSort && options && options.facetPositions) {\n        var dsf = depthSortedFacets[index];\n        dsf.ind = index * 3;\n        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);\n      } // compute the normals anyway\n\n\n      normals[v1x] += faceNormalx; // accumulate all the normals per face\n\n      normals[v1y] += faceNormaly;\n      normals[v1z] += faceNormalz;\n      normals[v2x] += faceNormalx;\n      normals[v2y] += faceNormaly;\n      normals[v2z] += faceNormalz;\n      normals[v3x] += faceNormalx;\n      normals[v3y] += faceNormaly;\n      normals[v3z] += faceNormalz;\n    } // last normalization of each normal\n\n\n    for (index = 0; index < normals.length / 3; index++) {\n      faceNormalx = normals[index * 3];\n      faceNormaly = normals[index * 3 + 1];\n      faceNormalz = normals[index * 3 + 2];\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      normals[index * 3] = faceNormalx;\n      normals[index * 3 + 1] = faceNormaly;\n      normals[index * 3 + 2] = faceNormalz;\n    }\n  };\n  /** @hidden */\n\n\n  VertexData._ComputeSides = function (sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {\n    var li = indices.length;\n    var ln = normals.length;\n    var i;\n    var n;\n    sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\n\n    switch (sideOrientation) {\n      case VertexData.FRONTSIDE:\n        // nothing changed\n        break;\n\n      case VertexData.BACKSIDE:\n        var tmp; // indices\n\n        for (i = 0; i < li; i += 3) {\n          tmp = indices[i];\n          indices[i] = indices[i + 2];\n          indices[i + 2] = tmp;\n        } // normals\n\n\n        for (n = 0; n < ln; n++) {\n          normals[n] = -normals[n];\n        }\n\n        break;\n\n      case VertexData.DOUBLESIDE:\n        // positions\n        var lp = positions.length;\n        var l = lp / 3;\n\n        for (var p = 0; p < lp; p++) {\n          positions[lp + p] = positions[p];\n        } // indices\n\n\n        for (i = 0; i < li; i += 3) {\n          indices[i + li] = indices[i + 2] + l;\n          indices[i + 1 + li] = indices[i + 1] + l;\n          indices[i + 2 + li] = indices[i] + l;\n        } // normals\n\n\n        for (n = 0; n < ln; n++) {\n          normals[ln + n] = -normals[n];\n        } // uvs\n\n\n        var lu = uvs.length;\n        var u = 0;\n\n        for (u = 0; u < lu; u++) {\n          uvs[u + lu] = uvs[u];\n        }\n\n        frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n        backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n        u = 0;\n\n        for (i = 0; i < lu / 2; i++) {\n          uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\n          uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\n          uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\n          uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\n          u += 2;\n        }\n\n        break;\n    }\n  };\n  /**\r\n   * Applies VertexData created from the imported parameters to the geometry\r\n   * @param parsedVertexData the parsed data from an imported file\r\n   * @param geometry the geometry to apply the VertexData to\r\n   */\n\n\n  VertexData.ImportVertexData = function (parsedVertexData, geometry) {\n    var vertexData = new VertexData(); // positions\n\n    var positions = parsedVertexData.positions;\n\n    if (positions) {\n      vertexData.set(positions, VertexBuffer.PositionKind);\n    } // normals\n\n\n    var normals = parsedVertexData.normals;\n\n    if (normals) {\n      vertexData.set(normals, VertexBuffer.NormalKind);\n    } // tangents\n\n\n    var tangents = parsedVertexData.tangents;\n\n    if (tangents) {\n      vertexData.set(tangents, VertexBuffer.TangentKind);\n    } // uvs\n\n\n    var uvs = parsedVertexData.uvs;\n\n    if (uvs) {\n      vertexData.set(uvs, VertexBuffer.UVKind);\n    } // uv2s\n\n\n    var uv2s = parsedVertexData.uv2s;\n\n    if (uv2s) {\n      vertexData.set(uv2s, VertexBuffer.UV2Kind);\n    } // uv3s\n\n\n    var uv3s = parsedVertexData.uv3s;\n\n    if (uv3s) {\n      vertexData.set(uv3s, VertexBuffer.UV3Kind);\n    } // uv4s\n\n\n    var uv4s = parsedVertexData.uv4s;\n\n    if (uv4s) {\n      vertexData.set(uv4s, VertexBuffer.UV4Kind);\n    } // uv5s\n\n\n    var uv5s = parsedVertexData.uv5s;\n\n    if (uv5s) {\n      vertexData.set(uv5s, VertexBuffer.UV5Kind);\n    } // uv6s\n\n\n    var uv6s = parsedVertexData.uv6s;\n\n    if (uv6s) {\n      vertexData.set(uv6s, VertexBuffer.UV6Kind);\n    } // colors\n\n\n    var colors = parsedVertexData.colors;\n\n    if (colors) {\n      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\n    } // matricesIndices\n\n\n    var matricesIndices = parsedVertexData.matricesIndices;\n\n    if (matricesIndices) {\n      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\n    } // matricesWeights\n\n\n    var matricesWeights = parsedVertexData.matricesWeights;\n\n    if (matricesWeights) {\n      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\n    } // indices\n\n\n    var indices = parsedVertexData.indices;\n\n    if (indices) {\n      vertexData.indices = indices;\n    }\n\n    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\n  };\n  /**\r\n   * Mesh side orientation : usually the external or front surface\r\n   */\n\n\n  VertexData.FRONTSIDE = 0;\n  /**\r\n   * Mesh side orientation : usually the internal or back surface\r\n   */\n\n  VertexData.BACKSIDE = 1;\n  /**\r\n   * Mesh side orientation : both internal and external or front and back surfaces\r\n   */\n\n  VertexData.DOUBLESIDE = 2;\n  /**\r\n   * Mesh side orientation : by default, `FRONTSIDE`\r\n   */\n\n  VertexData.DEFAULTSIDE = 0;\n  return VertexData;\n}();\n\nexport { VertexData };","map":null,"metadata":{},"sourceType":"module"}