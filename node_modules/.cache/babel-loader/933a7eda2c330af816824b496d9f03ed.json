{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryGraph = exports.postForm = exports.fetchPipe = exports.fetchBuffer = exports.fetchArrayBuffer = exports.fetchJson = exports.Fetcher = void 0;\n\nvar ms_1 = __importDefault(require(\"ms\"));\n\nvar abort_controller_1 = __importDefault(require(\"abort-controller\"));\n\nvar Helper_1 = require(\"./Helper\");\n\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\n\nvar FetcherConfiguration_1 = require(\"./FetcherConfiguration\");\n\nvar Fetcher = /*#__PURE__*/function () {\n  function Fetcher(customDefaults) {\n    _classCallCheck(this, Fetcher);\n\n    this.customDefaults = customDefaults ? customDefaults : {};\n  }\n\n  _createClass(Fetcher, [{\n    key: \"overrideDefaults\",\n    value: function overrideDefaults(_overrideDefaults) {\n      this.customDefaults = (0, Helper_1.mergeRequestOptions)(this.customDefaults, _overrideDefaults);\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(url, options) {\n      return fetchInternal(url, _objectSpread({\n        method: 'get',\n        // it is better to not assume how this generic fetch will be used, not sending retries\n        attempts: 1,\n        // no timeout by default\n        timeout: '0s',\n        // no wait-time by default\n        waitTime: '0s'\n      }, (0, Helper_1.mergeRequestOptions)(this.customDefaults, options)));\n    }\n    /**\n     * @deprecated please use Fetcher.fetch instead\n     */\n\n  }, {\n    key: \"fetchJson\",\n    value: function fetchJson(url, options) {\n      return _fetchJson(url, (0, Helper_1.mergeRequestOptions)(this.customDefaults, options));\n    }\n    /**\n     * @deprecated please use Fetcher.fetch instead\n     */\n\n  }, {\n    key: \"fetchBuffer\",\n    value: function fetchBuffer(url, options) {\n      return _fetchBuffer(url, (0, Helper_1.mergeRequestOptions)(this.customDefaults, options));\n    }\n    /**\n     * Fetches the url and pipes the response obtained from the upstream to the `writeTo` Stream and\n     * returns the headers from the upstream request.\n     * IMPORTANT: THIS METHOD DOES NOT AWAIT THE PIPE TO FINISH. THE PROMISE FULFILLS RIGHT AFTER WE RECEIVE THE HEADERS.\n     * @param url to request\n     * @param writeTo the stream to pipe the response to\n     * @param options config for the request\n     * @deprecated please use Fetcher.fetch instead\n     */\n\n  }, {\n    key: \"fetchPipe\",\n    value: function fetchPipe(url, writeTo, options) {\n      return _fetchPipe(url, writeTo, (0, Helper_1.mergeRequestOptions)(this.customDefaults, options));\n    }\n    /**\n     * @deprecated please use Fetcher.fetch instead\n     */\n\n  }, {\n    key: \"postForm\",\n    value: function postForm(url, options) {\n      return _postForm(url, (0, Helper_1.mergeRequestOptions)(this.customDefaults, options));\n    }\n  }, {\n    key: \"queryGraph\",\n    value: function queryGraph(url, query, variables, options) {\n      return _queryGraph(url, query, variables, (0, Helper_1.mergeRequestOptions)(this.customDefaults, options));\n    } // Clones the fetcher and creates a new one\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Fetcher(this.customDefaults);\n    }\n  }]);\n\n  return Fetcher;\n}();\n\nexports.Fetcher = Fetcher;\n\nfunction _fetchJson(_x, _x2) {\n  return _fetchJson2.apply(this, arguments);\n}\n\nfunction _fetchJson2() {\n  _fetchJson2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, options) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetchInternal(url, (0, Helper_1.mergeRequestOptions)(FetcherConfiguration_1.FETCH_JSON_DEFAULTS, options));\n\n          case 2:\n            response = _context.sent;\n            return _context.abrupt(\"return\", response.json());\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchJson2.apply(this, arguments);\n}\n\nexports.fetchJson = _fetchJson;\n\nfunction fetchArrayBuffer(_x3, _x4) {\n  return _fetchArrayBuffer.apply(this, arguments);\n}\n\nfunction _fetchArrayBuffer() {\n  _fetchArrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url, options) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return fetchInternal(url, (0, Helper_1.mergeRequestOptions)(FetcherConfiguration_1.FETCH_BUFFER_DEFAULTS, options));\n\n          case 2:\n            response = _context2.sent;\n            _context2.t0 = Uint8Array;\n            _context2.next = 6;\n            return response.arrayBuffer();\n\n          case 6:\n            _context2.t1 = _context2.sent;\n            return _context2.abrupt(\"return\", new _context2.t0(_context2.t1));\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _fetchArrayBuffer.apply(this, arguments);\n}\n\nexports.fetchArrayBuffer = fetchArrayBuffer;\n/**\n * @deprecated use fetchArrayBuffer instead\n */\n\nfunction _fetchBuffer(_x5, _x6) {\n  return _fetchBuffer2.apply(this, arguments);\n}\n\nfunction _fetchBuffer2() {\n  _fetchBuffer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(url, options) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return fetchInternal(url, (0, Helper_1.mergeRequestOptions)(FetcherConfiguration_1.FETCH_BUFFER_DEFAULTS, options));\n\n          case 2:\n            response = _context3.sent;\n            _context3.t0 = Buffer;\n            _context3.next = 6;\n            return response.arrayBuffer();\n\n          case 6:\n            _context3.t1 = _context3.sent;\n            return _context3.abrupt(\"return\", _context3.t0.from.call(_context3.t0, _context3.t1));\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _fetchBuffer2.apply(this, arguments);\n}\n\nexports.fetchBuffer = _fetchBuffer;\n/**\n * Fetches the url and pipes the response obtained from the upstream to the `writeTo` Stream and\n * returns the headers from the upstream request.\n * IMPORTANT: THIS METHOD DOES NOT AWAIT THE PIPE TO FINISH. THE PROMISE FULFILLS RIGHT AFTER WE RECEIVE THE HEADERS.\n * @param url to request\n * @param writeTo the stream to pipe the response to\n * @param options config for the request\n */\n\nfunction _fetchPipe(_x7, _x8, _x9) {\n  return _fetchPipe2.apply(this, arguments);\n}\n\nfunction _fetchPipe2() {\n  _fetchPipe2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url, writeTo, options) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return fetchInternal(url, (0, Helper_1.mergeRequestOptions)(FetcherConfiguration_1.FETCH_BUFFER_DEFAULTS, options));\n\n          case 2:\n            response = _context4.sent;\n\n            if (response.body) {\n              _context4.next = 5;\n              break;\n            }\n\n            throw new Error('The function fetchPipe only works in Node.js compatible enviroments');\n\n          case 5:\n            if (!('pipe' in response.body)) {\n              _context4.next = 9;\n              break;\n            }\n\n            ;\n            response.body.pipe(writeTo);\n            return _context4.abrupt(\"return\", response.headers);\n\n          case 9:\n            throw new Error('The function fetchPipe only works in Node.js compatible enviroments');\n\n          case 10:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _fetchPipe2.apply(this, arguments);\n}\n\nexports.fetchPipe = _fetchPipe;\n\nfunction _postForm(_x10, _x11) {\n  return _postForm2.apply(this, arguments);\n}\n\nfunction _postForm2() {\n  _postForm2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(url, options) {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return fetchInternal(url, (0, Helper_1.mergeRequestOptions)(FetcherConfiguration_1.POST_DEFAULTS, options));\n\n          case 2:\n            res = _context5.sent;\n            return _context5.abrupt(\"return\", res.json());\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _postForm2.apply(this, arguments);\n}\n\nexports.postForm = _postForm;\n\nfunction _queryGraph(_x12, _x13, _x14, _x15) {\n  return _queryGraph2.apply(this, arguments);\n}\n\nfunction _queryGraph2() {\n  _queryGraph2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(url, query, variables, options) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return _postForm(url, _objectSpread({\n              body: JSON.stringify({\n                query: query,\n                variables: variables\n              }),\n              headers: {\n                'Content-Type': 'application/json'\n              }\n            }, options));\n\n          case 2:\n            response = _context6.sent;\n\n            if (!response.errors) {\n              _context6.next = 5;\n              break;\n            }\n\n            throw new Error(\"Error querying graph. Reasons: \".concat(JSON.stringify(response.errors)));\n\n          case 5:\n            return _context6.abrupt(\"return\", response.data);\n\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _queryGraph2.apply(this, arguments);\n}\n\nexports.queryGraph = _queryGraph;\n\nfunction identity(_x16) {\n  return _identity.apply(this, arguments);\n}\n/**\n * This is the method where everything happens, all of the methods in this file call internally fetchInternal.\n * If you need to modify something for all requests, do it here.\n */\n\n\nfunction _identity() {\n  _identity = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(a) {\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            return _context7.abrupt(\"return\", a);\n\n          case 1:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _identity.apply(this, arguments);\n}\n\nfunction fetchInternal(_x17, _x18) {\n  return _fetchInternal.apply(this, arguments);\n}\n\nfunction _fetchInternal() {\n  _fetchInternal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(url, options) {\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            return _context9.abrupt(\"return\", (0, Helper_1.retry)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n              var controller, transformRequest, transformResponse, request, timeoutTime, timeout, response, responseText;\n              return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                while (1) {\n                  switch (_context8.prev = _context8.next) {\n                    case 0:\n                      controller = new abort_controller_1.default();\n                      transformRequest = options.requestMiddleware || identity;\n                      transformResponse = options.responseMiddleware || identity;\n                      _context8.next = 5;\n                      return transformRequest({\n                        requestInfo: url,\n                        requestInit: {\n                          signal: controller.signal,\n                          body: options.body,\n                          method: options.method,\n                          headers: (0, FetcherConfiguration_1.getAllHeaders)(options)\n                        }\n                      });\n\n                    case 5:\n                      request = _context8.sent;\n                      // schedule timeout right after transforming Request\n                      timeoutTime = (0, ms_1.default)(options.timeout);\n                      timeout = timeoutTime ? setTimeout(function () {\n                        controller.abort();\n                      }, timeoutTime) : 0;\n                      _context8.prev = 8;\n                      _context8.next = 11;\n                      return (0, cross_fetch_1.default)(request.requestInfo, request.requestInit);\n\n                    case 11:\n                      response = _context8.sent;\n\n                      if (!response.ok) {\n                        _context8.next = 18;\n                        break;\n                      }\n\n                      _context8.next = 15;\n                      return transformResponse(response);\n\n                    case 15:\n                      return _context8.abrupt(\"return\", _context8.sent);\n\n                    case 18:\n                      _context8.next = 20;\n                      return response.text();\n\n                    case 20:\n                      responseText = _context8.sent;\n                      throw new Error(\"Failed to fetch \".concat(url, \". Got status \").concat(response.status, \". Response was '\").concat(responseText, \"'\"));\n\n                    case 22:\n                      _context8.prev = 22;\n                      if (timeout) clearTimeout(timeout);\n                      return _context8.finish(22);\n\n                    case 25:\n                    case \"end\":\n                      return _context8.stop();\n                  }\n                }\n              }, _callee8, null, [[8,, 22, 25]]);\n            })), options.attempts, options.waitTime));\n\n          case 1:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _fetchInternal.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}