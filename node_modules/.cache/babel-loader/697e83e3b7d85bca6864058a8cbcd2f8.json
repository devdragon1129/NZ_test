{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Observable } from \"../../Misc/observable\";\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\nimport { TargetCamera } from \"../../Cameras/targetCamera\";\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera\";\nimport { VRDeviceOrientationFreeCamera } from \"../../Cameras/VR/vrDeviceOrientationFreeCamera\";\nimport { WebVRFreeCamera } from \"../../Cameras/VR/webVRCamera\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Color3, Color4 } from '../../Maths/math.color';\nimport { Gamepad } from \"../../Gamepads/gamepad\";\nimport { PoseEnabledController, PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController\";\nimport { WebVRController } from \"../../Gamepads/Controllers/webVRController\";\nimport { Xbox360Button } from \"../../Gamepads/xboxGamepad\";\nimport { Mesh } from \"../../Meshes/mesh\";\nimport { Ray } from \"../../Culling/ray\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess\";\nimport { SineEase, EasingFunction, CircleEase } from \"../../Animations/easing\";\nimport { Animation } from \"../../Animations/animation\";\nimport { VRCameraMetrics } from '../../Cameras/VR/vrCameraMetrics';\nimport \"../../Meshes/Builders/groundBuilder\";\nimport \"../../Meshes/Builders/torusBuilder\";\nimport \"../../Meshes/Builders/cylinderBuilder\";\nimport \"../../Gamepads/gamepadSceneComponent\";\nimport \"../../Animations/animatable\";\nimport { Axis } from '../../Maths/math.axis';\nimport { WebXRSessionManager } from '../../XR/webXRSessionManager';\nimport { WebXRState } from '../../XR/webXRTypes';\n\nvar VRExperienceHelperGazer =\n/** @class */\nfunction () {\n  function VRExperienceHelperGazer(scene, gazeTrackerToClone) {\n    if (gazeTrackerToClone === void 0) {\n      gazeTrackerToClone = null;\n    }\n\n    this.scene = scene;\n    /** @hidden */\n\n    this._pointerDownOnMeshAsked = false;\n    /** @hidden */\n\n    this._isActionableMesh = false;\n    /** @hidden */\n\n    this._teleportationRequestInitiated = false;\n    /** @hidden */\n\n    this._teleportationBackRequestInitiated = false;\n    /** @hidden */\n\n    this._rotationRightAsked = false;\n    /** @hidden */\n\n    this._rotationLeftAsked = false;\n    /** @hidden */\n\n    this._dpadPressed = true;\n    /** @hidden */\n\n    this._activePointer = false;\n    this._id = VRExperienceHelperGazer._idCounter++; // Gaze tracker\n\n    if (!gazeTrackerToClone) {\n      this._gazeTracker = Mesh.CreateTorus(\"gazeTracker\", 0.0035, 0.0025, 20, scene, false);\n\n      this._gazeTracker.bakeCurrentTransformIntoVertices();\n\n      this._gazeTracker.isPickable = false;\n      this._gazeTracker.isVisible = false;\n      var targetMat = new StandardMaterial(\"targetMat\", scene);\n      targetMat.specularColor = Color3.Black();\n      targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);\n      targetMat.backFaceCulling = false;\n      this._gazeTracker.material = targetMat;\n    } else {\n      this._gazeTracker = gazeTrackerToClone.clone(\"gazeTracker\");\n    }\n  }\n  /** @hidden */\n\n\n  VRExperienceHelperGazer.prototype._getForwardRay = function (length) {\n    return new Ray(Vector3.Zero(), new Vector3(0, 0, length));\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperGazer.prototype._selectionPointerDown = function () {\n    this._pointerDownOnMeshAsked = true;\n\n    if (this._currentHit) {\n      this.scene.simulatePointerDown(this._currentHit, {\n        pointerId: this._id\n      });\n    }\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperGazer.prototype._selectionPointerUp = function () {\n    if (this._currentHit) {\n      this.scene.simulatePointerUp(this._currentHit, {\n        pointerId: this._id\n      });\n    }\n\n    this._pointerDownOnMeshAsked = false;\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperGazer.prototype._activatePointer = function () {\n    this._activePointer = true;\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperGazer.prototype._deactivatePointer = function () {\n    this._activePointer = false;\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperGazer.prototype._updatePointerDistance = function (distance) {\n    if (distance === void 0) {\n      distance = 100;\n    }\n  };\n\n  VRExperienceHelperGazer.prototype.dispose = function () {\n    this._interactionsEnabled = false;\n    this._teleportationEnabled = false;\n\n    if (this._gazeTracker) {\n      this._gazeTracker.dispose();\n    }\n  };\n\n  VRExperienceHelperGazer._idCounter = 0;\n  return VRExperienceHelperGazer;\n}();\n\nvar VRExperienceHelperControllerGazer =\n/** @class */\nfunction (_super) {\n  __extends(VRExperienceHelperControllerGazer, _super);\n\n  function VRExperienceHelperControllerGazer(webVRController, scene, gazeTrackerToClone) {\n    var _this = _super.call(this, scene, gazeTrackerToClone) || this;\n\n    _this.webVRController = webVRController; // Laser pointer\n\n    _this._laserPointer = Mesh.CreateCylinder(\"laserPointer\", 1, 0.004, 0.0002, 20, 1, scene, false);\n    var laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", scene);\n    laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);\n    laserPointerMaterial.alpha = 0.6;\n    _this._laserPointer.material = laserPointerMaterial;\n    _this._laserPointer.rotation.x = Math.PI / 2;\n    _this._laserPointer.position.z = -0.5;\n    _this._laserPointer.isVisible = false;\n    _this._laserPointer.isPickable = false;\n\n    if (!webVRController.mesh) {\n      // Create an empty mesh that is used prior to loading the high quality model\n      var preloadMesh = new Mesh(\"preloadControllerMesh\", scene);\n      var preloadPointerPose = new Mesh(PoseEnabledController.POINTING_POSE, scene);\n      preloadPointerPose.rotation.x = -0.7;\n      preloadMesh.addChild(preloadPointerPose);\n      webVRController.attachToMesh(preloadMesh);\n    }\n\n    _this._setLaserPointerParent(webVRController.mesh);\n\n    _this._meshAttachedObserver = webVRController._meshAttachedObservable.add(function (mesh) {\n      _this._setLaserPointerParent(mesh);\n    });\n    return _this;\n  }\n\n  VRExperienceHelperControllerGazer.prototype._getForwardRay = function (length) {\n    return this.webVRController.getForwardRay(length);\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperControllerGazer.prototype._activatePointer = function () {\n    _super.prototype._activatePointer.call(this);\n\n    this._laserPointer.isVisible = true;\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperControllerGazer.prototype._deactivatePointer = function () {\n    _super.prototype._deactivatePointer.call(this);\n\n    this._laserPointer.isVisible = false;\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperControllerGazer.prototype._setLaserPointerColor = function (color) {\n    this._laserPointer.material.emissiveColor = color;\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperControllerGazer.prototype._setLaserPointerLightingDisabled = function (disabled) {\n    this._laserPointer.material.disableLighting = disabled;\n  };\n  /** @hidden */\n\n\n  VRExperienceHelperControllerGazer.prototype._setLaserPointerParent = function (mesh) {\n    var makeNotPick = function makeNotPick(root) {\n      root.isPickable = false;\n      root.getChildMeshes().forEach(function (c) {\n        makeNotPick(c);\n      });\n    };\n\n    makeNotPick(mesh);\n    var meshChildren = mesh.getChildren(undefined, false);\n    var laserParent = mesh;\n    this.webVRController._pointingPoseNode = null;\n\n    for (var i = 0; i < meshChildren.length; i++) {\n      if (meshChildren[i].name && meshChildren[i].name.indexOf(PoseEnabledController.POINTING_POSE) >= 0) {\n        laserParent = meshChildren[i];\n        this.webVRController._pointingPoseNode = laserParent;\n        break;\n      }\n    }\n\n    this._laserPointer.parent = laserParent;\n  };\n\n  VRExperienceHelperControllerGazer.prototype._updatePointerDistance = function (distance) {\n    if (distance === void 0) {\n      distance = 100;\n    }\n\n    this._laserPointer.scaling.y = distance;\n    this._laserPointer.position.z = -distance / 2;\n  };\n\n  VRExperienceHelperControllerGazer.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._laserPointer.dispose();\n\n    if (this._meshAttachedObserver) {\n      this.webVRController._meshAttachedObservable.remove(this._meshAttachedObserver);\n    }\n  };\n\n  return VRExperienceHelperControllerGazer;\n}(VRExperienceHelperGazer);\n\nvar VRExperienceHelperCameraGazer =\n/** @class */\nfunction (_super) {\n  __extends(VRExperienceHelperCameraGazer, _super);\n\n  function VRExperienceHelperCameraGazer(getCamera, scene) {\n    var _this = _super.call(this, scene) || this;\n\n    _this.getCamera = getCamera;\n    return _this;\n  }\n\n  VRExperienceHelperCameraGazer.prototype._getForwardRay = function (length) {\n    var camera = this.getCamera();\n\n    if (camera) {\n      return camera.getForwardRay(length);\n    } else {\n      return new Ray(Vector3.Zero(), Vector3.Forward());\n    }\n  };\n\n  return VRExperienceHelperCameraGazer;\n}(VRExperienceHelperGazer);\n/**\r\n * Event containing information after VR has been entered\r\n */\n\n\nvar OnAfterEnteringVRObservableEvent =\n/** @class */\nfunction () {\n  function OnAfterEnteringVRObservableEvent() {}\n\n  return OnAfterEnteringVRObservableEvent;\n}();\n\nexport { OnAfterEnteringVRObservableEvent };\n/**\r\n * Helps to quickly add VR support to an existing scene.\r\n * See https://doc.babylonjs.com/how_to/webvr_helper\r\n */\n\nvar VRExperienceHelper =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a VRExperienceHelper.\r\n   * Helps to quickly add VR support to an existing scene.\r\n   * @param scene The scene the VRExperienceHelper belongs to.\r\n   * @param webVROptions Options to modify the vr experience helper's behavior.\r\n   */\n  function VRExperienceHelper(scene,\n  /** Options to modify the vr experience helper's behavior. */\n  webVROptions) {\n    var _this = this;\n\n    if (webVROptions === void 0) {\n      webVROptions = {};\n    }\n\n    this.webVROptions = webVROptions; // Can the system support WebVR, even if a headset isn't plugged in?\n\n    this._webVRsupported = false; // If WebVR is supported, is a headset plugged in and are we ready to present?\n\n    this._webVRready = false; // Are we waiting for the requestPresent callback to complete?\n\n    this._webVRrequesting = false; // Are we presenting to the headset right now? (this is the vrDevice state)\n\n    this._webVRpresenting = false; // Are we presenting in the fullscreen fallback?\n\n    this._fullscreenVRpresenting = false;\n    /**\r\n     * Gets or sets a boolean indicating that gaze can be enabled even if pointer lock is not engage (useful on iOS where fullscreen mode and pointer lock are not supported)\r\n     */\n\n    this.enableGazeEvenWhenNoPointerLock = false;\n    /**\r\n     * Gets or sets a boolean indicating that the VREXperienceHelper will exit VR if double tap is detected\r\n     */\n\n    this.exitVROnDoubleTap = true;\n    /**\r\n     * Observable raised right before entering VR.\r\n     */\n\n    this.onEnteringVRObservable = new Observable();\n    /**\r\n     * Observable raised when entering VR has completed.\r\n     */\n\n    this.onAfterEnteringVRObservable = new Observable();\n    /**\r\n     * Observable raised when exiting VR.\r\n     */\n\n    this.onExitingVRObservable = new Observable();\n    /**\r\n     * Observable raised when controller mesh is loaded.\r\n     */\n\n    this.onControllerMeshLoadedObservable = new Observable();\n    this._useCustomVRButton = false;\n    this._teleportationRequested = false;\n    this._teleportActive = false;\n    this._floorMeshesCollection = [];\n    this._teleportationMode = VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME;\n    this._teleportationTime = 122;\n    this._teleportationSpeed = 20;\n    this._rotationAllowed = true;\n    this._teleportBackwardsVector = new Vector3(0, -1, -1);\n    this._isDefaultTeleportationTarget = true;\n    this._teleportationFillColor = \"#444444\";\n    this._teleportationBorderColor = \"#FFFFFF\";\n    this._rotationAngle = 0;\n    this._haloCenter = new Vector3(0, 0, 0);\n    this._padSensibilityUp = 0.65;\n    this._padSensibilityDown = 0.35;\n    this._leftController = null;\n    this._rightController = null;\n    this._gazeColor = new Color3(0.7, 0.7, 0.7);\n    this._laserColor = new Color3(0.7, 0.7, 0.7);\n    this._pickedLaserColor = new Color3(0.2, 0.2, 1);\n    this._pickedGazeColor = new Color3(0, 0, 1);\n    /**\r\n     * Observable raised when a new mesh is selected based on meshSelectionPredicate\r\n     */\n\n    this.onNewMeshSelected = new Observable();\n    /**\r\n     * Observable raised when a new mesh is selected based on meshSelectionPredicate.\r\n     * This observable will provide the mesh and the controller used to select the mesh\r\n     */\n\n    this.onMeshSelectedWithController = new Observable();\n    /**\r\n     * Observable raised when a new mesh is picked based on meshSelectionPredicate\r\n     */\n\n    this.onNewMeshPicked = new Observable();\n    /**\r\n     * Observable raised before camera teleportation\r\n    */\n\n    this.onBeforeCameraTeleport = new Observable();\n    /**\r\n     *  Observable raised after camera teleportation\r\n    */\n\n    this.onAfterCameraTeleport = new Observable();\n    /**\r\n    * Observable raised when current selected mesh gets unselected\r\n    */\n\n    this.onSelectedMeshUnselected = new Observable();\n    /**\r\n     * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.\r\n     */\n\n    this.teleportationEnabled = true;\n    this._teleportationInitialized = false;\n    this._interactionsEnabled = false;\n    this._interactionsRequested = false;\n    this._displayGaze = true;\n    this._displayLaserPointer = true;\n    /**\r\n     * If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes\r\n     */\n\n    this.updateGazeTrackerScale = true;\n    /**\r\n     * If the gaze trackers color should be updated when selecting meshes\r\n     */\n\n    this.updateGazeTrackerColor = true;\n    /**\r\n     * If the controller laser color should be updated when selecting meshes\r\n     */\n\n    this.updateControllerLaserColor = true;\n    /**\r\n     * Defines whether or not Pointer lock should be requested when switching to\r\n     * full screen.\r\n     */\n\n    this.requestPointerLockOnFullScreen = true;\n    /**\r\n     * Was the XR test done already. If this is true AND this.xr exists, xr is initialized.\r\n     * If this is true and no this.xr, xr exists but is not supported, using WebVR.\r\n     */\n\n    this.xrTestDone = false;\n\n    this._onResize = function () {\n      _this.moveButtonToBottomRight();\n\n      if (_this._fullscreenVRpresenting && _this._webVRready) {\n        _this.exitVR();\n      }\n    };\n\n    this._onFullscreenChange = function () {\n      var anyDoc = document;\n\n      if (anyDoc.fullscreen !== undefined) {\n        _this._fullscreenVRpresenting = document.fullscreen;\n      } else if (anyDoc.mozFullScreen !== undefined) {\n        _this._fullscreenVRpresenting = anyDoc.mozFullScreen;\n      } else if (anyDoc.webkitIsFullScreen !== undefined) {\n        _this._fullscreenVRpresenting = anyDoc.webkitIsFullScreen;\n      } else if (anyDoc.msIsFullScreen !== undefined) {\n        _this._fullscreenVRpresenting = anyDoc.msIsFullScreen;\n      } else if (document.msFullscreenElement !== undefined) {\n        _this._fullscreenVRpresenting = document.msFullscreenElement;\n      }\n\n      if (!_this._fullscreenVRpresenting && _this._inputElement) {\n        _this.exitVR();\n\n        if (!_this._useCustomVRButton && _this._btnVR) {\n          _this._btnVR.style.top = _this._inputElement.offsetTop + _this._inputElement.offsetHeight - 70 + \"px\";\n          _this._btnVR.style.left = _this._inputElement.offsetLeft + _this._inputElement.offsetWidth - 100 + \"px\"; // make sure the button is visible after setting its position\n\n          _this.updateButtonVisibility();\n        }\n      }\n    };\n\n    this._cachedAngularSensibility = {\n      angularSensibilityX: null,\n      angularSensibilityY: null,\n      angularSensibility: null\n    };\n\n    this.beforeRender = function () {\n      if (_this._leftController && _this._leftController._activePointer) {\n        _this._castRayAndSelectObject(_this._leftController);\n      }\n\n      if (_this._rightController && _this._rightController._activePointer) {\n        _this._castRayAndSelectObject(_this._rightController);\n      }\n\n      if (_this._noControllerIsActive && (_this._scene.getEngine().isPointerLock || _this.enableGazeEvenWhenNoPointerLock)) {\n        _this._castRayAndSelectObject(_this._cameraGazer);\n      } else {\n        _this._cameraGazer._gazeTracker.isVisible = false;\n      }\n    };\n\n    this._onNewGamepadConnected = function (gamepad) {\n      if (gamepad.type !== Gamepad.POSE_ENABLED) {\n        if (gamepad.leftStick) {\n          gamepad.onleftstickchanged(function (stickValues) {\n            if (_this._teleportationInitialized && _this.teleportationEnabled) {\n              // Listening to classic/xbox gamepad only if no VR controller is active\n              if (!_this._leftController && !_this._rightController || _this._leftController && !_this._leftController._activePointer && _this._rightController && !_this._rightController._activePointer) {\n                _this._checkTeleportWithRay(stickValues, _this._cameraGazer);\n\n                _this._checkTeleportBackwards(stickValues, _this._cameraGazer);\n              }\n            }\n          });\n        }\n\n        if (gamepad.rightStick) {\n          gamepad.onrightstickchanged(function (stickValues) {\n            if (_this._teleportationInitialized) {\n              _this._checkRotate(stickValues, _this._cameraGazer);\n            }\n          });\n        }\n\n        if (gamepad.type === Gamepad.XBOX) {\n          gamepad.onbuttondown(function (buttonPressed) {\n            if (_this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\n              _this._cameraGazer._selectionPointerDown();\n            }\n          });\n          gamepad.onbuttonup(function (buttonPressed) {\n            if (_this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\n              _this._cameraGazer._selectionPointerUp();\n            }\n          });\n        }\n      } else {\n        var webVRController = gamepad;\n        var controller = new VRExperienceHelperControllerGazer(webVRController, _this._scene, _this._cameraGazer._gazeTracker);\n\n        if (webVRController.hand === \"right\" || _this._leftController && _this._leftController.webVRController != webVRController) {\n          _this._rightController = controller;\n        } else {\n          _this._leftController = controller;\n        }\n\n        _this._tryEnableInteractionOnController(controller);\n      }\n    }; // This only succeeds if the controller's mesh exists for the controller so this must be called whenever new controller is connected or when mesh is loaded\n\n\n    this._tryEnableInteractionOnController = function (controller) {\n      if (_this._interactionsRequested && !controller._interactionsEnabled) {\n        _this._enableInteractionOnController(controller);\n      }\n\n      if (_this._teleportationRequested && !controller._teleportationEnabled) {\n        _this._enableTeleportationOnController(controller);\n      }\n    };\n\n    this._onNewGamepadDisconnected = function (gamepad) {\n      if (gamepad instanceof WebVRController) {\n        if (gamepad.hand === \"left\" && _this._leftController != null) {\n          _this._leftController.dispose();\n\n          _this._leftController = null;\n        }\n\n        if (gamepad.hand === \"right\" && _this._rightController != null) {\n          _this._rightController.dispose();\n\n          _this._rightController = null;\n        }\n      }\n    };\n\n    this._workingVector = Vector3.Zero();\n    this._workingQuaternion = Quaternion.Identity();\n    this._workingMatrix = Matrix.Identity();\n    this._scene = scene;\n    this._inputElement = scene.getEngine().getInputElement(); // check for VR support:\n\n    var vrSupported = ('getVRDisplays' in navigator); // no VR support? force XR\n\n    if (!vrSupported) {\n      webVROptions.useXR = true;\n    } // Parse options\n\n\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === undefined) {\n      webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;\n    }\n\n    if (webVROptions.createDeviceOrientationCamera === undefined) {\n      webVROptions.createDeviceOrientationCamera = true;\n    }\n\n    if (webVROptions.laserToggle === undefined) {\n      webVROptions.laserToggle = true;\n    }\n\n    if (webVROptions.defaultHeight === undefined) {\n      webVROptions.defaultHeight = 1.7;\n    }\n\n    if (webVROptions.useCustomVRButton) {\n      this._useCustomVRButton = true;\n\n      if (webVROptions.customVRButton) {\n        this._btnVR = webVROptions.customVRButton;\n      }\n    }\n\n    if (webVROptions.rayLength) {\n      this._rayLength = webVROptions.rayLength;\n    }\n\n    this._defaultHeight = webVROptions.defaultHeight;\n\n    if (webVROptions.positionScale) {\n      this._rayLength *= webVROptions.positionScale;\n      this._defaultHeight *= webVROptions.positionScale;\n    }\n\n    this._hasEnteredVR = false; // Set position\n\n    if (this._scene.activeCamera) {\n      this._position = this._scene.activeCamera.position.clone();\n    } else {\n      this._position = new Vector3(0, this._defaultHeight, 0);\n    } // Set non-vr camera\n\n\n    if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {\n      this._deviceOrientationCamera = new DeviceOrientationCamera(\"deviceOrientationVRHelper\", this._position.clone(), scene); // Copy data from existing camera\n\n      if (this._scene.activeCamera) {\n        this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\n        this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ; // Set rotation from previous camera\n\n        if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {\n          var targetCamera = this._scene.activeCamera;\n\n          if (targetCamera.rotationQuaternion) {\n            this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);\n          } else {\n            this._deviceOrientationCamera.rotationQuaternion.copyFrom(Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z));\n          }\n\n          this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();\n        }\n      }\n\n      this._scene.activeCamera = this._deviceOrientationCamera;\n\n      if (this._inputElement) {\n        this._scene.activeCamera.attachControl();\n      }\n    } else {\n      this._existingCamera = this._scene.activeCamera;\n    }\n\n    if (this.webVROptions.useXR && navigator.xr) {\n      // force-check XR session support\n      WebXRSessionManager.IsSessionSupportedAsync(\"immersive-vr\").then(function (supported) {\n        if (supported) {\n          Logger.Log(\"Using WebXR. It is recommended to use the WebXRDefaultExperience directly\"); // it is possible to use XR, let's do it!\n\n          scene.createDefaultXRExperienceAsync({\n            floorMeshes: webVROptions.floorMeshes || []\n          }).then(function (xr) {\n            _this.xr = xr; // connect observables\n\n            _this.xrTestDone = true;\n            _this._cameraGazer = new VRExperienceHelperCameraGazer(function () {\n              return _this.xr.baseExperience.camera;\n            }, scene);\n\n            _this.xr.baseExperience.onStateChangedObservable.add(function (state) {\n              // support for entering / exiting\n              switch (state) {\n                case WebXRState.ENTERING_XR:\n                  _this.onEnteringVRObservable.notifyObservers(_this);\n\n                  if (!_this._interactionsEnabled) {\n                    _this.xr.pointerSelection.detach();\n                  }\n\n                  _this.xr.pointerSelection.displayLaserPointer = _this._displayLaserPointer;\n                  break;\n\n                case WebXRState.EXITING_XR:\n                  _this.onExitingVRObservable.notifyObservers(_this); // resize to update width and height when exiting vr exits fullscreen\n\n\n                  _this._scene.getEngine().resize();\n\n                  break;\n\n                case WebXRState.IN_XR:\n                  _this._hasEnteredVR = true;\n                  break;\n\n                case WebXRState.NOT_IN_XR:\n                  _this._hasEnteredVR = false;\n                  break;\n              }\n            });\n          });\n        } else {\n          // XR not supported (thou exists), continue WebVR init\n          _this.completeVRInit(scene, webVROptions);\n        }\n      });\n    } else {\n      // no XR, continue init synchronous\n      this.completeVRInit(scene, webVROptions);\n    }\n  }\n\n  Object.defineProperty(VRExperienceHelper.prototype, \"onEnteringVR\", {\n    /** Return this.onEnteringVRObservable\r\n     * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly\r\n     */\n    get: function get() {\n      return this.onEnteringVRObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"onExitingVR\", {\n    /** Return this.onExitingVRObservable\r\n     * Note: This one is for backward compatibility. Please use onExitingVRObservable directly\r\n     */\n    get: function get() {\n      return this.onExitingVRObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"onControllerMeshLoaded\", {\n    /** Return this.onControllerMeshLoadedObservable\r\n     * Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly\r\n     */\n    get: function get() {\n      return this.onControllerMeshLoadedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"teleportationTarget\", {\n    /**\r\n     * The mesh used to display where the user is going to teleport.\r\n     */\n    get: function get() {\n      return this._teleportationTarget;\n    },\n\n    /**\r\n     * Sets the mesh to be used to display where the user is going to teleport.\r\n     */\n    set: function set(value) {\n      if (value) {\n        value.name = \"teleportationTarget\";\n        this._isDefaultTeleportationTarget = false;\n        this._teleportationTarget = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"gazeTrackerMesh\", {\n    /**\r\n     * The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller\r\n     * when set bakeCurrentTransformIntoVertices will be called on the mesh.\r\n     * See https://doc.babylonjs.com/resources/baking_transformations\r\n     */\n    get: function get() {\n      return this._cameraGazer._gazeTracker;\n    },\n    set: function set(value) {\n      if (value) {\n        // Dispose of existing meshes\n        if (this._cameraGazer._gazeTracker) {\n          this._cameraGazer._gazeTracker.dispose();\n        }\n\n        if (this._leftController && this._leftController._gazeTracker) {\n          this._leftController._gazeTracker.dispose();\n        }\n\n        if (this._rightController && this._rightController._gazeTracker) {\n          this._rightController._gazeTracker.dispose();\n        } // Set and create gaze trackers on head and controllers\n\n\n        this._cameraGazer._gazeTracker = value;\n\n        this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();\n\n        this._cameraGazer._gazeTracker.isPickable = false;\n        this._cameraGazer._gazeTracker.isVisible = false;\n        this._cameraGazer._gazeTracker.name = \"gazeTracker\";\n\n        if (this._leftController) {\n          this._leftController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\");\n        }\n\n        if (this._rightController) {\n          this._rightController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\");\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"leftControllerGazeTrackerMesh\", {\n    /**\r\n     * The gaze tracking mesh corresponding to the left controller\r\n     */\n    get: function get() {\n      if (this._leftController) {\n        return this._leftController._gazeTracker;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"rightControllerGazeTrackerMesh\", {\n    /**\r\n     * The gaze tracking mesh corresponding to the right controller\r\n     */\n    get: function get() {\n      if (this._rightController) {\n        return this._rightController._gazeTracker;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"displayGaze\", {\n    /**\r\n     * If the ray of the gaze should be displayed.\r\n     */\n    get: function get() {\n      return this._displayGaze;\n    },\n\n    /**\r\n     * Sets if the ray of the gaze should be displayed.\r\n     */\n    set: function set(value) {\n      this._displayGaze = value;\n\n      if (!value) {\n        this._cameraGazer._gazeTracker.isVisible = false;\n\n        if (this._leftController) {\n          this._leftController._gazeTracker.isVisible = false;\n        }\n\n        if (this._rightController) {\n          this._rightController._gazeTracker.isVisible = false;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"displayLaserPointer\", {\n    /**\r\n     * If the ray of the LaserPointer should be displayed.\r\n     */\n    get: function get() {\n      return this._displayLaserPointer;\n    },\n\n    /**\r\n     * Sets if the ray of the LaserPointer should be displayed.\r\n     */\n    set: function set(value) {\n      this._displayLaserPointer = value;\n\n      if (!value) {\n        if (this._rightController) {\n          this._rightController._deactivatePointer();\n\n          this._rightController._gazeTracker.isVisible = false;\n        }\n\n        if (this._leftController) {\n          this._leftController._deactivatePointer();\n\n          this._leftController._gazeTracker.isVisible = false;\n        }\n      } else {\n        if (this._rightController) {\n          this._rightController._activatePointer();\n        }\n\n        if (this._leftController) {\n          this._leftController._activatePointer();\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"deviceOrientationCamera\", {\n    /**\r\n     * The deviceOrientationCamera used as the camera when not in VR.\r\n     */\n    get: function get() {\n      return this._deviceOrientationCamera;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"currentVRCamera\", {\n    /**\r\n     * Based on the current WebVR support, returns the current VR camera used.\r\n     */\n    get: function get() {\n      if (this._webVRready) {\n        return this._webVRCamera;\n      } else {\n        return this._scene.activeCamera;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"webVRCamera\", {\n    /**\r\n     * The webVRCamera which is used when in VR.\r\n     */\n    get: function get() {\n      return this._webVRCamera;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"vrDeviceOrientationCamera\", {\n    /**\r\n     * The deviceOrientationCamera that is used as a fallback when vr device is not connected.\r\n     */\n    get: function get() {\n      return this._vrDeviceOrientationCamera;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"vrButton\", {\n    /**\r\n     * The html button that is used to trigger entering into VR.\r\n     */\n    get: function get() {\n      return this._btnVR;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VRExperienceHelper.prototype, \"_teleportationRequestInitiated\", {\n    get: function get() {\n      var result = this._cameraGazer._teleportationRequestInitiated || this._leftController !== null && this._leftController._teleportationRequestInitiated || this._rightController !== null && this._rightController._teleportationRequestInitiated;\n      return result;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VRExperienceHelper.prototype.completeVRInit = function (scene, webVROptions) {\n    var _this = this;\n\n    this.xrTestDone = true; // Create VR cameras\n\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\n      if (webVROptions.useMultiview) {\n        if (!webVROptions.vrDeviceOrientationCameraMetrics) {\n          webVROptions.vrDeviceOrientationCameraMetrics = VRCameraMetrics.GetDefault();\n        }\n\n        webVROptions.vrDeviceOrientationCameraMetrics.multiviewEnabled = true;\n      }\n\n      this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera(\"VRDeviceOrientationVRHelper\", this._position, this._scene, true, webVROptions.vrDeviceOrientationCameraMetrics);\n      this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\n    }\n\n    this._webVRCamera = new WebVRFreeCamera(\"WebVRHelper\", this._position, this._scene, webVROptions);\n\n    this._webVRCamera.useStandingMatrix();\n\n    this._cameraGazer = new VRExperienceHelperCameraGazer(function () {\n      return _this.currentVRCamera;\n    }, scene); // Create default button\n\n    if (!this._useCustomVRButton) {\n      this._btnVR = document.createElement(\"BUTTON\");\n      this._btnVR.className = \"babylonVRicon\";\n      this._btnVR.id = \"babylonVRiconbtn\";\n      this._btnVR.title = \"Click to switch to VR\";\n      var url = !window.SVGSVGElement ? \"https://cdn.babylonjs.com/Assets/vrButton.png\" : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\n      var css = \".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" + url + \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\n      css += \".babylonVRicon.vrdisplaypresenting { display: none; }\"; // TODO: Add user feedback so that they know what state the VRDisplay is in (disconnected, connected, entering-VR)\n      // css += \".babylonVRicon.vrdisplaysupported { }\";\n      // css += \".babylonVRicon.vrdisplayready { }\";\n      // css += \".babylonVRicon.vrdisplayrequesting { }\";\n\n      var style = document.createElement('style');\n      style.appendChild(document.createTextNode(css));\n      document.getElementsByTagName('head')[0].appendChild(style);\n      this.moveButtonToBottomRight();\n    } // VR button click event\n\n\n    if (this._btnVR) {\n      this._btnVR.addEventListener(\"click\", function () {\n        if (!_this.isInVRMode) {\n          _this.enterVR();\n        } else {\n          _this._scene.getEngine().disableVR();\n        }\n      });\n    } // Window events\n\n\n    var hostWindow = this._scene.getEngine().getHostWindow();\n\n    if (!hostWindow) {\n      return;\n    }\n\n    hostWindow.addEventListener(\"resize\", this._onResize);\n    document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, false);\n    document.addEventListener(\"mozfullscreenchange\", this._onFullscreenChange, false);\n    document.addEventListener(\"webkitfullscreenchange\", this._onFullscreenChange, false);\n    document.addEventListener(\"msfullscreenchange\", this._onFullscreenChange, false);\n    document.onmsfullscreenchange = this._onFullscreenChange; // Display vr button when headset is connected\n\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\n      this.displayVRButton();\n    } else {\n      this._scene.getEngine().onVRDisplayChangedObservable.add(function (e) {\n        if (e.vrDisplay) {\n          _this.displayVRButton();\n        }\n      });\n    } // Exiting VR mode using 'ESC' key on desktop\n\n\n    this._onKeyDown = function (event) {\n      if (event.keyCode === 27 && _this.isInVRMode) {\n        _this.exitVR();\n      }\n    };\n\n    document.addEventListener(\"keydown\", this._onKeyDown); // Exiting VR mode double tapping the touch screen\n\n    this._scene.onPrePointerObservable.add(function () {\n      if (_this._hasEnteredVR && _this.exitVROnDoubleTap) {\n        _this.exitVR();\n\n        if (_this._fullscreenVRpresenting) {\n          _this._scene.getEngine().exitFullscreen();\n        }\n      }\n    }, PointerEventTypes.POINTERDOUBLETAP, false); // Listen for WebVR display changes\n\n\n    this._onVRDisplayChanged = function (eventArgs) {\n      return _this.onVRDisplayChanged(eventArgs);\n    };\n\n    this._onVrDisplayPresentChange = function () {\n      return _this.onVrDisplayPresentChange();\n    };\n\n    this._onVRRequestPresentStart = function () {\n      _this._webVRrequesting = true;\n\n      _this.updateButtonVisibility();\n    };\n\n    this._onVRRequestPresentComplete = function () {\n      _this._webVRrequesting = false;\n\n      _this.updateButtonVisibility();\n    };\n\n    scene.getEngine().onVRDisplayChangedObservable.add(this._onVRDisplayChanged);\n    scene.getEngine().onVRRequestPresentStart.add(this._onVRRequestPresentStart);\n    scene.getEngine().onVRRequestPresentComplete.add(this._onVRRequestPresentComplete);\n    hostWindow.addEventListener('vrdisplaypresentchange', this._onVrDisplayPresentChange);\n    scene.onDisposeObservable.add(function () {\n      _this.dispose();\n    }); // Gamepad connection events\n\n    this._webVRCamera.onControllerMeshLoadedObservable.add(function (webVRController) {\n      return _this._onDefaultMeshLoaded(webVRController);\n    });\n\n    this._scene.gamepadManager.onGamepadConnectedObservable.add(this._onNewGamepadConnected);\n\n    this._scene.gamepadManager.onGamepadDisconnectedObservable.add(this._onNewGamepadDisconnected);\n\n    this.updateButtonVisibility(); //create easing functions\n\n    this._circleEase = new CircleEase();\n\n    this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n\n    this._teleportationEasing = this._circleEase; // Allow clicking in the vrDeviceOrientationCamera\n\n    scene.onPointerObservable.add(function (e) {\n      if (_this._interactionsEnabled) {\n        if (scene.activeCamera === _this.vrDeviceOrientationCamera && e.event.pointerType === \"mouse\") {\n          if (e.type === PointerEventTypes.POINTERDOWN) {\n            _this._cameraGazer._selectionPointerDown();\n          } else if (e.type === PointerEventTypes.POINTERUP) {\n            _this._cameraGazer._selectionPointerUp();\n          }\n        }\n      }\n    });\n\n    if (this.webVROptions.floorMeshes) {\n      this.enableTeleportation({\n        floorMeshes: this.webVROptions.floorMeshes\n      });\n    }\n  }; // Raised when one of the controller has loaded successfully its associated default mesh\n\n\n  VRExperienceHelper.prototype._onDefaultMeshLoaded = function (webVRController) {\n    if (this._leftController && this._leftController.webVRController == webVRController) {\n      if (webVRController.mesh) {\n        this._leftController._setLaserPointerParent(webVRController.mesh);\n      }\n    }\n\n    if (this._rightController && this._rightController.webVRController == webVRController) {\n      if (webVRController.mesh) {\n        this._rightController._setLaserPointerParent(webVRController.mesh);\n      }\n    }\n\n    try {\n      this.onControllerMeshLoadedObservable.notifyObservers(webVRController);\n    } catch (err) {\n      Logger.Warn(\"Error in your custom logic onControllerMeshLoaded: \" + err);\n    }\n  };\n\n  Object.defineProperty(VRExperienceHelper.prototype, \"isInVRMode\", {\n    /**\r\n     * Gets a value indicating if we are currently in VR mode.\r\n     */\n    get: function get() {\n      return this.xr && this.webVROptions.useXR && this.xr.baseExperience.state === WebXRState.IN_XR || this._webVRpresenting || this._fullscreenVRpresenting;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VRExperienceHelper.prototype.onVrDisplayPresentChange = function () {\n    var vrDisplay = this._scene.getEngine().getVRDevice();\n\n    if (vrDisplay) {\n      var wasPresenting = this._webVRpresenting;\n      this._webVRpresenting = vrDisplay.isPresenting;\n\n      if (wasPresenting && !this._webVRpresenting) {\n        this.exitVR();\n      }\n    } else {\n      Logger.Warn('Detected VRDisplayPresentChange on an unknown VRDisplay. Did you can enterVR on the vrExperienceHelper?');\n    }\n\n    this.updateButtonVisibility();\n  };\n\n  VRExperienceHelper.prototype.onVRDisplayChanged = function (eventArgs) {\n    this._webVRsupported = eventArgs.vrSupported;\n    this._webVRready = !!eventArgs.vrDisplay;\n    this._webVRpresenting = eventArgs.vrDisplay && eventArgs.vrDisplay.isPresenting;\n    this.updateButtonVisibility();\n  };\n\n  VRExperienceHelper.prototype.moveButtonToBottomRight = function () {\n    if (this._inputElement && !this._useCustomVRButton && this._btnVR) {\n      var rect = this._inputElement.getBoundingClientRect();\n\n      this._btnVR.style.top = rect.top + rect.height - 70 + \"px\";\n      this._btnVR.style.left = rect.left + rect.width - 100 + \"px\";\n    }\n  };\n\n  VRExperienceHelper.prototype.displayVRButton = function () {\n    if (!this._useCustomVRButton && !this._btnVRDisplayed && this._btnVR) {\n      document.body.appendChild(this._btnVR);\n      this._btnVRDisplayed = true;\n    }\n  };\n\n  VRExperienceHelper.prototype.updateButtonVisibility = function () {\n    if (!this._btnVR || this._useCustomVRButton) {\n      return;\n    }\n\n    this._btnVR.className = \"babylonVRicon\";\n\n    if (this.isInVRMode) {\n      this._btnVR.className += \" vrdisplaypresenting\";\n    } else {\n      if (this._webVRready) {\n        this._btnVR.className += \" vrdisplayready\";\n      }\n\n      if (this._webVRsupported) {\n        this._btnVR.className += \" vrdisplaysupported\";\n      }\n\n      if (this._webVRrequesting) {\n        this._btnVR.className += \" vrdisplayrequesting\";\n      }\n    }\n  };\n  /**\r\n   * Attempt to enter VR. If a headset is connected and ready, will request present on that.\r\n   * Otherwise, will use the fullscreen API.\r\n   */\n\n\n  VRExperienceHelper.prototype.enterVR = function () {\n    var _this = this;\n\n    if (this.xr) {\n      this.xr.baseExperience.enterXRAsync(\"immersive-vr\", \"local-floor\", this.xr.renderTarget);\n      return;\n    }\n\n    if (this.onEnteringVRObservable) {\n      try {\n        this.onEnteringVRObservable.notifyObservers(this);\n      } catch (err) {\n        Logger.Warn(\"Error in your custom logic onEnteringVR: \" + err);\n      }\n    }\n\n    if (this._scene.activeCamera) {\n      this._position = this._scene.activeCamera.position.clone();\n\n      if (this.vrDeviceOrientationCamera) {\n        this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();\n        this.vrDeviceOrientationCamera.angularSensibility = 2000;\n      }\n\n      if (this.webVRCamera) {\n        var currentYRotation = this.webVRCamera.deviceRotationQuaternion.toEulerAngles().y;\n        var desiredYRotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles().y;\n        var delta = desiredYRotation - currentYRotation;\n        var currentGlobalRotation = this.webVRCamera.rotationQuaternion.toEulerAngles().y;\n        this.webVRCamera.rotationQuaternion = Quaternion.FromEulerAngles(0, currentGlobalRotation + delta, 0);\n      } // make sure that we return to the last active camera\n\n\n      this._existingCamera = this._scene.activeCamera; // Remove and cache angular sensability to avoid camera rotation when in VR\n\n      if (this._existingCamera.angularSensibilityX) {\n        this._cachedAngularSensibility.angularSensibilityX = this._existingCamera.angularSensibilityX;\n        this._existingCamera.angularSensibilityX = Number.MAX_VALUE;\n      }\n\n      if (this._existingCamera.angularSensibilityY) {\n        this._cachedAngularSensibility.angularSensibilityY = this._existingCamera.angularSensibilityY;\n        this._existingCamera.angularSensibilityY = Number.MAX_VALUE;\n      }\n\n      if (this._existingCamera.angularSensibility) {\n        this._cachedAngularSensibility.angularSensibility = this._existingCamera.angularSensibility;\n        this._existingCamera.angularSensibility = Number.MAX_VALUE;\n      }\n    }\n\n    if (this._webVRrequesting) {\n      return;\n    } // If WebVR is supported and a headset is connected\n\n\n    if (this._webVRready) {\n      if (!this._webVRpresenting) {\n        this._scene.getEngine().onVRRequestPresentComplete.addOnce(function (result) {\n          _this.onAfterEnteringVRObservable.notifyObservers({\n            success: result\n          });\n        });\n\n        this._webVRCamera.position = this._position;\n        this._scene.activeCamera = this._webVRCamera;\n      }\n    } else if (this._vrDeviceOrientationCamera) {\n      this._vrDeviceOrientationCamera.position = this._position;\n\n      if (this._scene.activeCamera) {\n        this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\n      }\n\n      this._scene.activeCamera = this._vrDeviceOrientationCamera;\n\n      this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);\n\n      this.updateButtonVisibility();\n\n      this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(function () {\n        _this.onAfterEnteringVRObservable.notifyObservers({\n          success: true\n        });\n      });\n    }\n\n    if (this._scene.activeCamera && this._inputElement) {\n      this._scene.activeCamera.attachControl();\n    }\n\n    if (this._interactionsEnabled) {\n      this._scene.registerBeforeRender(this.beforeRender);\n    }\n\n    if (this._displayLaserPointer) {\n      [this._leftController, this._rightController].forEach(function (controller) {\n        if (controller) {\n          controller._activatePointer();\n        }\n      });\n    }\n\n    this._hasEnteredVR = true;\n  };\n  /**\r\n   * Attempt to exit VR, or fullscreen.\r\n   */\n\n\n  VRExperienceHelper.prototype.exitVR = function () {\n    if (this.xr) {\n      this.xr.baseExperience.exitXRAsync();\n      return;\n    }\n\n    if (this._hasEnteredVR) {\n      if (this.onExitingVRObservable) {\n        try {\n          this.onExitingVRObservable.notifyObservers(this);\n        } catch (err) {\n          Logger.Warn(\"Error in your custom logic onExitingVR: \" + err);\n        }\n      }\n\n      if (this._webVRpresenting) {\n        this._scene.getEngine().disableVR();\n      }\n\n      if (this._scene.activeCamera) {\n        this._position = this._scene.activeCamera.position.clone();\n      }\n\n      if (this.vrDeviceOrientationCamera) {\n        this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\n      }\n\n      if (this._deviceOrientationCamera) {\n        this._deviceOrientationCamera.position = this._position;\n        this._scene.activeCamera = this._deviceOrientationCamera; // Restore angular sensibility\n\n        if (this._cachedAngularSensibility.angularSensibilityX) {\n          this._deviceOrientationCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\n          this._cachedAngularSensibility.angularSensibilityX = null;\n        }\n\n        if (this._cachedAngularSensibility.angularSensibilityY) {\n          this._deviceOrientationCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\n          this._cachedAngularSensibility.angularSensibilityY = null;\n        }\n\n        if (this._cachedAngularSensibility.angularSensibility) {\n          this._deviceOrientationCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;\n          this._cachedAngularSensibility.angularSensibility = null;\n        }\n      } else if (this._existingCamera) {\n        this._existingCamera.position = this._position;\n        this._scene.activeCamera = this._existingCamera;\n\n        if (this._inputElement) {\n          this._scene.activeCamera.attachControl();\n        } // Restore angular sensibility\n\n\n        if (this._cachedAngularSensibility.angularSensibilityX) {\n          this._existingCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\n          this._cachedAngularSensibility.angularSensibilityX = null;\n        }\n\n        if (this._cachedAngularSensibility.angularSensibilityY) {\n          this._existingCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\n          this._cachedAngularSensibility.angularSensibilityY = null;\n        }\n\n        if (this._cachedAngularSensibility.angularSensibility) {\n          this._existingCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;\n          this._cachedAngularSensibility.angularSensibility = null;\n        }\n      }\n\n      this.updateButtonVisibility();\n\n      if (this._interactionsEnabled) {\n        this._scene.unregisterBeforeRender(this.beforeRender);\n\n        this._cameraGazer._gazeTracker.isVisible = false;\n\n        if (this._leftController) {\n          this._leftController._gazeTracker.isVisible = false;\n        }\n\n        if (this._rightController) {\n          this._rightController._gazeTracker.isVisible = false;\n        }\n      } // resize to update width and height when exiting vr exits fullscreen\n\n\n      this._scene.getEngine().resize();\n\n      [this._leftController, this._rightController].forEach(function (controller) {\n        if (controller) {\n          controller._deactivatePointer();\n        }\n      });\n      this._hasEnteredVR = false; // Update engine state to re enable non-vr camera input\n\n      var engine = this._scene.getEngine();\n\n      if (engine._onVrDisplayPresentChange) {\n        engine._onVrDisplayPresentChange();\n      }\n    }\n  };\n\n  Object.defineProperty(VRExperienceHelper.prototype, \"position\", {\n    /**\r\n     * The position of the vr experience helper.\r\n     */\n    get: function get() {\n      return this._position;\n    },\n\n    /**\r\n     * Sets the position of the vr experience helper.\r\n     */\n    set: function set(value) {\n      this._position = value;\n\n      if (this._scene.activeCamera) {\n        this._scene.activeCamera.position = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Enables controllers and user interactions such as selecting and object or clicking on an object.\r\n   */\n\n  VRExperienceHelper.prototype.enableInteractions = function () {\n    var _this = this;\n\n    if (!this._interactionsEnabled) {\n      this._interactionsRequested = true; // in XR it is enabled by default, but just to make sure, re-attach\n\n      if (this.xr) {\n        if (this.xr.baseExperience.state === WebXRState.IN_XR) {\n          this.xr.pointerSelection.attach();\n        }\n\n        return;\n      }\n\n      if (this._leftController) {\n        this._enableInteractionOnController(this._leftController);\n      }\n\n      if (this._rightController) {\n        this._enableInteractionOnController(this._rightController);\n      }\n\n      this.raySelectionPredicate = function (mesh) {\n        return mesh.isVisible && (mesh.isPickable || mesh.name === _this._floorMeshName);\n      };\n\n      this.meshSelectionPredicate = function () {\n        return true;\n      };\n\n      this._raySelectionPredicate = function (mesh) {\n        if (_this._isTeleportationFloor(mesh) || mesh.name.indexOf(\"gazeTracker\") === -1 && mesh.name.indexOf(\"teleportationTarget\") === -1 && mesh.name.indexOf(\"torusTeleportation\") === -1) {\n          return _this.raySelectionPredicate(mesh);\n        }\n\n        return false;\n      };\n\n      this._interactionsEnabled = true;\n    }\n  };\n\n  Object.defineProperty(VRExperienceHelper.prototype, \"_noControllerIsActive\", {\n    get: function get() {\n      return !(this._leftController && this._leftController._activePointer) && !(this._rightController && this._rightController._activePointer);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VRExperienceHelper.prototype._isTeleportationFloor = function (mesh) {\n    for (var i = 0; i < this._floorMeshesCollection.length; i++) {\n      if (this._floorMeshesCollection[i].id === mesh.id) {\n        return true;\n      }\n    }\n\n    if (this._floorMeshName && mesh.name === this._floorMeshName) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Adds a floor mesh to be used for teleportation.\r\n   * @param floorMesh the mesh to be used for teleportation.\r\n   */\n\n\n  VRExperienceHelper.prototype.addFloorMesh = function (floorMesh) {\n    if (!this._floorMeshesCollection) {\n      return;\n    }\n\n    if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {\n      return;\n    }\n\n    this._floorMeshesCollection.push(floorMesh);\n  };\n  /**\r\n   * Removes a floor mesh from being used for teleportation.\r\n   * @param floorMesh the mesh to be removed.\r\n   */\n\n\n  VRExperienceHelper.prototype.removeFloorMesh = function (floorMesh) {\n    if (!this._floorMeshesCollection) {\n      return;\n    }\n\n    var meshIndex = this._floorMeshesCollection.indexOf(floorMesh);\n\n    if (meshIndex !== -1) {\n      this._floorMeshesCollection.splice(meshIndex, 1);\n    }\n  };\n  /**\r\n   * Enables interactions and teleportation using the VR controllers and gaze.\r\n   * @param vrTeleportationOptions options to modify teleportation behavior.\r\n   */\n\n\n  VRExperienceHelper.prototype.enableTeleportation = function (vrTeleportationOptions) {\n    var _this = this;\n\n    if (vrTeleportationOptions === void 0) {\n      vrTeleportationOptions = {};\n    }\n\n    if (!this._teleportationInitialized) {\n      this._teleportationRequested = true;\n      this.enableInteractions();\n\n      if (this.webVROptions.useXR && (vrTeleportationOptions.floorMeshes || vrTeleportationOptions.floorMeshName)) {\n        var floorMeshes = vrTeleportationOptions.floorMeshes || [];\n\n        if (!floorMeshes.length) {\n          var floorMesh = this._scene.getMeshByName(vrTeleportationOptions.floorMeshName);\n\n          if (floorMesh) {\n            floorMeshes.push(floorMesh);\n          }\n        }\n\n        if (this.xr) {\n          floorMeshes.forEach(function (mesh) {\n            _this.xr.teleportation.addFloorMesh(mesh);\n          });\n\n          if (!this.xr.teleportation.attached) {\n            this.xr.teleportation.attach();\n          }\n\n          return;\n        } else if (!this.xrTestDone) {\n          var waitForXr_1 = function waitForXr_1() {\n            if (_this.xrTestDone) {\n              _this._scene.unregisterBeforeRender(waitForXr_1);\n\n              if (_this.xr) {\n                if (!_this.xr.teleportation.attached) {\n                  _this.xr.teleportation.attach();\n                }\n              } else {\n                _this.enableTeleportation(vrTeleportationOptions);\n              }\n            }\n          };\n\n          this._scene.registerBeforeRender(waitForXr_1);\n\n          return;\n        }\n      }\n\n      if (vrTeleportationOptions.floorMeshName) {\n        this._floorMeshName = vrTeleportationOptions.floorMeshName;\n      }\n\n      if (vrTeleportationOptions.floorMeshes) {\n        this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;\n      }\n\n      if (vrTeleportationOptions.teleportationMode) {\n        this._teleportationMode = vrTeleportationOptions.teleportationMode;\n      }\n\n      if (vrTeleportationOptions.teleportationTime && vrTeleportationOptions.teleportationTime > 0) {\n        this._teleportationTime = vrTeleportationOptions.teleportationTime;\n      }\n\n      if (vrTeleportationOptions.teleportationSpeed && vrTeleportationOptions.teleportationSpeed > 0) {\n        this._teleportationSpeed = vrTeleportationOptions.teleportationSpeed;\n      }\n\n      if (vrTeleportationOptions.easingFunction !== undefined) {\n        this._teleportationEasing = vrTeleportationOptions.easingFunction;\n      }\n\n      if (this._leftController != null) {\n        this._enableTeleportationOnController(this._leftController);\n      }\n\n      if (this._rightController != null) {\n        this._enableTeleportationOnController(this._rightController);\n      } // Creates an image processing post process for the vignette not relying\n      // on the main scene configuration for image processing to reduce setup and spaces\n      // (gamma/linear) conflicts.\n\n\n      var imageProcessingConfiguration = new ImageProcessingConfiguration();\n      imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);\n      imageProcessingConfiguration.vignetteEnabled = true;\n      this._postProcessMove = new ImageProcessingPostProcess(\"postProcessMove\", 1.0, this._webVRCamera, undefined, undefined, undefined, undefined, imageProcessingConfiguration);\n\n      this._webVRCamera.detachPostProcess(this._postProcessMove);\n\n      this._teleportationInitialized = true;\n\n      if (this._isDefaultTeleportationTarget) {\n        this._createTeleportationCircles();\n\n        this._teleportationTarget.scaling.scaleInPlace(this._webVRCamera.deviceScaleFactor);\n      }\n    }\n  };\n\n  VRExperienceHelper.prototype._enableInteractionOnController = function (controller) {\n    var _this = this;\n\n    var controllerMesh = controller.webVRController.mesh;\n\n    if (controllerMesh) {\n      controller._interactionsEnabled = true;\n\n      if (this.isInVRMode && this._displayLaserPointer) {\n        controller._activatePointer();\n      }\n\n      if (this.webVROptions.laserToggle) {\n        controller.webVRController.onMainButtonStateChangedObservable.add(function (stateObject) {\n          // Enabling / disabling laserPointer\n          if (_this._displayLaserPointer && stateObject.value === 1) {\n            if (controller._activePointer) {\n              controller._deactivatePointer();\n            } else {\n              controller._activatePointer();\n            }\n\n            if (_this.displayGaze) {\n              controller._gazeTracker.isVisible = controller._activePointer;\n            }\n          }\n        });\n      }\n\n      controller.webVRController.onTriggerStateChangedObservable.add(function (stateObject) {\n        var gazer = controller;\n\n        if (_this._noControllerIsActive) {\n          gazer = _this._cameraGazer;\n        }\n\n        if (!gazer._pointerDownOnMeshAsked) {\n          if (stateObject.value > _this._padSensibilityUp) {\n            gazer._selectionPointerDown();\n          }\n        } else if (stateObject.value < _this._padSensibilityDown) {\n          gazer._selectionPointerUp();\n        }\n      });\n    }\n  };\n\n  VRExperienceHelper.prototype._checkTeleportWithRay = function (stateObject, gazer) {\n    // Dont teleport if another gaze already requested teleportation\n    if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {\n      return;\n    }\n\n    if (!gazer._teleportationRequestInitiated) {\n      if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._activatePointer();\n\n        gazer._teleportationRequestInitiated = true;\n      }\n    } else {\n      // Listening to the proper controller values changes to confirm teleportation\n      if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {\n        if (this._teleportActive) {\n          this.teleportCamera(this._haloCenter);\n        }\n\n        gazer._teleportationRequestInitiated = false;\n      }\n    }\n  };\n\n  VRExperienceHelper.prototype._checkRotate = function (stateObject, gazer) {\n    // Only rotate when user is not currently selecting a teleportation location\n    if (gazer._teleportationRequestInitiated) {\n      return;\n    }\n\n    if (!gazer._rotationLeftAsked) {\n      if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._rotationLeftAsked = true;\n\n        if (this._rotationAllowed) {\n          this._rotateCamera(false);\n        }\n      }\n    } else {\n      if (stateObject.x > -this._padSensibilityDown) {\n        gazer._rotationLeftAsked = false;\n      }\n    }\n\n    if (!gazer._rotationRightAsked) {\n      if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._rotationRightAsked = true;\n\n        if (this._rotationAllowed) {\n          this._rotateCamera(true);\n        }\n      }\n    } else {\n      if (stateObject.x < this._padSensibilityDown) {\n        gazer._rotationRightAsked = false;\n      }\n    }\n  };\n\n  VRExperienceHelper.prototype._checkTeleportBackwards = function (stateObject, gazer) {\n    // Only teleport backwards when user is not currently selecting a teleportation location\n    if (gazer._teleportationRequestInitiated) {\n      return;\n    } // Teleport backwards\n\n\n    if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {\n      if (!gazer._teleportationBackRequestInitiated) {\n        if (!this.currentVRCamera) {\n          return;\n        } // Get rotation and position of the current camera\n\n\n        var rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());\n        var position = this.currentVRCamera.position; // If the camera has device position, use that instead\n\n        if (this.currentVRCamera.devicePosition && this.currentVRCamera.deviceRotationQuaternion) {\n          rotation = this.currentVRCamera.deviceRotationQuaternion;\n          position = this.currentVRCamera.devicePosition;\n        } // Get matrix with only the y rotation of the device rotation\n\n\n        rotation.toEulerAnglesToRef(this._workingVector);\n        this._workingVector.z = 0;\n        this._workingVector.x = 0;\n        Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);\n\n        this._workingQuaternion.toRotationMatrix(this._workingMatrix); // Rotate backwards ray by device rotation to cast at the ground behind the user\n\n\n        Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector); // Teleport if ray hit the ground and is not to far away eg. backwards off a cliff\n\n        var ray = new Ray(position, this._workingVector);\n\n        var hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\n\n        if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {\n          this.teleportCamera(hit.pickedPoint);\n        }\n\n        gazer._teleportationBackRequestInitiated = true;\n      }\n    } else {\n      gazer._teleportationBackRequestInitiated = false;\n    }\n  };\n\n  VRExperienceHelper.prototype._enableTeleportationOnController = function (controller) {\n    var _this = this;\n\n    var controllerMesh = controller.webVRController.mesh;\n\n    if (controllerMesh) {\n      if (!controller._interactionsEnabled) {\n        this._enableInteractionOnController(controller);\n      }\n\n      controller._interactionsEnabled = true;\n      controller._teleportationEnabled = true;\n\n      if (controller.webVRController.controllerType === PoseEnabledControllerType.VIVE) {\n        controller._dpadPressed = false;\n        controller.webVRController.onPadStateChangedObservable.add(function (stateObject) {\n          controller._dpadPressed = stateObject.pressed;\n\n          if (!controller._dpadPressed) {\n            controller._rotationLeftAsked = false;\n            controller._rotationRightAsked = false;\n            controller._teleportationBackRequestInitiated = false;\n          }\n        });\n      }\n\n      controller.webVRController.onPadValuesChangedObservable.add(function (stateObject) {\n        if (_this.teleportationEnabled) {\n          _this._checkTeleportBackwards(stateObject, controller);\n\n          _this._checkTeleportWithRay(stateObject, controller);\n        }\n\n        _this._checkRotate(stateObject, controller);\n      });\n    }\n  };\n\n  VRExperienceHelper.prototype._createTeleportationCircles = function () {\n    this._teleportationTarget = Mesh.CreateGround(\"teleportationTarget\", 2, 2, 2, this._scene);\n    this._teleportationTarget.isPickable = false;\n    var length = 512;\n    var dynamicTexture = new DynamicTexture(\"DynamicTexture\", length, this._scene, true);\n    dynamicTexture.hasAlpha = true;\n    var context = dynamicTexture.getContext();\n    var centerX = length / 2;\n    var centerY = length / 2;\n    var radius = 200;\n    context.beginPath();\n    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n    context.fillStyle = this._teleportationFillColor;\n    context.fill();\n    context.lineWidth = 10;\n    context.strokeStyle = this._teleportationBorderColor;\n    context.stroke();\n    context.closePath();\n    dynamicTexture.update();\n    var teleportationCircleMaterial = new StandardMaterial(\"TextPlaneMaterial\", this._scene);\n    teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n    this._teleportationTarget.material = teleportationCircleMaterial;\n    var torus = Mesh.CreateTorus(\"torusTeleportation\", 0.75, 0.1, 25, this._scene, false);\n    torus.isPickable = false;\n    torus.parent = this._teleportationTarget;\n    var animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n    var keys = [];\n    keys.push({\n      frame: 0,\n      value: 0\n    });\n    keys.push({\n      frame: 30,\n      value: 0.4\n    });\n    keys.push({\n      frame: 60,\n      value: 0\n    });\n    animationInnerCircle.setKeys(keys);\n    var easingFunction = new SineEase();\n    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n    animationInnerCircle.setEasingFunction(easingFunction);\n    torus.animations = [];\n    torus.animations.push(animationInnerCircle);\n\n    this._scene.beginAnimation(torus, 0, 60, true);\n\n    this._hideTeleportationTarget();\n  };\n\n  VRExperienceHelper.prototype._displayTeleportationTarget = function () {\n    this._teleportActive = true;\n\n    if (this._teleportationInitialized) {\n      this._teleportationTarget.isVisible = true;\n\n      if (this._isDefaultTeleportationTarget) {\n        this._teleportationTarget.getChildren()[0].isVisible = true;\n      }\n    }\n  };\n\n  VRExperienceHelper.prototype._hideTeleportationTarget = function () {\n    this._teleportActive = false;\n\n    if (this._teleportationInitialized) {\n      this._teleportationTarget.isVisible = false;\n\n      if (this._isDefaultTeleportationTarget) {\n        this._teleportationTarget.getChildren()[0].isVisible = false;\n      }\n    }\n  };\n\n  VRExperienceHelper.prototype._rotateCamera = function (right) {\n    var _this = this;\n\n    if (!(this.currentVRCamera instanceof FreeCamera)) {\n      return;\n    }\n\n    if (right) {\n      this._rotationAngle++;\n    } else {\n      this._rotationAngle--;\n    }\n\n    this.currentVRCamera.animations = [];\n    var target = Quaternion.FromRotationMatrix(Matrix.RotationY(Math.PI / 4 * this._rotationAngle));\n    var animationRotation = new Animation(\"animationRotation\", \"rotationQuaternion\", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var animationRotationKeys = [];\n    animationRotationKeys.push({\n      frame: 0,\n      value: this.currentVRCamera.rotationQuaternion\n    });\n    animationRotationKeys.push({\n      frame: 6,\n      value: target\n    });\n    animationRotation.setKeys(animationRotationKeys);\n    animationRotation.setEasingFunction(this._circleEase);\n    this.currentVRCamera.animations.push(animationRotation);\n    this._postProcessMove.animations = [];\n    var animationPP = new Animation(\"animationPP\", \"vignetteWeight\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var vignetteWeightKeys = [];\n    vignetteWeightKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteWeightKeys.push({\n      frame: 3,\n      value: 4\n    });\n    vignetteWeightKeys.push({\n      frame: 6,\n      value: 0\n    });\n    animationPP.setKeys(vignetteWeightKeys);\n    animationPP.setEasingFunction(this._circleEase);\n\n    this._postProcessMove.animations.push(animationPP);\n\n    var animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var vignetteStretchKeys = [];\n    vignetteStretchKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteStretchKeys.push({\n      frame: 3,\n      value: 10\n    });\n    vignetteStretchKeys.push({\n      frame: 6,\n      value: 0\n    });\n    animationPP2.setKeys(vignetteStretchKeys);\n    animationPP2.setEasingFunction(this._circleEase);\n\n    this._postProcessMove.animations.push(animationPP2);\n\n    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\n    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\n    this._postProcessMove.samples = 4;\n\n    this._webVRCamera.attachPostProcess(this._postProcessMove);\n\n    this._scene.beginAnimation(this._postProcessMove, 0, 6, false, 1, function () {\n      _this._webVRCamera.detachPostProcess(_this._postProcessMove);\n    });\n\n    this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);\n  };\n\n  VRExperienceHelper.prototype._moveTeleportationSelectorTo = function (hit, gazer, ray) {\n    if (hit.pickedPoint) {\n      if (gazer._teleportationRequestInitiated) {\n        this._displayTeleportationTarget();\n\n        this._haloCenter.copyFrom(hit.pickedPoint);\n\n        this._teleportationTarget.position.copyFrom(hit.pickedPoint);\n      }\n\n      var pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(true, false), ray);\n\n      if (pickNormal) {\n        var axis1 = Vector3.Cross(Axis.Y, pickNormal);\n        var axis2 = Vector3.Cross(pickNormal, axis1);\n        Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, this._teleportationTarget.rotation);\n      }\n\n      this._teleportationTarget.position.y += 0.1;\n    }\n  };\n  /**\r\n   * Teleports the users feet to the desired location\r\n   * @param location The location where the user's feet should be placed\r\n   */\n\n\n  VRExperienceHelper.prototype.teleportCamera = function (location) {\n    var _this = this;\n\n    if (!(this.currentVRCamera instanceof FreeCamera)) {\n      return;\n    } // Teleport the hmd to where the user is looking by moving the anchor to where they are looking minus the\n    // offset of the headset from the anchor.\n\n\n    if (this.webVRCamera.leftCamera) {\n      this._workingVector.copyFrom(this.webVRCamera.leftCamera.globalPosition);\n\n      this._workingVector.subtractInPlace(this.webVRCamera.position);\n\n      location.subtractToRef(this._workingVector, this._workingVector);\n    } else {\n      this._workingVector.copyFrom(location);\n    } // Add height to account for user's height offset\n\n\n    if (this.isInVRMode) {\n      this._workingVector.y += this.webVRCamera.deviceDistanceToRoomGround() * this._webVRCamera.deviceScaleFactor;\n    } else {\n      this._workingVector.y += this._defaultHeight;\n    }\n\n    this.onBeforeCameraTeleport.notifyObservers(this._workingVector); // Animations FPS\n\n    var FPS = 90;\n    var speedRatio, lastFrame;\n\n    if (this._teleportationMode == VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED) {\n      lastFrame = FPS;\n      var dist = Vector3.Distance(this.currentVRCamera.position, this._workingVector);\n      speedRatio = this._teleportationSpeed / dist;\n    } else {\n      // teleportationMode is TELEPORTATIONMODE_CONSTANTTIME\n      lastFrame = Math.round(this._teleportationTime * FPS / 1000);\n      speedRatio = 1;\n    } // Create animation from the camera's position to the new location\n\n\n    this.currentVRCamera.animations = [];\n    var animationCameraTeleportation = new Animation(\"animationCameraTeleportation\", \"position\", FPS, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var animationCameraTeleportationKeys = [{\n      frame: 0,\n      value: this.currentVRCamera.position\n    }, {\n      frame: lastFrame,\n      value: this._workingVector\n    }];\n    animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);\n    animationCameraTeleportation.setEasingFunction(this._teleportationEasing);\n    this.currentVRCamera.animations.push(animationCameraTeleportation);\n    this._postProcessMove.animations = []; // Calculate the mid frame for vignette animations\n\n    var midFrame = Math.round(lastFrame / 2);\n    var animationPP = new Animation(\"animationPP\", \"vignetteWeight\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var vignetteWeightKeys = [];\n    vignetteWeightKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteWeightKeys.push({\n      frame: midFrame,\n      value: 8\n    });\n    vignetteWeightKeys.push({\n      frame: lastFrame,\n      value: 0\n    });\n    animationPP.setKeys(vignetteWeightKeys);\n\n    this._postProcessMove.animations.push(animationPP);\n\n    var animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    var vignetteStretchKeys = [];\n    vignetteStretchKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteStretchKeys.push({\n      frame: midFrame,\n      value: 10\n    });\n    vignetteStretchKeys.push({\n      frame: lastFrame,\n      value: 0\n    });\n    animationPP2.setKeys(vignetteStretchKeys);\n\n    this._postProcessMove.animations.push(animationPP2);\n\n    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\n    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\n\n    this._webVRCamera.attachPostProcess(this._postProcessMove);\n\n    this._scene.beginAnimation(this._postProcessMove, 0, lastFrame, false, speedRatio, function () {\n      _this._webVRCamera.detachPostProcess(_this._postProcessMove);\n    });\n\n    this._scene.beginAnimation(this.currentVRCamera, 0, lastFrame, false, speedRatio, function () {\n      _this.onAfterCameraTeleport.notifyObservers(_this._workingVector);\n    });\n\n    this._hideTeleportationTarget();\n  };\n\n  VRExperienceHelper.prototype._convertNormalToDirectionOfRay = function (normal, ray) {\n    if (normal) {\n      var angle = Math.acos(Vector3.Dot(normal, ray.direction));\n\n      if (angle < Math.PI / 2) {\n        normal.scaleInPlace(-1);\n      }\n    }\n\n    return normal;\n  };\n\n  VRExperienceHelper.prototype._castRayAndSelectObject = function (gazer) {\n    if (!(this.currentVRCamera instanceof FreeCamera)) {\n      return;\n    }\n\n    var ray = gazer._getForwardRay(this._rayLength);\n\n    var hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\n\n    if (hit) {\n      // Populate the controllers mesh that can be used for drag/drop\n      if (gazer._laserPointer) {\n        hit.originMesh = gazer._laserPointer.parent;\n      }\n\n      this._scene.simulatePointerMove(hit, {\n        pointerId: gazer._id\n      });\n    }\n\n    gazer._currentHit = hit; // Moving the gazeTracker on the mesh face targetted\n\n    if (hit && hit.pickedPoint) {\n      if (this._displayGaze) {\n        var multiplier = 1;\n        gazer._gazeTracker.isVisible = true;\n\n        if (gazer._isActionableMesh) {\n          multiplier = 3;\n        }\n\n        if (this.updateGazeTrackerScale) {\n          gazer._gazeTracker.scaling.x = hit.distance * multiplier;\n          gazer._gazeTracker.scaling.y = hit.distance * multiplier;\n          gazer._gazeTracker.scaling.z = hit.distance * multiplier;\n        }\n\n        var pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(), ray); // To avoid z-fighting\n\n\n        var deltaFighting = 0.002;\n\n        if (pickNormal) {\n          var axis1 = Vector3.Cross(Axis.Y, pickNormal);\n          var axis2 = Vector3.Cross(pickNormal, axis1);\n          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, gazer._gazeTracker.rotation);\n        }\n\n        gazer._gazeTracker.position.copyFrom(hit.pickedPoint);\n\n        if (gazer._gazeTracker.position.x < 0) {\n          gazer._gazeTracker.position.x += deltaFighting;\n        } else {\n          gazer._gazeTracker.position.x -= deltaFighting;\n        }\n\n        if (gazer._gazeTracker.position.y < 0) {\n          gazer._gazeTracker.position.y += deltaFighting;\n        } else {\n          gazer._gazeTracker.position.y -= deltaFighting;\n        }\n\n        if (gazer._gazeTracker.position.z < 0) {\n          gazer._gazeTracker.position.z += deltaFighting;\n        } else {\n          gazer._gazeTracker.position.z -= deltaFighting;\n        }\n      } // Changing the size of the laser pointer based on the distance from the targetted point\n\n\n      gazer._updatePointerDistance(hit.distance);\n    } else {\n      gazer._updatePointerDistance();\n\n      gazer._gazeTracker.isVisible = false;\n    }\n\n    if (hit && hit.pickedMesh) {\n      // The object selected is the floor, we're in a teleportation scenario\n      if (this._teleportationInitialized && this._isTeleportationFloor(hit.pickedMesh) && hit.pickedPoint) {\n        // Moving the teleportation area to this targetted point\n        //Raise onSelectedMeshUnselected observable if ray collided floor mesh/meshes and a non floor mesh was previously selected\n        if (gazer._currentMeshSelected && !this._isTeleportationFloor(gazer._currentMeshSelected)) {\n          this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n        }\n\n        gazer._currentMeshSelected = null;\n\n        if (gazer._teleportationRequestInitiated) {\n          this._moveTeleportationSelectorTo(hit, gazer, ray);\n        }\n\n        return;\n      } // If not, we're in a selection scenario\n      //this._teleportationAllowed = false;\n\n\n      if (hit.pickedMesh !== gazer._currentMeshSelected) {\n        if (this.meshSelectionPredicate(hit.pickedMesh)) {\n          this.onNewMeshPicked.notifyObservers(hit);\n          gazer._currentMeshSelected = hit.pickedMesh;\n\n          if (hit.pickedMesh.isPickable && hit.pickedMesh.actionManager) {\n            this.changeGazeColor(this._pickedGazeColor);\n            this.changeLaserColor(this._pickedLaserColor);\n            gazer._isActionableMesh = true;\n          } else {\n            this.changeGazeColor(this._gazeColor);\n            this.changeLaserColor(this._laserColor);\n            gazer._isActionableMesh = false;\n          }\n\n          try {\n            this.onNewMeshSelected.notifyObservers(hit.pickedMesh);\n            var gazerAsControllerGazer = gazer;\n\n            if (gazerAsControllerGazer.webVRController) {\n              this.onMeshSelectedWithController.notifyObservers({\n                mesh: hit.pickedMesh,\n                controller: gazerAsControllerGazer.webVRController\n              });\n            }\n          } catch (err) {\n            Logger.Warn(\"Error while raising onNewMeshSelected or onMeshSelectedWithController: \" + err);\n          }\n        } else {\n          this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n\n          gazer._currentMeshSelected = null;\n          this.changeGazeColor(this._gazeColor);\n          this.changeLaserColor(this._laserColor);\n        }\n      }\n    } else {\n      this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n\n      gazer._currentMeshSelected = null; //this._teleportationAllowed = false;\n\n      this.changeGazeColor(this._gazeColor);\n      this.changeLaserColor(this._laserColor);\n    }\n  };\n\n  VRExperienceHelper.prototype._notifySelectedMeshUnselected = function (mesh) {\n    if (mesh) {\n      this.onSelectedMeshUnselected.notifyObservers(mesh);\n    }\n  };\n  /**\r\n   * Permanently set new colors for the laser pointer\r\n   * @param color the new laser color\r\n   * @param pickedColor the new laser color when picked mesh detected\r\n   */\n\n\n  VRExperienceHelper.prototype.setLaserColor = function (color, pickedColor) {\n    if (pickedColor === void 0) {\n      pickedColor = this._pickedLaserColor;\n    }\n\n    this._laserColor = color;\n    this._pickedLaserColor = pickedColor;\n  };\n  /**\r\n   * Set lighting enabled / disabled on the laser pointer of both controllers\r\n   * @param enabled should the lighting be enabled on the laser pointer\r\n   */\n\n\n  VRExperienceHelper.prototype.setLaserLightingState = function (enabled) {\n    if (enabled === void 0) {\n      enabled = true;\n    }\n\n    if (this._leftController) {\n      this._leftController._setLaserPointerLightingDisabled(!enabled);\n    }\n\n    if (this._rightController) {\n      this._rightController._setLaserPointerLightingDisabled(!enabled);\n    }\n  };\n  /**\r\n   * Permanently set new colors for the gaze pointer\r\n   * @param color the new gaze color\r\n   * @param pickedColor the new gaze color when picked mesh detected\r\n   */\n\n\n  VRExperienceHelper.prototype.setGazeColor = function (color, pickedColor) {\n    if (pickedColor === void 0) {\n      pickedColor = this._pickedGazeColor;\n    }\n\n    this._gazeColor = color;\n    this._pickedGazeColor = pickedColor;\n  };\n  /**\r\n   * Sets the color of the laser ray from the vr controllers.\r\n   * @param color new color for the ray.\r\n   */\n\n\n  VRExperienceHelper.prototype.changeLaserColor = function (color) {\n    if (!this.updateControllerLaserColor) {\n      return;\n    }\n\n    if (this._leftController) {\n      this._leftController._setLaserPointerColor(color);\n    }\n\n    if (this._rightController) {\n      this._rightController._setLaserPointerColor(color);\n    }\n  };\n  /**\r\n   * Sets the color of the ray from the vr headsets gaze.\r\n   * @param color new color for the ray.\r\n   */\n\n\n  VRExperienceHelper.prototype.changeGazeColor = function (color) {\n    if (!this.updateGazeTrackerColor) {\n      return;\n    }\n\n    if (!this._cameraGazer._gazeTracker.material) {\n      return;\n    }\n\n    this._cameraGazer._gazeTracker.material.emissiveColor = color;\n\n    if (this._leftController) {\n      this._leftController._gazeTracker.material.emissiveColor = color;\n    }\n\n    if (this._rightController) {\n      this._rightController._gazeTracker.material.emissiveColor = color;\n    }\n  };\n  /**\r\n   * Exits VR and disposes of the vr experience helper\r\n   */\n\n\n  VRExperienceHelper.prototype.dispose = function () {\n    if (this.isInVRMode) {\n      this.exitVR();\n    }\n\n    if (this._postProcessMove) {\n      this._postProcessMove.dispose();\n    }\n\n    if (this._webVRCamera) {\n      this._webVRCamera.dispose();\n    }\n\n    if (this._vrDeviceOrientationCamera) {\n      this._vrDeviceOrientationCamera.dispose();\n    }\n\n    if (!this._useCustomVRButton && this._btnVR && this._btnVR.parentNode) {\n      document.body.removeChild(this._btnVR);\n    }\n\n    if (this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera) {\n      this._deviceOrientationCamera.dispose();\n    }\n\n    if (this._cameraGazer) {\n      this._cameraGazer.dispose();\n    }\n\n    if (this._leftController) {\n      this._leftController.dispose();\n    }\n\n    if (this._rightController) {\n      this._rightController.dispose();\n    }\n\n    if (this._teleportationTarget) {\n      this._teleportationTarget.dispose();\n    }\n\n    if (this.xr) {\n      this.xr.dispose();\n    }\n\n    this._floorMeshesCollection = [];\n    document.removeEventListener(\"keydown\", this._onKeyDown);\n    window.removeEventListener('vrdisplaypresentchange', this._onVrDisplayPresentChange);\n    window.removeEventListener(\"resize\", this._onResize);\n    document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\n    document.removeEventListener(\"mozfullscreenchange\", this._onFullscreenChange);\n    document.removeEventListener(\"webkitfullscreenchange\", this._onFullscreenChange);\n    document.removeEventListener(\"msfullscreenchange\", this._onFullscreenChange);\n    document.onmsfullscreenchange = null;\n\n    this._scene.getEngine().onVRDisplayChangedObservable.removeCallback(this._onVRDisplayChanged);\n\n    this._scene.getEngine().onVRRequestPresentStart.removeCallback(this._onVRRequestPresentStart);\n\n    this._scene.getEngine().onVRRequestPresentComplete.removeCallback(this._onVRRequestPresentComplete);\n\n    window.removeEventListener('vrdisplaypresentchange', this._onVrDisplayPresentChange);\n\n    this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);\n\n    this._scene.gamepadManager.onGamepadDisconnectedObservable.removeCallback(this._onNewGamepadDisconnected);\n\n    this._scene.unregisterBeforeRender(this.beforeRender);\n  };\n  /**\r\n   * Gets the name of the VRExperienceHelper class\r\n   * @returns \"VRExperienceHelper\"\r\n   */\n\n\n  VRExperienceHelper.prototype.getClassName = function () {\n    return \"VRExperienceHelper\";\n  };\n  /**\r\n   * Time Constant Teleportation Mode\r\n   */\n\n\n  VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME = 0;\n  /**\r\n   * Speed Constant Teleportation Mode\r\n   */\n\n  VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED = 1;\n  return VRExperienceHelper;\n}();\n\nexport { VRExperienceHelper };","map":null,"metadata":{},"sourceType":"module"}