{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { Sprite } from \"./sprite\";\nimport { SpriteSceneComponent } from \"./spriteSceneComponent\";\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { Logger } from \"../Misc/logger\";\nimport { Engine } from '../Engines/engine';\nimport { WebRequest } from '../Misc/webRequest';\nimport { SpriteRenderer } from './spriteRenderer';\n/**\r\n * Class used to manage multiple sprites on the same spritesheet\r\n * @see https://doc.babylonjs.com/babylon101/sprites\r\n */\n\nvar SpriteManager =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new sprite manager\r\n   * @param name defines the manager's name\r\n   * @param imgUrl defines the sprite sheet url\r\n   * @param capacity defines the maximum allowed number of sprites\r\n   * @param cellSize defines the size of a sprite cell\r\n   * @param scene defines the hosting scene\r\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n   * @param samplingMode defines the smapling mode to use with spritesheet\r\n   * @param fromPacked set to false; do not alter\r\n   * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\r\n   */\n  function SpriteManager(\n  /** defines the manager's name */\n  name, imgUrl, capacity, cellSize, scene, epsilon, samplingMode, fromPacked, spriteJSON) {\n    var _this = this;\n\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (fromPacked === void 0) {\n      fromPacked = false;\n    }\n\n    if (spriteJSON === void 0) {\n      spriteJSON = null;\n    }\n\n    this.name = name;\n    /** Gets the list of sprites */\n\n    this.sprites = new Array();\n    /** Gets or sets the rendering group id (0 by default) */\n\n    this.renderingGroupId = 0;\n    /** Gets or sets camera layer mask */\n\n    this.layerMask = 0x0FFFFFFF;\n    /** Gets or sets a boolean indicating if the sprites are pickable */\n\n    this.isPickable = false;\n    /**\r\n    * An event triggered when the manager is disposed.\r\n    */\n\n    this.onDisposeObservable = new Observable();\n    /** Disables writing to the depth buffer when rendering the sprites.\r\n     *  It can be handy to disable depth writing when using textures without alpha channel\r\n     *  and setting some specific blend modes.\r\n    */\n\n    this.disableDepthWrite = false;\n    /** True when packed cell data from JSON file is ready*/\n\n    this._packedAndReady = false;\n\n    this._customUpdate = function (sprite, baseSize) {\n      if (!sprite.cellRef) {\n        sprite.cellIndex = 0;\n      }\n\n      var num = sprite.cellIndex;\n\n      if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\n        sprite.cellRef = _this._spriteMap[sprite.cellIndex];\n      }\n\n      sprite._xOffset = _this._cellData[sprite.cellRef].frame.x / baseSize.width;\n      sprite._yOffset = _this._cellData[sprite.cellRef].frame.y / baseSize.height;\n      sprite._xSize = _this._cellData[sprite.cellRef].frame.w;\n      sprite._ySize = _this._cellData[sprite.cellRef].frame.h;\n    };\n\n    if (!scene) {\n      scene = Engine.LastCreatedScene;\n    }\n\n    if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\n      scene._addComponent(new SpriteSceneComponent(scene));\n    }\n\n    this._fromPacked = fromPacked;\n    this._scene = scene;\n\n    var engine = this._scene.getEngine();\n\n    this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\n\n    if (cellSize.width && cellSize.height) {\n      this.cellWidth = cellSize.width;\n      this.cellHeight = cellSize.height;\n    } else if (cellSize !== undefined) {\n      this.cellWidth = cellSize;\n      this.cellHeight = cellSize;\n    } else {\n      this._spriteRenderer = null;\n      return;\n    }\n\n    this._scene.spriteManagers.push(this);\n\n    this.uniqueId = this.scene.getUniqueId();\n\n    if (imgUrl) {\n      this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\n    }\n\n    if (this._fromPacked) {\n      this._makePacked(imgUrl, spriteJSON);\n    }\n  }\n\n  Object.defineProperty(SpriteManager.prototype, \"onDispose\", {\n    /**\r\n     * Callback called when the manager is disposed\r\n     */\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"children\", {\n    /**\r\n     * Gets the array of sprites\r\n     */\n    get: function get() {\n      return this.sprites;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"scene\", {\n    /**\r\n     * Gets the hosting scene\r\n     */\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"capacity\", {\n    /**\r\n     * Gets the capacity of the manager\r\n     */\n    get: function get() {\n      return this._spriteRenderer.capacity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"texture\", {\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\n    get: function get() {\n      return this._spriteRenderer.texture;\n    },\n    set: function set(value) {\n      value.wrapU = Texture.CLAMP_ADDRESSMODE;\n      value.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._spriteRenderer.texture = value;\n      this._textureContent = null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"cellWidth\", {\n    /** Defines the default width of a cell in the spritesheet */\n    get: function get() {\n      return this._spriteRenderer.cellWidth;\n    },\n    set: function set(value) {\n      this._spriteRenderer.cellWidth = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"cellHeight\", {\n    /** Defines the default height of a cell in the spritesheet */\n    get: function get() {\n      return this._spriteRenderer.cellHeight;\n    },\n    set: function set(value) {\n      this._spriteRenderer.cellHeight = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"fogEnabled\", {\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\n    get: function get() {\n      return this._spriteRenderer.fogEnabled;\n    },\n    set: function set(value) {\n      this._spriteRenderer.fogEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"blendMode\", {\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static undefined properties provided in this class.\r\n     * Default value is 2\r\n     */\n    get: function get() {\n      return this._spriteRenderer.blendMode;\n    },\n    set: function set(blendMode) {\n      this._spriteRenderer.blendMode = blendMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"SpriteManager\"\r\n   * @returns \"SpriteManager\"\r\n   */\n\n  SpriteManager.prototype.getClassName = function () {\n    return \"SpriteManager\";\n  };\n\n  SpriteManager.prototype._makePacked = function (imgUrl, spriteJSON) {\n    var _this = this;\n\n    if (spriteJSON !== null) {\n      try {\n        //Get the JSON and Check its stucture.  If its an array parse it if its a JSON sring etc...\n        var celldata = void 0;\n\n        if (typeof spriteJSON === \"string\") {\n          celldata = JSON.parse(spriteJSON);\n        } else {\n          celldata = spriteJSON;\n        }\n\n        if (celldata.frames.length) {\n          var frametemp = {};\n\n          for (var i = 0; i < celldata.frames.length; i++) {\n            var _f = celldata.frames[i];\n\n            if (typeof Object.keys(_f)[0] !== \"string\") {\n              throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\n            }\n\n            var name_1 = _f[Object.keys(_f)[0]];\n\n            frametemp[name_1] = _f;\n          }\n\n          celldata.frames = frametemp;\n        }\n\n        var spritemap = Reflect.ownKeys(celldata.frames);\n        this._spriteMap = spritemap;\n        this._packedAndReady = true;\n        this._cellData = celldata.frames;\n      } catch (e) {\n        this._fromPacked = false;\n        this._packedAndReady = false;\n        throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\n      }\n    } else {\n      var re = /\\./g;\n      var li = void 0;\n\n      do {\n        li = re.lastIndex;\n        re.test(imgUrl);\n      } while (re.lastIndex > 0);\n\n      var jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\n      var xmlhttp_1 = new XMLHttpRequest();\n      xmlhttp_1.open(\"GET\", jsonUrl, true);\n\n      xmlhttp_1.onerror = function () {\n        Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\n        _this._fromPacked = false;\n        _this._packedAndReady = false;\n      };\n\n      xmlhttp_1.onload = function () {\n        try {\n          var celldata = JSON.parse(xmlhttp_1.response);\n          var spritemap = Reflect.ownKeys(celldata.frames);\n          _this._spriteMap = spritemap;\n          _this._packedAndReady = true;\n          _this._cellData = celldata.frames;\n        } catch (e) {\n          _this._fromPacked = false;\n          _this._packedAndReady = false;\n          throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\n        }\n      };\n\n      xmlhttp_1.send();\n    }\n  };\n\n  SpriteManager.prototype._checkTextureAlpha = function (sprite, ray, distance, min, max) {\n    if (!sprite.useAlphaForPicking || !this.texture) {\n      return true;\n    }\n\n    var textureSize = this.texture.getSize();\n\n    if (!this._textureContent) {\n      this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\n      this.texture.readPixels(0, 0, this._textureContent);\n    }\n\n    var contactPoint = TmpVectors.Vector3[0];\n    contactPoint.copyFrom(ray.direction);\n    contactPoint.normalize();\n    contactPoint.scaleInPlace(distance);\n    contactPoint.addInPlace(ray.origin);\n    var contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;\n    var contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5; // Rotate\n\n    var angle = sprite.angle;\n    var rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\n    var rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\n    var u = sprite._xOffset * textureSize.width + rotatedU * sprite._xSize | 0;\n    var v = sprite._yOffset * textureSize.height + rotatedV * sprite._ySize | 0;\n    var alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];\n    return alpha > 0.5;\n  };\n  /**\r\n   * Intersects the sprites with a ray\r\n   * @param ray defines the ray to intersect with\r\n   * @param camera defines the current active camera\r\n   * @param predicate defines a predicate used to select candidate sprites\r\n   * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\r\n   * @returns null if no hit or a PickingInfo\r\n   */\n\n\n  SpriteManager.prototype.intersects = function (ray, camera, predicate, fastCheck) {\n    var count = Math.min(this.capacity, this.sprites.length);\n    var min = Vector3.Zero();\n    var max = Vector3.Zero();\n    var distance = Number.MAX_VALUE;\n    var currentSprite = null;\n    var pickedPoint = TmpVectors.Vector3[0];\n    var cameraSpacePosition = TmpVectors.Vector3[1];\n    var cameraView = camera.getViewMatrix();\n\n    for (var index = 0; index < count; index++) {\n      var sprite = this.sprites[index];\n\n      if (!sprite) {\n        continue;\n      }\n\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n\n      if (ray.intersectsBoxMinMax(min, max)) {\n        var currentDistance = Vector3.Distance(cameraSpacePosition, ray.origin);\n\n        if (distance > currentDistance) {\n          if (!this._checkTextureAlpha(sprite, ray, currentDistance, min, max)) {\n            continue;\n          }\n\n          distance = currentDistance;\n          currentSprite = sprite;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (currentSprite) {\n      var result = new PickingInfo();\n      cameraView.invertToRef(TmpVectors.Matrix[0]);\n      result.hit = true;\n      result.pickedSprite = currentSprite;\n      result.distance = distance; // Get picked point\n\n      var direction = TmpVectors.Vector3[2];\n      direction.copyFrom(ray.direction);\n      direction.normalize();\n      direction.scaleInPlace(distance);\n      ray.origin.addToRef(direction, pickedPoint);\n      result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      return result;\n    }\n\n    return null;\n  };\n  /**\r\n   * Intersects the sprites with a ray\r\n   * @param ray defines the ray to intersect with\r\n   * @param camera defines the current active camera\r\n   * @param predicate defines a predicate used to select candidate sprites\r\n   * @returns null if no hit or a PickingInfo array\r\n   */\n\n\n  SpriteManager.prototype.multiIntersects = function (ray, camera, predicate) {\n    var count = Math.min(this.capacity, this.sprites.length);\n    var min = Vector3.Zero();\n    var max = Vector3.Zero();\n    var distance;\n    var results = [];\n    var pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\n    var cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\n    var cameraView = camera.getViewMatrix();\n\n    for (var index = 0; index < count; index++) {\n      var sprite = this.sprites[index];\n\n      if (!sprite) {\n        continue;\n      }\n\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n\n      if (ray.intersectsBoxMinMax(min, max)) {\n        distance = Vector3.Distance(cameraSpacePosition, ray.origin);\n\n        if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\n          continue;\n        }\n\n        var result = new PickingInfo();\n        results.push(result);\n        cameraView.invertToRef(TmpVectors.Matrix[0]);\n        result.hit = true;\n        result.pickedSprite = sprite;\n        result.distance = distance; // Get picked point\n\n        var direction = TmpVectors.Vector3[2];\n        direction.copyFrom(ray.direction);\n        direction.normalize();\n        direction.scaleInPlace(distance);\n        ray.origin.addToRef(direction, pickedPoint);\n        result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      }\n    }\n\n    return results;\n  };\n  /**\r\n   * Render all child sprites\r\n   */\n\n\n  SpriteManager.prototype.render = function () {\n    // Check\n    if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\n      return;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var deltaTime = engine.getDeltaTime();\n\n    if (this._packedAndReady) {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\n    } else {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\n    }\n  };\n  /**\r\n   * Release associated resources\r\n   */\n\n\n  SpriteManager.prototype.dispose = function () {\n    if (this._spriteRenderer) {\n      this._spriteRenderer.dispose();\n\n      this._spriteRenderer = null;\n    }\n\n    this._textureContent = null; // Remove from scene\n\n    var index = this._scene.spriteManagers.indexOf(this);\n\n    this._scene.spriteManagers.splice(index, 1); // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  };\n  /**\r\n   * Serializes the sprite manager to a JSON object\r\n   * @param serializeTexture defines if the texture must be serialized as well\r\n   * @returns the JSON object\r\n   */\n\n\n  SpriteManager.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.capacity = this.capacity;\n    serializationObject.cellWidth = this.cellWidth;\n    serializationObject.cellHeight = this.cellHeight;\n\n    if (this.texture) {\n      if (serializeTexture) {\n        serializationObject.texture = this.texture.serialize();\n      } else {\n        serializationObject.textureUrl = this.texture.name;\n        serializationObject.invertY = this.texture._invertY;\n      }\n    }\n\n    serializationObject.sprites = [];\n\n    for (var _i = 0, _a = this.sprites; _i < _a.length; _i++) {\n      var sprite = _a[_i];\n      serializationObject.sprites.push(sprite.serialize());\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Parses a JSON object to create a new sprite manager.\r\n   * @param parsedManager The JSON object to parse\r\n   * @param scene The scene to create the sprite managerin\r\n   * @param rootUrl The root url to use to load external dependencies like texture\r\n   * @returns the new sprite manager\r\n   */\n\n\n  SpriteManager.Parse = function (parsedManager, scene, rootUrl) {\n    var manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\n      width: parsedManager.cellWidth,\n      height: parsedManager.cellHeight\n    }, scene);\n\n    if (parsedManager.texture) {\n      manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);\n    } else if (parsedManager.textureName) {\n      manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\n    }\n\n    for (var _i = 0, _a = parsedManager.sprites; _i < _a.length; _i++) {\n      var parsedSprite = _a[_i];\n      Sprite.Parse(parsedSprite, manager);\n    }\n\n    return manager;\n  };\n  /**\r\n   * Creates a sprite manager from a snippet saved in a remote file\r\n   * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\r\n   * @param url defines the url to load from\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new sprite manager\r\n   */\n\n\n  SpriteManager.ParseFromFileAsync = function (name, url, scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n            var output = SpriteManager.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\n\n            if (name) {\n              output.name = name;\n            }\n\n            resolve(output);\n          } else {\n            reject(\"Unable to load the sprite manager\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\r\n   * Creates a sprite manager from a snippet saved by the sprite editor\r\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new sprite manager\r\n   */\n\n\n  SpriteManager.CreateFromSnippetAsync = function (snippetId, scene, rootUrl) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.spriteManager);\n            var output = SpriteManager.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /** Define the Url to load snippets */\n\n\n  SpriteManager.SnippetUrl = \"https://snippet.babylonjs.com\";\n  return SpriteManager;\n}();\n\nexport { SpriteManager };","map":null,"metadata":{},"sourceType":"module"}