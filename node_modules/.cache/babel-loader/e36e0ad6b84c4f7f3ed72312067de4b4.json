{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Observable } from \"../../Misc/observable\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { Tools } from \"../../Misc/tools\";\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\n\nvar FreeCameraMouseInput =\n/** @class */\nfunction () {\n  /**\r\n   * Manage the mouse inputs to control the movement of a free camera.\r\n   * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n   * @param touchEnabled Defines if touch is enabled or not\r\n   */\n  function FreeCameraMouseInput(\n  /**\r\n   * Define if touch is enabled in the mouse input\r\n   */\n  touchEnabled) {\n    if (touchEnabled === void 0) {\n      touchEnabled = true;\n    }\n\n    this.touchEnabled = touchEnabled;\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\n\n    this.buttons = [0, 1, 2];\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\n\n    this.angularSensibility = 2000.0;\n    this.previousPosition = null;\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\n\n    this.onPointerMovedObservable = new Observable();\n    /**\r\n     * @hidden\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\n\n    this._allowCameraRotation = true;\n  }\n  /**\r\n   * Attach the input controls to a specific dom element to get the input from.\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n\n  FreeCameraMouseInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this;\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    var engine = this.camera.getEngine();\n    var element = engine.getInputElement();\n\n    if (!this._pointerInput) {\n      this._pointerInput = function (p) {\n        var evt = p.event;\n\n        if (engine.isInVRExclusivePointerMode) {\n          return;\n        }\n\n        if (!_this.touchEnabled && evt.pointerType === \"touch\") {\n          return;\n        }\n\n        if (p.type !== PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {\n          return;\n        }\n\n        var srcElement = evt.srcElement || evt.target;\n\n        if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\n          try {\n            srcElement.setPointerCapture(evt.pointerId);\n          } catch (e) {//Nothing to do with the error. Execution will continue.\n          }\n\n          _this.previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n\n          if (!noPreventDefault) {\n            evt.preventDefault();\n            element && element.focus();\n          } // This is required to move while pointer button is down\n\n\n          if (engine.isPointerLock && _this._onMouseMove) {\n            _this._onMouseMove(p.event);\n          }\n        } else if (p.type === PointerEventTypes.POINTERUP && srcElement) {\n          try {\n            srcElement.releasePointerCapture(evt.pointerId);\n          } catch (e) {//Nothing to do with the error.\n          }\n\n          _this.previousPosition = null;\n\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n        } else if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (!_this.previousPosition) {\n            if (engine.isPointerLock && _this._onMouseMove) {\n              _this._onMouseMove(p.event);\n            }\n\n            return;\n          }\n\n          var offsetX = evt.clientX - _this.previousPosition.x;\n          var offsetY = evt.clientY - _this.previousPosition.y;\n\n          if (_this.camera.getScene().useRightHandedSystem) {\n            offsetX *= -1;\n          }\n\n          if (_this.camera.parent && _this.camera.parent._getWorldMatrixDeterminant() < 0) {\n            offsetX *= -1;\n          }\n\n          if (_this._allowCameraRotation) {\n            _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;\n            _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;\n          }\n\n          _this.onPointerMovedObservable.notifyObservers({\n            offsetX: offsetX,\n            offsetY: offsetY\n          });\n\n          _this.previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n        }\n      };\n    }\n\n    this._onMouseMove = function (evt) {\n      if (!engine.isPointerLock) {\n        return;\n      }\n\n      if (engine.isInVRExclusivePointerMode) {\n        return;\n      }\n\n      var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\n\n      if (_this.camera.getScene().useRightHandedSystem) {\n        offsetX *= -1;\n      }\n\n      if (_this.camera.parent && _this.camera.parent._getWorldMatrixDeterminant() < 0) {\n        offsetX *= -1;\n      }\n\n      _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;\n      var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\n      _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;\n      _this.previousPosition = null;\n\n      if (!noPreventDefault) {\n        evt.preventDefault();\n      }\n    };\n\n    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    element && element.addEventListener(\"contextmenu\", this.onContextMenu.bind(this), false);\n  };\n  /**\r\n   * Called on JS contextmenu event.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  FreeCameraMouseInput.prototype.onContextMenu = function (evt) {\n    evt.preventDefault();\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  FreeCameraMouseInput.prototype.detachControl = function (ignored) {\n    if (this._observer) {\n      this.camera.getScene().onPointerObservable.remove(this._observer);\n\n      if (this.onContextMenu) {\n        var engine = this.camera.getEngine();\n        var element = engine.getInputElement();\n        element && element.removeEventListener(\"contextmenu\", this.onContextMenu);\n      }\n\n      if (this.onPointerMovedObservable) {\n        this.onPointerMovedObservable.clear();\n      }\n\n      this._observer = null;\n      this._onMouseMove = null;\n      this.previousPosition = null;\n    }\n  };\n  /**\r\n   * Gets the class name of the current intput.\r\n   * @returns the class name\r\n   */\n\n\n  FreeCameraMouseInput.prototype.getClassName = function () {\n    return \"FreeCameraMouseInput\";\n  };\n  /**\r\n   * Get the friendly name associated with the input class.\r\n   * @returns the input friendly name\r\n   */\n\n\n  FreeCameraMouseInput.prototype.getSimpleName = function () {\n    return \"mouse\";\n  };\n\n  __decorate([serialize()], FreeCameraMouseInput.prototype, \"buttons\", void 0);\n\n  __decorate([serialize()], FreeCameraMouseInput.prototype, \"angularSensibility\", void 0);\n\n  return FreeCameraMouseInput;\n}();\n\nexport { FreeCameraMouseInput };\nCameraInputTypes[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;","map":null,"metadata":{},"sourceType":"module"}