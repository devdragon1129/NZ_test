{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebRequest } from './webRequest';\nimport { DomManagement } from './domManagement';\nimport { Observable } from './observable';\nimport { FilesInputStore } from './filesInputStore';\nimport { RetryStrategy } from './retryStrategy';\nimport { BaseError } from './baseError';\nimport { StringTools } from './stringTools';\nimport { ThinEngine } from '../Engines/thinEngine';\nimport { ShaderProcessor } from '../Engines/Processors/shaderProcessor';\n/** @ignore */\n\nvar LoadFileError =\n/** @class */\nfunction (_super) {\n  __extends(LoadFileError, _super);\n  /**\r\n   * Creates a new LoadFileError\r\n   * @param message defines the message of the error\r\n   * @param request defines the optional web request\r\n   * @param file defines the optional file\r\n   */\n\n\n  function LoadFileError(message, object) {\n    var _this = _super.call(this, message) || this;\n\n    _this.name = \"LoadFileError\";\n\n    BaseError._setPrototypeOf(_this, LoadFileError.prototype);\n\n    if (object instanceof WebRequest) {\n      _this.request = object;\n    } else {\n      _this.file = object;\n    }\n\n    return _this;\n  }\n\n  return LoadFileError;\n}(BaseError);\n\nexport { LoadFileError };\n/** @ignore */\n\nvar RequestFileError =\n/** @class */\nfunction (_super) {\n  __extends(RequestFileError, _super);\n  /**\r\n   * Creates a new LoadFileError\r\n   * @param message defines the message of the error\r\n   * @param request defines the optional web request\r\n   */\n\n\n  function RequestFileError(message, request) {\n    var _this = _super.call(this, message) || this;\n\n    _this.request = request;\n    _this.name = \"RequestFileError\";\n\n    BaseError._setPrototypeOf(_this, RequestFileError.prototype);\n\n    return _this;\n  }\n\n  return RequestFileError;\n}(BaseError);\n\nexport { RequestFileError };\n/** @ignore */\n\nvar ReadFileError =\n/** @class */\nfunction (_super) {\n  __extends(ReadFileError, _super);\n  /**\r\n   * Creates a new ReadFileError\r\n   * @param message defines the message of the error\r\n   * @param file defines the optional file\r\n   */\n\n\n  function ReadFileError(message, file) {\n    var _this = _super.call(this, message) || this;\n\n    _this.file = file;\n    _this.name = \"ReadFileError\";\n\n    BaseError._setPrototypeOf(_this, ReadFileError.prototype);\n\n    return _this;\n  }\n\n  return ReadFileError;\n}(BaseError);\n\nexport { ReadFileError };\n/**\r\n * @hidden\r\n */\n\nvar FileTools =\n/** @class */\nfunction () {\n  function FileTools() {}\n  /**\r\n   * Removes unwanted characters from an url\r\n   * @param url defines the url to clean\r\n   * @returns the cleaned url\r\n   */\n\n\n  FileTools._CleanUrl = function (url) {\n    url = url.replace(/#/mg, \"%23\");\n    return url;\n  };\n  /**\r\n   * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\r\n   * @param url define the url we are trying\r\n   * @param element define the dom element where to configure the cors policy\r\n   */\n\n\n  FileTools.SetCorsBehavior = function (url, element) {\n    if (url && url.indexOf(\"data:\") === 0) {\n      return;\n    }\n\n    if (FileTools.CorsBehavior) {\n      if (typeof FileTools.CorsBehavior === 'string' || this.CorsBehavior instanceof String) {\n        element.crossOrigin = FileTools.CorsBehavior;\n      } else {\n        var result = FileTools.CorsBehavior(url);\n\n        if (result) {\n          element.crossOrigin = result;\n        }\n      }\n    }\n  };\n  /**\r\n   * Loads an image as an HTMLImageElement.\r\n   * @param input url string, ArrayBuffer, or Blob to load\r\n   * @param onLoad callback called when the image successfully loads\r\n   * @param onError callback called when the image fails to load\r\n   * @param offlineProvider offline provider for caching\r\n   * @param mimeType optional mime type\r\n   * @returns the HTMLImageElement of the loaded image\r\n   */\n\n\n  FileTools.LoadImage = function (input, onLoad, onError, offlineProvider, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"\";\n    }\n\n    var url;\n    var usingObjectURL = false;\n\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n      if (typeof Blob !== 'undefined') {\n        url = URL.createObjectURL(new Blob([input], {\n          type: mimeType\n        }));\n        usingObjectURL = true;\n      } else {\n        url = \"data:\" + mimeType + \";base64,\" + StringTools.EncodeArrayBufferToBase64(input);\n      }\n    } else if (input instanceof Blob) {\n      url = URL.createObjectURL(input);\n      usingObjectURL = true;\n    } else {\n      url = FileTools._CleanUrl(input);\n      url = FileTools.PreprocessUrl(input);\n    }\n\n    if (typeof Image === \"undefined\") {\n      FileTools.LoadFile(url, function (data) {\n        createImageBitmap(new Blob([data], {\n          type: mimeType\n        })).then(function (imgBmp) {\n          onLoad(imgBmp);\n\n          if (usingObjectURL) {\n            URL.revokeObjectURL(url);\n          }\n        }).catch(function (reason) {\n          if (onError) {\n            onError(\"Error while trying to load image: \" + input, reason);\n          }\n        });\n      }, undefined, offlineProvider || undefined, true, function (request, exception) {\n        if (onError) {\n          onError(\"Error while trying to load image: \" + input, exception);\n        }\n      });\n      return null;\n    }\n\n    var img = new Image();\n    FileTools.SetCorsBehavior(url, img);\n\n    var loadHandler = function loadHandler() {\n      img.removeEventListener(\"load\", loadHandler);\n      img.removeEventListener(\"error\", errorHandler);\n      onLoad(img); // Must revoke the URL after calling onLoad to avoid security exceptions in\n      // certain scenarios (e.g. when hosted in vscode).\n\n      if (usingObjectURL && img.src) {\n        URL.revokeObjectURL(img.src);\n      }\n    };\n\n    var errorHandler = function errorHandler(err) {\n      img.removeEventListener(\"load\", loadHandler);\n      img.removeEventListener(\"error\", errorHandler);\n\n      if (onError) {\n        var inputText = input.toString();\n        onError(\"Error while trying to load image: \" + (inputText.length < 32 ? inputText : inputText.slice(0, 32) + \"...\"), err);\n      }\n\n      if (usingObjectURL && img.src) {\n        URL.revokeObjectURL(img.src);\n      }\n    };\n\n    img.addEventListener(\"load\", loadHandler);\n    img.addEventListener(\"error\", errorHandler);\n\n    var noOfflineSupport = function noOfflineSupport() {\n      img.src = url;\n    };\n\n    var loadFromOfflineSupport = function loadFromOfflineSupport() {\n      if (offlineProvider) {\n        offlineProvider.loadImage(url, img);\n      }\n    };\n\n    if (url.substr(0, 5) !== \"data:\" && offlineProvider && offlineProvider.enableTexturesOffline) {\n      offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n    } else {\n      if (url.indexOf(\"file:\") !== -1) {\n        var textureName = decodeURIComponent(url.substring(5).toLowerCase());\n\n        if (FilesInputStore.FilesToLoad[textureName]) {\n          try {\n            var blobURL;\n\n            try {\n              blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n            } catch (ex) {\n              // Chrome doesn't support oneTimeOnly parameter\n              blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n            }\n\n            img.src = blobURL;\n            usingObjectURL = true;\n          } catch (e) {\n            img.src = \"\";\n          }\n\n          return img;\n        }\n      }\n\n      noOfflineSupport();\n    }\n\n    return img;\n  };\n  /**\r\n   * Reads a file from a File object\r\n   * @param file defines the file to load\r\n   * @param onSuccess defines the callback to call when data is loaded\r\n   * @param onProgress defines the callback to call during loading process\r\n   * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n   * @param onError defines the callback to call when an error occurs\r\n   * @returns a file request object\r\n   */\n\n\n  FileTools.ReadFile = function (file, onSuccess, onProgress, useArrayBuffer, onError) {\n    var reader = new FileReader();\n    var request = {\n      onCompleteObservable: new Observable(),\n      abort: function abort() {\n        return reader.abort();\n      }\n    };\n\n    reader.onloadend = function (e) {\n      return request.onCompleteObservable.notifyObservers(request);\n    };\n\n    if (onError) {\n      reader.onerror = function (e) {\n        onError(new ReadFileError(\"Unable to read \" + file.name, file));\n      };\n    }\n\n    reader.onload = function (e) {\n      //target doesn't have result from ts 1.3\n      onSuccess(e.target['result']);\n    };\n\n    if (onProgress) {\n      reader.onprogress = onProgress;\n    }\n\n    if (!useArrayBuffer) {\n      // Asynchronous read\n      reader.readAsText(file);\n    } else {\n      reader.readAsArrayBuffer(file);\n    }\n\n    return request;\n  };\n  /**\r\n   * Loads a file from a url\r\n   * @param url url to load\r\n   * @param onSuccess callback called when the file successfully loads\r\n   * @param onProgress callback called while file is loading (if the server supports this mode)\r\n   * @param offlineProvider defines the offline provider for caching\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @param onError callback called when the file fails to load\r\n   * @returns a file request object\r\n   */\n\n\n  FileTools.LoadFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    // If file and file input are set\n    if (url.indexOf(\"file:\") !== -1) {\n      var fileName = decodeURIComponent(url.substring(5).toLowerCase());\n\n      if (fileName.indexOf('./') === 0) {\n        fileName = fileName.substring(2);\n      }\n\n      var file = FilesInputStore.FilesToLoad[fileName];\n\n      if (file) {\n        return FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? function (error) {\n          return onError(undefined, new LoadFileError(error.message, error.file));\n        } : undefined);\n      }\n    }\n\n    return FileTools.RequestFile(url, function (data, request) {\n      onSuccess(data, request ? request.responseURL : undefined);\n    }, onProgress, offlineProvider, useArrayBuffer, onError ? function (error) {\n      onError(error.request, new LoadFileError(error.message, error.request));\n    } : undefined);\n  };\n  /**\r\n   * Loads a file\r\n   * @param url url to load\r\n   * @param onSuccess callback called when the file successfully loads\r\n   * @param onProgress callback called while file is loading (if the server supports this mode)\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @param onError callback called when the file fails to load\r\n   * @param onOpened callback called when the web request is opened\r\n   * @returns a file request object\r\n   */\n\n\n  FileTools.RequestFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {\n    url = FileTools._CleanUrl(url);\n    url = FileTools.PreprocessUrl(url);\n    var loadUrl = FileTools.BaseUrl + url;\n    var aborted = false;\n    var fileRequest = {\n      onCompleteObservable: new Observable(),\n      abort: function abort() {\n        return aborted = true;\n      }\n    };\n\n    var requestFile = function requestFile() {\n      var request = new WebRequest();\n      var retryHandle = null;\n\n      fileRequest.abort = function () {\n        aborted = true;\n\n        if (request.readyState !== (XMLHttpRequest.DONE || 4)) {\n          request.abort();\n        }\n\n        if (retryHandle !== null) {\n          clearTimeout(retryHandle);\n          retryHandle = null;\n        }\n      };\n\n      var retryLoop = function retryLoop(retryIndex) {\n        request.open('GET', loadUrl);\n\n        if (onOpened) {\n          onOpened(request);\n        }\n\n        if (useArrayBuffer) {\n          request.responseType = \"arraybuffer\";\n        }\n\n        if (onProgress) {\n          request.addEventListener(\"progress\", onProgress);\n        }\n\n        var onLoadEnd = function onLoadEnd() {\n          request.removeEventListener(\"loadend\", onLoadEnd);\n          fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n          fileRequest.onCompleteObservable.clear();\n        };\n\n        request.addEventListener(\"loadend\", onLoadEnd);\n\n        var onReadyStateChange = function onReadyStateChange() {\n          if (aborted) {\n            return;\n          } // In case of undefined state in some browsers.\n\n\n          if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n            // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n            request.removeEventListener(\"readystatechange\", onReadyStateChange);\n\n            if (request.status >= 200 && request.status < 300 || request.status === 0 && (!DomManagement.IsWindowObjectExist() || FileTools.IsFileURL())) {\n              onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n              return;\n            }\n\n            var retryStrategy = FileTools.DefaultRetryStrategy;\n\n            if (retryStrategy) {\n              var waitTime = retryStrategy(loadUrl, request, retryIndex);\n\n              if (waitTime !== -1) {\n                // Prevent the request from completing for retry.\n                request.removeEventListener(\"loadend\", onLoadEnd);\n                request = new WebRequest();\n                retryHandle = setTimeout(function () {\n                  return retryLoop(retryIndex + 1);\n                }, waitTime);\n                return;\n              }\n            }\n\n            var error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n\n            if (onError) {\n              onError(error);\n            }\n          }\n        };\n\n        request.addEventListener(\"readystatechange\", onReadyStateChange);\n        request.send();\n      };\n\n      retryLoop(0);\n    }; // Caching all files\n\n\n    if (offlineProvider && offlineProvider.enableSceneOffline) {\n      var noOfflineSupport_1 = function noOfflineSupport_1(request) {\n        if (request && request.status > 400) {\n          if (onError) {\n            onError(request);\n          }\n        } else {\n          requestFile();\n        }\n      };\n\n      var loadFromOfflineSupport = function loadFromOfflineSupport() {\n        // TODO: database needs to support aborting and should return a IFileRequest\n        if (offlineProvider) {\n          offlineProvider.loadFile(FileTools.BaseUrl + url, function (data) {\n            if (!aborted) {\n              onSuccess(data);\n            }\n\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n          }, onProgress ? function (event) {\n            if (!aborted) {\n              onProgress(event);\n            }\n          } : undefined, noOfflineSupport_1, useArrayBuffer);\n        }\n      };\n\n      offlineProvider.open(loadFromOfflineSupport, noOfflineSupport_1);\n    } else {\n      requestFile();\n    }\n\n    return fileRequest;\n  };\n  /**\r\n   * Checks if the loaded document was accessed via `file:`-Protocol.\r\n   * @returns boolean\r\n   */\n\n\n  FileTools.IsFileURL = function () {\n    return typeof location !== \"undefined\" && location.protocol === \"file:\";\n  };\n  /**\r\n   * Gets or sets the retry strategy to apply when an error happens while loading an asset\r\n   */\n\n\n  FileTools.DefaultRetryStrategy = RetryStrategy.ExponentialBackoff();\n  /**\r\n   * Gets or sets the base URL to use to load assets\r\n   */\n\n  FileTools.BaseUrl = \"\";\n  /**\r\n   * Default behaviour for cors in the application.\r\n   * It can be a string if the expected behavior is identical in the entire app.\r\n   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\r\n   */\n\n  FileTools.CorsBehavior = \"anonymous\";\n  /**\r\n   * Gets or sets a function used to pre-process url before using them to load assets\r\n   */\n\n  FileTools.PreprocessUrl = function (url) {\n    return url;\n  };\n\n  return FileTools;\n}();\n\nexport { FileTools };\nThinEngine._FileToolsLoadImage = FileTools.LoadImage.bind(FileTools);\nThinEngine._FileToolsLoadFile = FileTools.LoadFile.bind(FileTools);\nShaderProcessor._FileToolsLoadFile = FileTools.LoadFile.bind(FileTools);","map":null,"metadata":{},"sourceType":"module"}