{"ast":null,"code":"import _regeneratorRuntime from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Base64 } from 'js-base64';\nimport { ethers, BigNumber } from 'ethers';\nexport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from '@ethersproject/properties';\nimport { isHexString, isBytes } from 'ethers/lib/utils';\n\nvar base64Encode = function base64Encode(val) {\n  return Base64.encode(val, true);\n};\n\nvar base64EncodeObject = function base64EncodeObject(obj) {\n  return Base64.encode(JSON.stringify(obj), true);\n};\n\nvar base64Decode = function base64Decode(encodedString) {\n  if (encodedString === null || encodedString === undefined) {\n    return undefined;\n  }\n\n  return Base64.decode(encodedString);\n};\n\nvar base64DecodeObject = function base64DecodeObject(encodedObject) {\n  if (encodedObject === null || encodedObject === undefined) {\n    return undefined;\n  }\n\n  return JSON.parse(Base64.decode(encodedObject));\n};\n\nvar encodeMessageDigest = function encodeMessageDigest(message) {\n  if (typeof message === 'string') {\n    return ethers.utils.arrayify(ethers.utils.keccak256(ethers.utils.toUtf8Bytes(message)));\n  } else {\n    return ethers.utils.arrayify(ethers.utils.keccak256(message));\n  }\n}; // packMessageData encodes the specified data ready for the Sequence Wallet contracts.\n\n\nvar packMessageData = function packMessageData(walletAddress, chainId, digest) {\n  return ethers.utils.solidityPack(['string', 'uint256', 'address', 'bytes32'], ['\\x19\\x01', chainId, walletAddress, digest]);\n};\n\nvar subDigestOf = function subDigestOf(address, chainId, digest) {\n  return ethers.utils.keccak256(packMessageData(address, chainId, digest));\n};\n\nvar isNode = function isNode() {\n  if (typeof window === 'undefined' && typeof process === 'object') {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nvar isBrowser = function isBrowser() {\n  return !isNode();\n};\n\nvar jwtDecodeClaims = function jwtDecodeClaims(jwt) {\n  var parts = jwt.split('.');\n\n  if (parts.length !== 3) {\n    throw new Error('invalid jwt');\n  }\n\n  var claims = JSON.parse(Base64.decode(parts[1]));\n  return claims;\n};\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar logLevel;\n\n(function (logLevel) {\n  logLevel[logLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n  logLevel[logLevel[\"INFO\"] = 2] = \"INFO\";\n  logLevel[logLevel[\"WARN\"] = 3] = \"WARN\";\n  logLevel[logLevel[\"ERROR\"] = 4] = \"ERROR\";\n  logLevel[logLevel[\"DISABLED\"] = 5] = \"DISABLED\";\n})(logLevel || (logLevel = {}));\n\nvar Logger = /*#__PURE__*/function () {\n  function Logger(config) {\n    _classCallCheck(this, Logger);\n\n    this.config = config;\n    this.logLevel = void 0;\n    this.configure(config);\n  }\n\n  _createClass(Logger, [{\n    key: \"configure\",\n    value: function configure(config) {\n      this.config = _extends({}, this.config, config);\n\n      switch (this.config.logLevel) {\n        case 'DEBUG':\n          this.logLevel = logLevel.DEBUG;\n          break;\n\n        case 'INFO':\n          this.logLevel = logLevel.INFO;\n          break;\n\n        case 'WARN':\n          this.logLevel = logLevel.WARN;\n          break;\n\n        case 'ERROR':\n          this.logLevel = logLevel.ERROR;\n          break;\n\n        case 'DISABLED':\n          this.logLevel = logLevel.DISABLED;\n          break;\n\n        default:\n          this.logLevel = logLevel.INFO;\n          break;\n      }\n    }\n  }, {\n    key: \"debug\",\n    value: function debug(message) {\n      if (this.logLevel === logLevel.DEBUG) {\n        var _console;\n\n        for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          optionalParams[_key - 1] = arguments[_key];\n        }\n\n        (_console = console).log.apply(_console, [message].concat(optionalParams));\n      }\n    }\n  }, {\n    key: \"info\",\n    value: function info(message) {\n      if (this.logLevel <= logLevel.INFO) {\n        var _console2;\n\n        for (var _len2 = arguments.length, optionalParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          optionalParams[_key2 - 1] = arguments[_key2];\n        }\n\n        (_console2 = console).log.apply(_console2, [message].concat(optionalParams));\n      }\n    }\n  }, {\n    key: \"warn\",\n    value: function warn(message) {\n      if (this.logLevel <= logLevel.WARN) {\n        var _console3;\n\n        for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          optionalParams[_key3 - 1] = arguments[_key3];\n        }\n\n        (_console3 = console).warn.apply(_console3, [message].concat(optionalParams));\n\n        if (this.config.onwarn) {\n          this.config.onwarn(message, optionalParams);\n        }\n      }\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      if (this.logLevel <= logLevel.ERROR) {\n        var _console4;\n\n        for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          optionalParams[_key4 - 1] = arguments[_key4];\n        }\n\n        (_console4 = console).error.apply(_console4, [message].concat(optionalParams));\n\n        if (this.config.onerror) {\n          this.config.onerror(message, optionalParams);\n        }\n      }\n    }\n  }]);\n\n  return Logger;\n}();\n\nvar logger = new Logger({\n  logLevel: 'INFO'\n});\n\nvar configureLogger = function configureLogger(config) {\n  return logger.configure(config);\n};\n\nfunction promisify(f, thisContext) {\n  return function () {\n    for (var _len5 = arguments.length, a = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      a[_key5] = arguments[_key5];\n    }\n\n    var args = Array.prototype.slice.call(a);\n    return new Promise( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                args.push(function (err, result) {\n                  return err ? reject(err) : resolve(result);\n                });\n                _context.next = 4;\n                return f.apply(thisContext, args);\n\n              case 4:\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                reject(_context.t0);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 6]]);\n      }));\n\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  };\n}\n\nvar getRandomInt = function getRandomInt() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_SAFE_INTEGER;\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction queryStringFromObject(name, obj) {\n  var k = encodeURIComponent(name);\n  var v = encodeURIComponent(JSON.stringify(obj));\n  return \"\".concat(k, \"=\").concat(v);\n}\n\nfunction queryStringToObject(qs) {\n  var p = qs.split('&');\n  var o = {};\n\n  var _iterator = _createForOfIteratorHelper(p),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var v = _step.value;\n      var z = v.split('=');\n      o[decodeURIComponent(z[0])] = JSON.parse(decodeURIComponent(z[1]));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return o;\n} // sanitizeNumberString accepts a number string and returns back a clean number string.\n// For example, input '1234.5678' will return '1234.5678' but '12javascript:{}etc' will return '12'\n\n\nvar sanitizeNumberString = function sanitizeNumberString(numString) {\n  if (!numString || typeof numString !== 'string') {\n    return '';\n  }\n\n  var v = numString.match(/[\\d.]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n}; // sanitizeAlphanumeric accepts any string and returns alphanumeric contents only\n\n\nvar sanitizeAlphanumeric = function sanitizeAlphanumeric(alphanum) {\n  if (!alphanum || typeof alphanum !== 'string') {\n    return '';\n  }\n\n  var v = alphanum.match(/[\\w\\s\\d]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n}; // sanitizeHost accepts any string and returns valid host string\n\n\nvar sanitizeHost = function sanitizeHost(host) {\n  if (!host || typeof host !== 'string') {\n    return '';\n  }\n\n  var v = host.match(/[\\w\\d.\\-:\\/]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n};\n\nvar sleep = function sleep(t) {\n  return new Promise(function (resolve) {\n    var timeout = setTimeout(function () {\n      clearTimeout(timeout);\n      resolve();\n    }, t);\n  });\n};\n\nvar encodeTypedDataHash = function encodeTypedDataHash(typedData) {\n  var types = _extends({}, typedData.types); // remove EIP712Domain key from types as ethers will auto-gen it in\n  // the hash encoder below\n\n\n  delete types['EIP712Domain'];\n  return ethers.utils._TypedDataEncoder.hash(typedData.domain, types, typedData.message);\n};\n\nvar encodeTypedDataDigest = function encodeTypedDataDigest(typedData) {\n  return ethers.utils.arrayify(encodeTypedDataHash(typedData));\n}; // urlClean removes double slashes from url path\n\n\nvar urlClean = function urlClean(url) {\n  return url.replace(/([^:]\\/)\\/+/g, '$1');\n};\n\nfunction isBigNumberish(value) {\n  return value != null && (BigNumber.isBigNumber(value) || typeof value === \"number\" && value % 1 === 0 || typeof value === \"string\" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === \"bigint\" || isBytes(value));\n}\n\nexport { Logger, base64Decode, base64DecodeObject, base64Encode, base64EncodeObject, configureLogger, encodeMessageDigest, encodeTypedDataDigest, encodeTypedDataHash, getRandomInt, isBigNumberish, isBrowser, isNode, jwtDecodeClaims, logger, packMessageData, promisify, queryStringFromObject, queryStringToObject, sanitizeAlphanumeric, sanitizeHost, sanitizeNumberString, sleep, subDigestOf, urlClean };","map":null,"metadata":{},"sourceType":"module"}