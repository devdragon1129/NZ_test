{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\nimport { Space, Axis } from '../Maths/math.axis';\n/**\r\n * Class used to make a bone look toward a point in space\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller\r\n */\n\nvar BoneLookController =\n/** @class */\nfunction () {\n  /**\r\n   * Create a BoneLookController\r\n   * @param mesh the mesh that the bone belongs to\r\n   * @param bone the bone that will be looking to the target\r\n   * @param target the target Vector3 to look at\r\n   * @param options optional settings:\r\n   * * maxYaw: the maximum angle the bone will yaw to\r\n   * * minYaw: the minimum angle the bone will yaw to\r\n   * * maxPitch: the maximum angle the bone will pitch to\r\n   * * minPitch: the minimum angle the bone will yaw to\r\n   * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\r\n   * * upAxis: the up axis of the coordinate system\r\n   * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\r\n   * * yawAxis: set yawAxis if the bone does not yaw on the y axis\r\n   * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\r\n   * * adjustYaw: used to make an adjustment to the yaw of the bone\r\n   * * adjustPitch: used to make an adjustment to the pitch of the bone\r\n   * * adjustRoll: used to make an adjustment to the roll of the bone\r\n   **/\n  function BoneLookController(mesh, bone, target, options) {\n    /**\r\n     * The up axis of the coordinate system that is used when the bone is rotated\r\n     */\n    this.upAxis = Vector3.Up();\n    /**\r\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\r\n     */\n\n    this.upAxisSpace = Space.LOCAL;\n    /**\r\n     * Used to make an adjustment to the yaw of the bone\r\n     */\n\n    this.adjustYaw = 0;\n    /**\r\n     * Used to make an adjustment to the pitch of the bone\r\n     */\n\n    this.adjustPitch = 0;\n    /**\r\n     * Used to make an adjustment to the roll of the bone\r\n     */\n\n    this.adjustRoll = 0;\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\n\n    this.slerpAmount = 1;\n    this._boneQuat = Quaternion.Identity();\n    this._slerping = false;\n    this._firstFrameSkipped = false;\n    this._fowardAxis = Vector3.Forward();\n    this.mesh = mesh;\n    this.bone = bone;\n    this.target = target;\n\n    if (options) {\n      if (options.adjustYaw) {\n        this.adjustYaw = options.adjustYaw;\n      }\n\n      if (options.adjustPitch) {\n        this.adjustPitch = options.adjustPitch;\n      }\n\n      if (options.adjustRoll) {\n        this.adjustRoll = options.adjustRoll;\n      }\n\n      if (options.maxYaw != null) {\n        this.maxYaw = options.maxYaw;\n      } else {\n        this.maxYaw = Math.PI;\n      }\n\n      if (options.minYaw != null) {\n        this.minYaw = options.minYaw;\n      } else {\n        this.minYaw = -Math.PI;\n      }\n\n      if (options.maxPitch != null) {\n        this.maxPitch = options.maxPitch;\n      } else {\n        this.maxPitch = Math.PI;\n      }\n\n      if (options.minPitch != null) {\n        this.minPitch = options.minPitch;\n      } else {\n        this.minPitch = -Math.PI;\n      }\n\n      if (options.slerpAmount != null) {\n        this.slerpAmount = options.slerpAmount;\n      }\n\n      if (options.upAxis != null) {\n        this.upAxis = options.upAxis;\n      }\n\n      if (options.upAxisSpace != null) {\n        this.upAxisSpace = options.upAxisSpace;\n      }\n\n      if (options.yawAxis != null || options.pitchAxis != null) {\n        var newYawAxis = Axis.Y;\n        var newPitchAxis = Axis.X;\n\n        if (options.yawAxis != null) {\n          newYawAxis = options.yawAxis.clone();\n          newYawAxis.normalize();\n        }\n\n        if (options.pitchAxis != null) {\n          newPitchAxis = options.pitchAxis.clone();\n          newPitchAxis.normalize();\n        }\n\n        var newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\n        this._transformYawPitch = Matrix.Identity();\n        Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\n        this._transformYawPitchInv = this._transformYawPitch.clone();\n\n        this._transformYawPitch.invert();\n      }\n    }\n\n    if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\n      this.upAxisSpace = Space.LOCAL;\n    }\n  }\n\n  Object.defineProperty(BoneLookController.prototype, \"minYaw\", {\n    /**\r\n     * Gets or sets the minimum yaw angle that the bone can look to\r\n     */\n    get: function get() {\n      return this._minYaw;\n    },\n    set: function set(value) {\n      this._minYaw = value;\n      this._minYawSin = Math.sin(value);\n      this._minYawCos = Math.cos(value);\n\n      if (this._maxYaw != null) {\n        this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;\n        this._yawRange = this._maxYaw - this._minYaw;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"maxYaw\", {\n    /**\r\n     * Gets or sets the maximum yaw angle that the bone can look to\r\n     */\n    get: function get() {\n      return this._maxYaw;\n    },\n    set: function set(value) {\n      this._maxYaw = value;\n      this._maxYawSin = Math.sin(value);\n      this._maxYawCos = Math.cos(value);\n\n      if (this._minYaw != null) {\n        this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;\n        this._yawRange = this._maxYaw - this._minYaw;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"minPitch\", {\n    /**\r\n     * Gets or sets the minimum pitch angle that the bone can look to\r\n     */\n    get: function get() {\n      return this._minPitch;\n    },\n    set: function set(value) {\n      this._minPitch = value;\n      this._minPitchTan = Math.tan(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"maxPitch\", {\n    /**\r\n     * Gets or sets the maximum pitch angle that the bone can look to\r\n     */\n    get: function get() {\n      return this._maxPitch;\n    },\n    set: function set(value) {\n      this._maxPitch = value;\n      this._maxPitchTan = Math.tan(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\r\n   */\n\n  BoneLookController.prototype.update = function () {\n    //skip the first frame when slerping so that the mesh rotation is correct\n    if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\n      this._firstFrameSkipped = true;\n      return;\n    }\n\n    var bone = this.bone;\n    var bonePos = BoneLookController._tmpVecs[0];\n    bone.getAbsolutePositionToRef(this.mesh, bonePos);\n    var target = this.target;\n    var _tmpMat1 = BoneLookController._tmpMats[0];\n    var _tmpMat2 = BoneLookController._tmpMats[1];\n    var mesh = this.mesh;\n    var parentBone = bone.getParent();\n    var upAxis = BoneLookController._tmpVecs[1];\n    upAxis.copyFrom(this.upAxis);\n\n    if (this.upAxisSpace == Space.BONE && parentBone) {\n      if (this._transformYawPitch) {\n        Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\n      }\n\n      parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\n    } else if (this.upAxisSpace == Space.LOCAL) {\n      mesh.getDirectionToRef(upAxis, upAxis);\n\n      if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\n        upAxis.normalize();\n      }\n    }\n\n    var checkYaw = false;\n    var checkPitch = false;\n\n    if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\n      checkYaw = true;\n    }\n\n    if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\n      checkPitch = true;\n    }\n\n    if (checkYaw || checkPitch) {\n      var spaceMat = BoneLookController._tmpMats[2];\n      var spaceMatInv = BoneLookController._tmpMats[3];\n\n      if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\n        parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\n      } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\n        spaceMat.copyFrom(mesh.getWorldMatrix());\n      } else {\n        var forwardAxis = BoneLookController._tmpVecs[2];\n        forwardAxis.copyFrom(this._fowardAxis);\n\n        if (this._transformYawPitch) {\n          Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\n        }\n\n        if (parentBone) {\n          parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\n        } else {\n          mesh.getDirectionToRef(forwardAxis, forwardAxis);\n        }\n\n        var rightAxis = Vector3.Cross(upAxis, forwardAxis);\n        rightAxis.normalize();\n        var forwardAxis = Vector3.Cross(rightAxis, upAxis);\n        Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\n      }\n\n      spaceMat.invertToRef(spaceMatInv);\n      var xzlen = null;\n\n      if (checkPitch) {\n        var localTarget = BoneLookController._tmpVecs[3];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n        var pitch = Math.atan2(localTarget.y, xzlen);\n        var newPitch = pitch;\n\n        if (pitch > this._maxPitch) {\n          localTarget.y = this._maxPitchTan * xzlen;\n          newPitch = this._maxPitch;\n        } else if (pitch < this._minPitch) {\n          localTarget.y = this._minPitchTan * xzlen;\n          newPitch = this._minPitch;\n        }\n\n        if (pitch != newPitch) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n\n      if (checkYaw) {\n        var localTarget = BoneLookController._tmpVecs[4];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        var yaw = Math.atan2(localTarget.x, localTarget.z);\n        var newYaw = yaw;\n\n        if (yaw > this._maxYaw || yaw < this._minYaw) {\n          if (xzlen == null) {\n            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n          }\n\n          if (this._yawRange > Math.PI) {\n            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          } else {\n            if (yaw > this._maxYaw) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (yaw < this._minYaw) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          }\n        }\n\n        if (this._slerping && this._yawRange > Math.PI) {\n          //are we going to be crossing into the min/max region?\n          var boneFwd = BoneLookController._tmpVecs[8];\n          boneFwd.copyFrom(Axis.Z);\n\n          if (this._transformYawPitch) {\n            Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\n          }\n\n          var boneRotMat = BoneLookController._tmpMats[4];\n\n          this._boneQuat.toRotationMatrix(boneRotMat);\n\n          this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\n          Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\n          Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\n          var boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\n\n          var angBtwTar = this._getAngleBetween(boneYaw, yaw);\n\n          var angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\n\n          if (angBtwTar > angBtwMidYaw) {\n            if (xzlen == null) {\n              xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n            }\n\n            var angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\n\n            var angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\n\n            if (angBtwMin < angBtwMax) {\n              newYaw = boneYaw + Math.PI * .75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            } else {\n              newYaw = boneYaw - Math.PI * .75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            }\n          }\n        }\n\n        if (yaw != newYaw) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n    }\n\n    var zaxis = BoneLookController._tmpVecs[5];\n    var xaxis = BoneLookController._tmpVecs[6];\n    var yaxis = BoneLookController._tmpVecs[7];\n    var _tmpQuat = BoneLookController._tmpQuat;\n    target.subtractToRef(bonePos, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(upAxis, zaxis, xaxis);\n    xaxis.normalize();\n    Vector3.CrossToRef(zaxis, xaxis, yaxis);\n    yaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\n\n    if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\n      return;\n    }\n\n    if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\n      return;\n    }\n\n    if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\n      return;\n    }\n\n    if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\n      Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\n\n      _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\n    }\n\n    if (this.slerpAmount < 1) {\n      if (!this._slerping) {\n        this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\n      }\n\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n\n      Quaternion.FromRotationMatrixToRef(_tmpMat1, _tmpQuat);\n      Quaternion.SlerpToRef(this._boneQuat, _tmpQuat, this.slerpAmount, this._boneQuat);\n      this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\n      this._slerping = true;\n    } else {\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n\n      this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\n      this._slerping = false;\n    }\n  };\n\n  BoneLookController.prototype._getAngleDiff = function (ang1, ang2) {\n    var angDiff = ang2 - ang1;\n    angDiff %= Math.PI * 2;\n\n    if (angDiff > Math.PI) {\n      angDiff -= Math.PI * 2;\n    } else if (angDiff < -Math.PI) {\n      angDiff += Math.PI * 2;\n    }\n\n    return angDiff;\n  };\n\n  BoneLookController.prototype._getAngleBetween = function (ang1, ang2) {\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    var ab = 0;\n\n    if (ang1 < ang2) {\n      ab = ang2 - ang1;\n    } else {\n      ab = ang1 - ang2;\n    }\n\n    if (ab > Math.PI) {\n      ab = Math.PI * 2 - ab;\n    }\n\n    return ab;\n  };\n\n  BoneLookController.prototype._isAngleBetween = function (ang, ang1, ang2) {\n    ang %= 2 * Math.PI;\n    ang = ang < 0 ? ang + 2 * Math.PI : ang;\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n\n    if (ang1 < ang2) {\n      if (ang > ang1 && ang < ang2) {\n        return true;\n      }\n    } else {\n      if (ang > ang2 && ang < ang1) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  BoneLookController._tmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);\n  BoneLookController._tmpQuat = Quaternion.Identity();\n  BoneLookController._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n  return BoneLookController;\n}();\n\nexport { BoneLookController };","map":null,"metadata":{},"sourceType":"module"}