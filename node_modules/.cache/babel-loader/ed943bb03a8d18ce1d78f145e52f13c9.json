{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { createSelector } from 'reselect';\nimport { getAddress } from 'decentraland-dapps/dist/modules/wallet/selectors';\nimport { isLoadingType } from 'decentraland-dapps/dist/modules/loading/selectors';\nimport { getData as getDeployments } from 'modules/deployment/selectors';\nimport { getTiles } from 'modules/tile/selectors';\nimport { FETCH_LANDS_REQUEST } from './actions';\nimport { coordsToId, colorByRole, hasNeighbour } from './utils';\nimport { LandType } from './types';\nexport var getState = function getState(state) {\n  return state.land;\n};\nexport var getData = function getData(state) {\n  return getState(state).data;\n};\nexport var getLoading = function getLoading(state) {\n  return getState(state).loading;\n};\nexport var getError = function getError(state) {\n  return getState(state).error;\n};\nexport var getAuthorizations = function getAuthorizations(state) {\n  return getState(state).authorizations;\n};\nexport var getLands = createSelector(getAddress, getData, function (address, data) {\n  return address && address in data ? data[address] : [];\n});\nexport var isLoading = function isLoading(state) {\n  return isLoadingType(getLoading(state), FETCH_LANDS_REQUEST);\n};\nexport var getCoordsByEstateId = createSelector(getTiles, function (tiles) {\n  var result = {};\n\n  for (var _i = 0, _Object$values = Object.values(tiles); _i < _Object$values.length; _i++) {\n    var tile = _Object$values[_i];\n\n    if (tile.estate_id) {\n      var exists = (tile.estate_id in result);\n\n      if (!exists) {\n        result[tile.estate_id] = [];\n      }\n\n      result[tile.estate_id].push(coordsToId(tile.x, tile.y));\n    }\n  }\n\n  return result;\n});\nexport var getLandTiles = createSelector(getLands, getTiles, getCoordsByEstateId, function (lands, tiles, coordsByEstateId) {\n  var result = {};\n\n  var _iterator = _createForOfIteratorHelper(lands),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var land = _step.value;\n\n      if (land.type === LandType.PARCEL) {\n        var id = coordsToId(land.x, land.y);\n        result[id] = {\n          color: colorByRole[land.role],\n          land: land\n        };\n      } else {\n        var estateId = land.id;\n        var coords = coordsByEstateId[estateId];\n\n        if (coords) {\n          var _iterator2 = _createForOfIteratorHelper(coords),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var coord = _step2.value;\n              var tile = tiles[coord];\n\n              if (tile) {\n                result[coord] = {\n                  color: colorByRole[land.role],\n                  top: !!tile.top,\n                  left: !!tile.left,\n                  topLeft: !!tile.topLeft,\n                  land: land\n                };\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result;\n});\nexport var getDeploymentsByCoord = createSelector(function (state) {\n  return getDeployments(state);\n}, function (deployments) {\n  var out = {};\n\n  for (var _i2 = 0, _Object$values2 = Object.values(deployments); _i2 < _Object$values2.length; _i2++) {\n    var deployment = _Object$values2[_i2];\n    var parcels = deployment.parcels;\n\n    var _iterator3 = _createForOfIteratorHelper(parcels),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var coord = _step3.value;\n        out[coord] = deployment;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  return out;\n});\nexport var getDeploymentsByLandId = createSelector(getLandTiles, getDeploymentsByCoord, function (tiles, deploymentsByCoord) {\n  var out = {};\n\n  for (var _i3 = 0, _Object$keys = Object.keys(deploymentsByCoord); _i3 < _Object$keys.length; _i3++) {\n    var coord = _Object$keys[_i3];\n    var tile = tiles[coord];\n\n    if (tile) {\n      var land = tile.land;\n      var exists = (land.id in out);\n\n      if (!exists) {\n        out[land.id] = [];\n      }\n\n      var deployment = deploymentsByCoord[coord];\n\n      if (out[land.id].indexOf(deployment) === -1) {\n        out[land.id].push(deployment);\n      }\n    }\n  }\n\n  return out;\n});\nexport var getParcelsAvailableToBuildEstates = createSelector(getLandTiles, function (landTiles) {\n  var all = Object.values(landTiles).filter(function (tile) {\n    return tile.land.type === LandType.PARCEL;\n  }).map(function (tile) {\n    return {\n      x: tile.land.x,\n      y: tile.land.y\n    };\n  });\n  var neighbours = Object.keys(landTiles).reduce(function (obj, id) {\n    var land = landTiles[id].land;\n    var coord = {\n      x: land.x,\n      y: land.y\n    };\n    obj[id] = hasNeighbour(coord, all);\n    return obj;\n  }, {});\n  return neighbours;\n});","map":{"version":3,"sources":["/opt/work/NZ_test/src/modules/land/selectors.ts"],"names":["createSelector","getAddress","isLoadingType","getData","getDeployments","getTiles","FETCH_LANDS_REQUEST","coordsToId","colorByRole","hasNeighbour","LandType","getState","state","land","data","getLoading","loading","getError","error","getAuthorizations","authorizations","getLands","address","isLoading","getCoordsByEstateId","tiles","result","Object","values","tile","estate_id","exists","push","x","y","getLandTiles","lands","coordsByEstateId","type","PARCEL","id","color","role","estateId","coords","coord","top","left","topLeft","getDeploymentsByCoord","deployments","out","deployment","parcels","getDeploymentsByLandId","deploymentsByCoord","keys","indexOf","getParcelsAvailableToBuildEstates","landTiles","all","filter","map","neighbours","reduce","obj"],"mappings":";;;;;;AAAA,SAASA,cAAT,QAA+B,UAA/B;AAEA,SAASC,UAAT,QAA2B,kDAA3B;AACA,SAASC,aAAT,QAA8B,mDAA9B;AAEA,SAASC,OAAO,IAAIC,cAApB,QAA0C,8BAA1C;AAEA,SAASC,QAAT,QAAyB,wBAAzB;AACA,SAASC,mBAAT,QAAoC,WAApC;AACA,SAASC,UAAT,EAAqBC,WAArB,EAAkCC,YAAlC,QAAsD,SAAtD;AACA,SAAeC,QAAf,QAAyC,SAAzC;AAGA,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,KAAD;AAAA,SAAsBA,KAAK,CAACC,IAA5B;AAAA,CAAjB;AACP,OAAO,IAAMV,OAAO,GAAG,SAAVA,OAAU,CAACS,KAAD;AAAA,SAAsBD,QAAQ,CAACC,KAAD,CAAR,CAAgBE,IAAtC;AAAA,CAAhB;AACP,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACH,KAAD;AAAA,SAAsBD,QAAQ,CAACC,KAAD,CAAR,CAAgBI,OAAtC;AAAA,CAAnB;AACP,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACL,KAAD;AAAA,SAAsBD,QAAQ,CAACC,KAAD,CAAR,CAAgBM,KAAtC;AAAA,CAAjB;AACP,OAAO,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACP,KAAD;AAAA,SAAsBD,QAAQ,CAACC,KAAD,CAAR,CAAgBQ,cAAtC;AAAA,CAA1B;AACP,OAAO,IAAMC,QAAQ,GAAGrB,cAAc,CACpCC,UADoC,EAEpCE,OAFoC,EAGpC,UAACmB,OAAD,EAAUR,IAAV;AAAA,SAAoBQ,OAAO,IAAIA,OAAO,IAAIR,IAAtB,GAA6BA,IAAI,CAACQ,OAAD,CAAjC,GAA6C,EAAjE;AAAA,CAHoC,CAA/B;AAKP,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACX,KAAD;AAAA,SAAsBV,aAAa,CAACa,UAAU,CAACH,KAAD,CAAX,EAAoBN,mBAApB,CAAnC;AAAA,CAAlB;AAEP,OAAO,IAAMkB,mBAAmB,GAAGxB,cAAc,CAAiEK,QAAjE,EAA2E,UAAAoB,KAAK,EAAI;AACnI,MAAMC,MAAgC,GAAG,EAAzC;;AACA,oCAAmBC,MAAM,CAACC,MAAP,CAAcH,KAAd,CAAnB,oCAAyC;AAApC,QAAMI,IAAI,qBAAV;;AACH,QAAIA,IAAI,CAACC,SAAT,EAAoB;AAClB,UAAMC,MAAM,IAAGF,IAAI,CAACC,SAAL,IAAkBJ,MAArB,CAAZ;;AACA,UAAI,CAACK,MAAL,EAAa;AACXL,QAAAA,MAAM,CAACG,IAAI,CAACC,SAAN,CAAN,GAAyB,EAAzB;AACD;;AACDJ,MAAAA,MAAM,CAACG,IAAI,CAACC,SAAN,CAAN,CAAuBE,IAAvB,CAA4BzB,UAAU,CAACsB,IAAI,CAACI,CAAN,EAASJ,IAAI,CAACK,CAAd,CAAtC;AACD;AACF;;AACD,SAAOR,MAAP;AACD,CAZgD,CAA1C;AAcP,OAAO,IAAMS,YAAY,GAAGnC,cAAc,CAMxCqB,QANwC,EAM9BhB,QAN8B,EAMpBmB,mBANoB,EAMC,UAACY,KAAD,EAAQX,KAAR,EAAeY,gBAAf,EAAoC;AAC7E,MAAMX,MAAgC,GAAG,EAAzC;;AAD6E,6CAE1DU,KAF0D;AAAA;;AAAA;AAE7E,wDAA0B;AAAA,UAAfvB,IAAe;;AACxB,UAAIA,IAAI,CAACyB,IAAL,KAAc5B,QAAQ,CAAC6B,MAA3B,EAAmC;AACjC,YAAMC,EAAE,GAAGjC,UAAU,CAACM,IAAI,CAACoB,CAAN,EAAUpB,IAAI,CAACqB,CAAf,CAArB;AACAR,QAAAA,MAAM,CAACc,EAAD,CAAN,GAAa;AACXC,UAAAA,KAAK,EAAEjC,WAAW,CAACK,IAAI,CAAC6B,IAAN,CADP;AAEX7B,UAAAA,IAAI,EAAJA;AAFW,SAAb;AAID,OAND,MAMO;AACL,YAAM8B,QAAQ,GAAG9B,IAAI,CAAC2B,EAAtB;AACA,YAAMI,MAAM,GAAGP,gBAAgB,CAACM,QAAD,CAA/B;;AACA,YAAIC,MAAJ,EAAY;AAAA,sDACUA,MADV;AAAA;;AAAA;AACV,mEAA4B;AAAA,kBAAjBC,KAAiB;AAC1B,kBAAMhB,IAAI,GAAGJ,KAAK,CAACoB,KAAD,CAAlB;;AACA,kBAAIhB,IAAJ,EAAU;AACRH,gBAAAA,MAAM,CAACmB,KAAD,CAAN,GAAgB;AACdJ,kBAAAA,KAAK,EAAEjC,WAAW,CAACK,IAAI,CAAC6B,IAAN,CADJ;AAEdI,kBAAAA,GAAG,EAAE,CAAC,CAACjB,IAAI,CAACiB,GAFE;AAGdC,kBAAAA,IAAI,EAAE,CAAC,CAAClB,IAAI,CAACkB,IAHC;AAIdC,kBAAAA,OAAO,EAAE,CAAC,CAACnB,IAAI,CAACmB,OAJF;AAKdnC,kBAAAA,IAAI,EAAJA;AALc,iBAAhB;AAOD;AACF;AAZS;AAAA;AAAA;AAAA;AAAA;AAaX;AACF;AACF;AA3B4E;AAAA;AAAA;AAAA;AAAA;;AA4B7E,SAAOa,MAAP;AACD,CAnCyC,CAAnC;AAqCP,OAAO,IAAMuB,qBAAqB,GAAGjD,cAAc,CACjD,UAAAY,KAAK;AAAA,SAAIR,cAAc,CAACQ,KAAD,CAAlB;AAAA,CAD4C,EAEjD,UAAAsC,WAAW,EAAI;AACb,MAAMC,GAA+B,GAAG,EAAxC;;AACA,sCAAyBxB,MAAM,CAACC,MAAP,CAAcsB,WAAd,CAAzB,uCAAqD;AAAhD,QAAME,UAAU,uBAAhB;AAAgD,QAC3CC,OAD2C,GAC/BD,UAD+B,CAC3CC,OAD2C;;AAAA,gDAE/BA,OAF+B;AAAA;;AAAA;AAEnD,6DAA6B;AAAA,YAAlBR,KAAkB;AAC3BM,QAAAA,GAAG,CAACN,KAAD,CAAH,GAAaO,UAAb;AACD;AAJkD;AAAA;AAAA;AAAA;AAAA;AAKpD;;AACD,SAAOD,GAAP;AACD,CAXgD,CAA5C;AAcP,OAAO,IAAMG,sBAAsB,GAAGtD,cAAc,CAKlDmC,YALkD,EAKpCc,qBALoC,EAKb,UAACxB,KAAD,EAAQ8B,kBAAR,EAA+B;AACpE,MAAMJ,GAAiC,GAAG,EAA1C;;AACA,mCAAoBxB,MAAM,CAAC6B,IAAP,CAAYD,kBAAZ,CAApB,oCAAqD;AAAhD,QAAMV,KAAK,oBAAX;AACH,QAAMhB,IAAI,GAAGJ,KAAK,CAACoB,KAAD,CAAlB;;AACA,QAAIhB,IAAJ,EAAU;AAAA,UACAhB,IADA,GACSgB,IADT,CACAhB,IADA;AAER,UAAMkB,MAAM,IAAGlB,IAAI,CAAC2B,EAAL,IAAWW,GAAd,CAAZ;;AACA,UAAI,CAACpB,MAAL,EAAa;AACXoB,QAAAA,GAAG,CAACtC,IAAI,CAAC2B,EAAN,CAAH,GAAe,EAAf;AACD;;AAED,UAAMY,UAAU,GAAGG,kBAAkB,CAACV,KAAD,CAArC;;AACA,UAAIM,GAAG,CAACtC,IAAI,CAAC2B,EAAN,CAAH,CAAaiB,OAAb,CAAqBL,UAArB,MAAqC,CAAC,CAA1C,EAA6C;AAC3CD,QAAAA,GAAG,CAACtC,IAAI,CAAC2B,EAAN,CAAH,CAAaR,IAAb,CAAkBoB,UAAlB;AACD;AACF;AACF;;AACD,SAAOD,GAAP;AACD,CAvBmD,CAA7C;AAyBP,OAAO,IAAMO,iCAAiC,GAAG1D,cAAc,CAC7DmC,YAD6D,EAE7D,UAAAwB,SAAS,EAAI;AACX,MAAMC,GAAG,GAAGjC,MAAM,CAACC,MAAP,CAAc+B,SAAd,EACTE,MADS,CACF,UAAAhC,IAAI;AAAA,WAAIA,IAAI,CAAChB,IAAL,CAAUyB,IAAV,KAAmB5B,QAAQ,CAAC6B,MAAhC;AAAA,GADF,EAETuB,GAFS,CAEE,UAAAjC,IAAI;AAAA,WAAK;AAAEI,MAAAA,CAAC,EAAEJ,IAAI,CAAChB,IAAL,CAAUoB,CAAf;AAAmBC,MAAAA,CAAC,EAAEL,IAAI,CAAChB,IAAL,CAAUqB;AAAhC,KAAL;AAAA,GAFN,CAAZ;AAGA,MAAM6B,UAAU,GAAGpC,MAAM,CAAC6B,IAAP,CAAYG,SAAZ,EAAuBK,MAAvB,CAA8B,UAACC,GAAD,EAAMzB,EAAN,EAAa;AAAA,QACpD3B,IADoD,GAC3C8C,SAAS,CAACnB,EAAD,CADkC,CACpD3B,IADoD;AAE5D,QAAMgC,KAAK,GAAG;AAAEZ,MAAAA,CAAC,EAAEpB,IAAI,CAACoB,CAAV;AAAcC,MAAAA,CAAC,EAAErB,IAAI,CAACqB;AAAtB,KAAd;AACA+B,IAAAA,GAAG,CAACzB,EAAD,CAAH,GAAU/B,YAAY,CAACoC,KAAD,EAAQe,GAAR,CAAtB;AACA,WAAOK,GAAP;AACD,GALkB,EAKhB,EALgB,CAAnB;AAMA,SAAOF,UAAP;AACD,CAb4D,CAAxD","sourcesContent":["import { createSelector } from 'reselect'\nimport { AtlasTile, Coord } from 'decentraland-ui'\nimport { getAddress } from 'decentraland-dapps/dist/modules/wallet/selectors'\nimport { isLoadingType } from 'decentraland-dapps/dist/modules/loading/selectors'\nimport { RootState } from 'modules/common/types'\nimport { getData as getDeployments } from 'modules/deployment/selectors'\nimport { DeploymentState } from 'modules/deployment/reducer'\nimport { getTiles } from 'modules/tile/selectors'\nimport { FETCH_LANDS_REQUEST } from './actions'\nimport { coordsToId, colorByRole, hasNeighbour } from './utils'\nimport { Land, LandType, LandTile } from './types'\nimport { Deployment } from 'modules/deployment/types'\n\nexport const getState = (state: RootState) => state.land\nexport const getData = (state: RootState) => getState(state).data\nexport const getLoading = (state: RootState) => getState(state).loading\nexport const getError = (state: RootState) => getState(state).error\nexport const getAuthorizations = (state: RootState) => getState(state).authorizations\nexport const getLands = createSelector<RootState, string | undefined, Record<string, Land[]>, Land[]>(\n  getAddress,\n  getData,\n  (address, data) => (address && address in data ? data[address] : [])\n)\nexport const isLoading = (state: RootState) => isLoadingType(getLoading(state), FETCH_LANDS_REQUEST)\n\nexport const getCoordsByEstateId = createSelector<RootState, Record<string, AtlasTile>, Record<string, string[]>>(getTiles, tiles => {\n  const result: Record<string, string[]> = {}\n  for (const tile of Object.values(tiles)) {\n    if (tile.estate_id) {\n      const exists = tile.estate_id in result\n      if (!exists) {\n        result[tile.estate_id] = []\n      }\n      result[tile.estate_id].push(coordsToId(tile.x, tile.y))\n    }\n  }\n  return result\n})\n\nexport const getLandTiles = createSelector<\n  RootState,\n  Land[],\n  Record<string, AtlasTile>,\n  Record<string, string[]>,\n  Record<string, LandTile>\n>(getLands, getTiles, getCoordsByEstateId, (lands, tiles, coordsByEstateId) => {\n  const result: Record<string, LandTile> = {}\n  for (const land of lands) {\n    if (land.type === LandType.PARCEL) {\n      const id = coordsToId(land.x!, land.y!)\n      result[id] = {\n        color: colorByRole[land.role],\n        land\n      }\n    } else {\n      const estateId = land.id\n      const coords = coordsByEstateId[estateId]\n      if (coords) {\n        for (const coord of coords) {\n          const tile = tiles[coord]\n          if (tile) {\n            result[coord] = {\n              color: colorByRole[land.role],\n              top: !!tile.top,\n              left: !!tile.left,\n              topLeft: !!tile.topLeft,\n              land\n            }\n          }\n        }\n      }\n    }\n  }\n  return result\n})\n\nexport const getDeploymentsByCoord = createSelector<RootState, DeploymentState['data'], Record<string, Deployment>>(\n  state => getDeployments(state),\n  deployments => {\n    const out: Record<string, Deployment> = {}\n    for (const deployment of Object.values(deployments)) {\n      const { parcels } = deployment\n      for (const coord of parcels) {\n        out[coord] = deployment\n      }\n    }\n    return out\n  }\n)\n\nexport const getDeploymentsByLandId = createSelector<\n  RootState,\n  Record<string, LandTile>,\n  Record<string, Deployment>,\n  Record<string, Deployment[]>\n>(getLandTiles, getDeploymentsByCoord, (tiles, deploymentsByCoord) => {\n  const out: Record<string, Deployment[]> = {}\n  for (const coord of Object.keys(deploymentsByCoord)) {\n    const tile = tiles[coord]\n    if (tile) {\n      const { land } = tile\n      const exists = land.id in out\n      if (!exists) {\n        out[land.id] = []\n      }\n\n      const deployment = deploymentsByCoord[coord]\n      if (out[land.id].indexOf(deployment) === -1) {\n        out[land.id].push(deployment)\n      }\n    }\n  }\n  return out\n})\n\nexport const getParcelsAvailableToBuildEstates = createSelector<RootState, Record<string, LandTile>, Record<string, boolean>>(\n  getLandTiles,\n  landTiles => {\n    const all = Object.values(landTiles)\n      .filter(tile => tile.land.type === LandType.PARCEL)\n      .map<Coord>(tile => ({ x: tile.land.x!, y: tile.land.y! }))\n    const neighbours = Object.keys(landTiles).reduce((obj, id) => {\n      const { land } = landTiles[id]\n      const coord = { x: land.x!, y: land.y! }\n      obj[id] = hasNeighbour(coord, all)\n      return obj\n    }, {} as Record<string, boolean>)\n    return neighbours\n  }\n)\n"]},"metadata":{},"sourceType":"module"}