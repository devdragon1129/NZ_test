{"ast":null,"code":"import { Animation } from \"./animation\";\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\nimport { Observable } from \"../Misc/observable\";\nimport { Scene } from \"../scene\";\nimport { Matrix, Quaternion, Vector3, TmpVectors } from '../Maths/math.vector';\nimport { PrecisionDate } from '../Misc/precisionDate';\nimport { Bone } from '../Bones/bone';\n/**\r\n * Class used to store an actual running animation\r\n */\n\nvar Animatable =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Animatable\r\n   * @param scene defines the hosting scene\r\n   * @param target defines the target object\r\n   * @param fromFrame defines the starting frame number (default is 0)\r\n   * @param toFrame defines the ending frame number (default is 100)\r\n   * @param loopAnimation defines if the animation must loop (default is false)\r\n   * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n   * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n   * @param animations defines a group of animation to add to the new Animatable\r\n   * @param onAnimationLoop defines a callback to call when animation loops\r\n   * @param isAdditive defines whether the animation should be evaluated additively\r\n   */\n  function Animatable(scene,\n  /** defines the target object */\n  target,\n  /** defines the starting frame number (default is 0) */\n  fromFrame,\n  /** defines the ending frame number (default is 100) */\n  toFrame,\n  /** defines if the animation must loop (default is false)  */\n  loopAnimation, speedRatio,\n  /** defines a callback to call when animation ends if it is not looping */\n  onAnimationEnd, animations,\n  /** defines a callback to call when animation loops */\n  onAnimationLoop,\n  /** defines whether the animation should be evaluated additively */\n  isAdditive) {\n    if (fromFrame === void 0) {\n      fromFrame = 0;\n    }\n\n    if (toFrame === void 0) {\n      toFrame = 100;\n    }\n\n    if (loopAnimation === void 0) {\n      loopAnimation = false;\n    }\n\n    if (speedRatio === void 0) {\n      speedRatio = 1.0;\n    }\n\n    if (isAdditive === void 0) {\n      isAdditive = false;\n    }\n\n    this.target = target;\n    this.fromFrame = fromFrame;\n    this.toFrame = toFrame;\n    this.loopAnimation = loopAnimation;\n    this.onAnimationEnd = onAnimationEnd;\n    this.onAnimationLoop = onAnimationLoop;\n    this.isAdditive = isAdditive;\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n    this._runtimeAnimations = new Array();\n    this._paused = false;\n    this._speedRatio = 1;\n    this._weight = -1.0;\n    this._syncRoot = null;\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\n\n    this.disposeOnEnd = true;\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\n\n    this.animationStarted = false;\n    /**\r\n     * Observer raised when the animation ends\r\n     */\n\n    this.onAnimationEndObservable = new Observable();\n    /**\r\n     * Observer raised when the animation loops\r\n     */\n\n    this.onAnimationLoopObservable = new Observable();\n    this._scene = scene;\n\n    if (animations) {\n      this.appendAnimations(target, animations);\n    }\n\n    this._speedRatio = speedRatio;\n\n    scene._activeAnimatables.push(this);\n  }\n\n  Object.defineProperty(Animatable.prototype, \"syncRoot\", {\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\n    get: function get() {\n      return this._syncRoot;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"masterFrame\", {\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\n    get: function get() {\n      if (this._runtimeAnimations.length === 0) {\n        return 0;\n      }\n\n      return this._runtimeAnimations[0].currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"weight\", {\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\n    get: function get() {\n      return this._weight;\n    },\n    set: function set(value) {\n      if (value === -1) {\n        // -1 is ok and means no weight\n        this._weight = -1;\n        return;\n      } // Else weight must be in [0, 1] range\n\n\n      this._weight = Math.min(Math.max(value, 0), 1.0);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"speedRatio\", {\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\n    get: function get() {\n      return this._speedRatio;\n    },\n    set: function set(value) {\n      for (var index = 0; index < this._runtimeAnimations.length; index++) {\n        var animation = this._runtimeAnimations[index];\n\n        animation._prepareForSpeedRatioChange(value);\n      }\n\n      this._speedRatio = value;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\r\n   * Synchronize and normalize current Animatable with a source Animatable\r\n   * This is useful when using animation weights and when animations are not of the same length\r\n   * @param root defines the root Animatable to synchronize with\r\n   * @returns the current Animatable\r\n   */\n\n  Animatable.prototype.syncWith = function (root) {\n    this._syncRoot = root;\n\n    if (root) {\n      // Make sure this animatable will animate after the root\n      var index = this._scene._activeAnimatables.indexOf(this);\n\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n\n        this._scene._activeAnimatables.push(this);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Gets the list of runtime animations\r\n   * @returns an array of RuntimeAnimation\r\n   */\n\n\n  Animatable.prototype.getAnimations = function () {\n    return this._runtimeAnimations;\n  };\n  /**\r\n   * Adds more animations to the current animatable\r\n   * @param target defines the target of the animations\r\n   * @param animations defines the new animations to add\r\n   */\n\n\n  Animatable.prototype.appendAnimations = function (target, animations) {\n    var _this = this;\n\n    for (var index = 0; index < animations.length; index++) {\n      var animation = animations[index];\n      var newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n\n      newRuntimeAnimation._onLoop = function () {\n        _this.onAnimationLoopObservable.notifyObservers(_this);\n\n        if (_this.onAnimationLoop) {\n          _this.onAnimationLoop();\n        }\n      };\n\n      this._runtimeAnimations.push(newRuntimeAnimation);\n    }\n  };\n  /**\r\n   * Gets the source animation for a specific property\r\n   * @param property defines the propertyu to look for\r\n   * @returns null or the source animation for the given property\r\n   */\n\n\n  Animatable.prototype.getAnimationByTargetProperty = function (property) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index].animation;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets the runtime animation for a specific property\r\n   * @param property defines the propertyu to look for\r\n   * @returns null or the runtime animation for the given property\r\n   */\n\n\n  Animatable.prototype.getRuntimeAnimationByTargetProperty = function (property) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Resets the animatable to its original state\r\n   */\n\n\n  Animatable.prototype.reset = function () {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].reset(true);\n    }\n\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n  };\n  /**\r\n   * Allows the animatable to blend with current running animations\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n   * @param blendingSpeed defines the blending speed to use\r\n   */\n\n\n  Animatable.prototype.enableBlending = function (blendingSpeed) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = true;\n      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n    }\n  };\n  /**\r\n   * Disable animation blending\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n   */\n\n\n  Animatable.prototype.disableBlending = function () {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = false;\n    }\n  };\n  /**\r\n   * Jump directly to a given frame\r\n   * @param frame defines the frame to jump to\r\n   */\n\n\n  Animatable.prototype.goToFrame = function (frame) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    if (runtimeAnimations[0]) {\n      var fps = runtimeAnimations[0].animation.framePerSecond;\n      var currentFrame = runtimeAnimations[0].currentFrame;\n      var delay = this.speedRatio === 0 ? 0 : (frame - currentFrame) / fps * 1000 / this.speedRatio;\n\n      if (this._localDelayOffset === null) {\n        this._localDelayOffset = 0;\n      }\n\n      this._localDelayOffset -= delay;\n    }\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].goToFrame(frame);\n    }\n  };\n  /**\r\n   * Pause the animation\r\n   */\n\n\n  Animatable.prototype.pause = function () {\n    if (this._paused) {\n      return;\n    }\n\n    this._paused = true;\n  };\n  /**\r\n   * Restart the animation\r\n   */\n\n\n  Animatable.prototype.restart = function () {\n    this._paused = false;\n  };\n\n  Animatable.prototype._raiseOnAnimationEnd = function () {\n    if (this.onAnimationEnd) {\n      this.onAnimationEnd();\n    }\n\n    this.onAnimationEndObservable.notifyObservers(this);\n  };\n  /**\r\n   * Stop and delete the current animation\r\n   * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n   */\n\n\n  Animatable.prototype.stop = function (animationName, targetMask) {\n    if (animationName || targetMask) {\n      var idx = this._scene._activeAnimatables.indexOf(this);\n\n      if (idx > -1) {\n        var runtimeAnimations = this._runtimeAnimations;\n\n        for (var index = runtimeAnimations.length - 1; index >= 0; index--) {\n          var runtimeAnimation = runtimeAnimations[index];\n\n          if (animationName && runtimeAnimation.animation.name != animationName) {\n            continue;\n          }\n\n          if (targetMask && !targetMask(runtimeAnimation.target)) {\n            continue;\n          }\n\n          runtimeAnimation.dispose();\n          runtimeAnimations.splice(index, 1);\n        }\n\n        if (runtimeAnimations.length == 0) {\n          this._scene._activeAnimatables.splice(idx, 1);\n\n          this._raiseOnAnimationEnd();\n        }\n      }\n    } else {\n      var index = this._scene._activeAnimatables.indexOf(this);\n\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n\n        var runtimeAnimations = this._runtimeAnimations;\n\n        for (var index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n\n        this._raiseOnAnimationEnd();\n      }\n    }\n  };\n  /**\r\n   * Wait asynchronously for the animation to end\r\n   * @returns a promise which will be fullfilled when the animation ends\r\n   */\n\n\n  Animatable.prototype.waitAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.onAnimationEndObservable.add(function () {\n        resolve(_this);\n      }, undefined, undefined, _this, true);\n    });\n  };\n  /** @hidden */\n\n\n  Animatable.prototype._animate = function (delay) {\n    if (this._paused) {\n      this.animationStarted = false;\n\n      if (this._pausedDelay === null) {\n        this._pausedDelay = delay;\n      }\n\n      return true;\n    }\n\n    if (this._localDelayOffset === null) {\n      this._localDelayOffset = delay;\n      this._pausedDelay = null;\n    } else if (this._pausedDelay !== null) {\n      this._localDelayOffset += delay - this._pausedDelay;\n      this._pausedDelay = null;\n    }\n\n    if (this._weight === 0) {\n      // We consider that an animation with a weight === 0 is \"actively\" paused\n      return true;\n    } // Animating\n\n\n    var running = false;\n    var runtimeAnimations = this._runtimeAnimations;\n    var index;\n\n    for (index = 0; index < runtimeAnimations.length; index++) {\n      var animation = runtimeAnimations[index];\n      var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n      running = running || isRunning;\n    }\n\n    this.animationStarted = running;\n\n    if (!running) {\n      if (this.disposeOnEnd) {\n        // Remove from active animatables\n        index = this._scene._activeAnimatables.indexOf(this);\n\n        this._scene._activeAnimatables.splice(index, 1); // Dispose all runtime animations\n\n\n        for (index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n      }\n\n      this._raiseOnAnimationEnd();\n\n      if (this.disposeOnEnd) {\n        this.onAnimationEnd = null;\n        this.onAnimationLoop = null;\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationEndObservable.clear();\n      }\n    }\n\n    return running;\n  };\n\n  return Animatable;\n}();\n\nexport { Animatable };\n\nScene.prototype._animate = function () {\n  if (!this.animationsEnabled) {\n    return;\n  } // Getting time\n\n\n  var now = PrecisionDate.Now;\n\n  if (!this._animationTimeLast) {\n    if (this._pendingData.length > 0) {\n      return;\n    }\n\n    this._animationTimeLast = now;\n  }\n\n  this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n  this._animationTimeLast = now;\n  var animatables = this._activeAnimatables;\n\n  if (animatables.length === 0) {\n    return;\n  }\n\n  this._animationTime += this.deltaTime;\n  var animationTime = this._animationTime;\n\n  for (var index = 0; index < animatables.length; index++) {\n    var animatable = animatables[index];\n\n    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n      index--; // Array was updated\n    }\n  } // Late animation bindings\n\n\n  this._processLateAnimationBindings();\n};\n\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight, loop, speedRatio, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive) {\n  if (weight === void 0) {\n    weight = 1.0;\n  }\n\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n  returnedAnimatable.weight = weight;\n  return returnedAnimatable;\n};\n\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (stopCurrent === void 0) {\n    stopCurrent = true;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n\n  if (stopCurrent) {\n    this.stopAnimation(target, undefined, targetMask);\n  }\n\n  if (!animatable) {\n    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n  }\n\n  var shouldRunTargetAnimations = targetMask ? targetMask(target) : true; // Local animations\n\n  if (target.animations && shouldRunTargetAnimations) {\n    animatable.appendAnimations(target, target.animations);\n  } // Children animations\n\n\n  if (target.getAnimatables) {\n    var animatables = target.getAnimatables();\n\n    for (var index = 0; index < animatables.length; index++) {\n      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n    }\n  }\n\n  animatable.reset();\n  return animatable;\n};\n\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (stopCurrent === void 0) {\n    stopCurrent = true;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var children = target.getDescendants(directDescendantsOnly);\n  var result = [];\n  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n\n  for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n    var child = children_1[_i];\n    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  }\n\n  return result;\n};\n\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  if (speedRatio === undefined) {\n    speedRatio = 1.0;\n  }\n\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n\n  var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n  return animatable;\n};\n\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var children = target.getDescendants(directDescendantsOnly);\n  var result = [];\n  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n\n  for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\n    var child = children_2[_i];\n    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  }\n\n  return result;\n};\n\nScene.prototype.getAnimatableByTarget = function (target) {\n  for (var index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      return this._activeAnimatables[index];\n    }\n  }\n\n  return null;\n};\n\nScene.prototype.getAllAnimatablesByTarget = function (target) {\n  var result = [];\n\n  for (var index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      result.push(this._activeAnimatables[index]);\n    }\n  }\n\n  return result;\n};\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\n\n\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\n  var animatables = this.getAllAnimatablesByTarget(target);\n\n  for (var _i = 0, animatables_1 = animatables; _i < animatables_1.length; _i++) {\n    var animatable = animatables_1[_i];\n    animatable.stop(animationName, targetMask);\n  }\n};\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\n\n\nScene.prototype.stopAllAnimations = function () {\n  if (this._activeAnimatables) {\n    for (var i = 0; i < this._activeAnimatables.length; i++) {\n      this._activeAnimatables[i].stop();\n    }\n\n    this._activeAnimatables = [];\n  }\n\n  for (var _i = 0, _a = this.animationGroups; _i < _a.length; _i++) {\n    var group = _a[_i];\n    group.stop();\n  }\n};\n\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\n  var target = runtimeAnimation.target;\n\n  this._registeredForLateAnimationBindings.pushNoDuplicate(target);\n\n  if (!target._lateAnimationHolders) {\n    target._lateAnimationHolders = {};\n  }\n\n  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n      totalWeight: 0,\n      totalAdditiveWeight: 0,\n      animations: [],\n      additiveAnimations: [],\n      originalValue: originalValue\n    };\n  }\n\n  if (runtimeAnimation.isAdditive) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n  } else {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n  }\n};\n\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return holder.originalValue;\n  }\n\n  var normalizer = 1.0;\n  var finalPosition = TmpVectors.Vector3[0];\n  var finalScaling = TmpVectors.Vector3[1];\n  var finalQuaternion = TmpVectors.Quaternion[0];\n  var startIndex = 0;\n  var originalAnimation = holder.animations[0];\n  var originalValue = holder.originalValue;\n  var scale = 1;\n  var skipOverride = false;\n\n  if (holder.totalWeight < 1.0) {\n    // We need to mix the original value in\n    scale = 1.0 - holder.totalWeight;\n    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } else {\n    startIndex = 1; // We need to normalize the weights\n\n    normalizer = holder.totalWeight;\n    scale = originalAnimation.weight / normalizer;\n\n    if (scale == 1) {\n      if (holder.totalAdditiveWeight) {\n        skipOverride = true;\n      } else {\n        return originalAnimation.currentValue;\n      }\n    }\n\n    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } // Add up the override animations\n\n\n  if (!skipOverride) {\n    finalScaling.scaleInPlace(scale);\n    finalPosition.scaleInPlace(scale);\n    finalQuaternion.scaleInPlace(scale);\n\n    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n      var runtimeAnimation = holder.animations[animIndex];\n\n      if (runtimeAnimation.weight === 0) {\n        continue;\n      }\n\n      var scale = runtimeAnimation.weight / normalizer;\n      var currentPosition = TmpVectors.Vector3[2];\n      var currentScaling = TmpVectors.Vector3[3];\n      var currentQuaternion = TmpVectors.Quaternion[1];\n      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n      currentScaling.scaleAndAddToRef(scale, finalScaling);\n      currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\n      currentPosition.scaleAndAddToRef(scale, finalPosition);\n    }\n  } // Add up the additive animations\n\n\n  for (var animIndex_1 = 0; animIndex_1 < holder.additiveAnimations.length; animIndex_1++) {\n    var runtimeAnimation = holder.additiveAnimations[animIndex_1];\n\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n\n    var currentPosition = TmpVectors.Vector3[2];\n    var currentScaling = TmpVectors.Vector3[3];\n    var currentQuaternion = TmpVectors.Quaternion[1];\n    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n    currentScaling.multiplyToRef(finalScaling, currentScaling);\n    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n  }\n\n  var workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n  return workValue;\n};\n\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return refQuaternion;\n  }\n\n  var originalAnimation = holder.animations[0];\n  var originalValue = holder.originalValue;\n  var cumulativeQuaternion = refQuaternion;\n\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n    cumulativeQuaternion.copyFrom(originalValue);\n  } else if (holder.animations.length === 1) {\n    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n\n    if (holder.totalAdditiveWeight === 0) {\n      return cumulativeQuaternion;\n    }\n  } else if (holder.animations.length > 1) {\n    // Add up the override animations\n    var normalizer = 1.0;\n    var quaternions = void 0;\n    var weights = void 0;\n\n    if (holder.totalWeight < 1.0) {\n      var scale = 1.0 - holder.totalWeight;\n      quaternions = [];\n      weights = [];\n      quaternions.push(originalValue);\n      weights.push(scale);\n    } else {\n      if (holder.animations.length === 2) {\n        // Slerp as soon as we can\n        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n\n        if (holder.totalAdditiveWeight === 0) {\n          return refQuaternion;\n        }\n      }\n\n      quaternions = [];\n      weights = [];\n      normalizer = holder.totalWeight;\n    }\n\n    for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n      var runtimeAnimation = holder.animations[animIndex];\n      quaternions.push(runtimeAnimation.currentValue);\n      weights.push(runtimeAnimation.weight / normalizer);\n    } // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n\n\n    var cumulativeAmount = 0;\n\n    for (var index = 0; index < quaternions.length;) {\n      if (!index) {\n        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n        cumulativeQuaternion = refQuaternion;\n        cumulativeAmount = weights[index] + weights[index + 1];\n        index += 2;\n        continue;\n      }\n\n      cumulativeAmount += weights[index];\n      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n      index++;\n    }\n  } // Add up the additive animations\n\n\n  for (var animIndex_2 = 0; animIndex_2 < holder.additiveAnimations.length; animIndex_2++) {\n    var runtimeAnimation = holder.additiveAnimations[animIndex_2];\n\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n\n    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n  }\n\n  return cumulativeQuaternion;\n};\n\nScene.prototype._processLateAnimationBindings = function () {\n  if (!this._registeredForLateAnimationBindings.length) {\n    return;\n  }\n\n  for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\n    var target = this._registeredForLateAnimationBindings.data[index];\n\n    for (var path in target._lateAnimationHolders) {\n      var holder = target._lateAnimationHolders[path];\n      var originalAnimation = holder.animations[0];\n      var originalValue = holder.originalValue;\n      var matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n\n      var finalValue = target[path];\n\n      if (matrixDecomposeMode) {\n        finalValue = this._processLateAnimationBindingsForMatrices(holder);\n      } else {\n        var quaternionMode = originalValue.w !== undefined;\n\n        if (quaternionMode) {\n          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n        } else {\n          var startIndex = 0;\n          var normalizer = 1.0;\n\n          if (holder.totalWeight < 1.0) {\n            // We need to mix the original value in\n            if (originalAnimation && originalValue.scale) {\n              finalValue = originalValue.scale(1.0 - holder.totalWeight);\n            } else if (originalAnimation) {\n              finalValue = originalValue * (1.0 - holder.totalWeight);\n            } else if (originalValue.clone) {\n              finalValue = originalValue.clone();\n            } else {\n              finalValue = originalValue;\n            }\n          } else if (originalAnimation) {\n            // We need to normalize the weights\n            normalizer = holder.totalWeight;\n            var scale_1 = originalAnimation.weight / normalizer;\n\n            if (scale_1 !== 1) {\n              if (originalAnimation.currentValue.scale) {\n                finalValue = originalAnimation.currentValue.scale(scale_1);\n              } else {\n                finalValue = originalAnimation.currentValue * scale_1;\n              }\n            } else {\n              finalValue = originalAnimation.currentValue;\n            }\n\n            startIndex = 1;\n          } // Add up the override animations\n\n\n          for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            var runtimeAnimation = holder.animations[animIndex];\n            var scale = runtimeAnimation.weight / normalizer;\n\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          } // Add up the additive animations\n\n\n          for (var animIndex_3 = 0; animIndex_3 < holder.additiveAnimations.length; animIndex_3++) {\n            var runtimeAnimation = holder.additiveAnimations[animIndex_3];\n            var scale = runtimeAnimation.weight;\n\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n        }\n      }\n\n      target[path] = finalValue;\n    }\n\n    target._lateAnimationHolders = {};\n  }\n\n  this._registeredForLateAnimationBindings.reset();\n};\n\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {\n  if (rescaleAsRequired === void 0) {\n    rescaleAsRequired = false;\n  }\n\n  if (skelDimensionsRatio === void 0) {\n    skelDimensionsRatio = null;\n  } // all animation may be coming from a library skeleton, so may need to create animation\n\n\n  if (this.animations.length === 0) {\n    this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n    this.animations[0].setKeys([]);\n  } // get animation info / verify there is such a range from the source bone\n\n\n  var sourceRange = source.animations[0].getRange(rangeName);\n\n  if (!sourceRange) {\n    return false;\n  }\n\n  var from = sourceRange.from;\n  var to = sourceRange.to;\n  var sourceKeys = source.animations[0].getKeys(); // rescaling prep\n\n  var sourceBoneLength = source.length;\n  var sourceParent = source.getParent();\n  var parent = this.getParent();\n  var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n  var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n  var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n  var destKeys = this.animations[0].getKeys(); // loop vars declaration\n\n  var orig;\n  var origTranslation;\n  var mat;\n\n  for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n    orig = sourceKeys[key];\n\n    if (orig.frame >= from && orig.frame <= to) {\n      if (rescaleAsRequired) {\n        mat = orig.value.clone(); // scale based on parent ratio, when bone has parent\n\n        if (parentScalingReqd) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.scaleInPlace(parentRatio)); // scale based on skeleton dimension ratio when root bone, and value is passed\n        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio)); // use original when root bone, and no data for skelDimensionsRatio\n        } else {\n          mat = orig.value;\n        }\n      } else {\n        mat = orig.value;\n      }\n\n      destKeys.push({\n        frame: orig.frame + frameOffset,\n        value: mat\n      });\n    }\n  }\n\n  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n  return true;\n};","map":null,"metadata":{},"sourceType":"module"}