{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { SerializationHelper } from \"../../Misc/decorators\";\nimport { EnvironmentTextureTools } from \"../../Misc/environmentTextureTools\";\nimport { InternalTextureSource } from \"./internalTexture\";\nimport { CubeTexture } from \"./cubeTexture\";\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * Raw cube texture where the raw buffers are passed in\r\n */\n\nvar RawCubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(RawCubeTexture, _super);\n  /**\r\n   * Creates a cube texture where the raw buffers are passed in.\r\n   * @param scene defines the scene the texture is attached to\r\n   * @param data defines the array of data to use to create each face\r\n   * @param size defines the size of the textures\r\n   * @param format defines the format of the data\r\n   * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n   * @param generateMipMaps  defines if the engine should generate the mip levels\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n   * @param compression defines the compression used (null by default)\r\n   */\n\n\n  function RawCubeTexture(scene, data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    var _this = _super.call(this, \"\", scene) || this;\n\n    _this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\n    return _this;\n  }\n  /**\r\n   * Updates the raw cube texture.\r\n   * @param data defines the data to store\r\n   * @param format defines the data format\r\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param compression defines the compression used (null by default)\r\n   * @param level defines which level of the texture to update\r\n   */\n\n\n  RawCubeTexture.prototype.update = function (data, format, type, invertY, compression) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);\n  };\n  /**\r\n   * Updates a raw cube texture with RGBD encoded data.\r\n   * @param data defines the array of data [mipmap][face] to use to create each face\r\n   * @param sphericalPolynomial defines the spherical polynomial for irradiance\r\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n   * @returns a promsie that resolves when the operation is complete\r\n   */\n\n\n  RawCubeTexture.prototype.updateRGBDAsync = function (data, sphericalPolynomial, lodScale, lodOffset) {\n    if (sphericalPolynomial === void 0) {\n      sphericalPolynomial = null;\n    }\n\n    if (lodScale === void 0) {\n      lodScale = 0.8;\n    }\n\n    if (lodOffset === void 0) {\n      lodOffset = 0;\n    }\n\n    return RawCubeTexture._UpdateRGBDAsync(this._texture, data, sphericalPolynomial, lodScale, lodOffset);\n  };\n  /**\r\n   * Clones the raw cube texture.\r\n   * @return a new cube texture\r\n   */\n\n\n  RawCubeTexture.prototype.clone = function () {\n    var _this = this;\n\n    return SerializationHelper.Clone(function () {\n      var scene = _this.getScene();\n\n      var internalTexture = _this._texture;\n      var texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n\n      if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\n        texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\n      }\n\n      return texture;\n    }, this);\n  };\n  /** @hidden */\n\n\n  RawCubeTexture._UpdateRGBDAsync = function (internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\n    internalTexture._bufferViewArrayArray = data;\n    internalTexture._lodGenerationScale = lodScale;\n    internalTexture._lodGenerationOffset = lodOffset;\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\n    return EnvironmentTextureTools.UploadLevelsAsync(internalTexture, data).then(function () {\n      internalTexture.isReady = true;\n    });\n  };\n\n  return RawCubeTexture;\n}(CubeTexture);\n\nexport { RawCubeTexture };","map":null,"metadata":{},"sourceType":"module"}