{"ast":null,"code":"import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { RibbonBuilder } from \"./ribbonBuilder\";\nimport { Path3D } from '../../Maths/math.path';\n\nMesh.CreateTube = function (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {\n  var options = {\n    path: path,\n    radius: radius,\n    tessellation: tessellation,\n    radiusFunction: radiusFunction,\n    arc: 1,\n    cap: cap,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    instance: instance\n  };\n  return TubeBuilder.CreateTube(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar TubeBuilder =\n/** @class */\nfunction () {\n  function TubeBuilder() {}\n  /**\r\n   * Creates a tube mesh.\r\n   * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n   * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n   * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n   * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n   * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`\r\n   * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n   * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n   * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n   * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the tube mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#tube\r\n   */\n\n\n  TubeBuilder.CreateTube = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var path = options.path;\n    var instance = options.instance;\n    var radius = 1.0;\n\n    if (options.radius !== undefined) {\n      radius = options.radius;\n    } else if (instance) {\n      radius = instance._creationDataStorage.radius;\n    }\n\n    var tessellation = options.tessellation || 64 | 0;\n    var radiusFunction = options.radiusFunction || null;\n    var cap = options.cap || Mesh.NO_CAP;\n    var invertUV = options.invertUV || false;\n    var updatable = options.updatable;\n\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0; // tube geometry\n\n    var tubePathArray = function tubePathArray(path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) {\n      var tangents = path3D.getTangents();\n      var normals = path3D.getNormals();\n      var distances = path3D.getDistances();\n      var pi2 = Math.PI * 2;\n      var step = pi2 / tessellation * arc;\n\n      var returnRadius = function returnRadius() {\n        return radius;\n      };\n\n      var radiusFunctionFinal = radiusFunction || returnRadius;\n      var circlePath;\n      var rad;\n      var normal;\n      var rotated;\n      var rotationMatrix = TmpVectors.Matrix[0];\n      var index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n\n      for (var i = 0; i < path.length; i++) {\n        rad = radiusFunctionFinal(i, distances[i]); // current radius\n\n        circlePath = Array(); // current circle array\n\n        normal = normals[i]; // current normal\n\n        for (var t = 0; t < tessellation; t++) {\n          Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\n          rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\n          Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\n          rotated.scaleInPlace(rad).addInPlace(path[i]);\n          circlePath[t] = rotated;\n        }\n\n        circlePaths[index] = circlePath;\n        index++;\n      } // cap\n\n\n      var capPath = function capPath(nbPoints, pathIndex) {\n        var pointCap = Array();\n\n        for (var i = 0; i < nbPoints; i++) {\n          pointCap.push(path[pathIndex]);\n        }\n\n        return pointCap;\n      };\n\n      switch (cap) {\n        case Mesh.NO_CAP:\n          break;\n\n        case Mesh.CAP_START:\n          circlePaths[0] = capPath(tessellation, 0);\n          circlePaths[1] = circlePaths[2].slice(0);\n          break;\n\n        case Mesh.CAP_END:\n          circlePaths[index] = circlePaths[index - 1].slice(0);\n          circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n          break;\n\n        case Mesh.CAP_ALL:\n          circlePaths[0] = capPath(tessellation, 0);\n          circlePaths[1] = circlePaths[2].slice(0);\n          circlePaths[index] = circlePaths[index - 1].slice(0);\n          circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n          break;\n\n        default:\n          break;\n      }\n\n      return circlePaths;\n    };\n\n    var path3D;\n    var pathArray;\n\n    if (instance) {\n      // tube update\n      var storage = instance._creationDataStorage;\n      var arc = options.arc || storage.arc;\n      path3D = storage.path3D.update(path);\n      pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\n      instance = RibbonBuilder.CreateRibbon(\"\", {\n        pathArray: pathArray,\n        instance: instance\n      }); // Update mode, no need to recreate the storage.\n\n      storage.path3D = path3D;\n      storage.pathArray = pathArray;\n      storage.arc = arc;\n      storage.radius = radius;\n      return instance;\n    } // tube creation\n\n\n    path3D = new Path3D(path);\n    var newPathArray = new Array();\n    cap = cap < 0 || cap > 3 ? 0 : cap;\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\n    var tube = RibbonBuilder.CreateRibbon(name, {\n      pathArray: pathArray,\n      closePath: true,\n      closeArray: false,\n      updatable: updatable,\n      sideOrientation: sideOrientation,\n      invertUV: invertUV,\n      frontUVs: options.frontUVs,\n      backUVs: options.backUVs\n    }, scene);\n    tube._creationDataStorage.pathArray = pathArray;\n    tube._creationDataStorage.path3D = path3D;\n    tube._creationDataStorage.tessellation = tessellation;\n    tube._creationDataStorage.cap = cap;\n    tube._creationDataStorage.arc = options.arc;\n    tube._creationDataStorage.radius = radius;\n    return tube;\n  };\n\n  return TubeBuilder;\n}();\n\nexport { TubeBuilder };","map":null,"metadata":{},"sourceType":"module"}