{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\nimport { SphereBuilder } from \"../../Meshes/Builders/sphereBuilder\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\nimport { Logger } from \"../../Misc/logger\";\n/**\r\n * Options for the controller physics feature\r\n */\n\nvar IWebXRControllerPhysicsOptions =\n/** @class */\nfunction () {\n  function IWebXRControllerPhysicsOptions() {}\n\n  return IWebXRControllerPhysicsOptions;\n}();\n\nexport { IWebXRControllerPhysicsOptions };\n/**\r\n * Add physics impostor to your webxr controllers,\r\n * including naive calculation of their linear and angular velocity\r\n */\n\nvar WebXRControllerPhysics =\n/** @class */\nfunction (_super) {\n  __extends(WebXRControllerPhysics, _super);\n  /**\r\n   * Construct a new Controller Physics Feature\r\n   * @param _xrSessionManager the corresponding xr session manager\r\n   * @param _options options to create this feature with\r\n   */\n\n\n  function WebXRControllerPhysics(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      if (!_this._xrSessionManager.scene.isPhysicsEnabled()) {\n        Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\n      } // if no motion controller available, create impostors!\n\n\n      if (_this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {\n        xrController.onMotionControllerInitObservable.addOnce(function (motionController) {\n          motionController.onModelLoadedObservable.addOnce(function () {\n            var impostor = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, __assign({\n              mass: 0\n            }, _this._options.physicsProperties));\n            var controllerMesh = xrController.grip || xrController.pointer;\n            _this._controllers[xrController.uniqueId] = {\n              xrController: xrController,\n              impostor: impostor,\n              oldPos: controllerMesh.position.clone(),\n              oldRotation: controllerMesh.rotationQuaternion.clone()\n            };\n          });\n        });\n      } else {\n        var impostorType = _this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;\n        var impostorSize = _this._options.physicsProperties.impostorSize || 0.1;\n        var impostorMesh = SphereBuilder.CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\n          diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n          diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n          diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n        });\n        impostorMesh.isVisible = _this._debugMode;\n        impostorMesh.isPickable = false;\n        impostorMesh.rotationQuaternion = new Quaternion();\n        var controllerMesh = xrController.grip || xrController.pointer;\n        impostorMesh.position.copyFrom(controllerMesh.position);\n        impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n        var impostor = new PhysicsImpostor(impostorMesh, impostorType, __assign({\n          mass: 0\n        }, _this._options.physicsProperties));\n        _this._controllers[xrController.uniqueId] = {\n          xrController: xrController,\n          impostor: impostor,\n          impostorMesh: impostorMesh\n        };\n      }\n    };\n\n    _this._controllers = {};\n    _this._debugMode = false;\n    _this._delta = 0;\n    _this._lastTimestamp = 0;\n    _this._tmpQuaternion = new Quaternion();\n    _this._tmpVector = new Vector3();\n\n    if (!_this._options.physicsProperties) {\n      _this._options.physicsProperties = {};\n    }\n\n    return _this;\n  }\n  /**\r\n   * @hidden\r\n   * enable debugging - will show console outputs and the impostor mesh\r\n   */\n\n\n  WebXRControllerPhysics.prototype._enablePhysicsDebug = function () {\n    var _this = this;\n\n    this._debugMode = true;\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      var controllerData = _this._controllers[controllerId];\n\n      if (controllerData.impostorMesh) {\n        controllerData.impostorMesh.isVisible = true;\n      }\n    });\n  };\n  /**\r\n   * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\r\n   * @param xrController the controller to add\r\n   */\n\n\n  WebXRControllerPhysics.prototype.addController = function (xrController) {\n    this._attachController(xrController);\n  };\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRControllerPhysics.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    if (!this._options.xrInput) {\n      return true;\n    }\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    if (this._options.enableHeadsetImpostor) {\n      var params = this._options.headsetImpostorParams || {\n        impostorType: PhysicsImpostor.SphereImpostor,\n        restitution: 0.8,\n        impostorSize: 0.3\n      };\n      var impostorSize = params.impostorSize || 0.3;\n      this._headsetMesh = SphereBuilder.CreateSphere(\"headset-mesh\", {\n        diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n        diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n        diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n      });\n      this._headsetMesh.rotationQuaternion = new Quaternion();\n      this._headsetMesh.isVisible = false;\n      this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, __assign({\n        mass: 0\n      }, params));\n    }\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRControllerPhysics.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n\n    if (this._headsetMesh) {\n      this._headsetMesh.dispose();\n    }\n\n    return true;\n  };\n  /**\r\n   * Get the headset impostor, if enabled\r\n   * @returns the impostor\r\n   */\n\n\n  WebXRControllerPhysics.prototype.getHeadsetImpostor = function () {\n    return this._headsetImpostor;\n  };\n  /**\r\n   * Get the physics impostor of a specific controller.\r\n   * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\r\n   * @param controller the controller or the controller id of which to get the impostor\r\n   * @returns the impostor or null\r\n   */\n\n\n  WebXRControllerPhysics.prototype.getImpostorForController = function (controller) {\n    var id = typeof controller === \"string\" ? controller : controller.uniqueId;\n\n    if (this._controllers[id]) {\n      return this._controllers[id].impostor;\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * Update the physics properties provided in the constructor\r\n   * @param newProperties the new properties object\r\n   */\n\n\n  WebXRControllerPhysics.prototype.setPhysicsProperties = function (newProperties) {\n    this._options.physicsProperties = __assign(__assign({}, this._options.physicsProperties), newProperties);\n  };\n\n  WebXRControllerPhysics.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\n    this._lastTimestamp = this._xrSessionManager.currentTimestamp;\n\n    if (this._headsetMesh) {\n      this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.position);\n\n      this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      var controllerData = _this._controllers[controllerId];\n      var controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\n      var comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;\n      var comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;\n      controllerMesh.position.subtractToRef(comparedPosition, _this._tmpVector);\n\n      _this._tmpVector.scaleInPlace(1000 / _this._delta);\n\n      controllerData.impostor.setLinearVelocity(_this._tmpVector);\n\n      if (_this._debugMode) {\n        console.log(_this._tmpVector, \"linear\");\n      }\n\n      if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {\n        // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\n        comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, _this._tmpQuaternion);\n        var len = Math.sqrt(_this._tmpQuaternion.x * _this._tmpQuaternion.x + _this._tmpQuaternion.y * _this._tmpQuaternion.y + _this._tmpQuaternion.z * _this._tmpQuaternion.z);\n\n        _this._tmpVector.set(_this._tmpQuaternion.x, _this._tmpQuaternion.y, _this._tmpQuaternion.z); // define a better epsilon\n\n\n        if (len < 0.001) {\n          _this._tmpVector.scaleInPlace(2);\n        } else {\n          var angle = 2 * Math.atan2(len, _this._tmpQuaternion.w);\n\n          _this._tmpVector.scaleInPlace(angle / (len * (_this._delta / 1000)));\n        }\n\n        controllerData.impostor.setAngularVelocity(_this._tmpVector);\n\n        if (_this._debugMode) {\n          console.log(_this._tmpVector, _this._tmpQuaternion, \"angular\");\n        }\n      }\n\n      comparedPosition.copyFrom(controllerMesh.position);\n      comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n    });\n  };\n\n  WebXRControllerPhysics.prototype._detachController = function (xrControllerUniqueId) {\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.impostorMesh) {\n      controllerData.impostorMesh.dispose();\n    } // remove from the map\n\n\n    delete this._controllers[xrControllerUniqueId];\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRControllerPhysics.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the webxr specs version\r\n   */\n\n  WebXRControllerPhysics.Version = 1;\n  return WebXRControllerPhysics;\n}(WebXRAbstractFeature);\n\nexport { WebXRControllerPhysics }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRControllerPhysics(xrSessionManager, options);\n  };\n}, WebXRControllerPhysics.Version, true);","map":null,"metadata":{},"sourceType":"module"}