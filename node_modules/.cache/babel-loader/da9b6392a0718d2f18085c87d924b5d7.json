{"ast":null,"code":"\"use strict\";\n/*\n  This file is part of web3x.\n\n  web3x is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  web3x is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with web3x.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar _classCallCheck = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"util\");\n\nvar abi_coder_1 = require(\"../../ethers/abi-coder\");\n\nvar utils_1 = require(\"../../utils\");\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\n\n\nvar ABICoder = /*#__PURE__*/function () {\n  function ABICoder() {\n    _classCallCheck(this, ABICoder);\n\n    this.ethersAbiCoder = new abi_coder_1.AbiCoder(function (type, value) {\n      if (type.match(/^u?int/) && !util_1.isArray(value) && (!util_1.isObject(value) || value.constructor.name !== 'BN')) {\n        return value.toString();\n      }\n\n      return value;\n    });\n  }\n  /**\n   * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n   *\n   * @method encodeFunctionSignature\n   * @param {String|Object} functionName\n   * @return {String} encoded function name\n   */\n\n\n  _createClass(ABICoder, [{\n    key: \"encodeFunctionSignature\",\n    value: function encodeFunctionSignature(functionName) {\n      if (util_1.isObject(functionName)) {\n        functionName = this.abiMethodToString(functionName);\n      }\n\n      return utils_1.sha3(functionName).slice(0, 10);\n    }\n    /**\n     * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n     *\n     * @method encodeEventSignature\n     * @param {String|Object} functionName\n     * @return {String} encoded function name\n     */\n\n  }, {\n    key: \"encodeEventSignature\",\n    value: function encodeEventSignature(functionName) {\n      if (util_1.isObject(functionName)) {\n        functionName = this.abiMethodToString(functionName);\n      }\n\n      return utils_1.sha3(functionName);\n    }\n    /**\n     * Should be used to encode plain param\n     *\n     * @method encodeParameter\n     * @param {String} type\n     * @param {Object} param\n     * @return {String} encoded plain param\n     */\n\n  }, {\n    key: \"encodeParameter\",\n    value: function encodeParameter(type, param) {\n      return this.encodeParameters([type], [param]);\n    }\n    /**\n     * Should be used to encode list of params\n     *\n     * @method encodeParameters\n     * @param {Array} types\n     * @param {Array} params\n     * @return {String} encoded list of params\n     */\n\n  }, {\n    key: \"encodeParameters\",\n    value: function encodeParameters(types, params) {\n      return this.ethersAbiCoder.encode(this.mapTypes(types), params);\n    }\n    /**\n     * Encodes a function call from its json interface and parameters.\n     *\n     * @method encodeFunctionCall\n     * @param {Array} jsonInterface\n     * @param {Array} params\n     * @return {String} The encoded ABI for this function call\n     */\n\n  }, {\n    key: \"encodeFunctionCall\",\n    value: function encodeFunctionCall(jsonInterface, params) {\n      return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n    }\n    /**\n     * Should be used to decode bytes to plain param\n     *\n     * @method decodeParameter\n     * @param {String} type\n     * @param {String} bytes\n     * @return {Object} plain param\n     */\n\n  }, {\n    key: \"decodeParameter\",\n    value: function decodeParameter(type, bytes) {\n      return this.decodeParameters([type], bytes)[0];\n    }\n    /**\n     * Should be used to decode list of params\n     *\n     * @method decodeParameter\n     * @param {Array} outputs\n     * @param {String} bytes\n     * @return {Array} array of plain params\n     */\n\n  }, {\n    key: \"decodeParameters\",\n    value: function decodeParameters(outputs, bytes) {\n      if (!bytes || bytes === '0x' || bytes === '0X') {\n        throw new Error(\"Returned values aren't valid, did it run Out of Gas?\");\n      }\n\n      var res = this.ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n      var returnValue = {};\n      returnValue.__length__ = 0;\n      outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = decodedValue === '0x' ? null : decodedValue;\n        returnValue[i] = decodedValue;\n\n        if (util_1.isObject(output) && output.name) {\n          returnValue[output.name] = decodedValue;\n        }\n\n        returnValue.__length__++;\n      });\n      return returnValue;\n    }\n    /**\n     * Decodes events non- and indexed parameters.\n     *\n     * @method decodeLog\n     * @param {Object} inputs\n     * @param {String} data\n     * @param {Array} topics\n     * @return {Array} array of plain params\n     */\n\n  }, {\n    key: \"decodeLog\",\n    value: function decodeLog(inputs, data, topics) {\n      var _this = this;\n\n      topics = util_1.isArray(topics) ? topics : [topics];\n      data = data || '';\n      var notIndexedInputs = [];\n      var indexedParams = [];\n      var topicCount = 0; // TODO check for anonymous logs?\n\n      inputs.forEach(function (input, i) {\n        if (input.indexed) {\n          indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].some(function (t) {\n            return input.type.includes(t);\n          }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n          topicCount++;\n        } else {\n          notIndexedInputs[i] = input;\n        }\n      });\n      var nonIndexedData = data;\n      var notIndexedParams = nonIndexedData && nonIndexedData !== '0x' ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n      var returnValue = {};\n      returnValue.__length__ = 0;\n      inputs.forEach(function (res, i) {\n        returnValue[i] = res.type === 'string' ? '' : null;\n\n        if (typeof notIndexedParams[i] !== 'undefined') {\n          returnValue[i] = notIndexedParams[i];\n        }\n\n        if (typeof indexedParams[i] !== 'undefined') {\n          returnValue[i] = indexedParams[i];\n        }\n\n        if (res.name) {\n          returnValue[res.name] = returnValue[i];\n        }\n\n        returnValue.__length__++;\n      });\n      return returnValue;\n    }\n    /**\n     * Map types if simplified format is used\n     *\n     * @method mapTypes\n     * @param {Array} types\n     * @return {Array}\n     */\n\n  }, {\n    key: \"mapTypes\",\n    value: function mapTypes(types) {\n      var _this2 = this;\n\n      var mappedTypes = [];\n      types.forEach(function (type) {\n        if (_this2.isSimplifiedStructFormat(type)) {\n          var structName = Object.keys(type)[0];\n          mappedTypes.push(Object.assign(_this2.mapStructNameAndType(structName), {\n            components: _this2.mapStructToCoderFormat(type[structName])\n          }));\n          return;\n        }\n\n        mappedTypes.push(type);\n      });\n      return mappedTypes;\n    }\n    /**\n     * Check if type is simplified struct format\n     *\n     * @method isSimplifiedStructFormat\n     * @param {string | Object} type\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSimplifiedStructFormat\",\n    value: function isSimplifiedStructFormat(type) {\n      return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n    }\n    /**\n     * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n     *\n     * @method mapStructNameAndType\n     * @param {string} structName\n     * @return {{type: string, name: *}}\n     */\n\n  }, {\n    key: \"mapStructNameAndType\",\n    value: function mapStructNameAndType(structName) {\n      var type = 'tuple';\n\n      if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n      }\n\n      return {\n        type: type,\n        name: structName\n      };\n    }\n    /**\n     * Maps the simplified format in to the expected format of the ABICoder\n     *\n     * @method mapStructToCoderFormat\n     * @param {Object} struct\n     * @return {Array}\n     */\n\n  }, {\n    key: \"mapStructToCoderFormat\",\n    value: function mapStructToCoderFormat(struct) {\n      var _this3 = this;\n\n      var components = [];\n      Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n          components.push(Object.assign(_this3.mapStructNameAndType(key), {\n            components: _this3.mapStructToCoderFormat(struct[key])\n          }));\n          return;\n        }\n\n        components.push({\n          name: key,\n          type: struct[key]\n        });\n      });\n      return components;\n    }\n    /**\n     * Should be used to create full function/event name from json abi\n     *\n     * @method jsonInterfaceMethodToString\n     * @param {Object} json\n     * @return {String} full function/event name\n     */\n\n  }, {\n    key: \"abiMethodToString\",\n    value: function abiMethodToString(json) {\n      if (util_1.isObject(json) && json.name && json.name.indexOf('(') !== -1) {\n        return json.name;\n      }\n\n      return json.name + '(' + flattenTypes(false, json.inputs).join(',') + ')';\n    }\n  }]);\n\n  return ABICoder;\n}();\n\nexports.ABICoder = ABICoder;\n/**\n * Should be used to flatten json abi inputs/outputs into an array of type-representing-strings\n *\n * @method flattenTypes\n * @param {bool} includeTuple\n * @param {Object} puts\n * @return {Array} parameters as strings\n */\n\nfunction flattenTypes(includeTuple, puts) {\n  // console.log(\"entered _flattenTypes. inputs/outputs: \" + puts)\n  var types = [];\n  puts.forEach(function (param) {\n    if (typeof param.components === 'object') {\n      if (param.type.substring(0, 5) !== 'tuple') {\n        throw new Error('components found but type is not tuple; report on GitHub');\n      }\n\n      var suffix = '';\n      var arrayBracket = param.type.indexOf('[');\n\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n\n      var result = flattenTypes(includeTuple, param.components); // console.log(\"result should have things: \" + result)\n\n      if (util_1.isArray(result) && includeTuple) {\n        // console.log(\"include tuple word, and its an array. joining...: \" + result.types)\n        types.push('tuple(' + result.join(',') + ')' + suffix);\n      } else if (!includeTuple) {\n        // console.log(\"don't include tuple, but its an array. joining...: \" + result)\n        types.push('(' + result.join(',') + ')' + suffix);\n      } else {\n        // console.log(\"its a single type within a tuple: \" + result.types)\n        types.push('(' + result + ')');\n      }\n    } else {\n      // console.log(\"its a type and not directly in a tuple: \" + param.type)\n      types.push(param.type);\n    }\n  });\n  return types;\n}\n\nexports.abiCoder = new ABICoder();","map":null,"metadata":{},"sourceType":"script"}