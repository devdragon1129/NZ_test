{"ast":null,"code":"import { Color3 } from '../Maths/math.color';\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { ParticleSystem } from \"../Particles/particleSystem\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\n/** Internal class used to store shapes for emitters */\n\nvar ParticleSystemSetEmitterCreationOptions =\n/** @class */\nfunction () {\n  function ParticleSystemSetEmitterCreationOptions() {}\n\n  return ParticleSystemSetEmitterCreationOptions;\n}();\n/**\r\n * Represents a set of particle systems working together to create a specific effect\r\n */\n\n\nvar ParticleSystemSet =\n/** @class */\nfunction () {\n  function ParticleSystemSet() {\n    /**\r\n     * Gets the particle system list\r\n     */\n    this.systems = new Array();\n  }\n\n  Object.defineProperty(ParticleSystemSet.prototype, \"emitterNode\", {\n    /**\r\n     * Gets the emitter node used with this set\r\n     */\n    get: function get() {\n      return this._emitterNode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a new emitter mesh as a sphere\r\n   * @param options defines the options used to create the sphere\r\n   * @param renderingGroupId defines the renderingGroupId to use for the sphere\r\n   * @param scene defines the hosting scene\r\n   */\n\n  ParticleSystemSet.prototype.setEmitterAsSphere = function (options, renderingGroupId, scene) {\n    if (this._emitterNode) {\n      this._emitterNode.dispose();\n    }\n\n    this._emitterCreationOptions = {\n      kind: \"Sphere\",\n      options: options,\n      renderingGroupId: renderingGroupId\n    };\n    var emitterMesh = SphereBuilder.CreateSphere(\"emitterSphere\", {\n      diameter: options.diameter,\n      segments: options.segments\n    }, scene);\n    emitterMesh.renderingGroupId = renderingGroupId;\n    var material = new StandardMaterial(\"emitterSphereMaterial\", scene);\n    material.emissiveColor = options.color;\n    emitterMesh.material = material;\n\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      system.emitter = emitterMesh;\n    }\n\n    this._emitterNode = emitterMesh;\n  };\n  /**\r\n   * Starts all particle systems of the set\r\n   * @param emitter defines an optional mesh to use as emitter for the particle systems\r\n   */\n\n\n  ParticleSystemSet.prototype.start = function (emitter) {\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n\n      if (emitter) {\n        system.emitter = emitter;\n      }\n\n      system.start();\n    }\n  };\n  /**\r\n   * Release all associated resources\r\n   */\n\n\n  ParticleSystemSet.prototype.dispose = function () {\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      system.dispose();\n    }\n\n    this.systems = [];\n\n    if (this._emitterNode) {\n      this._emitterNode.dispose();\n\n      this._emitterNode = null;\n    }\n  };\n  /**\r\n   * Serialize the set into a JSON compatible object\r\n   * @param serializeTexture defines if the texture must be serialized as well\r\n   * @returns a JSON compatible representation of the set\r\n   */\n\n\n  ParticleSystemSet.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var result = {};\n    result.systems = [];\n\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      result.systems.push(system.serialize(serializeTexture));\n    }\n\n    if (this._emitterNode) {\n      result.emitter = this._emitterCreationOptions;\n    }\n\n    return result;\n  };\n  /**\r\n   * Parse a new ParticleSystemSet from a serialized source\r\n   * @param data defines a JSON compatible representation of the set\r\n   * @param scene defines the hosting scene\r\n   * @param gpu defines if we want GPU particles or CPU particles\r\n   * @returns a new ParticleSystemSet\r\n   */\n\n\n  ParticleSystemSet.Parse = function (data, scene, gpu) {\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    var result = new ParticleSystemSet();\n    var rootUrl = this.BaseAssetsUrl + \"/textures/\";\n    scene = scene || EngineStore.LastCreatedScene;\n\n    for (var _i = 0, _a = data.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true) : ParticleSystem.Parse(system, scene, rootUrl, true));\n    }\n\n    if (data.emitter) {\n      var options = data.emitter.options;\n\n      switch (data.emitter.kind) {\n        case \"Sphere\":\n          result.setEmitterAsSphere({\n            diameter: options.diameter,\n            segments: options.segments,\n            color: Color3.FromArray(options.color)\n          }, data.emitter.renderingGroupId, scene);\n          break;\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Gets or sets base Assets URL\r\n   */\n\n\n  ParticleSystemSet.BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\n  return ParticleSystemSet;\n}();\n\nexport { ParticleSystemSet };","map":null,"metadata":{},"sourceType":"module"}