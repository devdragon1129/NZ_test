{"ast":null,"code":"import { PointerDragBehavior } from \"./pointerDragBehavior\";\nimport { Vector3 } from \"../../Maths/math.vector\";\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be scaled\r\n */\n\nvar MultiPointerScaleBehavior =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\r\n   */\n  function MultiPointerScaleBehavior() {\n    this._startDistance = 0;\n    this._initialScale = new Vector3(0, 0, 0);\n    this._targetScale = new Vector3(0, 0, 0);\n    this._sceneRenderObserver = null;\n    this._dragBehaviorA = new PointerDragBehavior({});\n    this._dragBehaviorA.moveAttached = false;\n    this._dragBehaviorB = new PointerDragBehavior({});\n    this._dragBehaviorB.moveAttached = false;\n  }\n\n  Object.defineProperty(MultiPointerScaleBehavior.prototype, \"name\", {\n    /**\r\n     *  The name of the behavior\r\n     */\n    get: function get() {\n      return \"MultiPointerScale\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   *  Initializes the behavior\r\n   */\n\n  MultiPointerScaleBehavior.prototype.init = function () {};\n\n  MultiPointerScaleBehavior.prototype._getCurrentDistance = function () {\n    return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\n  };\n  /**\r\n   * Attaches the scale behavior the passed in mesh\r\n   * @param ownerNode The mesh that will be scaled around once attached\r\n   */\n\n\n  MultiPointerScaleBehavior.prototype.attach = function (ownerNode) {\n    var _this = this;\n\n    this._ownerNode = ownerNode; // Create 2 drag behaviors such that each will only be triggered by a separate pointer\n\n    this._dragBehaviorA.onDragStartObservable.add(function (e) {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        if (_this._dragBehaviorA.currentDraggingPointerID == _this._dragBehaviorB.currentDraggingPointerID) {\n          _this._dragBehaviorA.releaseDrag();\n        } else {\n          _this._initialScale.copyFrom(ownerNode.scaling);\n\n          _this._startDistance = _this._getCurrentDistance();\n        }\n      }\n    });\n\n    this._dragBehaviorB.onDragStartObservable.add(function (e) {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        if (_this._dragBehaviorA.currentDraggingPointerID == _this._dragBehaviorB.currentDraggingPointerID) {\n          _this._dragBehaviorB.releaseDrag();\n        } else {\n          _this._initialScale.copyFrom(ownerNode.scaling);\n\n          _this._startDistance = _this._getCurrentDistance();\n        }\n      }\n    }); // Once both drag behaviors are active scale based on the distance between the two pointers\n\n\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(function (behavior) {\n      behavior.onDragObservable.add(function () {\n        if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n          var ratio = _this._getCurrentDistance() / _this._startDistance;\n\n          _this._initialScale.scaleToRef(ratio, _this._targetScale);\n        }\n      });\n    });\n    ownerNode.addBehavior(this._dragBehaviorA);\n    ownerNode.addBehavior(this._dragBehaviorB); // On every frame move towards target scaling to avoid jitter caused by vr controllers\n\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function () {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        var change = _this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\n\n        if (change.length() > 0.01) {\n          ownerNode.scaling.addInPlace(change);\n        }\n      }\n    });\n  };\n  /**\r\n   *  Detaches the behavior from the mesh\r\n   */\n\n\n  MultiPointerScaleBehavior.prototype.detach = function () {\n    var _this = this;\n\n    this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(function (behavior) {\n      behavior.onDragStartObservable.clear();\n      behavior.onDragObservable.clear();\n\n      _this._ownerNode.removeBehavior(behavior);\n    });\n  };\n\n  return MultiPointerScaleBehavior;\n}();\n\nexport { MultiPointerScaleBehavior };","map":null,"metadata":{},"sourceType":"module"}