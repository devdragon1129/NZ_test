{"ast":null,"code":"import { Camera } from \"../../Cameras/camera\";\nimport { Engine } from \"../../Engines/engine\";\nimport { Scene } from \"../../scene\";\nimport { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\nimport { Matrix, TmpVectors } from '../../Maths/math.vector';\nimport { UniformBuffer } from '../../Materials/uniformBuffer';\nimport { MultiviewRenderTarget } from '../../Materials/Textures/MultiviewRenderTarget';\nimport { Frustum } from '../../Maths/math.frustum';\n\nEngine.prototype.createMultiviewRenderTargetTexture = function (width, height) {\n  var gl = this._gl;\n\n  if (!this.getCaps().multiview) {\n    throw \"Multiview is not supported\";\n  }\n\n  var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n  internalTexture.width = width;\n  internalTexture.height = height;\n  internalTexture._framebuffer = gl.createFramebuffer();\n  internalTexture._colorTextureArray = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D_ARRAY, internalTexture._colorTextureArray);\n  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);\n  internalTexture._depthStencilTextureArray = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D_ARRAY, internalTexture._depthStencilTextureArray);\n  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.DEPTH32F_STENCIL8, width, height, 2);\n  internalTexture.isReady = true;\n  return internalTexture;\n};\n\nEngine.prototype.bindMultiviewFramebuffer = function (multiviewTexture) {\n  var gl = this._gl;\n  var ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\n  this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);\n  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);\n\n  if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {\n    if (this.getCaps().oculusMultiview) {\n      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);\n      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, multiviewTexture.samples, 0, 2);\n    } else {\n      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);\n      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);\n    }\n  } else {\n    throw \"Invalid multiview frame buffer\";\n  }\n};\n\nCamera.prototype._useMultiviewToSingleView = false;\nCamera.prototype._multiviewTexture = null;\n\nCamera.prototype._resizeOrCreateMultiviewTexture = function (width, height) {\n  if (!this._multiviewTexture) {\n    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), {\n      width: width,\n      height: height\n    });\n  } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {\n    this._multiviewTexture.dispose();\n\n    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), {\n      width: width,\n      height: height\n    });\n  }\n};\n\nScene.prototype._transformMatrixR = Matrix.Zero();\nScene.prototype._multiviewSceneUbo = null;\n\nScene.prototype._createMultiviewUbo = function () {\n  this._multiviewSceneUbo = new UniformBuffer(this.getEngine(), undefined, true);\n\n  this._multiviewSceneUbo.addUniform(\"viewProjection\", 16);\n\n  this._multiviewSceneUbo.addUniform(\"viewProjectionR\", 16);\n\n  this._multiviewSceneUbo.addUniform(\"view\", 16);\n};\n\nScene.prototype._updateMultiviewUbo = function (viewR, projectionR) {\n  if (viewR && projectionR) {\n    viewR.multiplyToRef(projectionR, this._transformMatrixR);\n  }\n\n  if (viewR && projectionR) {\n    viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);\n    Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane\n  }\n\n  if (this._multiviewSceneUbo) {\n    this._multiviewSceneUbo.updateMatrix(\"viewProjection\", this.getTransformMatrix());\n\n    this._multiviewSceneUbo.updateMatrix(\"viewProjectionR\", this._transformMatrixR);\n\n    this._multiviewSceneUbo.updateMatrix(\"view\", this._viewMatrix);\n\n    this._multiviewSceneUbo.update();\n  }\n};\n\nScene.prototype._renderMultiviewToSingleView = function (camera) {\n  // Multiview is only able to be displayed directly for API's such as webXR\n  // This displays a multiview image by rendering to the multiview image and then\n  // copying the result into the sub cameras instead of rendering them and proceeding as normal from there\n  // Render to a multiview texture\n  camera._resizeOrCreateMultiviewTexture(camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true), camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true));\n\n  if (!this._multiviewSceneUbo) {\n    this._createMultiviewUbo();\n  }\n\n  camera.outputRenderTarget = camera._multiviewTexture;\n\n  this._renderForCamera(camera);\n\n  camera.outputRenderTarget = null; // Consume the multiview texture through a shader for each eye\n\n  for (var index = 0; index < camera._rigCameras.length; index++) {\n    var engine = this.getEngine();\n    this._activeCamera = camera._rigCameras[index];\n    engine.setViewport(this._activeCamera.viewport);\n\n    if (this.postProcessManager) {\n      this.postProcessManager._prepareFrame();\n\n      this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}