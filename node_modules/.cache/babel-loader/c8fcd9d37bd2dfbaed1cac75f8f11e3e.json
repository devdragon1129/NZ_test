{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { SerializationHelper, serialize, expandToProperty, serializeAsColor3, serializeAsTexture } from \"../../Misc/decorators\";\nimport { Color3 } from '../../Maths/math.color';\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\n/**\r\n * Define the code related to the Sheen parameters of the pbr material.\r\n */\n\nvar PBRSheenConfiguration =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new istance of clear coat configuration.\r\n   * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n   */\n  function PBRSheenConfiguration(markAllSubMeshesAsTexturesDirty) {\n    this._isEnabled = false;\n    /**\r\n     * Defines if the material uses sheen.\r\n     */\n\n    this.isEnabled = false;\n    this._linkSheenWithAlbedo = false;\n    /**\r\n     * Defines if the sheen is linked to the sheen color.\r\n     */\n\n    this.linkSheenWithAlbedo = false;\n    /**\r\n     * Defines the sheen intensity.\r\n     */\n\n    this.intensity = 1;\n    /**\r\n     * Defines the sheen color.\r\n     */\n\n    this.color = Color3.White();\n    this._texture = null;\n    /**\r\n     * Stores the sheen tint values in a texture.\r\n     * rgb is tint\r\n     * a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)\r\n     * If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness\r\n     */\n\n    this.texture = null;\n    this._useRoughnessFromMainTexture = true;\n    /**\r\n     * Indicates that the alpha channel of the texture property will be used for roughness.\r\n     * Has no effect if the roughness (and texture!) property is not defined\r\n     */\n\n    this.useRoughnessFromMainTexture = true;\n    this._roughness = null;\n    /**\r\n     * Defines the sheen roughness.\r\n     * It is not taken into account if linkSheenWithAlbedo is true.\r\n     * To stay backward compatible, material roughness is used instead if sheen roughness = null\r\n     */\n\n    this.roughness = null;\n    this._textureRoughness = null;\n    /**\r\n     * Stores the sheen roughness in a texture.\r\n     * alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true\r\n     */\n\n    this.textureRoughness = null;\n    this._albedoScaling = false;\n    /**\r\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\r\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\r\n     * making it easier to setup and tweak the effect\r\n     */\n\n    this.albedoScaling = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\n  }\n  /** @hidden */\n\n\n  PBRSheenConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - boolean indicating that the submesh is ready or not.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.SheenTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\n          if (!this._textureRoughness.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.prepareDefines = function (defines, scene) {\n    var _a;\n\n    if (this._isEnabled) {\n      defines.SHEEN = this._isEnabled;\n      defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;\n      defines.SHEEN_ROUGHNESS = this._roughness !== null;\n      defines.SHEEN_ALBEDOSCALING = this._albedoScaling;\n      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\n      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);\n\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.SheenTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"SHEEN_TEXTURE\");\n          } else {\n            defines.SHEEN_TEXTURE = false;\n          }\n\n          if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, \"SHEEN_TEXTURE_ROUGHNESS\");\n          } else {\n            defines.SHEEN_TEXTURE_ROUGHNESS = false;\n          }\n        }\n      }\n    } else {\n      defines.SHEEN = false;\n      defines.SHEEN_TEXTURE = false;\n      defines.SHEEN_TEXTURE_ROUGHNESS = false;\n      defines.SHEEN_LINKWITHALBEDO = false;\n      defines.SHEEN_ROUGHNESS = false;\n      defines.SHEEN_ALBEDOSCALING = false;\n      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\n    }\n  };\n  /**\r\n   * Binds the material data.\r\n   * @param uniformBuffer defines the Uniform buffer to fill in.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @param isFrozen defines wether the material is frozen or not.\r\n   * @param subMesh the submesh to bind data for\r\n   */\n\n\n  PBRSheenConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, isFrozen, subMesh) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n\n    var defines = subMesh._materialDefines;\n    var identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;\n\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (identicalTextures && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.updateFloat4(\"vSheenInfos\", this._texture.coordinatesIndex, this._texture.level, -1, -1);\n        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\n      } else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.updateFloat4(\"vSheenInfos\", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);\n\n        if (this._texture) {\n          MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\n        }\n\n        if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {\n          MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, \"sheenRoughness\");\n        }\n      } // Sheen\n\n\n      uniformBuffer.updateFloat4(\"vSheenColor\", this.color.r, this.color.g, this.color.b, this.intensity);\n\n      if (this._roughness !== null) {\n        uniformBuffer.updateFloat(\"vSheenRoughness\", this._roughness);\n      }\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.setTexture(\"sheenSampler\", this._texture);\n      }\n\n      if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.setTexture(\"sheenRoughnessSampler\", this._textureRoughness);\n      }\n    }\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param texture - Base texture to use.\r\n   * @returns - Boolean specifying if a texture is used in the material.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.hasTexture = function (texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n\n    if (this._textureRoughness === texture) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns an array of the actively used textures.\r\n   * @param activeTextures Array of BaseTextures\r\n   */\n\n\n  PBRSheenConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n\n    if (this._textureRoughness) {\n      activeTextures.push(this._textureRoughness);\n    }\n  };\n  /**\r\n   * Returns the animatable textures.\r\n   * @param animatables Array of animatable textures.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n\n    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\n      animatables.push(this._textureRoughness);\n    }\n  };\n  /**\r\n   * Disposes the resources of the material.\r\n   * @param forceDisposeTextures - Forces the disposal of all textures.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    var _a, _b;\n\n    if (forceDisposeTextures) {\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\n      (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();\n    }\n  };\n  /**\r\n  * Get the current class name of the texture useful for serialization or dynamic coding.\r\n  * @returns \"PBRSheenConfiguration\"\r\n  */\n\n\n  PBRSheenConfiguration.prototype.getClassName = function () {\n    return \"PBRSheenConfiguration\";\n  };\n  /**\r\n   * Add fallbacks to the effect fallbacks list.\r\n   * @param defines defines the Base texture to use.\r\n   * @param fallbacks defines the current fallback list.\r\n   * @param currentRank defines the current fallback rank.\r\n   * @returns the new fallback rank.\r\n   */\n\n\n  PBRSheenConfiguration.AddFallbacks = function (defines, fallbacks, currentRank) {\n    if (defines.SHEEN) {\n      fallbacks.addFallback(currentRank++, \"SHEEN\");\n    }\n\n    return currentRank;\n  };\n  /**\r\n   * Add the required uniforms to the current list.\r\n   * @param uniforms defines the current uniform list.\r\n   */\n\n\n  PBRSheenConfiguration.AddUniforms = function (uniforms) {\n    uniforms.push(\"vSheenColor\", \"vSheenRoughness\", \"vSheenInfos\", \"sheenMatrix\", \"sheenRoughnessMatrix\");\n  };\n  /**\r\n   * Add the required uniforms to the current buffer.\r\n   * @param uniformBuffer defines the current uniform buffer.\r\n   */\n\n\n  PBRSheenConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\n    uniformBuffer.addUniform(\"vSheenColor\", 4);\n    uniformBuffer.addUniform(\"vSheenRoughness\", 1);\n    uniformBuffer.addUniform(\"vSheenInfos\", 4);\n    uniformBuffer.addUniform(\"sheenMatrix\", 16);\n    uniformBuffer.addUniform(\"sheenRoughnessMatrix\", 16);\n  };\n  /**\r\n   * Add the required samplers to the current list.\r\n   * @param samplers defines the current sampler list.\r\n   */\n\n\n  PBRSheenConfiguration.AddSamplers = function (samplers) {\n    samplers.push(\"sheenSampler\");\n    samplers.push(\"sheenRoughnessSampler\");\n  };\n  /**\r\n   * Makes a duplicate of the current configuration into another one.\r\n   * @param sheenConfiguration define the config where to copy the info\r\n   */\n\n\n  PBRSheenConfiguration.prototype.copyTo = function (sheenConfiguration) {\n    SerializationHelper.Clone(function () {\n      return sheenConfiguration;\n    }, this);\n  };\n  /**\r\n   * Serializes this BRDF configuration.\r\n   * @returns - An object with the serialized config.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Parses a anisotropy Configuration from a serialized object.\r\n   * @param source - Serialized object.\r\n   * @param scene Defines the scene we are parsing for\r\n   * @param rootUrl Defines the rootUrl to load from\r\n   */\n\n\n  PBRSheenConfiguration.prototype.parse = function (source, scene, rootUrl) {\n    var _this = this;\n\n    SerializationHelper.Parse(function () {\n      return _this;\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"isEnabled\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"linkSheenWithAlbedo\", void 0);\n\n  __decorate([serialize()], PBRSheenConfiguration.prototype, \"intensity\", void 0);\n\n  __decorate([serializeAsColor3()], PBRSheenConfiguration.prototype, \"color\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"texture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"useRoughnessFromMainTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"roughness\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"textureRoughness\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"albedoScaling\", void 0);\n\n  return PBRSheenConfiguration;\n}();\n\nexport { PBRSheenConfiguration };","map":null,"metadata":{},"sourceType":"module"}