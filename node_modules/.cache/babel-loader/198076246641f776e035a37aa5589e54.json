{"ast":null,"code":"/**\r\n * Class used to evalaute queries containing `and` and `or` operators\r\n */\nvar AndOrNotEvaluator =\n/** @class */\nfunction () {\n  function AndOrNotEvaluator() {}\n  /**\r\n   * Evaluate a query\r\n   * @param query defines the query to evaluate\r\n   * @param evaluateCallback defines the callback used to filter result\r\n   * @returns true if the query matches\r\n   */\n\n\n  AndOrNotEvaluator.Eval = function (query, evaluateCallback) {\n    if (!query.match(/\\([^\\(\\)]*\\)/g)) {\n      query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n    } else {\n      query = query.replace(/\\([^\\(\\)]*\\)/g, function (r) {\n        // remove parenthesis\n        r = r.slice(1, r.length - 1);\n        return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n      });\n    }\n\n    if (query === \"true\") {\n      return true;\n    }\n\n    if (query === \"false\") {\n      return false;\n    }\n\n    return AndOrNotEvaluator.Eval(query, evaluateCallback);\n  };\n\n  AndOrNotEvaluator._HandleParenthesisContent = function (parenthesisContent, evaluateCallback) {\n    evaluateCallback = evaluateCallback || function (r) {\n      return r === \"true\" ? true : false;\n    };\n\n    var result;\n    var or = parenthesisContent.split(\"||\");\n\n    for (var i in or) {\n      if (or.hasOwnProperty(i)) {\n        var ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n\n        var and = ori.split(\"&&\");\n\n        if (and.length > 1) {\n          for (var j = 0; j < and.length; ++j) {\n            var andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n\n            if (andj !== \"true\" && andj !== \"false\") {\n              if (andj[0] === \"!\") {\n                result = !evaluateCallback(andj.substring(1));\n              } else {\n                result = evaluateCallback(andj);\n              }\n            } else {\n              result = andj === \"true\" ? true : false;\n            }\n\n            if (!result) {\n              // no need to continue since 'false && ... && ...' will always return false\n              ori = \"false\";\n              break;\n            }\n          }\n        }\n\n        if (result || ori === \"true\") {\n          // no need to continue since 'true || ... || ...' will always return true\n          result = true;\n          break;\n        } // result equals false (or undefined)\n\n\n        if (ori !== \"true\" && ori !== \"false\") {\n          if (ori[0] === \"!\") {\n            result = !evaluateCallback(ori.substring(1));\n          } else {\n            result = evaluateCallback(ori);\n          }\n        } else {\n          result = ori === \"true\" ? true : false;\n        }\n      }\n    } // the whole parenthesis scope is replaced by 'true' or 'false'\n\n\n    return result ? \"true\" : \"false\";\n  };\n\n  AndOrNotEvaluator._SimplifyNegation = function (booleanString) {\n    booleanString = booleanString.replace(/^[\\s!]+/, function (r) {\n      // remove whitespaces\n      r = r.replace(/[\\s]/g, function () {\n        return \"\";\n      });\n      return r.length % 2 ? \"!\" : \"\";\n    });\n    booleanString = booleanString.trim();\n\n    if (booleanString === \"!true\") {\n      booleanString = \"false\";\n    } else if (booleanString === \"!false\") {\n      booleanString = \"true\";\n    }\n\n    return booleanString;\n  };\n\n  return AndOrNotEvaluator;\n}();\n\nexport { AndOrNotEvaluator };","map":null,"metadata":{},"sourceType":"module"}