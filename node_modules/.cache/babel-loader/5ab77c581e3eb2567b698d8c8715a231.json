{"ast":null,"code":"import { Vector3, Vector2 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color4 } from '@babylonjs/core/Maths/math.color';\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer\";\nimport { MTLFileLoader } from './mtlFileLoader';\n/**\r\n * OBJ file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\n\nvar OBJFileLoader =\n/** @class */\nfunction () {\n  /**\r\n   * Creates loader for .OBJ files\r\n   *\r\n   * @param meshLoadOptions options for loading and parsing OBJ/MTL files.\r\n   */\n  function OBJFileLoader(meshLoadOptions) {\n    /**\r\n     * Defines the name of the plugin.\r\n     */\n    this.name = \"obj\";\n    /**\r\n     * Defines the extension the plugin is able to load.\r\n     */\n\n    this.extensions = \".obj\";\n    /** @hidden */\n\n    this.obj = /^o/;\n    /** @hidden */\n\n    this.group = /^g/;\n    /** @hidden */\n\n    this.mtllib = /^mtllib /;\n    /** @hidden */\n\n    this.usemtl = /^usemtl /;\n    /** @hidden */\n\n    this.smooth = /^s /;\n    /** @hidden */\n\n    this.vertexPattern = /v(\\s+[\\d|\\.|\\+|\\-|e|E]+){3,7}/; // vn float float float\n\n    /** @hidden */\n\n    this.normalPattern = /vn(\\s+[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/; // vt float float\n\n    /** @hidden */\n\n    this.uvPattern = /vt(\\s+[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/; // f vertex vertex vertex ...\n\n    /** @hidden */\n\n    this.facePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/; // f vertex/uvs vertex/uvs vertex/uvs ...\n\n    /** @hidden */\n\n    this.facePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/; // f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal ...\n\n    /** @hidden */\n\n    this.facePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/; // f vertex//normal vertex//normal vertex//normal ...\n\n    /** @hidden */\n\n    this.facePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/; // f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal ...\n\n    /** @hidden */\n\n    this.facePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n    this._forAssetContainer = false;\n    this._meshLoadOptions = meshLoadOptions || OBJFileLoader.currentMeshLoadOptions;\n  }\n\n  Object.defineProperty(OBJFileLoader, \"INVERT_TEXTURE_Y\", {\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\n    get: function get() {\n      return MTLFileLoader.INVERT_TEXTURE_Y;\n    },\n    set: function set(value) {\n      MTLFileLoader.INVERT_TEXTURE_Y = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OBJFileLoader, \"currentMeshLoadOptions\", {\n    get: function get() {\n      return {\n        ComputeNormals: OBJFileLoader.COMPUTE_NORMALS,\n        ImportVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n        InvertY: OBJFileLoader.INVERT_Y,\n        InvertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n        UVScaling: OBJFileLoader.UV_SCALING,\n        MaterialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n        OptimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n        SkipMaterials: OBJFileLoader.SKIP_MATERIALS\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Calls synchronously the MTL file attached to this obj.\r\n   * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\r\n   * Without this function materials are not displayed in the first frame (but displayed after).\r\n   * In consequence it is impossible to get material information in your HTML file\r\n   *\r\n   * @param url The URL of the MTL file\r\n   * @param rootUrl\r\n   * @param onSuccess Callback function to be called when the MTL file is loaded\r\n   * @private\r\n   */\n\n  OBJFileLoader.prototype._loadMTL = function (url, rootUrl, onSuccess, onFailure) {\n    //The complete path to the mtl file\n    var pathOfFile = Tools.BaseUrl + rootUrl + url; // Loads through the babylon tools to allow fileInput search.\n\n    Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, function (request, exception) {\n      onFailure(pathOfFile, exception);\n    });\n  };\n  /**\r\n   * Instantiates a OBJ file loader plugin.\r\n   * @returns the created plugin\r\n   */\n\n\n  OBJFileLoader.prototype.createPlugin = function () {\n    return new OBJFileLoader(OBJFileLoader.currentMeshLoadOptions);\n  };\n  /**\r\n   * If the data string can be loaded directly.\r\n   *\r\n   * @param data string containing the file data\r\n   * @returns if the data can be loaded directly\r\n   */\n\n\n  OBJFileLoader.prototype.canDirectLoad = function (data) {\n    return false;\n  };\n  /**\r\n   * Imports one or more meshes from the loaded OBJ data and adds them to the scene\r\n   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n   * @param scene the scene the meshes should be added to\r\n   * @param data the OBJ data to load\r\n   * @param rootUrl root url to load from\r\n   * @param onProgress event that fires when loading progress has occured\r\n   * @param fileName Defines the name of the file to load\r\n   * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n   */\n\n\n  OBJFileLoader.prototype.importMeshAsync = function (meshesNames, scene, data, rootUrl, onProgress, fileName) {\n    //get the meshes from OBJ file\n    return this._parseSolid(meshesNames, scene, data, rootUrl).then(function (meshes) {\n      return {\n        meshes: meshes,\n        particleSystems: [],\n        skeletons: [],\n        animationGroups: [],\n        transformNodes: [],\n        geometries: [],\n        lights: []\n      };\n    });\n  };\n  /**\r\n   * Imports all objects from the loaded OBJ data and adds them to the scene\r\n   * @param scene the scene the objects should be added to\r\n   * @param data the OBJ data to load\r\n   * @param rootUrl root url to load from\r\n   * @param onProgress event that fires when loading progress has occured\r\n   * @param fileName Defines the name of the file to load\r\n   * @returns a promise which completes when objects have been loaded to the scene\r\n   */\n\n\n  OBJFileLoader.prototype.loadAsync = function (scene, data, rootUrl, onProgress, fileName) {\n    //Get the 3D model\n    return this.importMeshAsync(null, scene, data, rootUrl, onProgress).then(function () {// return void\n    });\n  };\n  /**\r\n   * Load into an asset container.\r\n   * @param scene The scene to load into\r\n   * @param data The data to import\r\n   * @param rootUrl The root url for scene and resources\r\n   * @param onProgress The callback when the load progresses\r\n   * @param fileName Defines the name of the file to load\r\n   * @returns The loaded asset container\r\n   */\n\n\n  OBJFileLoader.prototype.loadAssetContainerAsync = function (scene, data, rootUrl, onProgress, fileName) {\n    var _this = this;\n\n    this._forAssetContainer = true;\n    return this.importMeshAsync(null, scene, data, rootUrl).then(function (result) {\n      var container = new AssetContainer(scene);\n      result.meshes.forEach(function (mesh) {\n        return container.meshes.push(mesh);\n      });\n      result.meshes.forEach(function (mesh) {\n        var material = mesh.material;\n\n        if (material) {\n          // Materials\n          if (container.materials.indexOf(material) == -1) {\n            container.materials.push(material); // Textures\n\n            var textures = material.getActiveTextures();\n            textures.forEach(function (t) {\n              if (container.textures.indexOf(t) == -1) {\n                container.textures.push(t);\n              }\n            });\n          }\n        }\n      });\n      _this._forAssetContainer = false;\n      return container;\n    }).catch(function (ex) {\n      _this._forAssetContainer = false;\n      throw ex;\n    });\n  };\n  /**\r\n   * Read the OBJ file and create an Array of meshes.\r\n   * Each mesh contains all information given by the OBJ and the MTL file.\r\n   * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\r\n   *\r\n   * @param meshesNames\r\n   * @param scene Scene The scene where are displayed the data\r\n   * @param data String The content of the obj file\r\n   * @param rootUrl String The path to the folder\r\n   * @returns Array<AbstractMesh>\r\n   * @private\r\n   */\n\n\n  OBJFileLoader.prototype._parseSolid = function (meshesNames, scene, data, rootUrl) {\n    var _this = this;\n\n    var positions = []; //values for the positions of vertices\n\n    var normals = []; //Values for the normals\n\n    var uvs = []; //Values for the textures\n\n    var colors = [];\n    var meshesFromObj = []; //[mesh] Contains all the obj meshes\n\n    var handledMesh; //The current mesh of meshes array\n\n    var indicesForBabylon = []; //The list of indices for VertexData\n\n    var wrappedPositionForBabylon = []; //The list of position in vectors\n\n    var wrappedUvsForBabylon = []; //Array with all value of uvs to match with the indices\n\n    var wrappedColorsForBabylon = []; // Array with all color values to match with the indices\n\n    var wrappedNormalsForBabylon = []; //Array with all value of normals to match with the indices\n\n    var tuplePosNorm = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n\n    var curPositionInIndices = 0;\n    var hasMeshes = false; //Meshes are defined in the file\n\n    var unwrappedPositionsForBabylon = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\n\n    var unwrappedColorsForBabylon = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\n\n    var unwrappedNormalsForBabylon = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n\n    var unwrappedUVForBabylon = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n\n    var triangles = []; //Indices from new triangles coming from polygons\n\n    var materialNameFromObj = \"\"; //The name of the current material\n\n    var fileToLoad = \"\"; //The name of the mtlFile to load\n\n    var materialsFromMTLFile = new MTLFileLoader();\n    var objMeshName = \"\"; //The name of the current obj mesh\n\n    var increment = 1; //Id for meshes created by the multimaterial\n\n    var isFirstMaterial = true;\n    var grayColor = new Color4(0.5, 0.5, 0.5, 1);\n    /**\r\n     * Search for obj in the given array.\r\n     * This function is called to check if a couple of data already exists in an array.\r\n     *\r\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\r\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\r\n     * @param obj Array<number>\r\n     * @returns {boolean}\r\n     */\n\n    var isInArray = function isInArray(arr, obj) {\n      if (!arr[obj[0]]) {\n        arr[obj[0]] = {\n          normals: [],\n          idx: []\n        };\n      }\n\n      var idx = arr[obj[0]].normals.indexOf(obj[1]);\n      return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n    };\n\n    var isInArrayUV = function isInArrayUV(arr, obj) {\n      if (!arr[obj[0]]) {\n        arr[obj[0]] = {\n          normals: [],\n          idx: [],\n          uv: []\n        };\n      }\n\n      var idx = arr[obj[0]].normals.indexOf(obj[1]);\n\n      if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\n        return arr[obj[0]].idx[idx];\n      }\n\n      return -1;\n    };\n    /**\r\n     * This function set the data for each triangle.\r\n     * Data are position, normals and uvs\r\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\r\n     * If the tuple already exist, add only their indice\r\n     *\r\n     * @param indicePositionFromObj Integer The index in positions array\r\n     * @param indiceUvsFromObj Integer The index in uvs array\r\n     * @param indiceNormalFromObj Integer The index in normals array\r\n     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\r\n     * @param textureVectorFromOBJ Vector3 The value of uvs\r\n     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\r\n     */\n\n\n    var setData = function setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {\n      //Check if this tuple already exists in the list of tuples\n      var _index;\n\n      if (_this._meshLoadOptions.OptimizeWithUV) {\n        _index = isInArrayUV(tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\n      } else {\n        _index = isInArray(tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\n      } //If it not exists\n\n\n      if (_index === -1) {\n        //Add an new indice.\n        //The array of indices is only an array with his length equal to the number of triangles - 1.\n        //We add vertices data in this order\n        indicesForBabylon.push(wrappedPositionForBabylon.length); //Push the position of vertice for Babylon\n        //Each element is a Vector3(x,y,z)\n\n        wrappedPositionForBabylon.push(positionVectorFromOBJ); //Push the uvs for Babylon\n        //Each element is a Vector3(u,v)\n\n        wrappedUvsForBabylon.push(textureVectorFromOBJ); //Push the normals for Babylon\n        //Each element is a Vector3(x,y,z)\n\n        wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\n\n        if (positionColorsFromOBJ !== undefined) {\n          //Push the colors for Babylon\n          //Each element is a BABYLON.Color4(r,g,b,a)\n          wrappedColorsForBabylon.push(positionColorsFromOBJ);\n        } //Add the tuple in the comparison list\n\n\n        tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\n        tuplePosNorm[indicePositionFromObj].idx.push(curPositionInIndices++);\n\n        if (_this._meshLoadOptions.OptimizeWithUV) {\n          tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\n        }\n      } else {\n        //The tuple already exists\n        //Add the index of the already existing tuple\n        //At this index we can get the value of position, normal, color and uvs of vertex\n        indicesForBabylon.push(_index);\n      }\n    };\n    /**\r\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\r\n     */\n\n\n    var unwrapData = function unwrapData() {\n      //Every array has the same length\n      for (var l = 0; l < wrappedPositionForBabylon.length; l++) {\n        //Push the x, y, z values of each element in the unwrapped array\n        unwrappedPositionsForBabylon.push(wrappedPositionForBabylon[l].x, wrappedPositionForBabylon[l].y, wrappedPositionForBabylon[l].z);\n        unwrappedNormalsForBabylon.push(wrappedNormalsForBabylon[l].x, wrappedNormalsForBabylon[l].y, wrappedNormalsForBabylon[l].z);\n        unwrappedUVForBabylon.push(wrappedUvsForBabylon[l].x, wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n\n        if (_this._meshLoadOptions.ImportVertexColors === true) {\n          //Push the r, g, b, a values of each element in the unwrapped array\n          unwrappedColorsForBabylon.push(wrappedColorsForBabylon[l].r, wrappedColorsForBabylon[l].g, wrappedColorsForBabylon[l].b, wrappedColorsForBabylon[l].a);\n        }\n      } // Reset arrays for the next new meshes\n\n\n      wrappedPositionForBabylon = [];\n      wrappedNormalsForBabylon = [];\n      wrappedUvsForBabylon = [];\n      wrappedColorsForBabylon = [];\n      tuplePosNorm = [];\n      curPositionInIndices = 0;\n    };\n    /**\r\n     * Create triangles from polygons\r\n     * It is important to notice that a triangle is a polygon\r\n     * We get 5 patterns of face defined in OBJ File :\r\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\r\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\r\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\r\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\r\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\r\n     * Each pattern is divided by the same method\r\n     * @param face Array[String] The indices of elements\r\n     * @param v Integer The variable to increment\r\n     */\n\n\n    var getTriangles = function getTriangles(faces, v) {\n      //Work for each element of the array\n      for (var faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\n        //Add on the triangle variable the indexes to obtain triangles\n        triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n      } //Result obtained after 2 iterations:\n      //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n      //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n      //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n      //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n      //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n\n    };\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 1\r\n     * In this pattern we get vertice positions\r\n     * @param face\r\n     * @param v\r\n     */\n\n\n    var setDataForCurrentFaceWithPattern1 = function setDataForCurrentFaceWithPattern1(face, v) {\n      //Get the indices of triangles for each polygon\n      getTriangles(face, v); //For each element in the triangles array.\n      //This var could contains 1 to an infinity of triangles\n\n      for (var k = 0; k < triangles.length; k++) {\n        // Set position indice\n        var indicePositionFromObj = parseInt(triangles[k]) - 1;\n        setData(indicePositionFromObj, 0, 0, //In the pattern 1, normals and uvs are not defined\n        positions[indicePositionFromObj], //Get the vectors data\n        Vector2.Zero(), Vector3.Up(), //Create default vectors\n        _this._meshLoadOptions.ImportVertexColors === true ? colors[indicePositionFromObj] : undefined);\n      } //Reset variable for the next line\n\n\n      triangles = [];\n    };\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 2\r\n     * In this pattern we get vertice positions and uvsu\r\n     * @param face\r\n     * @param v\r\n     */\n\n\n    var setDataForCurrentFaceWithPattern2 = function setDataForCurrentFaceWithPattern2(face, v) {\n      //Get the indices of triangles for each polygon\n      getTriangles(face, v);\n\n      for (var k = 0; k < triangles.length; k++) {\n        //triangle[k] = \"1/1\"\n        //Split the data for getting position and uv\n        var point = triangles[k].split(\"/\"); // [\"1\", \"1\"]\n        //Set position indice\n\n        var indicePositionFromObj = parseInt(point[0]) - 1; //Set uv indice\n\n        var indiceUvsFromObj = parseInt(point[1]) - 1;\n        setData(indicePositionFromObj, indiceUvsFromObj, 0, //Default value for normals\n        positions[indicePositionFromObj], //Get the values for each element\n        uvs[indiceUvsFromObj], Vector3.Up(), //Default value for normals\n        _this._meshLoadOptions.ImportVertexColors === true ? colors[indicePositionFromObj] : undefined);\n      } //Reset variable for the next line\n\n\n      triangles = [];\n    };\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\n\n\n    var setDataForCurrentFaceWithPattern3 = function setDataForCurrentFaceWithPattern3(face, v) {\n      //Get the indices of triangles for each polygon\n      getTriangles(face, v);\n\n      for (var k = 0; k < triangles.length; k++) {\n        //triangle[k] = \"1/1/1\"\n        //Split the data for getting position, uv, and normals\n        var point = triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n        // Set position indice\n\n        var indicePositionFromObj = parseInt(point[0]) - 1; // Set uv indice\n\n        var indiceUvsFromObj = parseInt(point[1]) - 1; // Set normal indice\n\n        var indiceNormalFromObj = parseInt(point[2]) - 1;\n        setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj] //Set the vector for each component\n        );\n      } //Reset variable for the next line\n\n\n      triangles = [];\n    };\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 4\r\n     * In this pattern we get vertice positions and normals\r\n     * @param face\r\n     * @param v\r\n     */\n\n\n    var setDataForCurrentFaceWithPattern4 = function setDataForCurrentFaceWithPattern4(face, v) {\n      getTriangles(face, v);\n\n      for (var k = 0; k < triangles.length; k++) {\n        //triangle[k] = \"1//1\"\n        //Split the data for getting position and normals\n        var point = triangles[k].split(\"//\"); // [\"1\", \"1\"]\n        // We check indices, and normals\n\n        var indicePositionFromObj = parseInt(point[0]) - 1;\n        var indiceNormalFromObj = parseInt(point[1]) - 1;\n        setData(indicePositionFromObj, 1, //Default value for uv\n        indiceNormalFromObj, positions[indicePositionFromObj], //Get each vector of data\n        Vector2.Zero(), normals[indiceNormalFromObj], _this._meshLoadOptions.ImportVertexColors === true ? colors[indicePositionFromObj] : undefined);\n      } //Reset variable for the next line\n\n\n      triangles = [];\n    };\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\n\n\n    var setDataForCurrentFaceWithPattern5 = function setDataForCurrentFaceWithPattern5(face, v) {\n      //Get the indices of triangles for each polygon\n      getTriangles(face, v);\n\n      for (var k = 0; k < triangles.length; k++) {\n        //triangle[k] = \"-1/-1/-1\"\n        //Split the data for getting position, uv, and normals\n        var point = triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n        // Set position indice\n\n        var indicePositionFromObj = positions.length + parseInt(point[0]); // Set uv indice\n\n        var indiceUvsFromObj = uvs.length + parseInt(point[1]); // Set normal indice\n\n        var indiceNormalFromObj = normals.length + parseInt(point[2]);\n        setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj], //Set the vector for each component\n        _this._meshLoadOptions.ImportVertexColors === true ? colors[indicePositionFromObj] : undefined);\n      } //Reset variable for the next line\n\n\n      triangles = [];\n    };\n\n    var addPreviousObjMesh = function addPreviousObjMesh() {\n      //Check if it is not the first mesh. Otherwise we don't have data.\n      if (meshesFromObj.length > 0) {\n        //Get the previous mesh for applying the data about the faces\n        //=> in obj file, faces definition append after the name of the mesh\n        handledMesh = meshesFromObj[meshesFromObj.length - 1]; //Set the data into Array for the mesh\n\n        unwrapData(); // Reverse tab. Otherwise face are displayed in the wrong sens\n\n        indicesForBabylon.reverse(); //Set the information for the mesh\n        //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n\n        handledMesh.indices = indicesForBabylon.slice();\n        handledMesh.positions = unwrappedPositionsForBabylon.slice();\n        handledMesh.normals = unwrappedNormalsForBabylon.slice();\n        handledMesh.uvs = unwrappedUVForBabylon.slice();\n\n        if (_this._meshLoadOptions.ImportVertexColors === true) {\n          handledMesh.colors = unwrappedColorsForBabylon.slice();\n        } //Reset the array for the next mesh\n\n\n        indicesForBabylon = [];\n        unwrappedPositionsForBabylon = [];\n        unwrappedColorsForBabylon = [];\n        unwrappedNormalsForBabylon = [];\n        unwrappedUVForBabylon = [];\n      }\n    }; //Main function\n    //Split the file into lines\n\n\n    var lines = data.split('\\n'); //Look at each line\n\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i].trim().replace(/\\s\\s/g, \" \");\n      var result; //Comment or newLine\n\n      if (line.length === 0 || line.charAt(0) === '#') {\n        continue; //Get information about one position possible for the vertices\n      } else if (this.vertexPattern.test(line)) {\n        result = line.match(/[^ ]+/g); // match will return non-null due to passing regex pattern\n        // Value of result with line: \"v 1.0 2.0 3.0\"\n        // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\n        // Create a Vector3 with the position x, y, z\n\n        positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n\n        if (this._meshLoadOptions.ImportVertexColors === true) {\n          if (result.length >= 7) {\n            // TODO: if these numbers are > 1 we can use Color4.FromInts(r,g,b,a)\n            colors.push(new Color4(parseFloat(result[4]), parseFloat(result[5]), parseFloat(result[6]), result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7])));\n          } else {\n            // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\n            colors.push(grayColor);\n          }\n        }\n      } else if ((result = this.normalPattern.exec(line)) !== null) {\n        //Create a Vector3 with the normals x, y, z\n        //Value of result\n        // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n        //Add the Vector in the list of normals\n        normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n      } else if ((result = this.uvPattern.exec(line)) !== null) {\n        //Create a Vector2 with the normals u, v\n        //Value of result\n        // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n        //Add the Vector in the list of uvs\n        uvs.push(new Vector2(parseFloat(result[1]) * OBJFileLoader.UV_SCALING.x, parseFloat(result[2]) * OBJFileLoader.UV_SCALING.y)); //Identify patterns of faces\n        //Face could be defined in different type of pattern\n      } else if ((result = this.facePattern3.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n        //Set the data for this face\n        setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n        1);\n      } else if ((result = this.facePattern4.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n        //Set the data for this face\n        setDataForCurrentFaceWithPattern4(result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n        1);\n      } else if ((result = this.facePattern5.exec(line)) !== null) {\n        //Value of result:\n        //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n        //Set the data for this face\n        setDataForCurrentFaceWithPattern5(result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n        1);\n      } else if ((result = this.facePattern2.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n        //Set the data for this face\n        setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n        1);\n      } else if ((result = this.facePattern1.exec(line)) !== null) {\n        //Value of result\n        //[\"f 1 2 3\", \"1 2 3\"...]\n        //Set the data for this face\n        setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n        1); //Define a mesh or an object\n        //Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\n      } else if (this.group.test(line) || this.obj.test(line)) {\n        //Create a new mesh corresponding to the name of the group.\n        //Definition of the mesh\n        var objMesh = {\n          name: line.substring(2).trim(),\n          indices: undefined,\n          positions: undefined,\n          normals: undefined,\n          uvs: undefined,\n          colors: undefined,\n          materialName: \"\"\n        };\n        addPreviousObjMesh(); //Push the last mesh created with only the name\n\n        meshesFromObj.push(objMesh); //Set this variable to indicate that now meshesFromObj has objects defined inside\n\n        hasMeshes = true;\n        isFirstMaterial = true;\n        increment = 1; //Keyword for applying a material\n      } else if (this.usemtl.test(line)) {\n        //Get the name of the material\n        materialNameFromObj = line.substring(7).trim(); //If this new material is in the same mesh\n\n        if (!isFirstMaterial || !hasMeshes) {\n          //Set the data for the previous mesh\n          addPreviousObjMesh(); //Create a new mesh\n\n          var objMesh = //Set the name of the current obj mesh\n          {\n            name: (objMeshName || \"mesh\") + \"_mm\" + increment.toString(),\n            indices: undefined,\n            positions: undefined,\n            normals: undefined,\n            uvs: undefined,\n            colors: undefined,\n            materialName: materialNameFromObj\n          };\n          increment++; //If meshes are already defined\n\n          meshesFromObj.push(objMesh);\n          hasMeshes = true;\n        } //Set the material name if the previous line define a mesh\n\n\n        if (hasMeshes && isFirstMaterial) {\n          //Set the material name to the previous mesh (1 material per mesh)\n          meshesFromObj[meshesFromObj.length - 1].materialName = materialNameFromObj;\n          isFirstMaterial = false;\n        } //Keyword for loading the mtl file\n\n      } else if (this.mtllib.test(line)) {\n        //Get the name of mtl file\n        fileToLoad = line.substring(7).trim(); //Apply smoothing\n      } else if (this.smooth.test(line)) {// smooth shading => apply smoothing\n        //Today I don't know it work with babylon and with obj.\n        //With the obj file  an integer is set\n      } else {\n        //If there is another possibility\n        console.log(\"Unhandled expression at line : \" + line);\n      }\n    } //At the end of the file, add the last mesh into the meshesFromObj array\n\n\n    if (hasMeshes) {\n      //Set the data for the last mesh\n      handledMesh = meshesFromObj[meshesFromObj.length - 1]; //Reverse indices for displaying faces in the good sense\n\n      indicesForBabylon.reverse(); //Get the good array\n\n      unwrapData(); //Set array\n\n      handledMesh.indices = indicesForBabylon;\n      handledMesh.positions = unwrappedPositionsForBabylon;\n      handledMesh.normals = unwrappedNormalsForBabylon;\n      handledMesh.uvs = unwrappedUVForBabylon;\n\n      if (this._meshLoadOptions.ImportVertexColors === true) {\n        handledMesh.colors = unwrappedColorsForBabylon;\n      }\n    } //If any o or g keyword found, create a mesh with a random id\n\n\n    if (!hasMeshes) {\n      // reverse tab of indices\n      indicesForBabylon.reverse(); //Get positions normals uvs\n\n      unwrapData(); //Set data for one mesh\n\n      meshesFromObj.push({\n        name: Geometry.RandomId(),\n        indices: indicesForBabylon,\n        positions: unwrappedPositionsForBabylon,\n        colors: unwrappedColorsForBabylon,\n        normals: unwrappedNormalsForBabylon,\n        uvs: unwrappedUVForBabylon,\n        materialName: materialNameFromObj\n      });\n    } //Create a Mesh list\n\n\n    var babylonMeshesArray = []; //The mesh for babylon\n\n    var materialToUse = new Array(); //Set data for each mesh\n\n    for (var j = 0; j < meshesFromObj.length; j++) {\n      //check meshesNames (stlFileLoader)\n      if (meshesNames && meshesFromObj[j].name) {\n        if (meshesNames instanceof Array) {\n          if (meshesNames.indexOf(meshesFromObj[j].name) === -1) {\n            continue;\n          }\n        } else {\n          if (meshesFromObj[j].name !== meshesNames) {\n            continue;\n          }\n        }\n      } //Get the current mesh\n      //Set the data with VertexBuffer for each mesh\n\n\n      handledMesh = meshesFromObj[j]; //Create a Mesh with the name of the obj mesh\n\n      scene._blockEntityCollection = this._forAssetContainer;\n      var babylonMesh = new Mesh(meshesFromObj[j].name, scene);\n      scene._blockEntityCollection = false; //Push the name of the material to an array\n      //This is indispensable for the importMesh function\n\n      materialToUse.push(meshesFromObj[j].materialName);\n      var vertexData = new VertexData(); //The container for the values\n      //Set the data for the babylonMesh\n\n      vertexData.uvs = handledMesh.uvs;\n      vertexData.indices = handledMesh.indices;\n      vertexData.positions = handledMesh.positions;\n\n      if (this._meshLoadOptions.ComputeNormals === true) {\n        var normals_1 = new Array();\n        VertexData.ComputeNormals(handledMesh.positions, handledMesh.indices, normals_1);\n        vertexData.normals = normals_1;\n      } else {\n        vertexData.normals = handledMesh.normals;\n      }\n\n      if (this._meshLoadOptions.ImportVertexColors === true) {\n        vertexData.colors = handledMesh.colors;\n      } //Set the data from the VertexBuffer to the current Mesh\n\n\n      vertexData.applyToMesh(babylonMesh);\n\n      if (this._meshLoadOptions.InvertY) {\n        babylonMesh.scaling.y *= -1;\n      } //Push the mesh into an array\n\n\n      babylonMeshesArray.push(babylonMesh);\n    }\n\n    var mtlPromises = []; //load the materials\n    //Check if we have a file to load\n\n    if (fileToLoad !== \"\" && this._meshLoadOptions.SkipMaterials === false) {\n      //Load the file synchronously\n      mtlPromises.push(new Promise(function (resolve, reject) {\n        _this._loadMTL(fileToLoad, rootUrl, function (dataLoaded) {\n          try {\n            //Create materials thanks MTLLoader function\n            materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, _this._forAssetContainer); //Look at each material loaded in the mtl file\n\n            for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {\n              //Three variables to get all meshes with the same material\n              var startIndex = 0;\n              var _indices = [];\n\n              var _index; //The material from MTL file is used in the meshes loaded\n              //Push the indice in an array\n              //Check if the material is not used for another mesh\n\n\n              while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                _indices.push(_index);\n\n                startIndex = _index + 1;\n              } //If the material is not used dispose it\n\n\n              if (_index === -1 && _indices.length === 0) {\n                //If the material is not needed, remove it\n                materialsFromMTLFile.materials[n].dispose();\n              } else {\n                for (var o = 0; o < _indices.length; o++) {\n                  //Apply the material to the Mesh for each mesh with the material\n                  babylonMeshesArray[_indices[o]].material = materialsFromMTLFile.materials[n];\n                }\n              }\n            }\n\n            resolve();\n          } catch (e) {\n            Tools.Warn(\"Error processing MTL file: '\" + fileToLoad + \"'\");\n\n            if (_this._meshLoadOptions.MaterialLoadingFailsSilently) {\n              resolve();\n            } else {\n              reject(e);\n            }\n          }\n        }, function (pathOfFile, exception) {\n          Tools.Warn(\"Error downloading MTL file: '\" + fileToLoad + \"'\");\n\n          if (_this._meshLoadOptions.MaterialLoadingFailsSilently) {\n            resolve();\n          } else {\n            reject(exception);\n          }\n        });\n      }));\n    } //Return an array with all Mesh\n\n\n    return Promise.all(mtlPromises).then(function () {\n      return babylonMeshesArray;\n    });\n  };\n  /**\r\n   * Defines if UVs are optimized by default during load.\r\n   */\n\n\n  OBJFileLoader.OPTIMIZE_WITH_UV = true;\n  /**\r\n   * Invert model on y-axis (does a model scaling inversion)\r\n   */\n\n  OBJFileLoader.INVERT_Y = false;\n  /**\r\n   * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\r\n   */\n\n  OBJFileLoader.IMPORT_VERTEX_COLORS = false;\n  /**\r\n   * Compute the normals for the model, even if normals are present in the file.\r\n   */\n\n  OBJFileLoader.COMPUTE_NORMALS = false;\n  /**\r\n   * Defines custom scaling of UV coordinates of loaded meshes.\r\n   */\n\n  OBJFileLoader.UV_SCALING = new Vector2(1, 1);\n  /**\r\n   * Skip loading the materials even if defined in the OBJ file (materials are ignored).\r\n   */\n\n  OBJFileLoader.SKIP_MATERIALS = false;\n  /**\r\n   * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\r\n   *\r\n   * Defaults to true for backwards compatibility.\r\n   */\n\n  OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;\n  return OBJFileLoader;\n}();\n\nexport { OBJFileLoader };\n\nif (SceneLoader) {\n  //Add this loader into the register plugin\n  SceneLoader.RegisterPlugin(new OBJFileLoader());\n}","map":null,"metadata":{},"sourceType":"module"}