{"ast":null,"code":"import { Tools } from './tools';\nimport { Texture } from '../Materials/Textures/texture';\nimport { InternalTexture, InternalTextureSource } from '../Materials/Textures/internalTexture';\nimport { Scalar } from '../Maths/math.scalar';\n/**\r\n * Info about the .basis files\r\n */\n\nvar BasisFileInfo =\n/** @class */\nfunction () {\n  function BasisFileInfo() {}\n\n  return BasisFileInfo;\n}();\n/**\r\n * Result of transcoding a basis file\r\n */\n\n\nvar TranscodeResult =\n/** @class */\nfunction () {\n  function TranscodeResult() {}\n\n  return TranscodeResult;\n}();\n/**\r\n * Configuration options for the Basis transcoder\r\n */\n\n\nvar BasisTranscodeConfiguration =\n/** @class */\nfunction () {\n  function BasisTranscodeConfiguration() {}\n\n  return BasisTranscodeConfiguration;\n}();\n\nexport { BasisTranscodeConfiguration };\n/**\r\n * @hidden\r\n * Enum of basis transcoder formats\r\n */\n\nvar BASIS_FORMATS;\n\n(function (BASIS_FORMATS) {\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC1\"] = 0] = \"cTFETC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC1\"] = 1] = \"cTFBC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC4\"] = 2] = \"cTFBC4\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_OPAQUE_ONLY\"] = 3] = \"cTFPVRTC1_4_OPAQUE_ONLY\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC7_M6_OPAQUE_ONLY\"] = 4] = \"cTFBC7_M6_OPAQUE_ONLY\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2\"] = 5] = \"cTFETC2\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC3\"] = 6] = \"cTFBC3\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC5\"] = 7] = \"cTFBC5\";\n})(BASIS_FORMATS || (BASIS_FORMATS = {}));\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\n\n\nvar BasisTools =\n/** @class */\nfunction () {\n  function BasisTools() {}\n  /**\r\n   * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n   * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n   * @returns internal format corresponding to the Basis format\r\n   */\n\n\n  BasisTools.GetInternalFormatFromBasisFormat = function (basisFormat) {\n    // Corrisponding internal formats\n    var COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\n    var COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n    var RGB_ETC1_Format = 36196;\n\n    if (basisFormat === BASIS_FORMATS.cTFETC1) {\n      return RGB_ETC1_Format;\n    } else if (basisFormat === BASIS_FORMATS.cTFBC1) {\n      return COMPRESSED_RGB_S3TC_DXT1_EXT;\n    } else if (basisFormat === BASIS_FORMATS.cTFBC3) {\n      return COMPRESSED_RGBA_S3TC_DXT5_EXT;\n    } else {\n      throw \"The chosen Basis transcoder format is not currently supported\";\n    }\n  };\n\n  BasisTools._CreateWorkerAsync = function () {\n    var _this = this;\n\n    if (!this._WorkerPromise) {\n      this._WorkerPromise = new Promise(function (res) {\n        if (_this._Worker) {\n          res(_this._Worker);\n        } else {\n          Tools.LoadFileAsync(BasisTools.WasmModuleURL).then(function (wasmBinary) {\n            var workerBlobUrl = URL.createObjectURL(new Blob([\"(\" + workerFunc + \")()\"], {\n              type: \"application/javascript\"\n            }));\n            _this._Worker = new Worker(workerBlobUrl);\n\n            var initHandler = function initHandler(msg) {\n              if (msg.data.action === \"init\") {\n                _this._Worker.removeEventListener(\"message\", initHandler);\n\n                res(_this._Worker);\n              }\n            };\n\n            _this._Worker.addEventListener(\"message\", initHandler);\n\n            _this._Worker.postMessage({\n              action: \"init\",\n              url: BasisTools.JSModuleURL,\n              wasmBinary: wasmBinary\n            });\n          });\n        }\n      });\n    }\n\n    return this._WorkerPromise;\n  };\n  /**\r\n   * Transcodes a loaded image file to compressed pixel data\r\n   * @param data image data to transcode\r\n   * @param config configuration options for the transcoding\r\n   * @returns a promise resulting in the transcoded image\r\n   */\n\n\n  BasisTools.TranscodeAsync = function (data, config) {\n    var _this = this;\n\n    var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n    return new Promise(function (res, rej) {\n      _this._CreateWorkerAsync().then(function () {\n        var actionId = _this._actionId++;\n\n        var messageHandler = function messageHandler(msg) {\n          if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\n            _this._Worker.removeEventListener(\"message\", messageHandler);\n\n            if (!msg.data.success) {\n              rej(\"Transcode is not supported on this device\");\n            } else {\n              res(msg.data);\n            }\n          }\n        };\n\n        _this._Worker.addEventListener(\"message\", messageHandler);\n\n        var dataViewCopy = new Uint8Array(dataView.byteLength);\n        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n\n        _this._Worker.postMessage({\n          action: \"transcode\",\n          id: actionId,\n          imageData: dataViewCopy,\n          config: config,\n          ignoreSupportedFormats: _this._IgnoreSupportedFormats\n        }, [dataViewCopy.buffer]);\n      });\n    });\n  };\n  /**\r\n   * Loads a texture from the transcode result\r\n   * @param texture texture load to\r\n   * @param transcodeResult the result of transcoding the basis file to load from\r\n   */\n\n\n  BasisTools.LoadTextureFromTranscodeResult = function (texture, transcodeResult) {\n    var engine = texture.getEngine();\n\n    var _loop_1 = function _loop_1() {\n      rootImage = transcodeResult.fileInfo.images[i].levels[0];\n      texture._invertVScale = texture.invertY;\n\n      if (transcodeResult.format === -1) {\n        // No compatable compressed format found, fallback to RGB\n        texture.type = 10;\n        texture.format = 4;\n\n        if (engine.webGLVersion < 2 && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\n          // Create non power of two texture\n          var source_1 = new InternalTexture(engine, InternalTextureSource.Temp);\n          texture._invertVScale = texture.invertY;\n          source_1.type = 10;\n          source_1.format = 4; // Fallback requires aligned width/height\n\n          source_1.width = rootImage.width + 3 & ~3;\n          source_1.height = rootImage.height + 3 & ~3;\n\n          engine._bindTextureDirectly(engine._gl.TEXTURE_2D, source_1, true);\n\n          engine._uploadDataToTextureDirectly(source_1, rootImage.transcodedPixels, i, 0, 4, true); // Resize to power of two\n\n\n          engine._rescaleTexture(source_1, texture, engine.scenes[0], engine._getInternalFormat(4), function () {\n            engine._releaseTexture(source_1);\n\n            engine._bindTextureDirectly(engine._gl.TEXTURE_2D, texture, true);\n          });\n        } else {\n          // Fallback is already inverted\n          texture._invertVScale = !texture.invertY; // Upload directly\n\n          texture.width = rootImage.width + 3 & ~3;\n          texture.height = rootImage.height + 3 & ~3;\n\n          engine._uploadDataToTextureDirectly(texture, rootImage.transcodedPixels, i, 0, 4, true);\n        }\n      } else {\n        texture.width = rootImage.width;\n        texture.height = rootImage.height; // Upload all mip levels in the file\n\n        transcodeResult.fileInfo.images[i].levels.forEach(function (level, index) {\n          engine._uploadCompressedDataToTextureDirectly(texture, BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format), level.width, level.height, level.transcodedPixels, i, index);\n        });\n\n        if (engine.webGLVersion < 2 && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\n          Tools.Warn(\"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\");\n          texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\n          texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\n        }\n      }\n    };\n\n    var rootImage;\n\n    for (var i = 0; i < transcodeResult.fileInfo.images.length; i++) {\n      _loop_1();\n    }\n  };\n\n  BasisTools._IgnoreSupportedFormats = false;\n  /**\r\n   * URL to use when loading the basis transcoder\r\n   */\n\n  BasisTools.JSModuleURL = \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.js\";\n  /**\r\n   * URL to use when loading the wasm module for the transcoder\r\n   */\n\n  BasisTools.WasmModuleURL = \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.wasm\";\n  BasisTools._WorkerPromise = null;\n  BasisTools._Worker = null;\n  BasisTools._actionId = 0;\n  return BasisTools;\n}();\n\nexport { BasisTools };\n\nfunction workerFunc() {\n  var _BASIS_FORMAT = {\n    cTFETC1: 0,\n    cTFBC1: 1,\n    cTFBC4: 2,\n    cTFPVRTC1_4_OPAQUE_ONLY: 3,\n    cTFBC7_M6_OPAQUE_ONLY: 4,\n    cTFETC2: 5,\n    cTFBC3: 6,\n    cTFBC5: 7\n  };\n  var transcoderModulePromise = null;\n\n  onmessage = function onmessage(event) {\n    if (event.data.action === \"init\") {\n      // Load the transcoder if it hasn't been yet\n      if (!transcoderModulePromise) {\n        // Override wasm binary\n        Module = {\n          wasmBinary: event.data.wasmBinary\n        };\n        importScripts(event.data.url);\n        transcoderModulePromise = new Promise(function (res) {\n          Module.onRuntimeInitialized = function () {\n            Module.initializeBasis();\n            res();\n          };\n        });\n      }\n\n      transcoderModulePromise.then(function () {\n        postMessage({\n          action: \"init\"\n        });\n      });\n    } else if (event.data.action === \"transcode\") {\n      // Transcode the basis image and return the resulting pixels\n      var config = event.data.config;\n      var imgData = event.data.imageData;\n      var loadedFile = new Module.BasisFile(imgData);\n      var fileInfo = GetFileInfo(loadedFile);\n      var format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\n      var needsConversion = false;\n\n      if (format === null) {\n        needsConversion = true;\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      } // Begin transcode\n\n\n      var success = true;\n\n      if (!loadedFile.startTranscoding()) {\n        success = false;\n      }\n\n      var buffers = [];\n\n      for (var imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\n        if (!success) {\n          break;\n        }\n\n        var image = fileInfo.images[imageIndex];\n\n        if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\n          var mipCount = image.levels.length;\n\n          if (config.loadMipmapLevels === false) {\n            mipCount = 1;\n          }\n\n          for (var levelIndex = 0; levelIndex < mipCount; levelIndex++) {\n            var levelInfo = image.levels[levelIndex];\n            var pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);\n\n            if (!pixels) {\n              success = false;\n              break;\n            }\n\n            levelInfo.transcodedPixels = pixels;\n            buffers.push(levelInfo.transcodedPixels.buffer);\n          }\n        }\n      } // Close file\n\n\n      loadedFile.close();\n      loadedFile.delete();\n\n      if (needsConversion) {\n        format = -1;\n      }\n\n      if (!success) {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id\n        });\n      } else {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id,\n          fileInfo: fileInfo,\n          format: format\n        }, buffers);\n      }\n    }\n  };\n  /**\r\n   * Detects the supported transcode format for the file\r\n   * @param config transcode config\r\n   * @param fileInfo info about the file\r\n   * @returns the chosed format or null if none are supported\r\n   */\n\n\n  function GetSupportedTranscodeFormat(config, fileInfo) {\n    var format = null;\n\n    if (config.supportedCompressionFormats) {\n      if (config.supportedCompressionFormats.etc1) {\n        format = _BASIS_FORMAT.cTFETC1;\n      } else if (config.supportedCompressionFormats.s3tc) {\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      } else if (config.supportedCompressionFormats.pvrtc) {// TODO uncomment this after pvrtc bug is fixed is basis transcoder\n        // See discussion here: https://github.com/mrdoob/three.js/issues/16524#issuecomment-498929924\n        // format = _BASIS_FORMAT.cTFPVRTC1_4_OPAQUE_ONLY;\n      } else if (config.supportedCompressionFormats.etc2) {\n        format = _BASIS_FORMAT.cTFETC2;\n      }\n    }\n\n    return format;\n  }\n  /**\r\n   * Retreives information about the basis file eg. dimensions\r\n   * @param basisFile the basis file to get the info from\r\n   * @returns information about the basis file\r\n   */\n\n\n  function GetFileInfo(basisFile) {\n    var hasAlpha = basisFile.getHasAlpha();\n    var imageCount = basisFile.getNumImages();\n    var images = [];\n\n    for (var i = 0; i < imageCount; i++) {\n      var imageInfo = {\n        levels: []\n      };\n      var levelCount = basisFile.getNumLevels(i);\n\n      for (var level = 0; level < levelCount; level++) {\n        var levelInfo = {\n          width: basisFile.getImageWidth(i, level),\n          height: basisFile.getImageHeight(i, level)\n        };\n        imageInfo.levels.push(levelInfo);\n      }\n\n      images.push(imageInfo);\n    }\n\n    var info = {\n      hasAlpha: hasAlpha,\n      images: images\n    };\n    return info;\n  }\n\n  function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {\n    var dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\n    var dst = new Uint8Array(dstSize);\n\n    if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\n      return null;\n    } // If no supported format is found, load as dxt and convert to rgb565\n\n\n    if (convertToRgb565) {\n      var alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;\n      var alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;\n      dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\n    }\n\n    return dst;\n  }\n  /**\r\n   * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n   * An unoptimized version of dxtToRgb565.  Also, the floating\r\n   * point math used to compute the colors actually results in\r\n   * slightly different colors compared to hardware DXT decoders.\r\n   * @param src dxt src pixels\r\n   * @param srcByteOffset offset for the start of src\r\n   * @param  width aligned width of the image\r\n   * @param  height aligned height of the image\r\n   * @return the converted pixels\r\n   */\n\n\n  function ConvertDxtToRgb565(src, srcByteOffset, width, height) {\n    var c = new Uint16Array(4);\n    var dst = new Uint16Array(width * height);\n    var blockWidth = width / 4;\n    var blockHeight = height / 4;\n\n    for (var blockY = 0; blockY < blockHeight; blockY++) {\n      for (var blockX = 0; blockX < blockWidth; blockX++) {\n        var i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\n        c[0] = src[i] | src[i + 1] << 8;\n        c[1] = src[i + 2] | src[i + 3] << 8;\n        c[2] = (2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3 | (2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3 & 0xf800;\n        c[3] = (2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3 | (2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3 & 0xf800;\n\n        for (var row = 0; row < 4; row++) {\n          var m = src[i + 4 + row];\n          var dstI = (blockY * 4 + row) * width + blockX * 4;\n          dst[dstI++] = c[m & 0x3];\n          dst[dstI++] = c[m >> 2 & 0x3];\n          dst[dstI++] = c[m >> 4 & 0x3];\n          dst[dstI++] = c[m >> 6 & 0x3];\n        }\n      }\n    }\n\n    return dst;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}