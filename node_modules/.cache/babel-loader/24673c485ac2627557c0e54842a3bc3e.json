{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _taggedTemplateLiteral = require(\"/opt/work/NZ_test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar code_1 = require(\"../code\");\n\nexports.error = {\n  message: function message(_ref) {\n    var _ref$params = _ref.params,\n        property = _ref$params.property,\n        depsCount = _ref$params.depsCount,\n        deps = _ref$params.deps;\n    var property_ies = depsCount === 1 ? \"property\" : \"properties\";\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must have \", \" \", \" when property \", \" is present\"])), property_ies, deps, property);\n  },\n  params: function params(_ref2) {\n    var _ref2$params = _ref2.params,\n        property = _ref2$params.property,\n        depsCount = _ref2$params.depsCount,\n        deps = _ref2$params.deps,\n        missingProperty = _ref2$params.missingProperty;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{property: \", \",\\n    missingProperty: \", \",\\n    depsCount: \", \",\\n    deps: \", \"}\"])), property, missingProperty, depsCount, deps);\n  } // TODO change to reference\n\n};\nvar def = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: exports.error,\n  code: function code(cxt) {\n    var _splitDependencies = splitDependencies(cxt),\n        _splitDependencies2 = _slicedToArray(_splitDependencies, 2),\n        propDeps = _splitDependencies2[0],\n        schDeps = _splitDependencies2[1];\n\n    validatePropertyDeps(cxt, propDeps);\n    validateSchemaDeps(cxt, schDeps);\n  }\n};\n\nfunction splitDependencies(_ref3) {\n  var schema = _ref3.schema;\n  var propertyDeps = {};\n  var schemaDeps = {};\n\n  for (var key in schema) {\n    if (key === \"__proto__\") continue;\n    var deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n    deps[key] = schema[key];\n  }\n\n  return [propertyDeps, schemaDeps];\n}\n\nfunction validatePropertyDeps(cxt) {\n  var propertyDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  var gen = cxt.gen,\n      data = cxt.data,\n      it = cxt.it;\n  if (Object.keys(propertyDeps).length === 0) return;\n  var missing = gen.let(\"missing\");\n\n  var _loop = function _loop(prop) {\n    var deps = propertyDeps[prop];\n    if (deps.length === 0) return \"continue\";\n    var hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \")\n    });\n\n    if (it.allErrors) {\n      gen.if(hasProperty, function () {\n        var _iterator = _createForOfIteratorHelper(deps),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var depProp = _step.value;\n            (0, code_1.checkReportMissingProp)(cxt, depProp);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      });\n    } else {\n      gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" && (\", \")\"])), hasProperty, (0, code_1.checkMissingProp)(cxt, deps, missing)));\n      (0, code_1.reportMissingProp)(cxt, missing);\n      gen.else();\n    }\n  };\n\n  for (var prop in propertyDeps) {\n    var _ret = _loop(prop);\n\n    if (_ret === \"continue\") continue;\n  }\n}\n\nexports.validatePropertyDeps = validatePropertyDeps;\n\nfunction validateSchemaDeps(cxt) {\n  var schemaDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  var gen = cxt.gen,\n      data = cxt.data,\n      keyword = cxt.keyword,\n      it = cxt.it;\n  var valid = gen.name(\"valid\");\n\n  var _loop2 = function _loop2(prop) {\n    if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) return \"continue\";\n    gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), function () {\n      var schCxt = cxt.subschema({\n        keyword: keyword,\n        schemaProp: prop\n      }, valid);\n      cxt.mergeValidEvaluated(schCxt, valid);\n    }, function () {\n      return gen.var(valid, true);\n    } // TODO var\n    );\n    cxt.ok(valid);\n  };\n\n  for (var prop in schemaDeps) {\n    var _ret2 = _loop2(prop);\n\n    if (_ret2 === \"continue\") continue;\n  }\n}\n\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}